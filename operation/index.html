<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><link rel="canonical" href="https://modir.github.io/operation/" />
      <link rel="shortcut icon" href="../img/favicon.ico" />
    <title>Website Operation - Using Laminas Framework</title>
    <link rel="stylesheet" href="../css/theme.css" />
    <link rel="stylesheet" href="../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "Website Operation";
        var mkdocs_page_input_path = "operation.md";
        var mkdocs_page_url = "/operation/";
      </script>
    
    <!--[if lt IE 9]>
      <script src="../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
      <script>hljs.highlightAll();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href=".." class="icon icon-home"> Using Laminas Framework
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="..">Preface</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../intro/">None</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../acknowledgments/">Acknowledgments</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../intro/">Introduction to Laminas Framework</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../skeleton/">Laminas Skeleton Application</a>
                </li>
              </ul>
              <ul class="current">
                <li class="toctree-l1 current"><a class="reference internal current" href="./">Website Operation</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#php-classes">PHP Classes</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#php-namespaces">PHP Namespaces</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#php-interfaces">PHP Interfaces</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#php-class-autoloading">PHP Class Autoloading</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#class-map-autoloader">Class Map Autoloader</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#psr-4-standard">PSR-4 Standard</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#composer-provided-autoloader">Composer-provided Autoloader</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#psr-4-and-modules-source-directory-structure">PSR-4 and Module's Source Directory Structure</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#http-request-and-response">HTTP Request and Response</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#site-entry-script">Site Entry Script</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#events-applications-life-cycle">Events &amp; Application's Life Cycle</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#application-configuration">Application Configuration</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#application-level-config-files">Application-Level Config Files</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#application-level-extra-config-files">Application-Level Extra Config Files</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#application-level-development-config-file">Application-Level Development Config File</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#application-level-extra-development-config-files">Application-Level Extra Development Config Files</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#module-level-config-files">Module-Level Config Files</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#combining-the-configuration-files">Combining the Configuration Files</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#module-entry-point">Module Entry Point</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#service-manager">Service Manager</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#registering-a-service">Registering a Service</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#service-names">Service Names</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#overriding-an-existing-service">Overriding an Existing Service</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#registering-invokable-classes">Registering Invokable Classes</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#registering-a-factory">Registering a Factory</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#registering-an-abstract-factory">Registering an Abstract Factory</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#registering-service-aliases">Registering Service Aliases</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#shared-and-non-shared-services">Shared and Non-Shared Services</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#service-manager-configuration">Service Manager Configuration</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#plugin-managers">Plugin Managers</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#about-event-manager">About Event Manager</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#event-mvcevent">Event &amp; MvcEvent</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#eventmanager-sharedeventmanager">EventManager &amp; SharedEventManager</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#summary">Summary</a>
    </li>
    </ul>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../mvc/">Model-View-Controller</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../routing/">Routing</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../appearance/">Page Appearance and Layout</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../forms/">Collecting User Input with Forms</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../filters/">Transforming Input Data with Filters</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../validators/">Checking Input Data with Validators</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../uploads/">Uploading Files with Forms</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../forms_advanced/">Advanced Usage of Forms</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../doctrine/">Database Management with Doctrine ORM</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../doctrine_migrations/">Database Migrations</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../modules/">Creating a New Module</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../session/">Working with Sessions</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../users/">User Management, Authentication and Access Filtering</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../roles/">Role-Based Access Control</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../devenv/">Appendix A. Configuring Web Development Environment</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../netbeans/">Appendix B. Introduction to PHP Development in NetBeans IDE</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../bootstrap/">Appendix C. Introduction to Twitter Bootstrap</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../doctrine_intro/">Appendix D. Introduction to Doctrine</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../ec2_tutorial/">Appendix E. Installing a Laminas Web Application to Amazon EC2</a>
                </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="..">Using Laminas Framework</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href=".." class="icon icon-home" aria-label="Docs"></a></li>
      <li class="breadcrumb-item active">Website Operation</li>
    <li class="wy-breadcrumbs-aside">
          <a href="https://github.com/modir/laminas-book/edit/master/docs/operation.md" class="icon icon-github"> Edit on GitHub</a>
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="website-operation">Website Operation</h1>
<p>In this chapter we will provide some theory on how a typical Laminas Framework based web application
works. You'll learn some PHP basics like PHP classes, how PHP namespaces are used for avoiding name collisions,
what class autoloading is, how to define application configuration parameters and
the stages present in an application's life-cycle. You will also become familiar with such
important Laminas components as @<code>Laminas\EventManager</code>, @<code>Laminas\ModuleManager</code> and @<code>Laminas\ServiceManager</code>.
If instead of learning the theory, you want to have some practical examples, skip this chapter
and refer directly to <a href="#mvc">Model-View-Controller</a>.</p>
<p>Laminas components covered in this chapter:</p>
<table>
<thead>
<tr>
<th><em>Component</em></th>
<th><em>Description</em></th>
</tr>
</thead>
<tbody>
<tr>
<td>@<code>Laminas\Mvc</code></td>
<td>Support of Model-View-Controller pattern. Separation of business logic from presentation.</td>
</tr>
<tr>
<td>@<code>Laminas\ModuleManager</code></td>
<td>This component is responsible for loading and initializing modules of the web application.</td>
</tr>
<tr>
<td>@<code>Laminas\EventManager</code></td>
<td>This component implements functionality for triggering events and event handling.</td>
</tr>
<tr>
<td>@<code>Laminas\ServiceManager</code></td>
<td>Implements the registry of all services available in the web application.</td>
</tr>
</tbody>
</table>
<h2 id="php-classes">PHP Classes</h2>
<p>PHP supports object oriented style of programming (OOP). In OOP, the main building block of your code is a <em>class</em>.
A class can have <em>properties</em> and <em>methods</em>. For example, let's create a PHP script named <em>Person.php</em> and
define a simple class named <code>Person</code> in that file:</p>
<pre><code class="language-php">&lt;?php

class Person
{
    private $fullName;

    public function __construct()
    {
        // Some initialization code.
        $this-&gt;fullName = 'Unknown person';
    }

    public function getFullName()
    {
        return $this-&gt;fullName;
    }

    public function setFullName($fullName)
    {
        $this-&gt;fullName = $fullName;
    }
}
</code></pre>
<blockquote>
<p>You may notice that in example above we have the opening <code>&lt;?php</code> tag which
tells the PHP engine that the text after the tag is a PHP code. In example above, when the file contains
only the PHP code (without mixing PHP and HTML tags), you don't need to insert the
closing <code>?&gt;</code> tag after the end of the code. Moreover, this is not recommended and may cause undesired
effects, if you inadvertently add some character after the closing <code>?&gt;</code> tag.</p>
</blockquote>
<p>The <code>Person</code> class above has a private property <code>$fullName</code> and three methods:</p>
<ul>
<li>
<p><code>__construct()</code> method is a special method called <em>constructor</em>. It is used if you need to somehow initialize properties of the class.</p>
</li>
<li>
<p><code>getFullName()</code> and <code>setFullName()</code> are public methods used to do something with the class.</p>
</li>
</ul>
<p>Once you have defined the class, you can create <em>objects</em> of that class with the <code>new</code> operator, as follows:</p>
<pre><code class="language-php">&lt;?php

// Instantiate the Person.
$person = new Person();

// Set full name.
$person-&gt;setFullName('John Doe');

// Print person's full name to screen.
echo &quot;Person's full name is: &quot; . $person-&gt;getFullName() . &quot;\n&quot;;
</code></pre>
<blockquote>
<p>Classes allow to split your functionality into smaller blocks and make it well organised.
Laminas consists of hundreds of classes.
You will also write your own classes in your web applications.</p>
</blockquote>
<h2 id="php-namespaces">PHP Namespaces</h2>
<p>When you use classes from different libraries (or even classes from different components of a single library)
in your program, the class names may conflict.
This means you can encounter two classes having the same name, resulting in a PHP interpreter error.
If you've ever programmed websites with Laminas Framework 1, you might remember those <em>extra</em> long
class names like <code>Laminas_Controller_Abstract</code>. The idea with long names was
utilized to avoid name collisions between different components. Each component defined
its own name prefix, like <code>Laminas_</code> or <code>My_</code>.</p>
<p>To achieve the same goal, Laminas Framework uses a PHP language feature called <em>namespaces</em>.
The namespaces allow to solve name collisions between code components, and provide you with the
ability to make the long names shorter.</p>
<p>A namespace is a container for a group of names. You can nest namespaces into each other.
If a class does not define a namespace, it lives inside of the <em>global</em> namespace
(for example, PHP classes <code>Exception</code> and <code>DateTime</code> belong to global namespace).</p>
<p>A real-world example of a namespace definition (taken from @<code>Laminas\Mvc</code> component) is presented
below:</p>
<pre><code class="language-php">&lt;?php
namespace Laminas\Mvc;

/**
 * Main application class for invoking applications.
 */
class Application
{
    // ... class members were omitted for simplicity ...
}
</code></pre>
<p>In Laminas Framework, all classes belong to top-level <em>Laminas</em> namespace.
The line 2 defines the namespace <em>Mvc</em>, which is nested into <em>Laminas</em> namespace,
and all classes of this component (including the @<code>Application</code>[Laminas\Mvc\Application] class shown in
this example on lines 7-10) belong to this namespace. You separate nested
namespace names with the back-slash character ('\').</p>
<p>In other parts of code, you reference the @<code>Application</code>[Laminas\Mvc\Application] class using
its fully-qualified name:</p>
<pre><code class="language-php">&lt;?php
$application = new \Laminas\Mvc\Application();
</code></pre>
<blockquote>
<p>Please note the leading back-slash in @<code>\Laminas\Mvc\Application</code>
name. If you specify a class name with leading back-slash, this means the fully-qualified class name.
It is also possible to specify class name relatively to the current namespace, in that case you do not
specify the leading back-slash.</p>
</blockquote>
<p>It is also possible to use the <em>alias</em> (short name for the class) with the
help of PHP's <code>use</code> statement:</p>
<pre><code class="language-php">&lt;?php
// Define the alias in the beginning of the file.
use Laminas\Mvc\Application;

// Later in your code, use the short class name.
$application = new Application();
</code></pre>
<blockquote>
<p>Although the alias allows to use a short class name instead of the full name,
its usage is optional. You are not required to always use aliases, and can
refer the class by its fully-qualified name.</p>
</blockquote>
<p>Every PHP file of your application typically defines the namespace
(except <em>index.php</em> entry script and config files, which typically do not).
For example, the main module of your site, the <em>Application</em> module,
defines its own namespace whose name equals to the module name:</p>
<pre><code class="language-php">&lt;?php
namespace Application;

class Module
{
    // ... class members were omitted for simplicity ...
}
</code></pre>
<h2 id="php-interfaces">PHP Interfaces</h2>
<p>In PHP, <em>interfaces</em> allow you to define which behavior a class
should have, but without providing the implementation of such a behavior. This is also
called a <em>contract</em>: by implementing an interface, a class agrees to the contract terms.</p>
<p>In Laminas Framework, interfaces are widely used. For example, the @<code>Application</code> class implements the
@<code>ApplicationInterface</code>, which defines the methods every application class must provide:</p>
<pre><code class="language-php">&lt;?php
namespace Laminas\Mvc;

interface ApplicationInterface
{
    // Retrieves the service manager.
    public function getServiceManager();

    // Retrieves the HTTP request object.
    public function getRequest();

    // Retrieves the HTTP response object.
    public function getResponse();

    // Runs the application.
    public function run();
}
</code></pre>
<p>As you can see from the example above, an interface is defined using the <code>interface</code>
keyword, almost the same way you define a standard PHP class. As a usual class,
the interface defines methods. However, the interface does not provide any implementation
of its methods. In the @<code>ApplicationInterface</code> interface definition above, you can
see that every application implementing this interface will have method <code>getServiceManager()</code> for
retrieving the service manager (about the service manager, see later in this chapter), the
<code>getRequest()</code> and <code>getResponse()</code> methods for retrieving the HTTP request and response, respectively,
and method <code>run()</code> for running the application.</p>
<blockquote>
<p>In Laminas Framework, by convention, interface classes should be named with <code>Interface</code> suffix,
like @<code>ApplicationInterface</code>.</p>
</blockquote>
<p>A class implementing an interface is called a <em>concrete</em> class. The concrete @<code>Application</code> class
implements the @<code>ApplicationInterface</code>, which means it provides the implementation of the methods
defined by the interface:</p>
<pre><code class="language-php">&lt;?php
namespace Laminas\Mvc;

class Application implements ApplicationInterface
{
    // Implement the interface's methods here

    public function getServiceManager()
    {
        // Provide some implementation...
    }

    public function getRequest()
    {
        // Provide some implementation...
    }

    public function getResponse()
    {
        // Provide some implementation...
    }

    public function run()
    {
        // Provide some implementation...
    }
}
</code></pre>
<p>The concrete @<code>Application</code> class uses the <code>implements</code> keyword to show that it
provides an implementation of all methods of <code>ApplicationInterface</code> interface.
The @<code>Application</code> class can also have additional methods, which are not part
of the interface.</p>
<p>Graphically, the class relations are displayed using inheritance diagrams.
In figure 3.1, the diagram for @<code>Application</code> class is presented. The arrow
points from the child class to the parent class.</p>
<p><img alt="Figure 3.1. Application class diagram" src="../images/operation/Application.png" /></p>
<h2 id="php-class-autoloading">PHP Class Autoloading</h2>
<p>A web application consists of many PHP classes, and
each class typically resides in a separate file. This introduces
the need of <em>including</em> the files.</p>
<p>For example, let's assume we have the file named <em>Application.php</em>
which contains the definition for the @<code>\Laminas\Mvc\Application</code> class
from the previous section. Before you can
create an instance of the @<code>Application</code> class somewhere in your code,
you have to include the contents of <em>Application.php</em> file (you can do this with the
help of <code>require_once</code> statement, passing it the full path to the file):</p>
<pre><code class="language-php">&lt;?php
require_once &quot;/path/to/laminas/laminas-mvc/src/Application.php&quot;;

use Laminas\Mvc\Application;

$application = new Application();
</code></pre>
<p>As your application grows in size, it may be difficult to include
each needed file. Laminas Framework itself consists of hundreds of files,
and it can be very difficult to load the entire library and all its
dependencies this way. Moreover, when executing the resulting code, PHP interpreter will
take CPU time to process each included file, even if you don't create an
instance of its class.</p>
<p>To fix this problem, in PHP, the class autoloading feature has been introduced.
The PHP function <code>spl_autoload_register()</code> allows you to register
an <em>autoloader</em> function. For complex websites, you even can create
several autoloader functions, which are chained in a stack.</p>
<p>During script execution, if PHP interpreter encounters a class name
which has not been defined yet, it calls all the registered autoloader functions
in turn, until either the autoloader function includes the class or "not found" error is
raised. This allows for "lazy" loading, when PHP interpreter processes the class
definition only at the moment of class invocation, when it is really needed.</p>
<h3 id="class-map-autoloader">Class Map Autoloader</h3>
<p>To give you an idea of how an autoloader function looks like, below we provide a
simplified implementation of an autoloader function:</p>
<pre><code class="language-php">&lt;?php
// Autoloader function.
function autoloadFunc($className)
{
    // Class map static array.
    static $classMap = [
        '\\Laminas\\Mvc\\Application' =&gt; '/path/to/laminas/laminas-mvc/src/Laminas/Mvc/Application.php',
        '\\Application\\Module' =&gt; '/path/to/app/dir/module/Application/Module.php',
        //...
    ];

    // Check if such a class name presents in the class map.
    if(isset(static::$classMap[$className])) {
        $fileName = static::$classMap[$className];

        // Check if file exists and is readable.
        if (is_readable($fileName)) {
            // Include the file.
            require $fileName;
        }
    }
}

// Register our autoloader function.
spl_autoload_register(&quot;autoloadFunc&quot;);
</code></pre>
<p>In the above example, we define the <code>autoloadFunc()</code> autoloader function,
which we will further refer to as the <em>class map</em> autoloader.</p>
<p>The class map autoloader uses the class map for mapping between class name and
absolute path to PHP file containing that class. The class map is just a usual PHP
array containing keys and values. To determine the file path by class name, the
class map autoloader just needs to fetch the value from the class map array.
It is obvious, that the class map autoloader works very fast. However, the disadvantage
of it is that you have to maintain the class map and update it each time you add a new
class to your program.</p>
<h3 id="psr-4-standard">PSR-4 Standard</h3>
<p>Because each library's vendor uses its own code naming and file organization conventions,
you will have to register a different custom autoloader function per each dependent library,
which is rather annoying (and actually this is an unneeded work). To resolve this problem,
the PSR-4 standard was introduced.</p>
<blockquote>
<p>PSR stands for PHP Standards Recommendation.</p>
</blockquote>
<p>The <a href="http://www.php-fig.org/psr/psr-4/">PSR-4 standard</a>
defines the recommended code structure that an application or library must follow
to guarantee autoloader interoperability. In two words, the standard says that:</p>
<ul>
<li>The class namespaces should be organized in the following way:</li>
</ul>
<p><code>\&lt;Vendor Name&gt;\(&lt;Namespace&gt;)*\&lt;Class Name&gt;</code></p>
<ul>
<li>
<p>Namespaces can have as many nesting levels as desired,
  but the <em>Vendor Name</em> should be the top-level namespace.</p>
</li>
<li>
<p>Namespaces should map to directory structure. Each namespace separator ('\')
  is converted to a OS-specific <code>DIRECTORY_SEPARATOR</code> constant when loading from the file system.</p>
</li>
<li>
<p>The class name is suffixed with <em>.php</em> extension when loading the file from the file system.</p>
</li>
</ul>
<p>For example, for the @<code>Laminas\Mvc\Application</code> class,
you will have the following directory structure:</p>
<pre><code class="language-text">/path/to/laminas/laminas-mvc/src
  /Laminas
    /Mvc
       Application.php
</code></pre>
<p>The disadvantage of this is that you need to put your code in multiple nested directories (<em>Laminas</em> and <em>Mvc</em>).</p>
<p>To fix this, the PSR-4 allows you to define that a contiguous
series of one or more leading namespace and sub-namespace names corresponds to a "base directory".
For example, if you have the @<code>\Laminas\Mvc\Application</code> fully qualified class name, and if you define that
the series @<code>\Laminas\Mvc</code> corresponds to the "/path/to/laminas/laminas-mvc/src" directory, you can organise
your files as follows:</p>
<pre><code>/path/to/laminas/laminas-mvc/src
    Application.php
</code></pre>
<p>For the code conforming to the PSR-4 standard, we can write and register
an autoloader, which we will refer to as the "standard" autoloader:</p>
<pre><code class="language-php">&lt;?php

// &quot;Standard&quot; autoloader function.
function standardAutoloadFunc($className)
{
    // Replace the namespace prefix with base directory.
    $prefix = '\\Laminas\\Mvc';
    $baseDir = '/path/to/laminas/laminas-mvc/src/';
    if (substr($className, 0, strlen($prefix)) == $prefix) {
        $className = substr($className, strlen($prefix)+1);
        $className = $baseDir . $className;
    }

    // Replace namespace separators in class name with directory separators.
    $className = str_replace('\\', DIRECTORY_SEPARATOR, $className);

    // Add the .php extension.
    $fileName = $className . &quot;.php&quot;;

    // Check if file exists and is readable.
    if (is_readable($fileName)) {
        // Include the file.
        require $fileName;
    }
}

// Register the autoloader function.
spl_autoload_register(&quot;standardAutoloadFunc&quot;);
</code></pre>
<p>The standard autoloader works as follows. Assuming that the class namespace
can be mapped to the directory structure one-by-one, the function calculates
the path to PHP file by transforming back-slashes (namespace separators) to
forward slashes (path separators) and concatenating the resulting path with
the absolute path to the directory where the library is located. Then the
function checks if such a PHP file really exists, and if so, includes it
with the <code>require</code> statement.</p>
<p>It is obvious, that the standard autoloader works slower than the class map autoloader.
However, its advantage is that you don't need to maintain any class map,
which is very convenient when you develop new code and add new classes to
your application.</p>
<blockquote>
<p>Laminas Framework conforms to PSR-4 standard, making it possible to use standard
autoloading mechanism across all its components. It is also compatible with other
PSR-4 conforming libraries like Doctrine or Symfony.</p>
</blockquote>
<h3 id="composer-provided-autoloader">Composer-provided Autoloader</h3>
<p>Composer can generate autoloader functions (both class map autoloaders and PSR-4 standard autoloaders) for the code you install with it.
Laminas Framework uses the autoloader implementation provided by Composer. When you install a package with
Composer, it automatically creates the file <em>APP_DIR/vendor/autoload.php</em>,
which uses the <code>spl_autoload_register()</code> PHP function to register an autoloader. This way all PHP classes
located in <code>APP_DIR/vendor</code> directory are correctly autoloaded.</p>
<p>To autoload PHP classes located in your own modules (like <code>Application</code> module), you'll have to specify
the <code>autoload</code> key in your <code>composer.json</code> file:</p>
<pre><code class="language-json">&quot;autoload&quot;: {
    &quot;psr-4&quot;: {
        &quot;Application\\&quot;: &quot;module/Application/src/&quot;
    }
},
</code></pre>
<p>Then the only thing need to be done is to include that file in your website entry script <code>index.php</code>:</p>
<pre><code class="language-php">// Composer autoloading
include __DIR__ . '/../vendor/autoload.php';
</code></pre>
<blockquote>
<p>The <em>autoload.php</em> file is generated each time you install a package with Composer. Besides that, to
make Composer generate the <em>autoload.php</em> file, you may need to execute the <code>dump-autoload</code> command:</p>
<p><code>php composer.phar dump-autoload</code></p>
</blockquote>
<h3 id="psr-4-and-modules-source-directory-structure">PSR-4 and Module's Source Directory Structure</h3>
<p>In Laminas Skeleton Application, you can see how the PSR-4 standard is applied
in practice. For the default module of your website, the <code>Application</code> module, PHP classes which
are registered with the standard autoloader are stored under the <code>APP_DIR/module/Application/src</code>
directory ("src" abbreviation means "source").</p>
<blockquote>
<p>We will refer to the <code>src</code> directory as module's source directory.</p>
</blockquote>
<p>For example, lets look at the <code>IndexController.php</code> file of <code>Application</code> module (figure 3.2).</p>
<p><img alt="Figure 3.2. Skeleton application's directory structure conforms to PSR-4 standard" src="../images/operation/psr0_and_dir_structure.png" /></p>
<p>As you can see, it contains the <code>IndexController</code> class <sup id="fnref:controller"><a class="footnote-ref" href="#fn:controller">1</a></sup> belonging to <code>Application\Controller</code> namespace.
To be able to follow the PSR-4 standard and use the standard autoloader with this PHP class,
we have to put it under the <code>Controller</code> directory under the module's source
directory.</p>
<h2 id="http-request-and-response">HTTP Request and Response</h2>
<p>When a site user opens a web page in a web browser's window, the browser generates
a request message and sends it using HTTP protocol to the web server. The web server
directs this HTTP request to your web application.</p>
<blockquote>
<p><a href="https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol">HTTP</a> (stands for Hyper Text
Transfer Protocol) -- a protocol for transferring data
in the form of hyper text documents (web pages). HTTP is based on the client-server
technology: the client initiates a connection and sends a request to web server, and the
server waits for a connection, performs the necessary
actions and returns a response message back.</p>
</blockquote>
<p>Thus, the main underlying goal of any web application is handling the HTTP request
and producing an HTTP response typically containing the HTML code of the requested web page.
The response is sent by the web server to the client web browser and the browser displays a
web page on the screen.</p>
<p>A typical HTTP request is presented below:</p>
<pre><code class="language-text">GET http://www.w3schools.com/ HTTP/1.1
Host: www.w3schools.com
Connection: keep-alive
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64)
Accept-Encoding: gzip,deflate,sdch
Accept-Language: en-US;q=0.8,en;q=0.6
Cookie: __gads=ID=42213729da4df8df:T=1368250765:S=ALNI_MaOAFe3U1T9Syh;
(empty line)
(message body goes here)
</code></pre>
<p>The HTTP request message above consists of three parts:</p>
<ul>
<li>The starting line (line 1) specifies the method of the request (e.g GET or POST), the URL string
  and HTTP protocol version.</li>
<li>Optional headers (lines 2-8) characterize the message, the transmission parameters and provide other meta information.
  In the example above, each row represents a single header in the form of <em>name:value</em>.</li>
<li>Optional message body contains message data. It is separated from the headers with a blank line.</li>
</ul>
<p>The headers and the message body may be absent, but the starting line is always
present in the request, because it indicates its type and URL.</p>
<p>The server response for the above request is presented below:</p>
<pre><code class="language-text">HTTP/1.1 200 OK
Cache-Control: private
Content-Type: text/html
Content-Encoding: gzip
Vary: Accept-Encoding
Server: Microsoft-IIS/7.5
Set-Cookie: ASPSESSIONIDQQRBACTR=FOCCINICEFAMEKODNKIBFOJP; path=/
X-Powered-By: ASP.NET
Date: Sun, 04 Aug 2013 13:33:59 GMT
Content-Length: 8434
(empty line)
(page content follows)
</code></pre>
<p>As you can see from the dump above, the HTTP response has almost the same format as the request:</p>
<ul>
<li>
<p>The starting line (line 1) represents the HTTP protocol version,
  response status code and message (200 OK).</p>
</li>
<li>
<p>Optional headers (lines 2-10) provide various meta information about the response.</p>
</li>
<li>
<p>Optional message body follows the headers, and must be separated from headers
  by an empty line. The message body typically contains the HTML code of the requested
  web page.</p>
</li>
</ul>
<h2 id="site-entry-script">Site Entry Script</h2>
<p>When the Apache web server receives an HTTP request from a client browser,
it executes the <em>APP_DIR/public/index.php</em> file, also called the <em>entry script</em>.</p>
<blockquote>
<p>The entry script is the only PHP file accessible to the outside world. Apache web server
directs all HTTP requests to this script (remember the <em>.htaccess</em> file?). Having this
single entry script makes the website more secure (comparing with the situation when you allow
everyone to access all PHP files of your application).</p>
</blockquote>
<p>Although the <em>index.php</em> file is very important, it is surprisingly small (see below):</p>
<pre><code class="language-php">&lt;?php

use Laminas\Mvc\Application;
use Laminas\Stdlib\ArrayUtils;

/**
 * This makes our life easier when dealing with paths. Everything is relative
 * to the application root now.
 */
chdir(dirname(__DIR__));

// Decline static file requests back to the PHP built-in webserver
if (php_sapi_name() === 'cli-server') {
    $path = realpath(__DIR__ . parse_url($_SERVER['REQUEST_URI'], PHP_URL_PATH));
    if (__FILE__ !== $path &amp;&amp; is_file($path)) {
        return false;
    }
    unset($path);
}

// Composer autoloading
include __DIR__ . '/../vendor/autoload.php';

if (! class_exists(Application::class)) {
    throw new RuntimeException(
        &quot;Unable to load application.\n&quot;
        . &quot;- Type `composer install` if you are developing locally.\n&quot;
        . &quot;- Type `vagrant ssh -c 'composer install'` if you are using Vagrant.\n&quot;
        . &quot;- Type `docker-compose run zf composer install` if you are using Docker.\n&quot;
    );
}

// Retrieve configuration
$appConfig = require __DIR__ . '/../config/application.config.php';
if (file_exists(__DIR__ . '/../config/development.config.php')) {
    $appConfig = ArrayUtils::merge($appConfig, require __DIR__ . '/../config/development.config.php');
}

// Run the application!
Application::init($appConfig)-&gt;run();
</code></pre>
<p>Mainly, there are three things done in it.</p>
<p>First, in line 10, current working directory is changed to <code>APP_DIR</code>.
This makes it simple to define relative file paths in your application.</p>
<p>Next, in line 22, PHP class autoloading is initialized. This allows to easily load any
class either located in Laminas Framework library or in your application without the need
for <code>require_once</code> statement.</p>
<p>And finally, in line 40, an instance of @<code>Laminas\Mvc\Application</code> class is created.
The application is initialized with the settings read from <em>application.config.php</em>
configuration file, and, the application is run.</p>
<h2 id="events-applications-life-cycle">Events &amp; Application's Life Cycle</h2>
<p>As you've learned from the previous section, on every HTTP request, the @<code>Laminas\Mvc\Application</code>
object is created. Typically, an application "lives" for a second or less
(this time is enough to generate the HTTP response). The application's "life" consists of several stages.</p>
<blockquote>
<p>Laminas Framework uses the concept of <em>event</em>. One class can <em>trigger</em> an event,
and other classes may <em>listen</em> to events. Technically, triggering an event means just calling
another class' "callback" method. The event management is implemented inside of
the @<code>Laminas\EventManager</code> component.</p>
</blockquote>
<p>Each application life stage is initiated by the application by triggering an event (this
event is represented by the @<code>MvcEvent</code> class living in @<code>Laminas\Mvc</code> namespace). Other
classes (either belonging to Laminas Framework or specific to your application) may listen
to events and react accordingly.</p>
<p>Below, the five main events (life stages) are presented:</p>
<p><strong>Bootstrap</strong>. When this event is triggered by the application, a module has a chance to
register itself as a listener of further application events in its <code>onBootstrap()</code>
callback method.</p>
<p><strong>Route</strong>. When this event is triggered, the request's URL is analyzed using a <em>router</em> class (typically, with
@<code>Laminas\Router\Http\TreeRouteStack</code> class). If an exact match between the URL and a route
is found, the request is passed to the site-specific <em>controller</em> class assigned to the route.</p>
<p><strong>Dispatch</strong>. The controller class "dispatches" the request using the corresponding action method
and produces the data that can be displayed on the web page.</p>
<p><strong>Render</strong>. On this event, the data produced by the controller's action method are passed for rendering to
@<code>Laminas\View\Renderer\PhpRenderer</code> class. The renderer class uses a
<em>view template</em> file for producing an HTML page.</p>
<p><strong>Finish</strong>. On this event, the HTTP response is sent back to client.</p>
<p>The event flow is illustrated in figure 3.3:</p>
<p><img alt="Figure 3.3. Event flow during the application's life cycle" src="../images/operation/app_life_cycle.png" /></p>
<blockquote>
<p>Although needed relatively rarely, some practical examples of
how to listen and react to an event can be found in <a href="#modules">Creating a New Module</a>
chapter.</p>
</blockquote>
<h2 id="application-configuration">Application Configuration</h2>
<p>Most of Laminas Framework components which are used in your website,
require configuration (fine-tuning). For example, in the configuration
file you define database connection credentials, specify which modules
are present in your application, and, optionally, provide some custom
parameters specific to your application.</p>
<p>You can define the configuration parameters at two levels: either at the
application level, or at the module level. At the application level you typically
define parameters which control the whole app and are common to all
modules of your application. At the module level, you define parameters which
affect only this module.</p>
<blockquote>
<p>Some PHP frameworks prefer <em>conventions over configuration</em> concept, where
most of your parameters are hard-coded and do not require configuration.
This makes it faster to develop the application, but makes it less customizable.
In Laminas Framework, the <em>configuration over conventions</em> concept is used,
so you can customize any aspect of your application, but have to
spend some time for learning how to do that.</p>
</blockquote>
<h3 id="application-level-config-files">Application-Level Config Files</h3>
<p>The <em>APP_DIR/config</em> subdirectory contains application-wide configuration files. Let's look
at this subdirectory in more details (figure 3.4).</p>
<p><img alt="Figure 3.4. Configuration files" src="../images/operation/config.png" /></p>
<p>The <em>APP_DIR/config/application.config.php</em> file is the main configuration file.
It is used by the application on start up for determining which application modules should be loaded
and which services to create by default.</p>
<p>Below, the content of <em>application.config.php</em> file
is presented. You can see that the configuration file is just a usual
PHP nested associative array, and each component
may have a specific key in that array. You can provide inline comments for the array keys
to make it easier for others to understand what each key means.</p>
<blockquote>
<p>By convention, key names should be in lower case, and if the key name consists
of several words, the words should be separated by the underscore symbol ('_').</p>
</blockquote>
<pre><code class="language-php">return [
    // Retrieve list of modules used in this application.
    'modules' =&gt; require __DIR__ . '/modules.config.php',

    // These are various options for the listeners attached to the ModuleManager
    'module_listener_options' =&gt; [
        // This should be an array of paths in which modules reside.
        // If a string key is provided, the listener will consider that a module
        // namespace, the value of that key the specific path to that module's
        // Module class.
        'module_paths' =&gt; [
            './module',
            './vendor',
        ],

        // An array of paths from which to glob configuration files after
        // modules are loaded. These effectively override configuration
        // provided by modules themselves. Paths may use GLOB_BRACE notation.
        'config_glob_paths' =&gt; [
            realpath(__DIR__) . '/autoload/{{,*.}global,{,*.}local}.php',
        ],

        // Whether or not to enable a configuration cache.
        // If enabled, the merged configuration will be cached and used in
        // subsequent requests.
        'config_cache_enabled' =&gt; true,

        // The key used to create the configuration cache file name.
        'config_cache_key' =&gt; 'application.config.cache',

        // Whether or not to enable a module class map cache.
        // If enabled, creates a module class map cache which will be used
        // by in future requests, to reduce the autoloading process.
        'module_map_cache_enabled' =&gt; true,

        // The key used to create the class map cache file name.
        'module_map_cache_key' =&gt; 'application.module.cache',

        // The path in which to cache merged configuration.
        'cache_dir' =&gt; 'data/cache/',

        // Whether or not to enable modules dependency checking.
        // Enabled by default, prevents usage of modules that depend on other modules
        // that weren't loaded.
        // 'check_dependencies' =&gt; true,
    ],

    // Used to create an own service manager. May contain one or more child arrays.
    //'service_listener_options' =&gt; [
    //     [
    //         'service_manager' =&gt; $stringServiceManagerName,
    //         'config_key'      =&gt; $stringConfigKey,
    //         'interface'       =&gt; $stringOptionalInterface,
    //         'method'          =&gt; $stringRequiredMethodName,
    //     ],
    // ],

   // Initial configuration with which to seed the ServiceManager.
   // Should be compatible with Laminas\ServiceManager\Config.
   // 'service_manager' =&gt; [],
];
</code></pre>
<p>In line 3 we have the <em>modules</em> key defining which modules will be loaded on start up. You can see that
the module names are stored inside of another config file <code>modules.config.php</code>, which lists all modules
present in your website.</p>
<p>In line 11, there is the <code>module_paths</code> key which tells Laminas about
directories where to look for source files belonging to modules. Application modules
that you develop are located under <em>APP_DIR/module</em> directory, and third-party
modules may be located inside the <em>APP_DIR/vendor</em> directory.</p>
<p>And in line 19 we have the <code>config_glob_paths</code> key, which tells Laminas where to
look for extra config files. You see that files from <em>APP_DIR/config/autoload</em>
which have <em>global.php</em> or <em>local.php</em> suffix, are automatically loaded.</p>
<p>Summing up, you typically use the main <em>application.config.php</em> file for storing the information
about which modules should be loaded into your app and where they are located and
how they are loaded (for example, you can control caching options here). In this
file you can also tune the service manager. It is not recommended to add more
keys in this file. For that purpose it is better to use <code>autoload/global.php</code> file.</p>
<p>And let's also look inside the <code>modules.config.php</code> file. Currently, you have the following modules
installed in your website:</p>
<pre><code class="language-php">return [
    'Laminas\Session',
    'Laminas\Mvc\Plugin\Prg',
    'Laminas\Mvc\Plugin\Identity',
    'Laminas\Mvc\Plugin\FlashMessenger',
    'Laminas\Mvc\Plugin\FilePrg',
    'Laminas\Form',
    'Laminas\Router',
    'Laminas\Validator',
    'Application',
];
</code></pre>
<p>The <code>Application</code> module is a module containing your app's files. All other modules listed are Laminas Framework
components.</p>
<blockquote>
<p>In Laminas, a special Composer plugin called <em>component installer</em> was introduced. If you remember, in the
chapter <a href="#skeleton">Laminas Skeleton Application</a>, we answered several yes/no questions of the installer, determining
which components to install. And the installer <em>injected</em> those components' module names here, in <code>modules.config.php</code></p>
</blockquote>
<h3 id="application-level-extra-config-files">Application-Level Extra Config Files</h3>
<p>"Extra" config files, <em>APP_DIR/config/autoload/global.php</em> and <em>APP_DIR/config/autoload/local.php</em>
files define application-wide environment-agnostic and environment-dependent parameters, respectively.
These config files are automatically loaded and recursively merged with the module-provided config files,
that's why their directory is named <em>autoload</em>.</p>
<p>Having different config files in <em>APP_DIR/config/autoload</em> directory, you might have been
confused about which parameters should be put into each one. Here are some hints:</p>
<ul>
<li>
<p>You use the <em>autoload/global.php</em> file for storing parameters which do not depend
  on the concrete machine environment. For example, here you can store parameters which
  override the default parameters of some module. Do not store sensitive information
  (like database credentials) here, for that purpose it's better to use <em>autoload/local.php</em>.</p>
</li>
<li>
<p>You use the <em>autoload/local.php</em> file for storing parameters specific to the
  concrete environment. For example, here you can store your database credentials.
  Each developer usually has a local database when developing and testing the website.
  The developer thus will edit the <em>local.php</em> file and enter his own database credentials here.
  When you install your site to the production server, you will edit the <code>local.php</code> file and enter
  the credentials for the "live" database here.</p>
</li>
</ul>
<blockquote>
<p>Because the <em>autoload/local.php</em> file contains environment-specific parameters,
in version control system you store its "distribution template" <em>local.php.dist</em>.
Each developer in your team then renames the <em>local.php.dist</em> file into <em>local.php</em> and
enters his own parameters. This <em>local.php</em> file should not be stored under
version control, because it may contain sensitive information like database credentials
(username and password), and you might want that other people do not see these.</p>
</blockquote>
<h3 id="application-level-development-config-file">Application-Level Development Config File</h3>
<p>The application-level development configuration file (<code>APP_DIR/config/development.config.php</code>) presents only
when you enable the <em>development mode</em>. If you remember, we enabled the development mode earlier in the <a href="#skeleton">Laminas Skeleton Application</a> chapter.</p>
<blockquote>
<p>You enable the development mode with the following command:</p>
<p><code>php composer.phar development-enable</code></p>
</blockquote>
<p>The <code>development.config.php</code> file is merged with the main <code>application.config.php</code> file. This allows you to
override some parameters. For example, you can:</p>
<ul>
<li>disable config caching. When you develop your website, you frequently modify your config files, so config caching
    may have undesired consequences, like inability to see the result of your changes immediately.</li>
<li>load additional modules. For example, you can load <a href="https://github.com/laminas/LaminasDeveloperTools">LaminasDeveloperTools</a> module only in development mode.</li>
</ul>
<p>If you disable the development mode, the <code>development.config.php</code> file will be removed. So, you should not
store this file under the version control. Instead, store its <em>distribution</em> version, <code>development.config.php.dist</code> under version control.</p>
<h3 id="application-level-extra-development-config-files">Application-Level Extra Development Config Files</h3>
<p>The application-level extra development configuration file (<code>APP_DIR/config/autoload/development.local.php</code>) presents only
when you enable the <em>development mode</em>.</p>
<p>The <code>development.local.php</code> file is merged with other module-level config files. This allows you to
override some module-specific parameters used in development environment only.</p>
<p>If you disable the development mode, the <code>development.local.php</code> file will be removed. So, you should not
store this file under the version control. Instead, store its <em>distribution</em> version, <code>development.local.php.dist</code>
under version control.</p>
<h3 id="module-level-config-files">Module-Level Config Files</h3>
<p>In figure 3.4, you could see that the <em>Application</em> module shipped with your application
has the <em>module.config.php</em> file, in which you put your module-specific parameters. Let's
look at <code>module.config.php</code> file of the <code>Application</code> module:</p>
<pre><code class="language-php">&lt;?php
namespace Application;

use Laminas\Router\Http\Literal;
use Laminas\Router\Http\Segment;
use Laminas\ServiceManager\Factory\InvokableFactory;

return [
    'router' =&gt; [
        'routes' =&gt; [
            'home' =&gt; [
                'type' =&gt; Literal::class,
                'options' =&gt; [
                    'route'    =&gt; '/',
                    'defaults' =&gt; [
                        'controller' =&gt; Controller\IndexController::class,
                        'action'     =&gt; 'index',
                    ],
                ],
            ],
            'application' =&gt; [
                'type'    =&gt; Segment::class,
                'options' =&gt; [
                    'route'    =&gt; '/application[/:action]',
                    'defaults' =&gt; [
                        'controller'    =&gt; Controller\IndexController::class,
                        'action'        =&gt; 'index',
                    ],
                ],
            ],
        ],
    ],
    'controllers' =&gt; [
        'factories' =&gt; [
            Controller\IndexController::class =&gt; InvokableFactory::class,
        ],
    ],
    'view_manager' =&gt; [
        'display_not_found_reason' =&gt; true,
        'display_exceptions'       =&gt; true,
        'doctype'                  =&gt; 'HTML5',
        'not_found_template'       =&gt; 'error/404',
        'exception_template'       =&gt; 'error/index',
        'template_map' =&gt; [
            'layout/layout'           =&gt; __DIR__ . '/../view/layout/layout.phtml',
            'application/index/index' =&gt; __DIR__ . '/../view/application/index/index.phtml',
            'error/404'               =&gt; __DIR__ . '/../view/error/404.phtml',
            'error/index'             =&gt; __DIR__ . '/../view/error/index.phtml',
        ],
        'template_path_stack' =&gt; [
            __DIR__ . '/../view',
        ],
    ],
];
</code></pre>
<p>In this file, you register the module's controllers, put information about routing rules
for mapping URLs to your controllers, register controller plugins, and also register view templates
and view helpers (we will learn more about these terms in this chapter and in the next chapters).</p>
<h3 id="combining-the-configuration-files">Combining the Configuration Files</h3>
<p>When an application is being created, module-provided configuration files and extra configuration files from
<em>APP_DIR/config/autoload</em> directory are being merged into one big nested array,
so every configuration parameter becomes available to any piece of the website.
So, potentially, you are able to override some parameters specified by the modules.</p>
<blockquote>
<p>You might also have seen the "combined" config file when installing PHP, where there is
the main <em>php.ini</em> file and several extra config files, which are included into the main one.
Such a separation makes your application configuration fine-grained and flexible,
because you don't have to put all your params to a single file and edit it each time you need
to change something.</p>
</blockquote>
<p>The configuration files are loaded in the following order:</p>
<ul>
<li>
<p>The main <em>application.config.php</em> file is loaded first. It is used to initialize the
  service manager and load application modules. The data loaded from this config
  is stored alone and not merged with other config files.</p>
</li>
<li>
<p>Configuration files for each application module are loaded and merged. Modules
  are loaded in the same order as they are listed in the <em>application.config.php</em> file.
  If two modules store (either intentionally, or by mistake) parameters in the
  similar-named keys, these parameters may be overwritten.</p>
</li>
<li>
<p>Extra config files from the <em>APP_DIR/config/autoload</em> folder are loaded and merged into a
  single array. Then this array is merged with the module config array produced on the previous
  stage, when loading the module configuration. Application-wide configuration has
  higher priority than the module configuration, so you can override module keys here,
  if you wish.</p>
</li>
</ul>
<h2 id="module-entry-point">Module Entry Point</h2>
<p>In Laminas, your web application consists of modules. By default, you have the single <code>Application</code> module, but can
create more if needed. Typically, your own modules are stored in <em>APP_DIR/module</em> directory, while third-party
modules live in <em>APP_DIR/vendor</em> directory.</p>
<p>On start up, when the @<code>Laminas\Mvc\Application</code> object is created, it uses the @<code>Laminas\ModuleManager</code> component to find and load
all modules registered in application config.</p>
<p>Each module of the web application has the <em>Module.php</em> file which is some kind
of <em>entry point</em> for the module. This file provides the <code>Module</code> class. Below, the contents
of skeleton application's <code>Module</code> class is presented:</p>
<pre><code class="language-php">&lt;?php
namespace Application;

class Module
{
    public function getConfig()
    {
        return include __DIR__ . '/../config/module.config.php';
    }
}
</code></pre>
<p>The class <code>Module</code> belongs to the module's namespace (for the main module
it belongs to the <code>Application</code> namespace).</p>
<p>The <code>getConfig()</code> method is typically used to provide module's configuration to Laminas Framework (<em>module.config.php</em> file).</p>
<blockquote>
<p>You can also register some <em>event listeners</em> here, we'll see how to do this later
in <a href="#modules">Creating a New Module</a> chapter.</p>
</blockquote>
<h2 id="service-manager">Service Manager</h2>
<p>You can imagine the web application as a set of <em>services</em>. For example,
you can have an authentication service responsible for logging in the site users,
entity manager service responsible for accessing the database, event manager service
responsible for triggering events and delivering them to event listeners, etc.</p>
<p>In Laminas Framework, the @<code>ServiceManager</code> class is a centralized <em>container</em> for all
application services. The service manager is implemented in @<code>Laminas\ServiceManager</code>
component, as the @<code>ServiceManager</code> class. Class inheritance diagram is shown in figure 3.5 below:</p>
<p><img alt="Figure 3.5. Service manager class inheritance diagram" src="../images/operation/service_manager_inheritance.png" /></p>
<p>The service manager is created on application start up (inside of <code>init()</code>
static method of @<code>Laminas\Mvc\Application</code> class).
The standard services available through service manager are presented in table 3.1.
This table is incomplete, because the actual number of services registered in service manager
may be much bigger.</p>
<table>
<thead>
<tr>
<th>Service Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Application</code></td>
<td>Allows to retrieve the singleton of @<code>Laminas\Mvc\Application</code> class.</td>
</tr>
<tr>
<td><code>ApplicationConfig</code></td>
<td>Configuration array extracted from <em>application.config.php</em> file.  Merged configuration array extracted from <em>module.config.php</em> files merged with <em>autoload/global.php</em> and <em>autoload/local.php</em>.</td>
</tr>
<tr>
<td><code>EventManager</code></td>
<td>Allows to retrieve a <em>new</em> instance of @<code>Laminas\EventManager\EventManager</code> class. The event manager allows to send (trigger) events and attach event listeners.</td>
</tr>
<tr>
<td><code>SharedEventManager</code></td>
<td>Allows to retrieve the singleton instance of @<code>Laminas\EventManager\SharedEventManager</code> class. The shared event manager allows to listen to events defined by other classes and components.</td>
</tr>
<tr>
<td><code>ModuleManager</code></td>
<td>Allows to retrieve the singleton of @<code>Laminas\ModuleManager\ModuleManager</code> class. The module manager is responsible for loading application modules.</td>
</tr>
<tr>
<td><code>Request</code></td>
<td>The singleton of @<code>Laminas\Http\Request</code> class. Represents HTTP request received from client.</td>
</tr>
<tr>
<td><code>Response</code></td>
<td>The singleton of @<code>Laminas\Http\Response</code> class. Represents HTTP response that will be sent to client.</td>
</tr>
<tr>
<td><code>Router</code></td>
<td>The singleton of @<code>Laminas\Router\Http\TreeRouteStack</code>. Performs URL routing.</td>
</tr>
<tr>
<td><code>ServiceManager</code></td>
<td>Service manager itself.</td>
</tr>
<tr>
<td><code>ViewManager</code></td>
<td>The singleton of @<code>Laminas\Mvc\View\Http\ViewManager</code> class. Responsible for preparing the view layer for page rendering.</td>
</tr>
</tbody>
</table>
<p>Table 3.1. Standard services</p>
<p>A service is typically an arbitrary PHP class, but not always. For example, when Laminas
loads the configuration files and merges the data into nested arrays, it saves the arrays
in the service manager as a couple of services (!): <code>ApplicationConfig</code> and <code>Config</code>.
The first one is the array loaded from application-level configuration file <em>application.config.php</em>,
and the later one is the merged array from module-level config files and auto-loaded
application-level config files. Thus, in the service manager you can store anything
you want: a PHP class, a simple variable or an array.</p>
<p>From table 3.1, you can see that in Laminas almost everything can be considered as a service. The service
manager is itself registered as a service. Moreover, the @<code>Application</code> class is also
registered as a service.</p>
<blockquote>
<p>An important thing you should note about the services is that they are <em>typically</em>
stored in a single instance only (this is also called the <em>singleton</em> pattern). Obviously,
you don't need the second instance of the @<code>Application</code> class (in that case you
would have a nightmare).</p>
<p>But, there is an important exception from the rule above. It may be confusing at first, but the
@<code>EventManager</code> is not a singleton. Each time you retrieve the event manager service from service manager,
you receive a <em>new</em> object. This is done for performance reasons and to avoid possible event conflicts between
different components. We will discuss this further in the <em>About Event Manager</em> section later in this chapter.</p>
</blockquote>
<p>The service manager defines several methods needed for locating and retrieving
a service from the service manager (see the table 3.2 below).</p>
<table>
<thead>
<tr>
<th>Method Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>has($name)</code></td>
<td>Checks if such a service is registered.</td>
</tr>
<tr>
<td><code>get($name)</code></td>
<td>Retrieves a registered service's instance.</td>
</tr>
<tr>
<td><code>build($name, $options)</code></td>
<td>Always returns a new instance of the requested service.</td>
</tr>
</tbody>
</table>
<p>Table 3.2. ServiceManager methods</p>
<p>You can test if a service is registered by passing its name to the service manager's
<code>has()</code> method. It returns a boolean <code>true</code> if the service is registered, or
<code>false</code> if the service with such a name is not registered.</p>
<p>You can retrieve a service by its name later with the help of the service manager's <code>get()</code> method.
This method takes a single parameter representing the service name. Look at the following
example:</p>
<pre><code class="language-php">&lt;?php

// Retrieve the application config array.
$appConfig = $serviceManager-&gt;get('ApplicationConfig');

// Use it (for example, retrieve the module list).
$modules = $appConfig['modules'];
</code></pre>
<p>And the <code>build()</code> method always creates a new instance of the service when you call it (comparing to <code>get()</code>, which
typically creates the instance of the service only once and returns it on later requests).</p>
<blockquote>
<p>You will typically retrieve services from service manager not in <em>any</em> place of your code, but inside of a <em>factory</em>. A factory
is a code responsible for creation of an object. When creating the object, you can retrieve services it depends on from the service manager
and pass those services (dependencies) to the object's constructor. This is also called <em>dependency injection</em>.</p>
<p>If you have some experience with Laminas Framework 2, you may notice that the things are now a little different than before.
In ZF2, there was <code>ServiceLocator</code> pattern allowing to get dependencies from service manager in <em>any</em> part of your app
(in controllers, services, etc.) In Laminas, you have to pass dependencies explicitly. It is a little more boring,
but it removes "hidden" dependencies and makes your code more clear and easier to understand.</p>
</blockquote>
<h3 id="registering-a-service">Registering a Service</h3>
<p>When writing your website, you will often need to register your own service
in the service manager. One of the ways to register a service is using the <code>setService()</code> method of the service manager.
For example, let's create and register the currency converter service class, which
will be used, for example, on a shopping cart page to convert EUR currency to USD:</p>
<pre><code class="language-php">&lt;?php
// Define a namespace where our custom service lives.
namespace Application\Service;

// Define a currency converter service class.
class CurrencyConverter
{
    // Converts euros to US dollars.
    public function convertEURtoUSD($amount)
    {
        return $amount*1.25;
    }

    //...
}
</code></pre>
<p>Above, in lines 6-15 we define an example <code>CurrencyConverter</code> class (for simplicity, we implement
only a single method <code>convertEURtoUSD()</code> which is able to convert euros to US dollars).</p>
<pre><code class="language-php">// Create an instance of the class.
$service = new CurrencyConverter();
// Save the instance to service manager.
$serviceManager-&gt;setService(CurrencyConverter::class, $service);
</code></pre>
<p>In the example above, we instantiate the class with the <code>new</code> operator, and register it
with the service manager using the <code>setService()</code> method (we assume that the <code>$serviceManager</code> variable
is of type @<code>Laminas\ServiceManager\ServiceManager</code> class, and that it was declared somewhere else).</p>
<p>The <code>setService()</code> method takes two parameters: the service name string, and the service instance.
The service name should be unique within all other possible services.</p>
<p>Once the service is stored in service manager, you can retrieve it by name at any place of your
application with the help of the service manager's <code>get()</code> method. Look at the following
example:</p>
<pre><code class="language-php">&lt;?php
// Retrieve the currency converter service.
$service = $serviceManager-&gt;get(CurrencyConverter::class);

// Use it (convert money amount).
$convertedAmount = $service-&gt;convertEURtoUSD(50);
</code></pre>
<h3 id="service-names">Service Names</h3>
<p>Different services can use different naming styles. For example, the same currency converter service
may be registered under the different names: <code>CurrencyConverter</code>,  <code>currency_converter</code>
and so on. To introduce some uniform naming convention, it is recommended to register a service by
its fully qualified class name, as follows:</p>
<pre><code class="language-php">$serviceManager-&gt;setService(CurrencyConverter::class);
</code></pre>
<p>In the example above, we used the keyword <code>class</code>. It is available since PHP 5.5 and is used for class
name resolution. <code>CurrencyConverter::class</code> is expanded to the fully qualified name of the class,
like <code>\Application\Service\CurrencyConverter</code>.</p>
<h3 id="overriding-an-existing-service">Overriding an Existing Service</h3>
<p>If you are trying to register the service name which is already present, the <code>setService()</code> method will throw an exception. But sometimes
you want to override the service with the same name (to replace it by the new one). For this purpose,
you can use the <code>setAllowOverride()</code> method of the service manager:</p>
<pre><code class="language-php">&lt;?php
// Allow to replace services
$serviceManager-&gt;setAllowOverride(true);

// Save the instance to service manager. There will be no exception
// even if there is another service with such a name.
$serviceManager-&gt;setService(CurrencyConverter::class, $service);
</code></pre>
<p>Above, the <code>setAllowOverride()</code> method takes the single boolean parameter defining whether
to allow you replace the service <code>CurrencyConverter</code> if such a name is already present, or not.</p>
<h3 id="registering-invokable-classes">Registering Invokable Classes</h3>
<p>What is bad with the <code>setService()</code> method is that you have to create the service instance
before you really need it. If you never use the service, the service instantiation will only
waste the time and memory. To resolve this issue, the service manager provides you with the
<code>setInvokableClass()</code> method.</p>
<pre><code class="language-php">&lt;?php
// Register an invokable class
$serviceManager-&gt;setInvokableClass(CurrencyConverter::class);
</code></pre>
<p>In the example above, we pass to the service manager the fully qualified class name of
the service instead of passing its instance. With this technique, the service
will be instantiated by the service manager only when someone calls the <code>get(CurrencyConverter::class)</code>
method. This is also called lazy loading.</p>
<blockquote>
<p>Services often depend on each other. For example, the currency converter service may use entity manager service
to read money exchange rates from database. The disadvantage of <code>setInvokableClass()</code> method is that it doesn't allow to pass parameters (dependencies)
to the service on object instantiation. To resolve this issue, you can use <em>factories</em>, as described below.</p>
</blockquote>
<h3 id="registering-a-factory">Registering a Factory</h3>
<p>A <em>factory</em> is a class that can do only one thing - to create other objects.</p>
<p>You register a factory for a service with the <code>setFactory()</code> method of the service manager:</p>
<p>The simplest factory is @<code>InvokableFactory</code> - it is analogous to the <code>setInvokableClass()</code> method from the previous
section.</p>
<pre><code class="language-php">&lt;?php
use Laminas\ServiceManager\Factory\InvokableFactory;

// This is equivalent to the setInvokableClass() method from previous section.
$serviceManager-&gt;setFactory(CurrencyConverter::class, InvokableFactory::class);
</code></pre>
<p>After you have registered the factory you can retrieve the service from service manager as usual with the <code>get()</code> method. The service
will be instantiated only when you retrieve it from service manager (lazy loading).</p>
<p>Sometimes, service instantiation is more complex than just creating the service instance
with <code>new</code> operator (like @<code>InvokableFactory</code> does). You may need to pass some parameters to the service's constructor or
invoke some service methods just after construction. This complex instantiation logic
can be encapsulated inside of your own custom <em>factory</em> class. The factory class typically implements the @<code>FactoryInterface</code>[Laminas\ServiceManager\Factory\FactoryInterface]:</p>
<pre><code class="language-php">&lt;?php
namespace Laminas\ServiceManager\Factory;

use Interop\Container\ContainerInterface;

interface FactoryInterface
{
    public function __invoke(ContainerInterface $container,
                        $requestedName, array $options = null);
}
</code></pre>
<p>As we see from the definition of the @<code>FactoryInterface</code>[Laminas\ServiceManager\Factory\FactoryInterface], the factory class must provide
the <code>__invoke</code> magic method returning the instance of a single service. The service manager is
passed to the <code>__invoke</code> method as the <code>$container</code> parameter; it can be used during the construction of
the service for accessing other services (to inject <em>dependencies</em>). The second argument (<code>$requestedName</code>) is
the service name. The third argument (<code>$options</code>) can be used to pass some parameters to the service, and
is used only when you request the service with the <code>build()</code> method of the service manager.</p>
<p>As an example, let's write a factory for our currency converter service (see the code below).
We don't use complex construction logics for our <code>CurrencyConverter</code> service, but for more complex
services, you may need to use one.</p>
<pre><code class="language-php">&lt;?php
namespace Application\Service\Factory;

use Laminas\ServiceManager\Factory\FactoryInterface;
use Application\Service\CurrencyConverter;

// Factory class
class CurrencyConverterFactory implements FactoryInterface
{
    public function __invoke(ContainerInterface $container,
                     $requestedName, array $options = null)
    {
        // Create an instance of the class.
        $service = new CurrencyConverter();

        return $service;
    }
}
</code></pre>
<blockquote>
<p>Technically, in Laminas you <em>can</em> use the same factory class for instantiating several services that have similar
instantiation code (for that purpose, you can use the <code>$requestedName</code> argument passed to the <code>__invoke()</code> method of the factory).
However, <em>mostly</em> you will create a different factory per each service.</p>
</blockquote>
<h3 id="registering-an-abstract-factory">Registering an Abstract Factory</h3>
<p>Even more complex case of a factory is when you need to determine at run
time which service names should be registered. For such a situation,
you can use an <em>abstract factory</em>. An abstract factory class should
implement the @<code>AbstractFactoryInterface</code>[Laminas\ServiceManager\Factory\AbstractFactoryInterface] interface:</p>
<pre><code class="language-php">&lt;?php
namespace Laminas\ServiceManager\Factory;

use Interop\Container\ContainerInterface;

interface AbstractFactoryInterface extends FactoryInterface
{
    public function canCreate(ContainerInterface $container, $requestedName);
}
</code></pre>
<p>An abstract factory has two methods: <code>canCreate()</code>
and <code>__invoke()</code>. The first one is needed to test if the factory can
create the service with the certain name, and the latter one allows to actually
create the service. The methods take two parameters: service manager (<code>$container</code>) and
service name (<code>$requestedName</code>).</p>
<p>Comparing to usual factory class, the difference is that the
usual factory class <em>typically</em> creates only a single type of service, but an abstract factory can dynamically
create as many types of services as it wants.</p>
<p>You register an abstract factory with the <code>setAbstractFactory()</code> method of the service manager.</p>
<blockquote>
<p>Abstract factories are a powerful feature, but you should use them only when really necessary, because
they negatively impact the performance. It is better to use the usual (non-abstract) factories.</p>
</blockquote>
<h3 id="registering-service-aliases">Registering Service Aliases</h3>
<p>Sometimes, you may want to define an <em>alias</em> for a service. The alias
is like a symbolic link: it references the already registered service.
To create an alias, you use the service manager's <code>setAlias()</code> method:</p>
<pre><code class="language-php">&lt;?php
// Register an alias for the CurrencyConverter service
$serviceManager-&gt;setAlias('CurConv', CurrencyConverter::class);
</code></pre>
<p>Once registered, you can retrieve the service by both its name and alias using the
service manager's <code>get()</code> method.</p>
<h3 id="shared-and-non-shared-services">Shared and Non-Shared Services</h3>
<p>By default, services are stored in service manager in single instance only. This is also called the <em>singleton</em>
design pattern. For example, when you try to retrieve the <code>CurrencyConverter</code> service twice, you will receive
the same object. This is also called a <em>shared</em> service.</p>
<p>But, in some (rare) situations, you will need to create a <em>new</em> instance of a service each time someone requests
it from service manager. An example is the @<code>EventManager</code> - you get a new instance of it each time you request it.</p>
<p>To mark a service as a non-shared, you can use service manager's <code>setShared()</code> method:</p>
<pre><code class="language-php">$serviceManager-&gt;setShared('EventManager', false);
</code></pre>
<h3 id="service-manager-configuration">Service Manager Configuration</h3>
<p>In your website, you typically use service manager configuration to register your services (instead of calling
service manager's methods as described above).</p>
<p>To automatically register a service within the service manager, typically the
<code>service_manager</code> key of a configuration file is used. You can put this key
either inside of an application-level configuration file or in a module-level
configuration file.</p>
<p>W&gt; If you are putting this key in a module-level configuration file, be
W&gt; careful about the danger of name overwriting during the configs merge.
W&gt; Do not register the same service name in different modules.</p>
<p>This <code>service_manager</code> key should look like below:</p>
<pre><code class="language-php">&lt;?php
return [
    //...

    // Register the services under this key
    'service_manager' =&gt; [
        'services' =&gt; [
            // Register service class instances here
            //...
        ],
        'invokables' =&gt; [
            // Register invokable classes here
            //...
        ],
        'factories' =&gt; [
            // Register factories here
            //...
        ],
        'abstract_factories' =&gt; [
            // Register abstract factories here
            //...
        ],
        'aliases' =&gt; [
            // Register service aliases here
            //...
        ],
        'shared' =&gt; [
            // Specify here which services must be non-shared
        ]
  ],

  //...
];
</code></pre>
<p>In the example above, you can see that the <code>service_manager</code> key may contain several
subkeys for registering services in different ways:</p>
<ul>
<li>the <code>services</code> subkey (line 7) allows to register class instances;</li>
<li>the <code>invokables</code> subkey (line 11) allows to register full class name of a service;
  the service will be instantiated using lazy loading;</li>
<li>the <code>factories</code> subkey (line 15) allows for registering a factory, which is able
  to create instances of a single service;</li>
<li>the <code>abstract_factories</code> (line 19) can be used for registering abstract factories,
  which are able to register several services by name;</li>
<li>the <code>aliases</code> subkey (line 23) provides an ability to register an alias for a service.</li>
<li>the <code>shared</code> subkey (line 27) allows to specify which services must be non-shared.</li>
</ul>
<p>As an example, let's register our <code>CurrencyConverter</code> service and create an alias for it:</p>
<pre><code class="language-php">&lt;?php
use Laminas\ServiceManager\Factory\InvokableFactory;
use Application\Service\CurrencyConverter;

return [
    //...

    // Register the services under this key
    'service_manager' =&gt; [
        'factories' =&gt; [
            // Register CurrencyConverter service.
            CurrencyConverter::class =&gt; InvokableFactory::class
        ],
        'aliases' =&gt; [
            // Register an alias for the CurrencyConverter service.
            'CurConv' =&gt; CurrencyConverter::class
        ],
  ],

  //...
];
</code></pre>
<h2 id="plugin-managers">Plugin Managers</h2>
<p>Now that you understand what service manager is, it shouldn't be very difficult for you to learn
the concept of <em>plugin managers</em>. A <em>plugin manager</em> is almost the same as the service manager,
but it can instantiate services of the single type only. Which plugin type a plugin manager may
be hard-coded instantiated inside the plugin manager class.</p>
<p>Why would you need such thing? Actually, in Laminas, plugin managers are widely used, because they
allow to instantiate a plugin only when it is needed (this reduces CPU and memory usage). There is a
separate plugin manager for:</p>
<ul>
<li>controllers (the @<code>Laminas\Mvc\Controller\ControllerManager</code> class)</li>
<li>controller plugins (the @<code>Laminas\Mvc\Controller\PluginManager</code> class)</li>
<li>view helpers (the @<code>Laminas\View\HelperPluginManager</code> class)</li>
<li>form elements (the @<code>Laminas\Form\FormElementManager\FormElementManagerV3Polyfill</code> class)</li>
<li>filters (the @<code>Laminas\Filter\FilterPluginManager</code> class)</li>
<li>validators (the @<code>Laminas\Validator\ValidatorPluginManager</code> class)</li>
<li>and probably other stuff</li>
</ul>
<p>The fact that each plugin manager inherits from the @<code>Laminas\ServiceManager\ServiceManager</code> base
class allows all plugin managers to have similar configuration. For example, controllers are
registered under the <code>controllers</code> key in <em>module.config.php</em> file, and this key may have the same subkeys:
<em>services</em>, <em>invokables</em>, <em>factories</em>, <em>abstract_factories</em>, and <em>aliases</em>. The same structure has the
<em>view_helpers</em> key that is used for registering view helpers, the <em>controller_plugins</em> key that is used
for registering controller plugins, and so on.</p>
<h2 id="about-event-manager">About Event Manager</h2>
<blockquote>
<p>In this section, we will give some advanced information about event manager. You can relatively safely skip this
   section, however refer to it if you plan to implement some advanced event listeners in your website.</p>
</blockquote>
<p>Previously in this chapter we have mentioned that the application life cycle consists of <em>events</em>.
One class can <em>trigger</em> an event, and other classes may <em>listen</em> to events. Technically, triggering an event means just calling
another class' "callback" method. The event management is implemented inside of
the @<code>Laminas\EventManager</code> component.</p>
<blockquote>
<p>Laminas (and particularly its @<code>Laminas\Mvc</code> component) hardly depends on events to operate,
and because of that its source code is a combination of event listeners which is rather difficult to understand.
Fortunately, in most cases you do not need to understand how Laminas triggers and handles events internally, you just need
to understand what event is, what events present in application life cycle and what is the difference between usual <em>event manager</em> and
<em>shared event manager</em>.</p>
</blockquote>
<h3 id="event-mvcevent">Event &amp; MvcEvent</h3>
<p>An <em>event</em> is technically an instance of the @<code>Laminas\EventManager\Event</code> class.
An event can basically have at least the following parts:</p>
<ul>
<li><em>name</em> - uniquely identifies the event;</li>
<li><em>target</em> - this is typically a pointer to the object which triggered the event;</li>
<li>and <em>params</em> - event-specific arguments passed to the event listeners.</li>
</ul>
<p>It is possible to create custom types of events by extending the @<code>Event</code>[Laminas\EventManager\Event] class.
For example, the @<code>Laminas\Mvc</code> component defines the custom event type named @<code>Laminas\Mvc\MvcEvent</code>,
which extends the <code>Event</code> class and adds several properties and methods
needed for the @<code>Laminas\Mvc</code> component to work.</p>
<h3 id="eventmanager-sharedeventmanager">EventManager &amp; SharedEventManager</h3>
<p>It is important to understand the difference between the <em>usual</em> event manager and the <em>shared</em> event manager.</p>
<p>The usual event manager is not stored as a singleton in the service manager. Every time you request the @<code>EventManager</code>
service from the service manager, you receive a new instance of it. This is done for privacy and performance reasons:</p>
<ul>
<li>
<p>It is assumed by default that the class triggering events will request and save somewhere
    its own private event manager, because it doesn't want other classes to
    automatically listen to those events. Events triggered by the class are assumed to belong to that class privately.</p>
</li>
<li>
<p>If anyone would be able to listen to any event triggered by any class, there would be performance hell - too many
    event listeners would be invoked, thus increasing page load time. It is better to avoid this by keeping events private.</p>
</li>
</ul>
<p>But, in case if someone intentionally <em>needs</em> to listen to other's events, there is a special <em>shared</em> event manager. The @<code>SharedEventManager</code>
service is stored in the service manager as a singleton, so you can be sure everyone will have the same instance of it.</p>
<p>With the @<code>SharedEventManager</code>, you can attach a listener to private events triggered by certain class (or several classes).
You specify the unique class identifier(s) to which you would like to listen. That simple!</p>
<blockquote>
<p>Some practical examples of how to listen and react to an event can be found in <a href="#modules">Creating a New Module</a>
chapter and <a href="#users">User Management, Authentication &amp; Access Filtering</a> chapter.</p>
</blockquote>
<h2 id="summary">Summary</h2>
<p>In this chapter, we've learned some theory about laminas-based website operation basics.</p>
<p>Laminas uses PHP namespaces and class autoloading features, simplifying the development
of applications which use many third-party components. The namespaces allow to solve the
name collisions between code components, and provide you with the ability to make the long names shorter.</p>
<p>The class autoloading makes it possible to use any PHP class in any library installed with Composer
without the use of <code>require_once</code> statement. Composer also provides a PSR-4 autoloader for the classes
located in the modules of your web application.</p>
<p>Most of Laminas Framework components require configuration. You can define the configuration parameters either at
the application level, or at the module level.</p>
<p>The main goal of any web application is handling the HTTP request and producing an
HTTP response typically containing the HTML code of the requested web page. When
Apache web server receives an HTTP request from a client browser, it executes the <em>index.php</em>
file, which is also called the site's entry script. On every HTTP request, the @<code>Laminas\Mvc\Application</code>
object is created, whose "life cycle" consists of several stages (or events).</p>
<p>The web application's business logic can be also considered as a set of services. In Laminas Framework,
the service manager is a centralized container for all the application services. A service is typically
a PHP class, but in general it can be a variable or an array, if needed.</p>
<div class="footnote">
<hr />
<ol>
<li id="fn:controller">
<p><code>IndexController</code> class is the default controller for the skeleton website.
           We will talk about controllers later in chapter <a href="#mvc">Model-View-Controller</a>.&#160;<a class="footnote-backref" href="#fnref:controller" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
</ol>
</div>
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Footer Navigation">
        <a href="../skeleton/" class="btn btn-neutral float-left" title="Laminas Skeleton Application"><span class="icon icon-circle-arrow-left"></span> Previous</a>
        <a href="../mvc/" class="btn btn-neutral float-right" title="Model-View-Controller">Next <span class="icon icon-circle-arrow-right"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
        <span>
          <a href="https://github.com/modir/laminas-book" class="fa fa-github" style="color: #fcfcfc"> GitHub</a>
        </span>
    
    
      <span><a href="../skeleton/" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
      <span><a href="../mvc/" style="color: #fcfcfc">Next &raquo;</a></span>
    
  </span>
</div>
    <script src="../js/jquery-3.6.0.min.js"></script>
    <script>var base_url = "..";</script>
    <script src="../js/theme_extra.js"></script>
    <script src="../js/theme.js"></script>
      <script src="../search/main.js"></script>
    <script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>

</body>
</html>
