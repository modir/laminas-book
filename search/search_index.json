{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Preface \"Using Laminas Framework\" is a free and open-source book about programming web applications with Laminas Framework. This book uses Creative Commons Attribution-NonCommercial-ShareAlike license. About Laminas Laminas is a modern PHP framework intended for building professional, scalable and secure websites. Such websites are easy to test and maintain. The framework utilizes the best practices and common design patterns inspired by the evolution of the web development industry. This includes the Model-View-Controller pattern allowing an application's code to be organized in a consistent and standard way. The Laminas Framework started as Zend Framework. After Zend Framework version 3 it got renamed to Laminas. About this Book This book is not only about Laminas Framework, but also about closely related libraries. Although Laminas Framework has a dedicated component for accessing the database, in this book we use a third-party library called Doctrine ORM which is a de-facto standard object-oriented way to perform database management. In the sample applications we will create in chapters of this book, Twitter Bootstrap CSS Framework is used to produce nicely styled and laid out web pages. This book was initially written by Oleg Krivtsov as a Zend 3 book. As nobody took care of it Raffael Luthiger took over and rewrote it as a Laminas book. Intended Audience This book is intended for web developers involved in the development of web-based applications in PHP. The author strives to start with simple things that a beginner should understand. Advanced things go last in a chapter. This makes this book the first book about Laminas Framework that is easy to read and understand for a newbie. You do not need to be a guru in design patterns to understand most of the content. To read and understand this book, you need to have a basic knowledge of PHP. A good point for learning PHP is its official website and the on-line documentation . It would be good if you have some understanding of HTTP requests, GET and POST variables, namespaces, classes and interfaces. Because PHP is closely related to other web technologies, it is also recommended that you have some basic experience in the following: HTML (Hyper Text Markup Language) -- used for creating web pages that can be displayed in a web browser. CSS (Cascading Style Sheets) -- used for defining the look and feel of a web page, like font size or background color. JavaScript -- a client-side scripting language used for making a web page more interactive. For learning HTML, CSS and JavaScript, a good starting point is W3Schools Tutorials . Examples and Source Code This book's text is illustrated with code samples. Each sample is a complete website you can install and run yourself to see Laminas Framework in action. You can even use the samples as a base for your own websites. Note Important: The book is now migrated to Laminas. There are links though to example applications which are still written in Zend. Once I have some more spare time I will migrate them as well. Or maybe someone else has the time for it. All the source code is stored on GitHub. The code is publicly available, and you can download the entire code archive by visiting this page . To download the archive, click the Clone or Download button that can be found on the page (see the figure below). The structure of the code archive is presented below. using-laminas-book-samples blog helloworld formdemo ... Your Feedback Thank you for reading this book and helping to make it better. You are encouraged to point out errors and make suggestions and critical remarks. You can edit the code of this book directly on github with the buttons on the top of each page. Furthermore you can write to the current maintainer through his e-mail address ( r.luthiger@huanga.com ). Your feedback is highly appreciated. About the Original Author Oleg Krivtsov is a C++ and PHP developer. He has been developing software professionally since 2005. Oleg is a Certified Laminas Framework 2 Architect and a Certified MySQL Developer. He likes contributing to open-source and writing programming articles for popular web resources, like CodeProject. This writing passion has also inspired him to create this book about Laminas Framework. Oleg also loves skiing and watching Formula 1. You can contact Oleg through his e-mail address ( olegkrivtsov@gmail.com ).","title":"Preface"},{"location":"#preface","text":"\"Using Laminas Framework\" is a free and open-source book about programming web applications with Laminas Framework. This book uses Creative Commons Attribution-NonCommercial-ShareAlike license.","title":"Preface"},{"location":"#about-laminas","text":"Laminas is a modern PHP framework intended for building professional, scalable and secure websites. Such websites are easy to test and maintain. The framework utilizes the best practices and common design patterns inspired by the evolution of the web development industry. This includes the Model-View-Controller pattern allowing an application's code to be organized in a consistent and standard way. The Laminas Framework started as Zend Framework. After Zend Framework version 3 it got renamed to Laminas.","title":"About Laminas"},{"location":"#about-this-book","text":"This book is not only about Laminas Framework, but also about closely related libraries. Although Laminas Framework has a dedicated component for accessing the database, in this book we use a third-party library called Doctrine ORM which is a de-facto standard object-oriented way to perform database management. In the sample applications we will create in chapters of this book, Twitter Bootstrap CSS Framework is used to produce nicely styled and laid out web pages. This book was initially written by Oleg Krivtsov as a Zend 3 book. As nobody took care of it Raffael Luthiger took over and rewrote it as a Laminas book.","title":"About this Book"},{"location":"#intended-audience","text":"This book is intended for web developers involved in the development of web-based applications in PHP. The author strives to start with simple things that a beginner should understand. Advanced things go last in a chapter. This makes this book the first book about Laminas Framework that is easy to read and understand for a newbie. You do not need to be a guru in design patterns to understand most of the content. To read and understand this book, you need to have a basic knowledge of PHP. A good point for learning PHP is its official website and the on-line documentation . It would be good if you have some understanding of HTTP requests, GET and POST variables, namespaces, classes and interfaces. Because PHP is closely related to other web technologies, it is also recommended that you have some basic experience in the following: HTML (Hyper Text Markup Language) -- used for creating web pages that can be displayed in a web browser. CSS (Cascading Style Sheets) -- used for defining the look and feel of a web page, like font size or background color. JavaScript -- a client-side scripting language used for making a web page more interactive. For learning HTML, CSS and JavaScript, a good starting point is W3Schools Tutorials .","title":"Intended Audience"},{"location":"#examples-and-source-code","text":"This book's text is illustrated with code samples. Each sample is a complete website you can install and run yourself to see Laminas Framework in action. You can even use the samples as a base for your own websites. Note Important: The book is now migrated to Laminas. There are links though to example applications which are still written in Zend. Once I have some more spare time I will migrate them as well. Or maybe someone else has the time for it. All the source code is stored on GitHub. The code is publicly available, and you can download the entire code archive by visiting this page . To download the archive, click the Clone or Download button that can be found on the page (see the figure below). The structure of the code archive is presented below. using-laminas-book-samples blog helloworld formdemo ...","title":"Examples and Source Code"},{"location":"#your-feedback","text":"Thank you for reading this book and helping to make it better. You are encouraged to point out errors and make suggestions and critical remarks. You can edit the code of this book directly on github with the buttons on the top of each page. Furthermore you can write to the current maintainer through his e-mail address ( r.luthiger@huanga.com ). Your feedback is highly appreciated.","title":"Your Feedback"},{"location":"#about-the-original-author","text":"Oleg Krivtsov is a C++ and PHP developer. He has been developing software professionally since 2005. Oleg is a Certified Laminas Framework 2 Architect and a Certified MySQL Developer. He likes contributing to open-source and writing programming articles for popular web resources, like CodeProject. This writing passion has also inspired him to create this book about Laminas Framework. Oleg also loves skiing and watching Formula 1. You can contact Oleg through his e-mail address ( olegkrivtsov@gmail.com ).","title":"About the Original Author"},{"location":"acknowledgments/","text":"Acknowledgments From the Original Zend 3 Book Thanks to Edu Torres, a 2D artist from Spain, for making the cover for this book. Thanks to Roman Belinsky, a translator from Saint Pitersburg, for his hard work in translating this book to Russian. Great thanks to Guillermo Lengemann for translating the book into Spanish and contributing his translation. Great thanks to Cora Cox for contributing her French translation. Thanks to Igor Conde for starting Portuguese translation of the book. Also thanks to Alan Stanley, Sam Sheridan, Kevin Foster, Blount, Alex Lashford, Jakub Ksiazek, Guillermo Lengemann, Olexiy Guzenko, Pavel Savostin, Alessandro De Giuli, Alex Belkin, @csharpninja, Cyrille Hamel, Greg Bell, Yuri Aya, Dmitriy Halytskiy, Denis Krupnov, Vladim\u00edr N\u00e1prstek, Renato Mendes, Mulot, Paolo Bernardi, Behzad Moradi, @bitwombat, Rodion Abdurakhimov, Fadel Chafai, Moriancumer Richard Uy and Charles Naylor for helping to find and fix mistakes in the text. For the New Laminas Book Thanks to Raffael Luthiger for migrating the book from Zend to Laminas","title":"Acknowledgments"},{"location":"acknowledgments/#acknowledgments","text":"","title":"Acknowledgments"},{"location":"acknowledgments/#from-the-original-zend-3-book","text":"Thanks to Edu Torres, a 2D artist from Spain, for making the cover for this book. Thanks to Roman Belinsky, a translator from Saint Pitersburg, for his hard work in translating this book to Russian. Great thanks to Guillermo Lengemann for translating the book into Spanish and contributing his translation. Great thanks to Cora Cox for contributing her French translation. Thanks to Igor Conde for starting Portuguese translation of the book. Also thanks to Alan Stanley, Sam Sheridan, Kevin Foster, Blount, Alex Lashford, Jakub Ksiazek, Guillermo Lengemann, Olexiy Guzenko, Pavel Savostin, Alessandro De Giuli, Alex Belkin, @csharpninja, Cyrille Hamel, Greg Bell, Yuri Aya, Dmitriy Halytskiy, Denis Krupnov, Vladim\u00edr N\u00e1prstek, Renato Mendes, Mulot, Paolo Bernardi, Behzad Moradi, @bitwombat, Rodion Abdurakhimov, Fadel Chafai, Moriancumer Richard Uy and Charles Naylor for helping to find and fix mistakes in the text.","title":"From the Original Zend 3 Book"},{"location":"acknowledgments/#for-the-new-laminas-book","text":"Thanks to Raffael Luthiger for migrating the book from Zend to Laminas","title":"For the New Laminas Book"},{"location":"appearance/","text":"Page Appearance and Layout In this chapter you will learn how to make your web pages attractive and professionally looking with the help of Twitter Bootstrap CSS Framework and how to position elements on a page using Laminas layout mechanism. You'll also become familiar with common view helpers allowing for composing web pages of reusable parts. If you are new to Twitter Bootstrap, it is also recommended that you refer to Appendix C. Introduction to Twitter Bootstrap for advanced description of Bootstrap capabilities. Laminas components covered in this chapter: Component Description @ Laminas\\Mvc Support of MVC pattern. Implements base controller classes, controller plugins, etc. @ Laminas\\View Implements the functionality for variable containers, rendering a web page and common view helpers. About CSS Stylesheets and Twitter Bootstrap In a laminas-based web site, for defining the visual appearance and style of the web pages, CSS stylesheets are utilized. These CSS 1 files are typically stored in APP_DIR/public/css directory. Because the CSS rules may be rather complex and require laborious adjustment and the skills of a designer, they can be separated in a \"library\" (framework). Analogous to PHP frameworks, CSS frameworks allow for code reusability. Today, several CSS frameworks exist on the market, and one of them is Twitter Bootstrap (or shortly, the Bootstrap). Originally designed at Twitter to unify the appearance of their own web tools, Bootstrap has became a popular CSS framework, allowing to make your web site professionally looking and visually appealing, even if you don't have advanced designer skills and without the need of creating basic CSS rules (but, of course you can define your own custom CSS rules on top of Bootstrap to customize your site's appearance). Bootstrap is freely distributed under the Apache License v.2.0 . Note Twitter Bootstrap is shipped with Laminas Skeleton Application, so you can use it out of the box. Alternatively, you can download the newest version of Bootstrap from the project's official page . At the moment of writing this book, the latest version is v.5.x. Generally, the Bootstrap does the following things: It provides the CSS reset that is a style sheet defining styles for all possible HTML elements. This ensures your web site will look the same way in all web browsers. It provides the base CSS rules that define style of typography (headings and text), tables, forms, buttons, images and so on. It defines the grid system . The grid system allows to arrange elements on your web page in a grid-like structure. For example, look at the Skeleton Application's main page (figure 6.1), where we have the grid consisting of three columns. It defines useful web interface components like dropdown menus, navigation bars, breadcrumbs, pagination and so on. For example, on the skeleton app's main page, there is the navigation bar component at the top, and the header (also called the Hero Unit or Jumbotron) component below the navbar. These components are very handy on any web site. In includes the JavaScript extensions that allow to make Bootstrap-provided interface components more interactive. For example, JavaScript is used to animate dropdown menus and display \"modal dialogs\". Note If you are new to Twitter Bootstrap, it is recommended that you refer to Appendix C. Introduction to Twitter Bootstrap , where you can find more information about using Twitter Bootstrap and its components. Page Layout in Laminas Framework Pages of your web site typically have some common structure that can be shared among them. For example, a typical page has the <!DOCTYPE> declaration to identify the HTML document, and the <head> and <body> elements: <!DOCTYPE html> <html lang=\"en\"> <head> <title>Welcome</title> <!-- Include metas, stylesheets and scripts here --> </head> <body> <!-- Include page content here --> </body> </html> The <head> element contains the page title text, meta information and references to included stylesheets and scripts. The <body> element contains the content of the page, like the logo image, the navigation bar, the page text, and the footer with copyright information. In Laminas Framework, you define this common structure with the \"master\" view template called the layout . The layout \"decorates\" other view templates. The layout template typically has a placeholder in which Laminas puts the content specific to a particular page (see figure 6.2 for example). In the Skeleton Application, the default layout template file is called layout.phtml and is located inside of the view/layout directory in Application module's directory (see figure 6.3 for example). Let's look at the layout.phtml template file in more details. Below, the complete contents of the file is presented: <?= $this->doctype() ?> <html lang=\"en\"> <head> <meta charset=\"utf-8\"> <?= $this->headTitle('ZF Skeleton Application') ->setSeparator(' - ')->setAutoEscape(false) ?> <?= $this->headMeta() ->appendName('viewport', 'width=device-width, initial-scale=1.0') ->appendHttpEquiv('X-UA-Compatible', 'IE=edge') ?> <!-- The styles (CSS) --> <?= $this->headLink(['rel' => 'shortcut icon', 'type' => 'image/vnd.microsoft.icon', 'href' => $this->basePath() . '/img/favicon.ico']) ->prependStylesheet($this->basePath('css/style.css')) ->prependStylesheet($this->basePath('css/bootstrap-theme.min.css')) ->prependStylesheet($this->basePath('css/bootstrap.min.css')) ?> <!-- JS Scripts --> <?= $this->headScript() ->prependFile($this->basePath('js/bootstrap.min.js')) ->prependFile($this->basePath('js/jquery-2.2.4.min.js')) ?> </head> <body> <nav class=\"navbar navbar-inverse navbar-fixed-top\" role=\"navigation\"> <div class=\"container\"> <div class=\"navbar-header\"> <button type=\"button\" class=\"navbar-toggle\" data-toggle=\"collapse\" data-target=\".navbar-collapse\"> <span class=\"icon-bar\"></span> <span class=\"icon-bar\"></span> <span class=\"icon-bar\"></span> </button> <a class=\"navbar-brand\" href=\"<?php echo $this->url('home') ?>\"> <img src=\"<?= $this->basePath('img/zf-logo.png') ?>\" alt=\"Laminas Framework <?= \\Application\\Module::VERSION ?>\"/> &nbsp;Skeleton Application </a> </div> <div class=\"collapse navbar-collapse\"> <ul class=\"nav navbar-nav\"> <li class=\"active\"> <a href=\"<?= $this->url('home') ?>\">Home</a> </li> </ul> </div> </div> </nav> <div class=\"container\"> <?= $this->content; ?> <hr> <footer> <p>&copy; 2005 - <?= date('Y') ?> by Laminas Technologies Ltd. All rights reserved. </p> </footer> </div> <?= $this->inlineScript() ?> </body> </html> You can see that the layout.phtml file (as a usual view template) consists of HTML tags mixed with PHP code fragments. When the template is being rendered, Laminas evaluates the inline PHP fragments and generates resulting HTML page visible to site users. Line 1 above generates the <!DOCTYPE> 2 declaration of the HTML page with the @ Doctype view helper. Line 3 defines the <html> element representing the root of the HTML document. The <html> tag is followed by the <head> tag (line 4), which typically contains a title for the document, and can include other information like scripts, CSS styles and meta information. In line 5, the <meta> tag provides the browser with a hint that the document is encoded using UTF-8 3 character encoding. In line 6, we have the @ HeadTitle view helper that allows to define the title for the page (\"ZF Skeleton Application\"). The title will be displayed in the web browser's caption. The setSeparator() method is used to define the separator character for the compound page titles 4 ; the setAutoEscape() method enhances the security by escaping unsafe characters from the page title. In line 9, the @ HeadMeta view helper allows to define the <meta name=\"viewport\"> tag containing meta information for the web browser to control layout on different display devices, including mobile browsers. The width property controls the size of the viewport, while the initial-scale property controls the zoom level when the page is loaded. This makes the web page layout \"responsive\" to device viewport size. In line 15, the @ HeadLink view helper allows to define the <link> tags. With the <link> tags, you typically define the \"favicon\" for the page (located in APP_DATA/public/img/favicon.ico file) and the CSS stylesheets. In lines 17-19, the stylesheets common to all site pages are included by the prependStylesheet() method of the @ HeadLink view helper. Any page in our website will load three CSS stylesheet files: bootstrap.min.css (the minified version of Twitter Bootstrap CSS Framework), bootstrap-theme.min.css (the minified Bootstrap theme stylesheet) and style.css (CSS file allowing us to define our own CSS rules overriding Bootstrap CSS rules). Lines 23-25 include the JavaScript files that all your web pages will load. The scripts are executed by the client's web browser, allowing to introduce some interactive features for your pages. We use the bootstrap.min.js (minified version of Twitter Bootstrap) and jquery-2.2.4.min.js (minified version of jQuery library) scripts. All scripts are located in APP_DIR/public/js directory. Line 28 defines the <body> tag, the document's body which contains all the contents of the document, such as the navigation bar, text, hyperlinks, images, tables, lists, etc. In lines 29-52, you can recognize the Bootstrap navigation bar definition. The skeleton application uses the collapsible navbar with dark inverse theme. The navbar contains the single link Home . If you look at lines 53-61, you should notice the <div> element with container class which denotes the container element for the grid system. So, you can use the Bootstrap grid system to arrange the contents of your pages. Line 54 is very important, because this line defines the inline PHP code that represents the page content placeholder we talked about in the beginning of this section. When the Laminas page renderer evaluates the layout template, it echoes the actual page content here. Lines 56-60 define the page footer area. The footer contains the copyright information like \"2016 by Laminas Technologies Ltd. All rights reserved.\" You can replace this information with you own company name. Line 62 is the placeholder for JavaScript scripts loaded by the concrete page. The @ InlineScript view helper will substitute here all the scripts you register (about registering JavaScript scripts, you will see it later in this chapter). And finally, lines 63-64 contain the closing tags for the body and the HTML document. Modifying the Default Page Layout To demonstrate how you can define your own page layout, we will modify the original layout of the Laminas Skeleton Application website. We want to make it display the \"Hello world\" page title, the \"Hello world!\" header text at the top, the navigation bar and breadcrumbs below the header, page content placeholder in the middle of the page, and the footer with the copyright information at the bottom (see figure 6.4 for an example of what we are trying to achieve). Let's start with the \"Hello World\" page title. We replace the lines 6-7 in the layout.phtml file as follows: <?= $this->headTitle('Hello World')->setSeparator(' - ')->setAutoEscape(false) ?> Next, we will use the Bootstrap-provided grid system for arranging the main blocks on the page. Replace the HTML code of the <body> element (lines 28-63) with the following one: <body> <div class=\"container\"> <div class=\"row\"> <!-- Page header --> <div class=\"col-md-4\"> <div class=\"app-caption\">Hello World!</div> </div> </div> <div class=\"row\"> <div class=\"col-md-12\"> <!-- Navigation bar --> </div> </div> <div class=\"row\"> <div class=\"col-md-12\"> <!-- Breadcrumbs --> </div> </div> <div class=\"row\"> <div class=\"col-md-12\"> <!-- Page content placeholder --> <?= $this->content; ?> </div> </div> <div class=\"row\"> <div class=\"col-md-12\"> <hr> <p>&copy; 2005 - <?= date('Y') ?> by Your Company. All rights reserved.</p> </div> </div> <!-- /container --> <?php echo $this->inlineScript() ?> </body> In the code above, we defined the <div> element with the container class and put the <div> elements of the grid inside of it. The grid consists of 5 rows: The page header containing the \"Hello World!\" text (lines 3-8). The header text spans four grid columns. For styling the text, we use our custom CSS class app-caption (we will define this class in style.css file a little bit later). We left the space for navigation bar interface component in line 11. In line 16, we have the space for breadcrumbs component. In line 22, we have the page content placeholder. When the renderer evaluates the page, it will echo the value of the $content variable, so the actual page content will be substituted here. And in lines 25-29, we provided the page footer with the text \"(c) 2013 by Your Company. All rights reserved.\" You can change this text and substitute your company name here, if you wish. Next, we put the navigation bar in the corresponding grid row: <!-- Navigation bar --> <nav class=\"navbar navbar-default\" role=\"navigation\"> <div class=\"collapse navbar-collapse navbar-ex1-collapse\"> <ul class=\"nav navbar-nav\"> <li class=\"active\"> <a href=\"<?= $this->url('home') ?>\">Home</a> </li> <li> <a href=\"<?= $this->url('application', ['action'=>'downloads']) ?>\"> Downloads </a> </li> <li class=\"dropdown\"> <a href=\"#\" class=\"dropdown-toggle\" data-toggle=\"dropdown\"> Support <b class=\"caret\"></b> <ul class=\"dropdown-menu\"> <li> <a href=\"<?= $this->url('doc', ['page'=>'contents']) ?>\"> Documentation </a> </li> <li> <a href=\"<?= $this->url('static', ['page'=>'help']) ?>\"> Help </a> </li> </ul> </a> </li> <li> <a href=\"<?= $this->url('about') ?>\">About</a> </li> </ul> </div> </nav> In the code above, we used the navbar interface component provided by the Bootstrap. We also used the @ Url [Laminas\\View\\Helper\\Url] view helper to insert the links to the navigation items. Note We discussed the usage of the @ Url [Laminas\\View\\Helper\\Url] view helper in the Generating URLs from Route section in Routing . Next, put the breadcrumbs component to the corresponding grid row: <!-- Breadcrumbs --> <ol class=\"breadcrumb\"> <li class=\"active\">Home</li> </ol> Finally, we need to provide a couple of custom CSS rules to fine-tune the look and feel. We define our own CSS rules in the style.css stylesheet. We want to make the \"Hello World!\" header text to use larger bold font and use a nice looking color. To do this, open the style.css file, and append the following lines to the end: div.app-caption { padding: 25px 0px; font-size: 3.0em; font-weight: bold; color: #6aacaf } In the CSS code above, we created the app-caption class which can be applied to <div> element and defining the 25 pixels vertical padding, large font size, bold text style and the hexadecimal representation of the RGB text color. By default, in skeleton application, the navbar is pinned to page top, and the CSS rule for the page body defines the 20 pixels top padding to leave space for it. Since in our Hello World example we've unpinned the navigation bar from top of the page and placed it in page flow, we need to remove the padding from page body top. To do that, edit the body CSS rule in the style.css file and make it look like the one below: body { padding-bottom: 40px; } Great, we've completed the page layout template! To see the result of our changes, open the site in your browser, you should see the page as in figure 6.4. You can click the links in navigation bar to visit the pages like About or Documentation , etc. The content of a particular page is put into the content placeholder of our layout. Note The result can also be seen in action in the Hello World sample application that is part of this book's example code available on GitHub. Switching between Layouts By default, Laminas provides you with a single layout template layout.phtml . In real-life applications, you will probably need to have several layouts and switch the layout for certain controller/action. For example, you may have a front-end and a back-end part of your site. The front-end part would consist of web pages publicly visible to all users and would utilize the default layout for all of these pages. The back-end part would consist of pages visible to the administrator user only and utilize another layout template containing the administrative menu. First, prepare another layout template file. For example, call it layout2.phtml . To simplify the file preparation, copy the content of the default layout.phtml file and make the necessary changes. When the second layout template is ready, you can switch between layouts for a particular controller's action by using the following code: // A controller's action method that uses an alternative // layout template. public function indexAction() { //... // Use the Layout plugin to access the ViewModel // object associated with layout template. $this->layout()->setTemplate('layout/layout2'); //... } In the example action method above, we use the @ Layout [Laminas\\Mvc\\Controller\\Plugin\\Layout] controller plugin (line 9) that allows to access the instance of the @ ViewModel [Laminas\\View\\Model\\ViewModel] class associated with the layout template. To change the layout template for this particular action method, we called the setTemplate() method provided by the ViewModel class. Note In addition to the @ Layout [Laminas\\Mvc\\Controller\\Plugin\\Layout] controller plugin, there is the @ Layout [Laminas\\View\\Helper\\Layout] view helper which provides the same capabilities. With the @ Layout [Laminas\\View\\Helper\\Layout] view helper, you can, for example, switch layout from the \"static\" page which has no specific controller action. Setting Layout for All Actions of a Controller If all action methods of a controller class need to use the same alternative layout, you can override the onDispatch() method of the @ AbstractActionController class and call the setTemplate() method there, as shown in the example below: // Add this alias in the beginning of the controller file use Laminas\\Mvc\\MvcEvent; // ... class IndexController extends AbstractActionController { /** * We override the parent class' onDispatch() method to * set an alternative layout for all actions in this controller. */ public function onDispatch(MvcEvent $e) { // Call the base class' onDispatch() first and grab the response $response = parent::onDispatch($e); // Set alternative layout $this->layout()->setTemplate('layout/layout2'); // Return the response return $response; } } Partial Views A partial view is a .phtml view template file which can be rendered by another view template. Partial views allow to compose your page of pieces and reuse pieces of view rendering logic across different view templates. For a simple example of partial view usage, let's imagine that we need to render a table of some products. Each product has the ID, the name and the price. We can use partial view template to render a single row of the table several times. First, let's add the partialDemoAction() method to the Index controller: // An action that demonstrates the usage of partial views. public function partialDemoAction() { $products = [ [ 'id' => 1, 'name' => 'Digital Camera', 'price' => 99.95, ], [ 'id' => 2, 'name' => 'Tripod', 'price' => 29.95, ], [ 'id' => 3, 'name' => 'Camera Case', 'price' => 2.99, ], [ 'id' => 4, 'name' => 'Batteries', 'price' => 39.99, ], [ 'id' => 5, 'name' => 'Charger', 'price' => 29.99, ], ]; return new ViewModel(['products' => $products]); } The action method above just prepares an array of products for rendering and passes it to the view template with the help of the @ ViewModel [Laminas\\View\\Model\\ViewModel] variable container. Next, add the partial-demo.phtml template file: <?php $this->headTitle('Partial View Demo'); ?> <h1>Partial View Demo</h1> <p> Below, the table of products is presented. It is rendered with the help of partial views. </p> <table class=\"table table-striped table-hover\"> <tr> <th>ID</th> <th>Product</th> <th>Price</th> </tr> <?php foreach ($this->products as $product) { echo $this->partial('application/index/table-row', ['product'=>$product]); } ?> </table> In the view template above, we define the markup for the table of products (lines 10-22). In line 18, we walk through the items of the products array and render each row with the @ Partial view helper. The first argument of the @ Partial view helper is the name of the partial view template file (\"application/index/table-row\"). The second argument of the @ Partial view helper should be an array of arguments passed to the view template. They will be accessible the same way as if you would pass them with the @ ViewModel [Laminas\\View\\Model\\ViewModel] variable container. Finally, create the table-row.phtml view template, which will be used as the partial view template: <tr> <td> <?= $this->product['id'] ?> </td> <td> <?= $this->product['name'] ?> </td> <td> <?= $this->product['price'] ?> </td> </tr> In the view template above, we just render a single row of the table. To see the resulting web page, type \"http://localhost/application/partial-demo\" URL in your browser's navigation bar. You should see something like in figure 6.5. Placeholder View Helper The @ Placeholder [Laminas\\View\\Helper\\Placeholder] is another useful view helper allowing for capturing HTML content and storing 5 it for later use. Thus, analogous to the @ Partial view helper, it allows to compose your page of several pieces. For example, you can use the @ Placeholder [Laminas\\View\\Helper\\Placeholder] view helper in pair with the @ Partial view helper to \"decorate\" the content of a view template with another view template. A useful practical application for this is layout \"inheritance\". Imagine the situation, when you need to create an alternative layout which has exactly the same head section, header and the footer, but has differences in the middle page section. The \"brute force\" way for making such a layout would be to copy and paste the content of the original layout template, and make necessary changes. Another (better) way is \"inheriting\" the original one, when the resulting layout will reuse the common parts. To demonstrate how to inherit a layout, we will create the layout2.phtml view template, which will inherit the default layout.phtml template, and add the Ads bar at the right of the page. Keeping ads in layout would be useful, if you plan to profit from displaying commercial ads on all (or on most) pages of your site. Put the following code in the layout2.phtml template file: <?php $this->placeholder('content')->captureStart(); ?> <div class=\"row\"> <div class=\"col-md-8\"> <?= $this->content; ?> </div> <div class=\"col-md-4\"> <div class=\"panel panel-default\"> <div class=\"panel-heading\"> <h3 class=\"panel-title\">Ads</h3> </div> <div class=\"panel-body\"> <strong>Laminas Framework Book</strong> <p>Learn how to create modern web applications with PHP and Laminas Framework</p> <a target=\"_blank\" href=\"https://github.com/olegkrivtsov/using-laminas-framework-book\"> Learn More </a> </div> </div> </div> </div> <?php $this->placeholder('content')->captureEnd(); echo $this->partial('layout/layout', ['content'=>$this->placeholder('content')]); ?> In the code above, we call the captureStart() method (line 1) and captureEnd() method (line 26) of the @ Placeholder [Laminas\\View\\Helper\\Placeholder] view helper to delimit the HTML markup that will be captured by the view helper and stored in its internal storage (instead of rendering to PHP standard output stream). In lines 3-23, we put the markup of the \"inherited\" layout. The derived layout uses the two-cell grid. The first cell of the grid (spanning 8 columns) will contain the actual content of a certain page, and the second cell (spanning 4 columns) will contain advertisements. For styling the ads, we utilize the Panel interface component provided by the Twitter Bootstrap. In line 27, we use the @ Partial view helper which is used to render the \"parent\" layout ( layout.phtml ). We pass the content captured by the @ Placeholder [Laminas\\View\\Helper\\Placeholder] view helper to the @ Partial view helper as the second argument. This way, we produced the nice-looking layout which inherits the default layout and improves the code reusability. Now, if you set the layout2.phtml for all actions of, say Index controller, you should be able to see the result as in figure 6.6. Adding Scripts to a Web Page JavaScript code can be inserted into HTML pages and make them interactive. Scripts should be inserted to an HTML file between <script> and </script> tags. Below, an example JavaScript code is presented: <script type=\"text/javascript\"> // Show a simple alert window with the \"Hello World!\" text. $(document).ready(function() { alert('Hello World!'); }); </script> In the example above, we created the <script> element, and put the jQuery callback function in it. The jQuery binds a function to be executed when the DOM has finished loading. When the function is executed, a simple alert window with the \"Hello World!\" text and OK button will appear. Since you put this JavaScript code inside the HTML file, we will refer to it as inline script. An alternative way of storing JavaScript code is putting it in an external .js file. External files typically contain code that is designed to be used by several web pages. Typically, external JavaScript files are stored in APP_DIR/public/js/ directory. To link an external JS file to your HTML page, you add the <script> element like below: <script type=\"text/javascript\" src=\"/js/yourscript.js\"></script> When the browser encounter such a <script> element, it reads the external JS file and executes the code. Generally, there are two places inside an HTML file where you can put the script: JavaScript code can be put in the <head> section of an HTML page. This method is recommended to use when you need JavaScript to be loaded before the content of the page. We used this method for loading the Twitter Bootstrap JavaScript extensions and jQuery library. Script can be placed at the bottom of the <body> section of an HTML page, just before the closing </body> tag. This way is acceptable when you need the entire DOM 6 to be loaded before the script can start executing. If a certain JavaScript file needs to be used on all (or on most) of the web pages, it is better to place it in layout view template. But when a script needs to be used on a single page only, putting it in the layout template is not the best idea. If you put such a script to layout template, the script will be loaded to all pages, which can produce an unneeded traffic and increase page load time for the whole site. To avoid this, you can add such a script for the desired page only. To add a page-specific script which will be put in the <head> section of the web page, you use the @ HeadScript view helper. Its methods are summarized by table 6.1: Method name Description appendFile() Puts a link to external JS file after all others. offsetSetFile() Inserts a link to external JS file in a given list position. prependFile() Puts a link to external JS file before all others. setFile() Clears the list of scripts and puts the single external JS file in it. appendScript() Puts an inline script after all others. offsetSetScript() Inserts an inline script to a given list position. prependScript() Puts an inline script before all others. setScript() Clears the list of inline scripts and puts the single inline script in it. Table 6.1 To add a link to external JS file to the <head> section, of a page, you add the following PHP code in the beginning of your view template ( .phtml ) file: <?php $this->headScript()->appendFile('/js/yourscript.js', 'text/javascript'); ?> In the code above, we called the appendFile() method of the @ HeadScript view helper. This method takes two arguments. The first one is the path to external JS file (if the file is stored inside of APP_DIR/public/js directory, or an URL of a JS file if the file is located on another web server). The second argument is the type of the script (it is typically equal to \"text/javascript\"). Other methods provided by @ HeadScript view helper (such as prependFile() , offsetSetFile() and setFile() ) differentiate only in the position in the list of scripts into which the new script will be inserted. The methods prependScript() , appendScript() , offsetSetScript() and setScript() are designed to insert an inline JavaScript code. They are rarely used, because you typically insert external JS scripts in the head section of the document To insert a script to the end of the <body> section of the document, you can use the @ InlineScript view helper 7 . It provides exactly the same methods as the @ HeadScript view helper. Below, an example is presented which can be used to append an inline JavaScript code to the end of document body: <?php $script = <<<EOT $(document).ready(function() { alert('Hello World!'); }); EOT; $this->inlineScript()->appendScript($script); In the example above, we used the PHP's Heredoc 8 syntax to fill in the $script variable with the inline JavaScript code. Then we call the appendScript() function on the @ InlineScript view helper and pass the code as its argument. But, using the @ InlineScript view helper may be not very convenient in sense of readability. Moreover, NetBeans IDE syntax checker will be stuck on the Heredoc notation and will not recognize the JavaScript code. To fix this, you can simply put the <script> element at the bottom of your view template, as shown in the example below: <!-- Page content goes first --> <!-- Inline script goes last --> <script type=\"text/javascript\"> $(document).ready(function() { // Show a simple alert window with the \"Hello World!\" text. alert(\"Hello World!\"); }); </script> This ensures the same effect is achieved as with @ InlineScript view helper, but allows for better script readability and automatic syntax checking in NetBeans IDE. Note For @ HeadScript and @ InlineScript view helpers to work, you should ensure their content is echoed in layout view template (look at lines 23 and 62 of layout.phtml file). If you remove those lines from the layout template, the scripts won't be inserted in the web page. Example For a real-life example of inserting a JavaScript code in your web page, let's add a page with auto-complete feature. With this feature, the web browser will predict a word or phrase that the user wants to type in by several first letters, without the user actually entering the text completely. We can use an auxiliary JavaScript library called Twitter Typeahead . Analogous to Twitter Bootstrap, the Typeahead library was developed in Twitter Inc. for their internal purposes and is distributed freely. Download typeahead.min.js file (a minified version of the Typeahead library) from the official project page . When the download is finished, place the file in your APP_DIR/public/js directory. Then add the typeahead.phtml file in your application/index/static subdirectory under the module's view directory. This directory is served by the StaticRoute route type that we've created and configured earlier in chapter Routing , and all \"static\" pages placed here will automatically become available to site users. In the typeahead.phtml view template file, put the following content: <?php $this->headTitle('Typeahead'); // Add a JavaScript file $this->headScript()->appendFile('/js/typeahead.min.js', 'text/javascript'); ?> <h1>Typeahead</h1> <p>Type a continent name (e.g. Africa) in the text field below:</p> <input type=\"text\" class=\"typeahead\" title=\"Type here\"/> <script type=\"text/javascript\"> $(document).ready(function() { $('input.typeahead').typeahead({ name: 'continents', local: [ 'Africa', 'Antarctica', 'Asia', 'Europe', 'South America', 'North America' ] }); }); </script> In the code above, we set the title for the page (line 2), then we append the typeahead.min.js file to the <head> section of the page with the @ HeadScript view helper (line 4). In line 9, we create a text input field where the user will be able to enter some text. We mark the input field with the typeahead CSS class. Lines 11-25 contain inline JavaScript code placed at the bottom of the view template (we don't use @ InlineScript view helper for better code readability). In line 12, we have the jQuery event handler bound to the \"document is ready\" event. This event is fired when the complete DOM tree has been loaded. In line 13, we have the jQuery selector (\"input.typeahead\") which selects all input fields marked with the typeahead CSS class and execute the typeahead() function on them. The typeahead() function binds the change event handler to the text input field. Once the user enters a character in the field, the handler is executed and checks the letters entered. It then displays the dropdown menu with suggested auto-completion variants. The typeahead() function takes two arguments: the name argument identifies the dataset, and the local argument is a JSON array containing the available auto-completion variants. To give the auto-completion field and its dropdown menu a nice-looking visual appearance, add the following CSS rules to your style.css file. .typeahead, .tt-query, .tt-hint { width: 396px; height: 30px; padding: 0px 12px; font-size: 1.1em; border: 2px solid #ccc; border-radius: 4px; outline: none; } .tt-dropdown-menu { width: 422px; margin-top: 12px; padding: 8px 0; background-color: #fff; border: 1px solid #ccc; border: 1px solid rgba(0, 0, 0, 0.2); border-radius: 4px; } .tt-suggestion { padding: 3px 20px; font-size: 1.1em; line-height: 24px; } .tt-suggestion.tt-is-under-cursor { color: #fff; background-color: #0097cf; } .tt-suggestion p { margin: 0; } To see the auto-completion feature in work, type the \"http://localhost/typeahead\" URL in your browser and press Enter. The Typeahead page will appear with the prompt to enter a continent name. For example, type a letter to see how Typeahead suggests you available variants (figure 6.7). You can see this example working in the Hello World sample bundled with this book by typing the URL \"http://localhost/typeahead\" in your browser. Adding CSS Stylesheets to a Web Page CSS stylesheets are typically placed to the <head> section of an HTML document, either as a link to an external file (external CSS stylesheet files are usually stored in APP_DIR/public/css directory.) <link rel=\"stylesheet\" type=\"text/css\" href=\"/css/style.css\"> or as an inline <style> element <style> body { padding-top: 60px; padding-bottom: 40px; } </style> To store the CSS rules, external CSS stylesheets are recommended. For example, the base CSS rules provided by Twitter Bootstrap CSS framework are loaded from bootstrap.min.css and bootstrap-theme.min.css files. Custom site-specific CSS rules can be stored in style.css file. Since you need this CSS stylesheets for most of your pages, it is better to link them in the head section of the layout template. But, if a certain CSS stylesheet needs to be loaded for a single page only, you place it on that page's view template. To add an external CSS stylesheet to a view template, you use the @ HeadLink view helper: <?php $this->headLink()->appendStylesheet('/css/style.css'); $this->headLink()->appendStylesheet( '//code.jquery.com/ui/1.10.3/themes/smoothness/jquery-ui.css'); In the example code above, we used the appendStylesheet() method of the @ HeadLink view helper to add an external CSS stylesheet to the head section of the document. The method accepts a path to local CSS file (line 2) or a URL to CSS file located on another server (line 3). The summary of @ HeadLink view helper's methods is provided in table 6.2. Method name Description appendStylesheet() Puts a link to CSS stylesheet file after all others. offsetSetStylesheet() Inserts a link to CSS stylesheet file in a given list position. prependStylesheet() Puts a link to external CSS stylesheet file before all others. setStylesheet() Clears the list and puts the single CSS file instead. Table 6.2 If you want to add an inline <style> element in the head section of the document, you can use the @ HeadStyle view helper. Its methods are presented in table 6.3 below: Method name Description appendStyle() Adds a CSS stylesheet inline after all others. offsetSetStyle() Inserts a CSS stylesheet inline in a given list position. prependStyle() Puts a CSS stylesheet inline before all others. setStyle() Clears the list and puts the single CSS stylesheet inline instead. Table 6.3 Example To demonstrate how to add a CSS stylesheet to your web page, we will take a real-life example. Assume you need to let the user the ability to type a date (in YYYY-MM-DD format) in a text input field. You would like to improve user experience by not just letting him to type the date, but also by selecting it from a pop-up date-picker widget. To achieve this goal, you can use a third-party library called jQuery UI 9 . To integrate jQuery UI in your page, you need to download two files from the official project page : jquery-ui.min.js -- the minified version of jQuery UI JavaScript code; jquery-ui.min.css -- the minified version of jQuery UI theming styles. Put the jquery-ui.min.js file to APP_DIR/public/js , and jquery-ui.min.css file to APP_DIR/public/css . Finally, add the datepicker.phtml view template to the application/index/static directory under the module's view directory: <?php $this->headTitle('Datepicker'); $this->headScript()->appendFile('/js/jquery-ui.min.js', 'text/javascript'); $this->headLink()->appendStylesheet('/css/jquery-ui.min.css'); ?> <h1>Datepicker</h1> <p> Click the edit box below to show the datepicker. </p> <input type=\"text\" class=\"datepicker\" title=\"Type here\"/> <script> $(document).ready(function() { $(\"input.datepicker\").datepicker({ dateFormat: 'yy-mm-dd' }); }); </script> In the example above, we use the @ HeadScript view helper's appendFile() method (line 4) to add the link to jquery-ui.min.js file to the head section of the document. In line 5, we used the @ HeadLink view helper's appendStylesheet() method to add the link to jquery-ui.min.css CSS stylesheet to the head section of the document. In line 14, we added the text input field which will be used to enter the date. In line 16-20, we added an inline JavaScript code for binding jQuery event handler to the text input field. When the user clicks the text input field, the datepicker widget will appear allowing to select the date. To see the result, enter the \"http://localhost/datepicker\" URL into your browser's navigation bar (see figure 6.8 for example). Writing Own View Helpers Earlier in this chapter, we've created the layout common to all pages of the web site. But we still have a couple of things to do to make the layout fully functional. If you remember, the layout template contains the navigation bar and breadcrumbs. But both navigation bar and breadcrumbs interface components provided by Twitter Bootstrap are currently \"static\", while they need to be more interactive. For example, the active item of the navigation bar should depend on the controller's action that is being executed at the moment. And the breadcrumbs should display the path to the currently viewed page. In this section we will make these widgets completely ready for the website with the help of our own view helpers. A typical view helper is a PHP class deriving from @ Laminas\\View\\Helper\\AbstractHelper base class, which in turn implements the @ Laminas\\View\\Helper\\HelperInterface interface (class inheritance diagram is presented in figure 6.9). Menu First, let's implement the Menu view helper class that will render the HTML code of the navigation bar. The Menu class will provide several methods allowing to set menu items in a form of array, set the active menu item and render the menu (see table 6.4 for method summary). Method name Description __construct($items) Class constructor. setItems($items) Method for setting the menu items. setActiveItemId($activeItemId) Method for setting the currently active menu item. render() Renders the menu. renderItem($item) Renders a single menu item. Table 6.4 The information describing a single menu item will be represented by an array like below (for example, the Home item will have an ID, text label and an URL for a hyperlink): [ 'id' => 'home', 'label' => 'Home', 'link' => $this->url('home') ] We also want to add the support for dropdown menus as navigation items. For example, in case of the Support dropdown menu having the Documentation and Help sub-items, the item description will take the following form: [ 'id' => 'support', 'label' => 'Support', 'dropdown' => [ [ 'id' => 'documentation', 'label' => 'Documentation', 'link' => $this->url('doc', ['page'=>'contents']) ], [ 'id' => 'help', 'label' => 'Help', 'link' => $this->url('static', ['page'=>'help']) ] ] ] We want to put the Menu class in Application\\View\\Helper namespace. Thus, start from creating the Menu.php file in the View/Helper directory under the Application module's source directory (figure 6.10). Why do we place the view helper class under module's source directory? View helpers (unlike .phtml view templates) are stored under module's src/ directory, because they are usual PHP classes and require to be resolved by a PHP class auto-loading feature. On the other hand, view templates are resolved by the special Laminas class called view resolver , and for this reason, view templates are stored under the module's view/ directory. Next, create the stub code for the Menu class: <?php namespace Application\\View\\Helper; use Laminas\\View\\Helper\\AbstractHelper; // This view helper class displays a menu bar. class Menu extends AbstractHelper { // Menu items array. protected $items = []; // Active item's ID. protected $activeItemId = ''; // Constructor. public function __construct($items=[]) { $this->items = $items; } // Sets menu items. public function setItems($items) { $this->items = $items; } // Sets ID of the active items. public function setActiveItemId($activeItemId) { $this->activeItemId = $activeItemId; } } In the code above, we defined several private fields for the Menu class. The $items field (line 10) is an array which will store the information on the menu items; and the $activeItemId field (line 13) is the ID of an active menu item. The active menu item will be visually highlighted. In lines 16-19, we defined the class constructor method, which (optionally) takes the array of items for initializing the menu. An alternative method of menu initialization is through the setItems() method (lines 22-25). And the setActiveItemId() method (lines 28-31) sets the ID of the currently active menu item. Next, let's add the render() method, which will generate HTML code for the whole navigation bar and return it as a text string: // Renders the menu. public function render() { if (count($this->items)==0) return ''; // Do nothing if there are no items. $result = '<nav class=\"navbar navbar-default\" role=\"navigation\">'; $result .= '<div class=\"navbar-header\">'; $result .= '<button type=\"button\" class=\"navbar-toggle\" '; $result .= 'data-toggle=\"collapse\" data-target=\".navbar-ex1-collapse\">'; $result .= '<span class=\"sr-only\">Toggle navigation</span>'; $result .= '<span class=\"icon-bar\"></span>'; $result .= '<span class=\"icon-bar\"></span>'; $result .= '<span class=\"icon-bar\"></span>'; $result .= '</button>'; $result .= '</div>'; $result .= '<div class=\"collapse navbar-collapse navbar-ex1-collapse\">'; $result .= '<ul class=\"nav navbar-nav\">'; // Render items foreach ($this->items as $item) { $result .= $this->renderItem($item); } $result .= '</ul>'; $result .= '</div>'; $result .= '</nav>'; return $result; } In the code above, we produce the HTML markup for the Bootstrap navbar component. The navbar will use the default theme and will be collapsible (adaptive to different screen widths). The navbar will not have the brand text in the header. In lines 22-24, we loop through the menu items and render each one with the renderItem() method. Finally, the render() method returns the resulting HTML code as a text string. To finish with creating the Menu class, let's implement the renderItem() method. This method will produce the HTML code for a single menu item: // Renders an item. protected function renderItem($item) { $id = isset($item['id']) ? $item['id'] : ''; $isActive = ($id==$this->activeItemId); $label = isset($item['label']) ? $item['label'] : ''; $result = ''; if(isset($item['dropdown'])) { $dropdownItems = $item['dropdown']; $result .= '<li class=\"dropdown ' . ($isActive?'active':'') . '\">'; $result .= '<a href=\"#\" class=\"dropdown-toggle\" data-toggle=\"dropdown\">'; $result .= $label . ' <b class=\"caret\"></b>'; $result .= '</a>'; $result .= '<ul class=\"dropdown-menu\">'; foreach ($dropdownItems as $item) { $link = isset($item['link']) ? $item['link'] : '#'; $label = isset($item['label']) ? $item['label'] : ''; $result .= '<li>'; $result .= '<a href=\"'.$link.'\">'.$label.'</a>'; $result .= '</li>'; } $result .= '</ul>'; $result .= '</a>'; $result .= '</li>'; } else { $link = isset($item['link']) ? $item['link'] : '#'; $result .= $isActive?'<li class=\"active\">':'<li>'; $result .= '<a href=\"'.$link.'\">'.$label.'</a>'; $result .= '</li>'; } return $result; } In the renderItem() method's code above we did the following. First, we checked whether the item is a dropdown menu or a simple item (line 10). If the item is a dropdown menu, we walk through the dropdown menu items, and render each one in turn (lines 21-28). Lines 35-39 contain the rendering code for the case of a simple item. To be able to use the Menu view helper in a view template, it is required to register it in configuration. To do that, add the following view_helpers key in the module.config.php file: <?php return [ // ... // The following registers our custom view // helper classes in view plugin manager. 'view_helpers' => [ 'factories' => [ View\\Helper\\Menu::class => InvokableFactory::class, ], 'aliases' => [ 'mainMenu' => View\\Helper\\Menu::class ] ], ]; In the example above, we registered our Menu class as a mainMenu view helper and will be able to access it from any view template. Since we plan to use the Menu view helper in the layout view template, replace the navigation menu markup in layout.phtml file with the following code: <!-- Navigation bar --> <?php $this->mainMenu()->setItems([ [ 'id' => 'home', 'label' => 'Home', 'link' => $this->url('home') ], [ 'id' => 'downloads', 'label' => 'Downloads', 'link' => $this->url(\"application\", ['action'=>'downloads']) ], [ 'id' => 'support', 'label' => 'Support', 'dropdown' => [ [ 'id' => 'documentation', 'label' => 'Documentation', 'link' => $this->url('doc', ['page'=>'contents']) ], [ 'id' => 'help', 'label' => 'Help', 'link' => $this->url('static', ['page'=>'help']) ] ] ], [ 'id' => 'about', 'label' => 'About', 'link' => $this->url('about') ], ]); echo $this->mainMenu()->render(); ?> In the code above, we access the registered mainMenu view helper and set the navigation bar items with the help of setItems() method (line 3). As a parameter for the method, we pass the array of items. Then we render the navigation bar with the render() method. To set the active item for the navigation bar, we can call the setActiveItemId() method from any view template. For example, add the following code to the beginning of the view template for the About page ( application/index/about.phtml ) as follows: <?php $this->mainMenu()->setActiveItemId('about'); ?> Now, if you open the About page in your browser, you should see that the About item of the navigation menu is highlighted with a different color. To display the active item properly, you need to call the setActiveItemId() method for each page presenting in the navbar ( Home , Downloads , Documentation , etc.) You can see how this is done in the Hello World sample. Breadcrumbs Now that you know how to implement a view helper, let's create the second view helper for rendering the breadcrumbs. It is completely analogous to the Menu view helper, so below we just provide the complete code of the Breadcrumbs class: <?php namespace Application\\View\\Helper; use Laminas\\View\\Helper\\AbstractHelper; // This view helper class displays breadcrumbs. class Breadcrumbs extends AbstractHelper { // Array of items. private $items = []; // Constructor. public function __construct($items=[]) { $this->items = $items; } // Sets the items. public function setItems($items) { $this->items = $items; } // Renders the breadcrumbs. public function render() { if(count($this->items)==0) return ''; // Do nothing if there are no items. // Resulting HTML code will be stored in this var $result = '<ol class=\"breadcrumb\">'; // Get item count $itemCount = count($this->items); $itemNum = 1; // item counter // Walk through items foreach ($this->items as $label=>$link) { // Make the last item inactive $isActive = ($itemNum==$itemCount?true:false); // Render current item $result .= $this->renderItem($label, $link, $isActive); // Increment item counter $itemNum++; } $result .= '</ol>'; return $result; } // Renders an item. protected function renderItem($label, $link, $isActive) { $result = $isActive?'<li class=\"active\">':'<li>'; if(!$isActive) $result .= '<a href=\"'.$link.'\">'.$label.'</a>'; else $result .= $label; $result .= '</li>'; return $result; } } To be able to use the Breadcrumbs view helper, register it in the module.config.php file as follows: <?php return [ //... // The following registers our custom view helper classes. 'view_helpers' => [ 'factories' => [ View\\Helper\\Breadcrumbs::class => InvokableFactory::class, ], 'aliases' => [ 'pageBreadcrumbs' => View\\Helper\\Breadcrumbs::class, ] ], ]; Since we plan to use the Breadcrumbs view helper in the layout view template, replace the breadcrumbs markup in layout.phtml file with the following code: <!-- Breadcrumbs --> <?= $this->pageBreadcrumbs()->render(); ?> In the code above, we access the pageBreadcrumbs() view helper and call it with the render() method. The echo operator then outputs the HTML code of the breadcrumbs. Finally, you need to pass the breadcrumbs items for each view template. For example, add the following lines in the view template for the About page: <?php $this->pageBreadcrumbs()->setItems([ 'Home'=>$this->url('home'), 'About'=>$this->url('about'), ]); ?> Now, if you open the about page, you should see breadcrumbs as in figure 6.11 below. Site users will easily see what page they are visiting right now and will not get lost. View Models and Page Composition Earlier, when we wrote action methods for the controller classes, we used the @ ViewModel [Laminas\\View\\Model\\ViewModel] class as a variable container for passing the variables from controller to view template, and we also used the @ ViewModel [Laminas\\View\\Model\\ViewModel] for overriding the default view template name. But, actually the @ ViewModel [Laminas\\View\\Model\\ViewModel] class is more than just a variable container plus view template name. In fact, it is closely related to the layout and page composition. The third big capability of the view model class is that it allows for combining several view models in a tree-like structure. Each view model in the tree has the associated view template name and data variables that can be passed to the view template to control the process of rendering. This feature is internally used by Laminas Framework when \"combining\" the layout view template and the view template associated with the controller's action method. Laminas internally creates the view model for the layout template and assigns it with layout/layout view template name. When your controller's action method returns the @ ViewModel [Laminas\\View\\Model\\ViewModel] object, this object is attached as a child to the layout view model (see figure 6.12 for an example). The resulting process of page rendering is the following: The child view model is visited first and its associated view template is rendered, and the resulting HTML markup is saved in a temporary storage; The output HTML markup of the child view model is passed to the layout view model as the $content variable. This way the layout view template can render the content specific to the certain page. Table 6.5 gives the summary of the methods provided by the @ ViewModel [Laminas\\View\\Model\\ViewModel] class for the purpose of page composition: Method name Description addChild() Adds a child view model. getChildren() Gets the list of child view models. hasChildren() Tests if the view model has children or not. clearChildren() Removes all child view models. count() Returns count of child view models. getIterator() Returns the iterator for child view models. setTerminal() Sets the terminal flag. terminate() Tests whether the view model is terminal. setCaptureTo() Sets the name of the variable for capturing the output. setAppend() Sets the append flag. isAppend() Tests whether to append this view model to another one. Table 6.5. Methods of the ViewModel class for page composition Below, we provide the brief description of the methods presented in the table above. The addChild() , getChild() , hasChildren() and clearChildren() methods are used for (respectively) adding a child view model to the parent one, retrieving the array of view models attached, testing if the view model is leaf (doesn't have children) and detaching all children. The setCaptureTo() method allows to set the variable in the parent view template into which to inject the HTML markup code produced by a child view template. If two child view models use the same variable, the second one will overwrite the first one. The setAppend() method can be used when you need to inject the results of two or more view templates into a single placeholder variable. The next rendered view template will be appended to the variable's existing content. The view model returned by the controller is assigned the $content capture variable. A view model can be marked as terminal with the setTerminal() method. The setTerminal() method takes a single flag parameter. If true , the view model is considered as terminal (top-level parent) and the renderer returns the output of the view template to the application, otherwise its parents are rendered as well. The method terminate() tests whether the view model is terminal or not. The setTerminal() method is very useful in some situations, because with its help you can disable the rendering of the layout view template. If you return from controller the view model marked as terminal, the layout will not be applied. This can be used, for example, when you want to load part of a page asynchronously by an AJAX 10 request and need to insert its HTML code in the DOM tree of an existing page. Summary Laminas Framework is shipped with Twitter Bootstrap that is a CSS framework allowing for creating visual appealing and professionally looking web applications. It provides the base CSS rules, the simple layout grid, and useful interface components (like navigation bars, breadcrumbs, pagination, etc.) In a typical web site, pages have common structure (for example, a typical page may have a navigation bar at the top, the body with page content, and the footer with the copyright information at the bottom). In Laminas Framework, you define this common structure with a view template file called the layout. The layout template may have placeholder(s) in which Laminas puts the content specific to a particular web page. View helpers are (relatively) simple PHP classes that encapsulate a part of page rendering work. For example, they allow for composing the page of several parts, setting page title and meta tags, and creating the reusable widgets like navigation bar or breadcrumbs. If you are new to CSS, please refer to the excellent W3Schools CSS tutorial by visiting this link . \u21a9 The <!DOCTYPE> declaration goes first in the HTML document, before the <html> tag. The declaration provides an instruction to the web browser about what version of HTML the page is written in (in our web site, we use HTML5-conformant document type declaration). \u21a9 The UTF-8 allows to encode any character in any alphabet around the world, that's why it is recommended for encoding the web pages. \u21a9 A \"compound\" page title consists of two parts: the first part (\"ZF Skeleton Application\") is defined by the layout, and the second part - defined by a particular page - is prepended to the first one. For example, for the About page of your site you will have the \"About - ZF Skeleton Application\", and for the Documentation page you will have something like \"Documentation - ZF Skeleton Application\". \u21a9 The @ Placeholder [Laminas\\View\\Helper\\Placeholder] view helper stores the data in PHP session storage. So, in theory, you can even capture content on one page and then render/use it on another one. \u21a9 The DOM (Document Object Model) is a convenient representation of an HTML document structure as a tree of elements. \u21a9 The name @ InlineScript does not fully reflect the capabilities of this view helper. Actually, it can insert both inline and external scripts. The better name for this view helper would be BodyScript , because it is intended for inserting scripts in document body. \u21a9 Heredoc is an alternative string definition method provided by PHP. It works well with multi-line strings. \u21a9 jQuery UI provides a set of \"user interface interactions, effects, widgets, and themes\"; it is based on jQuery library. jQuery UI is analogous to Twitter Bootstrap in the sense that both provide reusable user interface components. \u21a9 AJAX (stands for Asynchronous JavaScript and XML) is a capability provided by modern browsers which can be used to send data to, and retrieve data from, a server asynchronously (in background) without interfering with the display and behavior of the existing page. \u21a9","title":"Page Appearance and Layout"},{"location":"appearance/#page-appearance-and-layout","text":"In this chapter you will learn how to make your web pages attractive and professionally looking with the help of Twitter Bootstrap CSS Framework and how to position elements on a page using Laminas layout mechanism. You'll also become familiar with common view helpers allowing for composing web pages of reusable parts. If you are new to Twitter Bootstrap, it is also recommended that you refer to Appendix C. Introduction to Twitter Bootstrap for advanced description of Bootstrap capabilities. Laminas components covered in this chapter: Component Description @ Laminas\\Mvc Support of MVC pattern. Implements base controller classes, controller plugins, etc. @ Laminas\\View Implements the functionality for variable containers, rendering a web page and common view helpers.","title":"Page Appearance and Layout"},{"location":"appearance/#about-css-stylesheets-and-twitter-bootstrap","text":"In a laminas-based web site, for defining the visual appearance and style of the web pages, CSS stylesheets are utilized. These CSS 1 files are typically stored in APP_DIR/public/css directory. Because the CSS rules may be rather complex and require laborious adjustment and the skills of a designer, they can be separated in a \"library\" (framework). Analogous to PHP frameworks, CSS frameworks allow for code reusability. Today, several CSS frameworks exist on the market, and one of them is Twitter Bootstrap (or shortly, the Bootstrap). Originally designed at Twitter to unify the appearance of their own web tools, Bootstrap has became a popular CSS framework, allowing to make your web site professionally looking and visually appealing, even if you don't have advanced designer skills and without the need of creating basic CSS rules (but, of course you can define your own custom CSS rules on top of Bootstrap to customize your site's appearance). Bootstrap is freely distributed under the Apache License v.2.0 . Note Twitter Bootstrap is shipped with Laminas Skeleton Application, so you can use it out of the box. Alternatively, you can download the newest version of Bootstrap from the project's official page . At the moment of writing this book, the latest version is v.5.x. Generally, the Bootstrap does the following things: It provides the CSS reset that is a style sheet defining styles for all possible HTML elements. This ensures your web site will look the same way in all web browsers. It provides the base CSS rules that define style of typography (headings and text), tables, forms, buttons, images and so on. It defines the grid system . The grid system allows to arrange elements on your web page in a grid-like structure. For example, look at the Skeleton Application's main page (figure 6.1), where we have the grid consisting of three columns. It defines useful web interface components like dropdown menus, navigation bars, breadcrumbs, pagination and so on. For example, on the skeleton app's main page, there is the navigation bar component at the top, and the header (also called the Hero Unit or Jumbotron) component below the navbar. These components are very handy on any web site. In includes the JavaScript extensions that allow to make Bootstrap-provided interface components more interactive. For example, JavaScript is used to animate dropdown menus and display \"modal dialogs\". Note If you are new to Twitter Bootstrap, it is recommended that you refer to Appendix C. Introduction to Twitter Bootstrap , where you can find more information about using Twitter Bootstrap and its components.","title":"About CSS Stylesheets and Twitter Bootstrap"},{"location":"appearance/#page-layout-in-laminas-framework","text":"Pages of your web site typically have some common structure that can be shared among them. For example, a typical page has the <!DOCTYPE> declaration to identify the HTML document, and the <head> and <body> elements: <!DOCTYPE html> <html lang=\"en\"> <head> <title>Welcome</title> <!-- Include metas, stylesheets and scripts here --> </head> <body> <!-- Include page content here --> </body> </html> The <head> element contains the page title text, meta information and references to included stylesheets and scripts. The <body> element contains the content of the page, like the logo image, the navigation bar, the page text, and the footer with copyright information. In Laminas Framework, you define this common structure with the \"master\" view template called the layout . The layout \"decorates\" other view templates. The layout template typically has a placeholder in which Laminas puts the content specific to a particular page (see figure 6.2 for example). In the Skeleton Application, the default layout template file is called layout.phtml and is located inside of the view/layout directory in Application module's directory (see figure 6.3 for example). Let's look at the layout.phtml template file in more details. Below, the complete contents of the file is presented: <?= $this->doctype() ?> <html lang=\"en\"> <head> <meta charset=\"utf-8\"> <?= $this->headTitle('ZF Skeleton Application') ->setSeparator(' - ')->setAutoEscape(false) ?> <?= $this->headMeta() ->appendName('viewport', 'width=device-width, initial-scale=1.0') ->appendHttpEquiv('X-UA-Compatible', 'IE=edge') ?> <!-- The styles (CSS) --> <?= $this->headLink(['rel' => 'shortcut icon', 'type' => 'image/vnd.microsoft.icon', 'href' => $this->basePath() . '/img/favicon.ico']) ->prependStylesheet($this->basePath('css/style.css')) ->prependStylesheet($this->basePath('css/bootstrap-theme.min.css')) ->prependStylesheet($this->basePath('css/bootstrap.min.css')) ?> <!-- JS Scripts --> <?= $this->headScript() ->prependFile($this->basePath('js/bootstrap.min.js')) ->prependFile($this->basePath('js/jquery-2.2.4.min.js')) ?> </head> <body> <nav class=\"navbar navbar-inverse navbar-fixed-top\" role=\"navigation\"> <div class=\"container\"> <div class=\"navbar-header\"> <button type=\"button\" class=\"navbar-toggle\" data-toggle=\"collapse\" data-target=\".navbar-collapse\"> <span class=\"icon-bar\"></span> <span class=\"icon-bar\"></span> <span class=\"icon-bar\"></span> </button> <a class=\"navbar-brand\" href=\"<?php echo $this->url('home') ?>\"> <img src=\"<?= $this->basePath('img/zf-logo.png') ?>\" alt=\"Laminas Framework <?= \\Application\\Module::VERSION ?>\"/> &nbsp;Skeleton Application </a> </div> <div class=\"collapse navbar-collapse\"> <ul class=\"nav navbar-nav\"> <li class=\"active\"> <a href=\"<?= $this->url('home') ?>\">Home</a> </li> </ul> </div> </div> </nav> <div class=\"container\"> <?= $this->content; ?> <hr> <footer> <p>&copy; 2005 - <?= date('Y') ?> by Laminas Technologies Ltd. All rights reserved. </p> </footer> </div> <?= $this->inlineScript() ?> </body> </html> You can see that the layout.phtml file (as a usual view template) consists of HTML tags mixed with PHP code fragments. When the template is being rendered, Laminas evaluates the inline PHP fragments and generates resulting HTML page visible to site users. Line 1 above generates the <!DOCTYPE> 2 declaration of the HTML page with the @ Doctype view helper. Line 3 defines the <html> element representing the root of the HTML document. The <html> tag is followed by the <head> tag (line 4), which typically contains a title for the document, and can include other information like scripts, CSS styles and meta information. In line 5, the <meta> tag provides the browser with a hint that the document is encoded using UTF-8 3 character encoding. In line 6, we have the @ HeadTitle view helper that allows to define the title for the page (\"ZF Skeleton Application\"). The title will be displayed in the web browser's caption. The setSeparator() method is used to define the separator character for the compound page titles 4 ; the setAutoEscape() method enhances the security by escaping unsafe characters from the page title. In line 9, the @ HeadMeta view helper allows to define the <meta name=\"viewport\"> tag containing meta information for the web browser to control layout on different display devices, including mobile browsers. The width property controls the size of the viewport, while the initial-scale property controls the zoom level when the page is loaded. This makes the web page layout \"responsive\" to device viewport size. In line 15, the @ HeadLink view helper allows to define the <link> tags. With the <link> tags, you typically define the \"favicon\" for the page (located in APP_DATA/public/img/favicon.ico file) and the CSS stylesheets. In lines 17-19, the stylesheets common to all site pages are included by the prependStylesheet() method of the @ HeadLink view helper. Any page in our website will load three CSS stylesheet files: bootstrap.min.css (the minified version of Twitter Bootstrap CSS Framework), bootstrap-theme.min.css (the minified Bootstrap theme stylesheet) and style.css (CSS file allowing us to define our own CSS rules overriding Bootstrap CSS rules). Lines 23-25 include the JavaScript files that all your web pages will load. The scripts are executed by the client's web browser, allowing to introduce some interactive features for your pages. We use the bootstrap.min.js (minified version of Twitter Bootstrap) and jquery-2.2.4.min.js (minified version of jQuery library) scripts. All scripts are located in APP_DIR/public/js directory. Line 28 defines the <body> tag, the document's body which contains all the contents of the document, such as the navigation bar, text, hyperlinks, images, tables, lists, etc. In lines 29-52, you can recognize the Bootstrap navigation bar definition. The skeleton application uses the collapsible navbar with dark inverse theme. The navbar contains the single link Home . If you look at lines 53-61, you should notice the <div> element with container class which denotes the container element for the grid system. So, you can use the Bootstrap grid system to arrange the contents of your pages. Line 54 is very important, because this line defines the inline PHP code that represents the page content placeholder we talked about in the beginning of this section. When the Laminas page renderer evaluates the layout template, it echoes the actual page content here. Lines 56-60 define the page footer area. The footer contains the copyright information like \"2016 by Laminas Technologies Ltd. All rights reserved.\" You can replace this information with you own company name. Line 62 is the placeholder for JavaScript scripts loaded by the concrete page. The @ InlineScript view helper will substitute here all the scripts you register (about registering JavaScript scripts, you will see it later in this chapter). And finally, lines 63-64 contain the closing tags for the body and the HTML document.","title":"Page Layout in Laminas Framework"},{"location":"appearance/#modifying-the-default-page-layout","text":"To demonstrate how you can define your own page layout, we will modify the original layout of the Laminas Skeleton Application website. We want to make it display the \"Hello world\" page title, the \"Hello world!\" header text at the top, the navigation bar and breadcrumbs below the header, page content placeholder in the middle of the page, and the footer with the copyright information at the bottom (see figure 6.4 for an example of what we are trying to achieve). Let's start with the \"Hello World\" page title. We replace the lines 6-7 in the layout.phtml file as follows: <?= $this->headTitle('Hello World')->setSeparator(' - ')->setAutoEscape(false) ?> Next, we will use the Bootstrap-provided grid system for arranging the main blocks on the page. Replace the HTML code of the <body> element (lines 28-63) with the following one: <body> <div class=\"container\"> <div class=\"row\"> <!-- Page header --> <div class=\"col-md-4\"> <div class=\"app-caption\">Hello World!</div> </div> </div> <div class=\"row\"> <div class=\"col-md-12\"> <!-- Navigation bar --> </div> </div> <div class=\"row\"> <div class=\"col-md-12\"> <!-- Breadcrumbs --> </div> </div> <div class=\"row\"> <div class=\"col-md-12\"> <!-- Page content placeholder --> <?= $this->content; ?> </div> </div> <div class=\"row\"> <div class=\"col-md-12\"> <hr> <p>&copy; 2005 - <?= date('Y') ?> by Your Company. All rights reserved.</p> </div> </div> <!-- /container --> <?php echo $this->inlineScript() ?> </body> In the code above, we defined the <div> element with the container class and put the <div> elements of the grid inside of it. The grid consists of 5 rows: The page header containing the \"Hello World!\" text (lines 3-8). The header text spans four grid columns. For styling the text, we use our custom CSS class app-caption (we will define this class in style.css file a little bit later). We left the space for navigation bar interface component in line 11. In line 16, we have the space for breadcrumbs component. In line 22, we have the page content placeholder. When the renderer evaluates the page, it will echo the value of the $content variable, so the actual page content will be substituted here. And in lines 25-29, we provided the page footer with the text \"(c) 2013 by Your Company. All rights reserved.\" You can change this text and substitute your company name here, if you wish. Next, we put the navigation bar in the corresponding grid row: <!-- Navigation bar --> <nav class=\"navbar navbar-default\" role=\"navigation\"> <div class=\"collapse navbar-collapse navbar-ex1-collapse\"> <ul class=\"nav navbar-nav\"> <li class=\"active\"> <a href=\"<?= $this->url('home') ?>\">Home</a> </li> <li> <a href=\"<?= $this->url('application', ['action'=>'downloads']) ?>\"> Downloads </a> </li> <li class=\"dropdown\"> <a href=\"#\" class=\"dropdown-toggle\" data-toggle=\"dropdown\"> Support <b class=\"caret\"></b> <ul class=\"dropdown-menu\"> <li> <a href=\"<?= $this->url('doc', ['page'=>'contents']) ?>\"> Documentation </a> </li> <li> <a href=\"<?= $this->url('static', ['page'=>'help']) ?>\"> Help </a> </li> </ul> </a> </li> <li> <a href=\"<?= $this->url('about') ?>\">About</a> </li> </ul> </div> </nav> In the code above, we used the navbar interface component provided by the Bootstrap. We also used the @ Url [Laminas\\View\\Helper\\Url] view helper to insert the links to the navigation items. Note We discussed the usage of the @ Url [Laminas\\View\\Helper\\Url] view helper in the Generating URLs from Route section in Routing . Next, put the breadcrumbs component to the corresponding grid row: <!-- Breadcrumbs --> <ol class=\"breadcrumb\"> <li class=\"active\">Home</li> </ol> Finally, we need to provide a couple of custom CSS rules to fine-tune the look and feel. We define our own CSS rules in the style.css stylesheet. We want to make the \"Hello World!\" header text to use larger bold font and use a nice looking color. To do this, open the style.css file, and append the following lines to the end: div.app-caption { padding: 25px 0px; font-size: 3.0em; font-weight: bold; color: #6aacaf } In the CSS code above, we created the app-caption class which can be applied to <div> element and defining the 25 pixels vertical padding, large font size, bold text style and the hexadecimal representation of the RGB text color. By default, in skeleton application, the navbar is pinned to page top, and the CSS rule for the page body defines the 20 pixels top padding to leave space for it. Since in our Hello World example we've unpinned the navigation bar from top of the page and placed it in page flow, we need to remove the padding from page body top. To do that, edit the body CSS rule in the style.css file and make it look like the one below: body { padding-bottom: 40px; } Great, we've completed the page layout template! To see the result of our changes, open the site in your browser, you should see the page as in figure 6.4. You can click the links in navigation bar to visit the pages like About or Documentation , etc. The content of a particular page is put into the content placeholder of our layout. Note The result can also be seen in action in the Hello World sample application that is part of this book's example code available on GitHub.","title":"Modifying the Default Page Layout"},{"location":"appearance/#switching-between-layouts","text":"By default, Laminas provides you with a single layout template layout.phtml . In real-life applications, you will probably need to have several layouts and switch the layout for certain controller/action. For example, you may have a front-end and a back-end part of your site. The front-end part would consist of web pages publicly visible to all users and would utilize the default layout for all of these pages. The back-end part would consist of pages visible to the administrator user only and utilize another layout template containing the administrative menu. First, prepare another layout template file. For example, call it layout2.phtml . To simplify the file preparation, copy the content of the default layout.phtml file and make the necessary changes. When the second layout template is ready, you can switch between layouts for a particular controller's action by using the following code: // A controller's action method that uses an alternative // layout template. public function indexAction() { //... // Use the Layout plugin to access the ViewModel // object associated with layout template. $this->layout()->setTemplate('layout/layout2'); //... } In the example action method above, we use the @ Layout [Laminas\\Mvc\\Controller\\Plugin\\Layout] controller plugin (line 9) that allows to access the instance of the @ ViewModel [Laminas\\View\\Model\\ViewModel] class associated with the layout template. To change the layout template for this particular action method, we called the setTemplate() method provided by the ViewModel class. Note In addition to the @ Layout [Laminas\\Mvc\\Controller\\Plugin\\Layout] controller plugin, there is the @ Layout [Laminas\\View\\Helper\\Layout] view helper which provides the same capabilities. With the @ Layout [Laminas\\View\\Helper\\Layout] view helper, you can, for example, switch layout from the \"static\" page which has no specific controller action.","title":"Switching between Layouts"},{"location":"appearance/#setting-layout-for-all-actions-of-a-controller","text":"If all action methods of a controller class need to use the same alternative layout, you can override the onDispatch() method of the @ AbstractActionController class and call the setTemplate() method there, as shown in the example below: // Add this alias in the beginning of the controller file use Laminas\\Mvc\\MvcEvent; // ... class IndexController extends AbstractActionController { /** * We override the parent class' onDispatch() method to * set an alternative layout for all actions in this controller. */ public function onDispatch(MvcEvent $e) { // Call the base class' onDispatch() first and grab the response $response = parent::onDispatch($e); // Set alternative layout $this->layout()->setTemplate('layout/layout2'); // Return the response return $response; } }","title":"Setting Layout for All Actions of a Controller"},{"location":"appearance/#partial-views","text":"A partial view is a .phtml view template file which can be rendered by another view template. Partial views allow to compose your page of pieces and reuse pieces of view rendering logic across different view templates. For a simple example of partial view usage, let's imagine that we need to render a table of some products. Each product has the ID, the name and the price. We can use partial view template to render a single row of the table several times. First, let's add the partialDemoAction() method to the Index controller: // An action that demonstrates the usage of partial views. public function partialDemoAction() { $products = [ [ 'id' => 1, 'name' => 'Digital Camera', 'price' => 99.95, ], [ 'id' => 2, 'name' => 'Tripod', 'price' => 29.95, ], [ 'id' => 3, 'name' => 'Camera Case', 'price' => 2.99, ], [ 'id' => 4, 'name' => 'Batteries', 'price' => 39.99, ], [ 'id' => 5, 'name' => 'Charger', 'price' => 29.99, ], ]; return new ViewModel(['products' => $products]); } The action method above just prepares an array of products for rendering and passes it to the view template with the help of the @ ViewModel [Laminas\\View\\Model\\ViewModel] variable container. Next, add the partial-demo.phtml template file: <?php $this->headTitle('Partial View Demo'); ?> <h1>Partial View Demo</h1> <p> Below, the table of products is presented. It is rendered with the help of partial views. </p> <table class=\"table table-striped table-hover\"> <tr> <th>ID</th> <th>Product</th> <th>Price</th> </tr> <?php foreach ($this->products as $product) { echo $this->partial('application/index/table-row', ['product'=>$product]); } ?> </table> In the view template above, we define the markup for the table of products (lines 10-22). In line 18, we walk through the items of the products array and render each row with the @ Partial view helper. The first argument of the @ Partial view helper is the name of the partial view template file (\"application/index/table-row\"). The second argument of the @ Partial view helper should be an array of arguments passed to the view template. They will be accessible the same way as if you would pass them with the @ ViewModel [Laminas\\View\\Model\\ViewModel] variable container. Finally, create the table-row.phtml view template, which will be used as the partial view template: <tr> <td> <?= $this->product['id'] ?> </td> <td> <?= $this->product['name'] ?> </td> <td> <?= $this->product['price'] ?> </td> </tr> In the view template above, we just render a single row of the table. To see the resulting web page, type \"http://localhost/application/partial-demo\" URL in your browser's navigation bar. You should see something like in figure 6.5.","title":"Partial Views"},{"location":"appearance/#placeholder-view-helper","text":"The @ Placeholder [Laminas\\View\\Helper\\Placeholder] is another useful view helper allowing for capturing HTML content and storing 5 it for later use. Thus, analogous to the @ Partial view helper, it allows to compose your page of several pieces. For example, you can use the @ Placeholder [Laminas\\View\\Helper\\Placeholder] view helper in pair with the @ Partial view helper to \"decorate\" the content of a view template with another view template. A useful practical application for this is layout \"inheritance\". Imagine the situation, when you need to create an alternative layout which has exactly the same head section, header and the footer, but has differences in the middle page section. The \"brute force\" way for making such a layout would be to copy and paste the content of the original layout template, and make necessary changes. Another (better) way is \"inheriting\" the original one, when the resulting layout will reuse the common parts. To demonstrate how to inherit a layout, we will create the layout2.phtml view template, which will inherit the default layout.phtml template, and add the Ads bar at the right of the page. Keeping ads in layout would be useful, if you plan to profit from displaying commercial ads on all (or on most) pages of your site. Put the following code in the layout2.phtml template file: <?php $this->placeholder('content')->captureStart(); ?> <div class=\"row\"> <div class=\"col-md-8\"> <?= $this->content; ?> </div> <div class=\"col-md-4\"> <div class=\"panel panel-default\"> <div class=\"panel-heading\"> <h3 class=\"panel-title\">Ads</h3> </div> <div class=\"panel-body\"> <strong>Laminas Framework Book</strong> <p>Learn how to create modern web applications with PHP and Laminas Framework</p> <a target=\"_blank\" href=\"https://github.com/olegkrivtsov/using-laminas-framework-book\"> Learn More </a> </div> </div> </div> </div> <?php $this->placeholder('content')->captureEnd(); echo $this->partial('layout/layout', ['content'=>$this->placeholder('content')]); ?> In the code above, we call the captureStart() method (line 1) and captureEnd() method (line 26) of the @ Placeholder [Laminas\\View\\Helper\\Placeholder] view helper to delimit the HTML markup that will be captured by the view helper and stored in its internal storage (instead of rendering to PHP standard output stream). In lines 3-23, we put the markup of the \"inherited\" layout. The derived layout uses the two-cell grid. The first cell of the grid (spanning 8 columns) will contain the actual content of a certain page, and the second cell (spanning 4 columns) will contain advertisements. For styling the ads, we utilize the Panel interface component provided by the Twitter Bootstrap. In line 27, we use the @ Partial view helper which is used to render the \"parent\" layout ( layout.phtml ). We pass the content captured by the @ Placeholder [Laminas\\View\\Helper\\Placeholder] view helper to the @ Partial view helper as the second argument. This way, we produced the nice-looking layout which inherits the default layout and improves the code reusability. Now, if you set the layout2.phtml for all actions of, say Index controller, you should be able to see the result as in figure 6.6.","title":"Placeholder View Helper"},{"location":"appearance/#adding-scripts-to-a-web-page","text":"JavaScript code can be inserted into HTML pages and make them interactive. Scripts should be inserted to an HTML file between <script> and </script> tags. Below, an example JavaScript code is presented: <script type=\"text/javascript\"> // Show a simple alert window with the \"Hello World!\" text. $(document).ready(function() { alert('Hello World!'); }); </script> In the example above, we created the <script> element, and put the jQuery callback function in it. The jQuery binds a function to be executed when the DOM has finished loading. When the function is executed, a simple alert window with the \"Hello World!\" text and OK button will appear. Since you put this JavaScript code inside the HTML file, we will refer to it as inline script. An alternative way of storing JavaScript code is putting it in an external .js file. External files typically contain code that is designed to be used by several web pages. Typically, external JavaScript files are stored in APP_DIR/public/js/ directory. To link an external JS file to your HTML page, you add the <script> element like below: <script type=\"text/javascript\" src=\"/js/yourscript.js\"></script> When the browser encounter such a <script> element, it reads the external JS file and executes the code. Generally, there are two places inside an HTML file where you can put the script: JavaScript code can be put in the <head> section of an HTML page. This method is recommended to use when you need JavaScript to be loaded before the content of the page. We used this method for loading the Twitter Bootstrap JavaScript extensions and jQuery library. Script can be placed at the bottom of the <body> section of an HTML page, just before the closing </body> tag. This way is acceptable when you need the entire DOM 6 to be loaded before the script can start executing. If a certain JavaScript file needs to be used on all (or on most) of the web pages, it is better to place it in layout view template. But when a script needs to be used on a single page only, putting it in the layout template is not the best idea. If you put such a script to layout template, the script will be loaded to all pages, which can produce an unneeded traffic and increase page load time for the whole site. To avoid this, you can add such a script for the desired page only. To add a page-specific script which will be put in the <head> section of the web page, you use the @ HeadScript view helper. Its methods are summarized by table 6.1: Method name Description appendFile() Puts a link to external JS file after all others. offsetSetFile() Inserts a link to external JS file in a given list position. prependFile() Puts a link to external JS file before all others. setFile() Clears the list of scripts and puts the single external JS file in it. appendScript() Puts an inline script after all others. offsetSetScript() Inserts an inline script to a given list position. prependScript() Puts an inline script before all others. setScript() Clears the list of inline scripts and puts the single inline script in it. Table 6.1 To add a link to external JS file to the <head> section, of a page, you add the following PHP code in the beginning of your view template ( .phtml ) file: <?php $this->headScript()->appendFile('/js/yourscript.js', 'text/javascript'); ?> In the code above, we called the appendFile() method of the @ HeadScript view helper. This method takes two arguments. The first one is the path to external JS file (if the file is stored inside of APP_DIR/public/js directory, or an URL of a JS file if the file is located on another web server). The second argument is the type of the script (it is typically equal to \"text/javascript\"). Other methods provided by @ HeadScript view helper (such as prependFile() , offsetSetFile() and setFile() ) differentiate only in the position in the list of scripts into which the new script will be inserted. The methods prependScript() , appendScript() , offsetSetScript() and setScript() are designed to insert an inline JavaScript code. They are rarely used, because you typically insert external JS scripts in the head section of the document To insert a script to the end of the <body> section of the document, you can use the @ InlineScript view helper 7 . It provides exactly the same methods as the @ HeadScript view helper. Below, an example is presented which can be used to append an inline JavaScript code to the end of document body: <?php $script = <<<EOT $(document).ready(function() { alert('Hello World!'); }); EOT; $this->inlineScript()->appendScript($script); In the example above, we used the PHP's Heredoc 8 syntax to fill in the $script variable with the inline JavaScript code. Then we call the appendScript() function on the @ InlineScript view helper and pass the code as its argument. But, using the @ InlineScript view helper may be not very convenient in sense of readability. Moreover, NetBeans IDE syntax checker will be stuck on the Heredoc notation and will not recognize the JavaScript code. To fix this, you can simply put the <script> element at the bottom of your view template, as shown in the example below: <!-- Page content goes first --> <!-- Inline script goes last --> <script type=\"text/javascript\"> $(document).ready(function() { // Show a simple alert window with the \"Hello World!\" text. alert(\"Hello World!\"); }); </script> This ensures the same effect is achieved as with @ InlineScript view helper, but allows for better script readability and automatic syntax checking in NetBeans IDE. Note For @ HeadScript and @ InlineScript view helpers to work, you should ensure their content is echoed in layout view template (look at lines 23 and 62 of layout.phtml file). If you remove those lines from the layout template, the scripts won't be inserted in the web page.","title":"Adding Scripts to a Web Page"},{"location":"appearance/#example","text":"For a real-life example of inserting a JavaScript code in your web page, let's add a page with auto-complete feature. With this feature, the web browser will predict a word or phrase that the user wants to type in by several first letters, without the user actually entering the text completely. We can use an auxiliary JavaScript library called Twitter Typeahead . Analogous to Twitter Bootstrap, the Typeahead library was developed in Twitter Inc. for their internal purposes and is distributed freely. Download typeahead.min.js file (a minified version of the Typeahead library) from the official project page . When the download is finished, place the file in your APP_DIR/public/js directory. Then add the typeahead.phtml file in your application/index/static subdirectory under the module's view directory. This directory is served by the StaticRoute route type that we've created and configured earlier in chapter Routing , and all \"static\" pages placed here will automatically become available to site users. In the typeahead.phtml view template file, put the following content: <?php $this->headTitle('Typeahead'); // Add a JavaScript file $this->headScript()->appendFile('/js/typeahead.min.js', 'text/javascript'); ?> <h1>Typeahead</h1> <p>Type a continent name (e.g. Africa) in the text field below:</p> <input type=\"text\" class=\"typeahead\" title=\"Type here\"/> <script type=\"text/javascript\"> $(document).ready(function() { $('input.typeahead').typeahead({ name: 'continents', local: [ 'Africa', 'Antarctica', 'Asia', 'Europe', 'South America', 'North America' ] }); }); </script> In the code above, we set the title for the page (line 2), then we append the typeahead.min.js file to the <head> section of the page with the @ HeadScript view helper (line 4). In line 9, we create a text input field where the user will be able to enter some text. We mark the input field with the typeahead CSS class. Lines 11-25 contain inline JavaScript code placed at the bottom of the view template (we don't use @ InlineScript view helper for better code readability). In line 12, we have the jQuery event handler bound to the \"document is ready\" event. This event is fired when the complete DOM tree has been loaded. In line 13, we have the jQuery selector (\"input.typeahead\") which selects all input fields marked with the typeahead CSS class and execute the typeahead() function on them. The typeahead() function binds the change event handler to the text input field. Once the user enters a character in the field, the handler is executed and checks the letters entered. It then displays the dropdown menu with suggested auto-completion variants. The typeahead() function takes two arguments: the name argument identifies the dataset, and the local argument is a JSON array containing the available auto-completion variants. To give the auto-completion field and its dropdown menu a nice-looking visual appearance, add the following CSS rules to your style.css file. .typeahead, .tt-query, .tt-hint { width: 396px; height: 30px; padding: 0px 12px; font-size: 1.1em; border: 2px solid #ccc; border-radius: 4px; outline: none; } .tt-dropdown-menu { width: 422px; margin-top: 12px; padding: 8px 0; background-color: #fff; border: 1px solid #ccc; border: 1px solid rgba(0, 0, 0, 0.2); border-radius: 4px; } .tt-suggestion { padding: 3px 20px; font-size: 1.1em; line-height: 24px; } .tt-suggestion.tt-is-under-cursor { color: #fff; background-color: #0097cf; } .tt-suggestion p { margin: 0; } To see the auto-completion feature in work, type the \"http://localhost/typeahead\" URL in your browser and press Enter. The Typeahead page will appear with the prompt to enter a continent name. For example, type a letter to see how Typeahead suggests you available variants (figure 6.7). You can see this example working in the Hello World sample bundled with this book by typing the URL \"http://localhost/typeahead\" in your browser.","title":"Example"},{"location":"appearance/#adding-css-stylesheets-to-a-web-page","text":"CSS stylesheets are typically placed to the <head> section of an HTML document, either as a link to an external file (external CSS stylesheet files are usually stored in APP_DIR/public/css directory.) <link rel=\"stylesheet\" type=\"text/css\" href=\"/css/style.css\"> or as an inline <style> element <style> body { padding-top: 60px; padding-bottom: 40px; } </style> To store the CSS rules, external CSS stylesheets are recommended. For example, the base CSS rules provided by Twitter Bootstrap CSS framework are loaded from bootstrap.min.css and bootstrap-theme.min.css files. Custom site-specific CSS rules can be stored in style.css file. Since you need this CSS stylesheets for most of your pages, it is better to link them in the head section of the layout template. But, if a certain CSS stylesheet needs to be loaded for a single page only, you place it on that page's view template. To add an external CSS stylesheet to a view template, you use the @ HeadLink view helper: <?php $this->headLink()->appendStylesheet('/css/style.css'); $this->headLink()->appendStylesheet( '//code.jquery.com/ui/1.10.3/themes/smoothness/jquery-ui.css'); In the example code above, we used the appendStylesheet() method of the @ HeadLink view helper to add an external CSS stylesheet to the head section of the document. The method accepts a path to local CSS file (line 2) or a URL to CSS file located on another server (line 3). The summary of @ HeadLink view helper's methods is provided in table 6.2. Method name Description appendStylesheet() Puts a link to CSS stylesheet file after all others. offsetSetStylesheet() Inserts a link to CSS stylesheet file in a given list position. prependStylesheet() Puts a link to external CSS stylesheet file before all others. setStylesheet() Clears the list and puts the single CSS file instead. Table 6.2 If you want to add an inline <style> element in the head section of the document, you can use the @ HeadStyle view helper. Its methods are presented in table 6.3 below: Method name Description appendStyle() Adds a CSS stylesheet inline after all others. offsetSetStyle() Inserts a CSS stylesheet inline in a given list position. prependStyle() Puts a CSS stylesheet inline before all others. setStyle() Clears the list and puts the single CSS stylesheet inline instead. Table 6.3","title":"Adding CSS Stylesheets to a Web Page"},{"location":"appearance/#example_1","text":"To demonstrate how to add a CSS stylesheet to your web page, we will take a real-life example. Assume you need to let the user the ability to type a date (in YYYY-MM-DD format) in a text input field. You would like to improve user experience by not just letting him to type the date, but also by selecting it from a pop-up date-picker widget. To achieve this goal, you can use a third-party library called jQuery UI 9 . To integrate jQuery UI in your page, you need to download two files from the official project page : jquery-ui.min.js -- the minified version of jQuery UI JavaScript code; jquery-ui.min.css -- the minified version of jQuery UI theming styles. Put the jquery-ui.min.js file to APP_DIR/public/js , and jquery-ui.min.css file to APP_DIR/public/css . Finally, add the datepicker.phtml view template to the application/index/static directory under the module's view directory: <?php $this->headTitle('Datepicker'); $this->headScript()->appendFile('/js/jquery-ui.min.js', 'text/javascript'); $this->headLink()->appendStylesheet('/css/jquery-ui.min.css'); ?> <h1>Datepicker</h1> <p> Click the edit box below to show the datepicker. </p> <input type=\"text\" class=\"datepicker\" title=\"Type here\"/> <script> $(document).ready(function() { $(\"input.datepicker\").datepicker({ dateFormat: 'yy-mm-dd' }); }); </script> In the example above, we use the @ HeadScript view helper's appendFile() method (line 4) to add the link to jquery-ui.min.js file to the head section of the document. In line 5, we used the @ HeadLink view helper's appendStylesheet() method to add the link to jquery-ui.min.css CSS stylesheet to the head section of the document. In line 14, we added the text input field which will be used to enter the date. In line 16-20, we added an inline JavaScript code for binding jQuery event handler to the text input field. When the user clicks the text input field, the datepicker widget will appear allowing to select the date. To see the result, enter the \"http://localhost/datepicker\" URL into your browser's navigation bar (see figure 6.8 for example).","title":"Example"},{"location":"appearance/#writing-own-view-helpers","text":"Earlier in this chapter, we've created the layout common to all pages of the web site. But we still have a couple of things to do to make the layout fully functional. If you remember, the layout template contains the navigation bar and breadcrumbs. But both navigation bar and breadcrumbs interface components provided by Twitter Bootstrap are currently \"static\", while they need to be more interactive. For example, the active item of the navigation bar should depend on the controller's action that is being executed at the moment. And the breadcrumbs should display the path to the currently viewed page. In this section we will make these widgets completely ready for the website with the help of our own view helpers. A typical view helper is a PHP class deriving from @ Laminas\\View\\Helper\\AbstractHelper base class, which in turn implements the @ Laminas\\View\\Helper\\HelperInterface interface (class inheritance diagram is presented in figure 6.9).","title":"Writing Own View Helpers"},{"location":"appearance/#menu","text":"First, let's implement the Menu view helper class that will render the HTML code of the navigation bar. The Menu class will provide several methods allowing to set menu items in a form of array, set the active menu item and render the menu (see table 6.4 for method summary). Method name Description __construct($items) Class constructor. setItems($items) Method for setting the menu items. setActiveItemId($activeItemId) Method for setting the currently active menu item. render() Renders the menu. renderItem($item) Renders a single menu item. Table 6.4 The information describing a single menu item will be represented by an array like below (for example, the Home item will have an ID, text label and an URL for a hyperlink): [ 'id' => 'home', 'label' => 'Home', 'link' => $this->url('home') ] We also want to add the support for dropdown menus as navigation items. For example, in case of the Support dropdown menu having the Documentation and Help sub-items, the item description will take the following form: [ 'id' => 'support', 'label' => 'Support', 'dropdown' => [ [ 'id' => 'documentation', 'label' => 'Documentation', 'link' => $this->url('doc', ['page'=>'contents']) ], [ 'id' => 'help', 'label' => 'Help', 'link' => $this->url('static', ['page'=>'help']) ] ] ] We want to put the Menu class in Application\\View\\Helper namespace. Thus, start from creating the Menu.php file in the View/Helper directory under the Application module's source directory (figure 6.10). Why do we place the view helper class under module's source directory? View helpers (unlike .phtml view templates) are stored under module's src/ directory, because they are usual PHP classes and require to be resolved by a PHP class auto-loading feature. On the other hand, view templates are resolved by the special Laminas class called view resolver , and for this reason, view templates are stored under the module's view/ directory. Next, create the stub code for the Menu class: <?php namespace Application\\View\\Helper; use Laminas\\View\\Helper\\AbstractHelper; // This view helper class displays a menu bar. class Menu extends AbstractHelper { // Menu items array. protected $items = []; // Active item's ID. protected $activeItemId = ''; // Constructor. public function __construct($items=[]) { $this->items = $items; } // Sets menu items. public function setItems($items) { $this->items = $items; } // Sets ID of the active items. public function setActiveItemId($activeItemId) { $this->activeItemId = $activeItemId; } } In the code above, we defined several private fields for the Menu class. The $items field (line 10) is an array which will store the information on the menu items; and the $activeItemId field (line 13) is the ID of an active menu item. The active menu item will be visually highlighted. In lines 16-19, we defined the class constructor method, which (optionally) takes the array of items for initializing the menu. An alternative method of menu initialization is through the setItems() method (lines 22-25). And the setActiveItemId() method (lines 28-31) sets the ID of the currently active menu item. Next, let's add the render() method, which will generate HTML code for the whole navigation bar and return it as a text string: // Renders the menu. public function render() { if (count($this->items)==0) return ''; // Do nothing if there are no items. $result = '<nav class=\"navbar navbar-default\" role=\"navigation\">'; $result .= '<div class=\"navbar-header\">'; $result .= '<button type=\"button\" class=\"navbar-toggle\" '; $result .= 'data-toggle=\"collapse\" data-target=\".navbar-ex1-collapse\">'; $result .= '<span class=\"sr-only\">Toggle navigation</span>'; $result .= '<span class=\"icon-bar\"></span>'; $result .= '<span class=\"icon-bar\"></span>'; $result .= '<span class=\"icon-bar\"></span>'; $result .= '</button>'; $result .= '</div>'; $result .= '<div class=\"collapse navbar-collapse navbar-ex1-collapse\">'; $result .= '<ul class=\"nav navbar-nav\">'; // Render items foreach ($this->items as $item) { $result .= $this->renderItem($item); } $result .= '</ul>'; $result .= '</div>'; $result .= '</nav>'; return $result; } In the code above, we produce the HTML markup for the Bootstrap navbar component. The navbar will use the default theme and will be collapsible (adaptive to different screen widths). The navbar will not have the brand text in the header. In lines 22-24, we loop through the menu items and render each one with the renderItem() method. Finally, the render() method returns the resulting HTML code as a text string. To finish with creating the Menu class, let's implement the renderItem() method. This method will produce the HTML code for a single menu item: // Renders an item. protected function renderItem($item) { $id = isset($item['id']) ? $item['id'] : ''; $isActive = ($id==$this->activeItemId); $label = isset($item['label']) ? $item['label'] : ''; $result = ''; if(isset($item['dropdown'])) { $dropdownItems = $item['dropdown']; $result .= '<li class=\"dropdown ' . ($isActive?'active':'') . '\">'; $result .= '<a href=\"#\" class=\"dropdown-toggle\" data-toggle=\"dropdown\">'; $result .= $label . ' <b class=\"caret\"></b>'; $result .= '</a>'; $result .= '<ul class=\"dropdown-menu\">'; foreach ($dropdownItems as $item) { $link = isset($item['link']) ? $item['link'] : '#'; $label = isset($item['label']) ? $item['label'] : ''; $result .= '<li>'; $result .= '<a href=\"'.$link.'\">'.$label.'</a>'; $result .= '</li>'; } $result .= '</ul>'; $result .= '</a>'; $result .= '</li>'; } else { $link = isset($item['link']) ? $item['link'] : '#'; $result .= $isActive?'<li class=\"active\">':'<li>'; $result .= '<a href=\"'.$link.'\">'.$label.'</a>'; $result .= '</li>'; } return $result; } In the renderItem() method's code above we did the following. First, we checked whether the item is a dropdown menu or a simple item (line 10). If the item is a dropdown menu, we walk through the dropdown menu items, and render each one in turn (lines 21-28). Lines 35-39 contain the rendering code for the case of a simple item. To be able to use the Menu view helper in a view template, it is required to register it in configuration. To do that, add the following view_helpers key in the module.config.php file: <?php return [ // ... // The following registers our custom view // helper classes in view plugin manager. 'view_helpers' => [ 'factories' => [ View\\Helper\\Menu::class => InvokableFactory::class, ], 'aliases' => [ 'mainMenu' => View\\Helper\\Menu::class ] ], ]; In the example above, we registered our Menu class as a mainMenu view helper and will be able to access it from any view template. Since we plan to use the Menu view helper in the layout view template, replace the navigation menu markup in layout.phtml file with the following code: <!-- Navigation bar --> <?php $this->mainMenu()->setItems([ [ 'id' => 'home', 'label' => 'Home', 'link' => $this->url('home') ], [ 'id' => 'downloads', 'label' => 'Downloads', 'link' => $this->url(\"application\", ['action'=>'downloads']) ], [ 'id' => 'support', 'label' => 'Support', 'dropdown' => [ [ 'id' => 'documentation', 'label' => 'Documentation', 'link' => $this->url('doc', ['page'=>'contents']) ], [ 'id' => 'help', 'label' => 'Help', 'link' => $this->url('static', ['page'=>'help']) ] ] ], [ 'id' => 'about', 'label' => 'About', 'link' => $this->url('about') ], ]); echo $this->mainMenu()->render(); ?> In the code above, we access the registered mainMenu view helper and set the navigation bar items with the help of setItems() method (line 3). As a parameter for the method, we pass the array of items. Then we render the navigation bar with the render() method. To set the active item for the navigation bar, we can call the setActiveItemId() method from any view template. For example, add the following code to the beginning of the view template for the About page ( application/index/about.phtml ) as follows: <?php $this->mainMenu()->setActiveItemId('about'); ?> Now, if you open the About page in your browser, you should see that the About item of the navigation menu is highlighted with a different color. To display the active item properly, you need to call the setActiveItemId() method for each page presenting in the navbar ( Home , Downloads , Documentation , etc.) You can see how this is done in the Hello World sample.","title":"Menu"},{"location":"appearance/#breadcrumbs","text":"Now that you know how to implement a view helper, let's create the second view helper for rendering the breadcrumbs. It is completely analogous to the Menu view helper, so below we just provide the complete code of the Breadcrumbs class: <?php namespace Application\\View\\Helper; use Laminas\\View\\Helper\\AbstractHelper; // This view helper class displays breadcrumbs. class Breadcrumbs extends AbstractHelper { // Array of items. private $items = []; // Constructor. public function __construct($items=[]) { $this->items = $items; } // Sets the items. public function setItems($items) { $this->items = $items; } // Renders the breadcrumbs. public function render() { if(count($this->items)==0) return ''; // Do nothing if there are no items. // Resulting HTML code will be stored in this var $result = '<ol class=\"breadcrumb\">'; // Get item count $itemCount = count($this->items); $itemNum = 1; // item counter // Walk through items foreach ($this->items as $label=>$link) { // Make the last item inactive $isActive = ($itemNum==$itemCount?true:false); // Render current item $result .= $this->renderItem($label, $link, $isActive); // Increment item counter $itemNum++; } $result .= '</ol>'; return $result; } // Renders an item. protected function renderItem($label, $link, $isActive) { $result = $isActive?'<li class=\"active\">':'<li>'; if(!$isActive) $result .= '<a href=\"'.$link.'\">'.$label.'</a>'; else $result .= $label; $result .= '</li>'; return $result; } } To be able to use the Breadcrumbs view helper, register it in the module.config.php file as follows: <?php return [ //... // The following registers our custom view helper classes. 'view_helpers' => [ 'factories' => [ View\\Helper\\Breadcrumbs::class => InvokableFactory::class, ], 'aliases' => [ 'pageBreadcrumbs' => View\\Helper\\Breadcrumbs::class, ] ], ]; Since we plan to use the Breadcrumbs view helper in the layout view template, replace the breadcrumbs markup in layout.phtml file with the following code: <!-- Breadcrumbs --> <?= $this->pageBreadcrumbs()->render(); ?> In the code above, we access the pageBreadcrumbs() view helper and call it with the render() method. The echo operator then outputs the HTML code of the breadcrumbs. Finally, you need to pass the breadcrumbs items for each view template. For example, add the following lines in the view template for the About page: <?php $this->pageBreadcrumbs()->setItems([ 'Home'=>$this->url('home'), 'About'=>$this->url('about'), ]); ?> Now, if you open the about page, you should see breadcrumbs as in figure 6.11 below. Site users will easily see what page they are visiting right now and will not get lost.","title":"Breadcrumbs"},{"location":"appearance/#view-models-and-page-composition","text":"Earlier, when we wrote action methods for the controller classes, we used the @ ViewModel [Laminas\\View\\Model\\ViewModel] class as a variable container for passing the variables from controller to view template, and we also used the @ ViewModel [Laminas\\View\\Model\\ViewModel] for overriding the default view template name. But, actually the @ ViewModel [Laminas\\View\\Model\\ViewModel] class is more than just a variable container plus view template name. In fact, it is closely related to the layout and page composition. The third big capability of the view model class is that it allows for combining several view models in a tree-like structure. Each view model in the tree has the associated view template name and data variables that can be passed to the view template to control the process of rendering. This feature is internally used by Laminas Framework when \"combining\" the layout view template and the view template associated with the controller's action method. Laminas internally creates the view model for the layout template and assigns it with layout/layout view template name. When your controller's action method returns the @ ViewModel [Laminas\\View\\Model\\ViewModel] object, this object is attached as a child to the layout view model (see figure 6.12 for an example). The resulting process of page rendering is the following: The child view model is visited first and its associated view template is rendered, and the resulting HTML markup is saved in a temporary storage; The output HTML markup of the child view model is passed to the layout view model as the $content variable. This way the layout view template can render the content specific to the certain page. Table 6.5 gives the summary of the methods provided by the @ ViewModel [Laminas\\View\\Model\\ViewModel] class for the purpose of page composition: Method name Description addChild() Adds a child view model. getChildren() Gets the list of child view models. hasChildren() Tests if the view model has children or not. clearChildren() Removes all child view models. count() Returns count of child view models. getIterator() Returns the iterator for child view models. setTerminal() Sets the terminal flag. terminate() Tests whether the view model is terminal. setCaptureTo() Sets the name of the variable for capturing the output. setAppend() Sets the append flag. isAppend() Tests whether to append this view model to another one. Table 6.5. Methods of the ViewModel class for page composition Below, we provide the brief description of the methods presented in the table above. The addChild() , getChild() , hasChildren() and clearChildren() methods are used for (respectively) adding a child view model to the parent one, retrieving the array of view models attached, testing if the view model is leaf (doesn't have children) and detaching all children. The setCaptureTo() method allows to set the variable in the parent view template into which to inject the HTML markup code produced by a child view template. If two child view models use the same variable, the second one will overwrite the first one. The setAppend() method can be used when you need to inject the results of two or more view templates into a single placeholder variable. The next rendered view template will be appended to the variable's existing content. The view model returned by the controller is assigned the $content capture variable. A view model can be marked as terminal with the setTerminal() method. The setTerminal() method takes a single flag parameter. If true , the view model is considered as terminal (top-level parent) and the renderer returns the output of the view template to the application, otherwise its parents are rendered as well. The method terminate() tests whether the view model is terminal or not. The setTerminal() method is very useful in some situations, because with its help you can disable the rendering of the layout view template. If you return from controller the view model marked as terminal, the layout will not be applied. This can be used, for example, when you want to load part of a page asynchronously by an AJAX 10 request and need to insert its HTML code in the DOM tree of an existing page.","title":"View Models and Page Composition"},{"location":"appearance/#summary","text":"Laminas Framework is shipped with Twitter Bootstrap that is a CSS framework allowing for creating visual appealing and professionally looking web applications. It provides the base CSS rules, the simple layout grid, and useful interface components (like navigation bars, breadcrumbs, pagination, etc.) In a typical web site, pages have common structure (for example, a typical page may have a navigation bar at the top, the body with page content, and the footer with the copyright information at the bottom). In Laminas Framework, you define this common structure with a view template file called the layout. The layout template may have placeholder(s) in which Laminas puts the content specific to a particular web page. View helpers are (relatively) simple PHP classes that encapsulate a part of page rendering work. For example, they allow for composing the page of several parts, setting page title and meta tags, and creating the reusable widgets like navigation bar or breadcrumbs. If you are new to CSS, please refer to the excellent W3Schools CSS tutorial by visiting this link . \u21a9 The <!DOCTYPE> declaration goes first in the HTML document, before the <html> tag. The declaration provides an instruction to the web browser about what version of HTML the page is written in (in our web site, we use HTML5-conformant document type declaration). \u21a9 The UTF-8 allows to encode any character in any alphabet around the world, that's why it is recommended for encoding the web pages. \u21a9 A \"compound\" page title consists of two parts: the first part (\"ZF Skeleton Application\") is defined by the layout, and the second part - defined by a particular page - is prepended to the first one. For example, for the About page of your site you will have the \"About - ZF Skeleton Application\", and for the Documentation page you will have something like \"Documentation - ZF Skeleton Application\". \u21a9 The @ Placeholder [Laminas\\View\\Helper\\Placeholder] view helper stores the data in PHP session storage. So, in theory, you can even capture content on one page and then render/use it on another one. \u21a9 The DOM (Document Object Model) is a convenient representation of an HTML document structure as a tree of elements. \u21a9 The name @ InlineScript does not fully reflect the capabilities of this view helper. Actually, it can insert both inline and external scripts. The better name for this view helper would be BodyScript , because it is intended for inserting scripts in document body. \u21a9 Heredoc is an alternative string definition method provided by PHP. It works well with multi-line strings. \u21a9 jQuery UI provides a set of \"user interface interactions, effects, widgets, and themes\"; it is based on jQuery library. jQuery UI is analogous to Twitter Bootstrap in the sense that both provide reusable user interface components. \u21a9 AJAX (stands for Asynchronous JavaScript and XML) is a capability provided by modern browsers which can be used to send data to, and retrieve data from, a server asynchronously (in background) without interfering with the display and behavior of the existing page. \u21a9","title":"Summary"},{"location":"bootstrap/","text":"Appendix C. Introduction to Twitter Bootstrap Twitter Bootstrap (shortly, Bootstrap) is a popular CSS framework allowing to make your web site professionally looking and visually appealing, even if you don't have advanced designer skills. In this appendix, you can find some introductory information about Bootstrap and its usage examples. Overview of Bootstrap Files The source code of Bootstrap framework's components is spread across many CSS files. It is known that downloading multiple small files is typically slower than downloading a single large file. For this reason, Bootstrap CSS stylesheets are \"concatenated\" with the special tool and distributed in a form of a single file named bootstrap.css . However, this bootstrap.css file has a disadvantage: it contains many characters (white space characters, new line characters, comments, etc.) unneeded for code execution, wasting network bandwidth when downloading the file, thus increasing page load time. To fix this problem, the minification is used. The minification is the process of removing all unnecessary characters from the source code without changing its functionality. The minified Bootstrap file is called bootstrap.min.css . Note It is generally recommended to use the minified file, especially in production environment, because it reduces the page load time. However, if you plan to dig into Bootstrap code to understand how it works, you better use the usual (non-minified) file, or even download the original source files (not concatenated ones). Let's look in more details at the files stored inside the APP_DIR/public directory and its subdirectories (figure C.1). The css directory contains the CSS stylesheets: The bootstrap.css and bootstrap.min.css files are the usual and minified versions of Bootstrap, respectively. The bootstrap-theme.css is the optional Bootstrap theme file for a \"visually enhanced experience\". The bootstrap-theme.min.css is its minified version. The style.css file is the stylesheet that can be used and extended by you to define your own CSS rules which will be applied on top of Bootstrap rules. This way you can customize the appearance of your web application. You may also notice various files with .map extension, which is the MAP 1 files that can be used for debugging the CSS code. The fonts directory contains several files (e.g. glyphicons-halflings-regular.svg ) needed by Bootstrap for rendering icons. These icons (also called Glyphicons) can be used to enhance the appearance of the buttons and dropdown menus. The APP_DIR/public/js subdirectory contains JavaScript extensions of the Bootstrap framework. They are implemented as jQuery plugins: The bootstrap.js is the file containing the JavaScript code of the Bootstrap extensions. The bootstrap.min.js file is its minified version. Because Bootstrap extensions are implemented as jQuery plugins, they require the latest version of jQuery library to be present. Thus, the js directory includes the jQuery library file jquery-2.2.4.min.js . Grid System In most websites, content is required to be organized in a table-like structure having rows and columns. In figure C.2, you can see an example layout of a typical website: it has the header block with a logo, the sidebar at the left, page content area in the middle, the ads bar at the right, and the footer at the bottom of the page. These blocks are arranged in a grid, although grid cells have unequal width (some cells can span several columns). Bootstrap provides a simple layout grid system to make it easy to arrange content on your pages in rows and columns. Each row consists of up to 12 columns 2 (figure C.3). Column width is flexible and depends on the width of the grid container element. Column height may vary depending on the height of the content of the cell. The space between columns is 30 pixels (15 pixels padding at both sides of the column). Columns can be spanned, so a single cell takes the space of several columns. For example, in figure C.3, the upper grid row consists of 12 columns, and each cell spans a single column. In the bottom row, the first cell spans 2 columns, the second and the third ones span 4 columns each, and the fourth cell spans 2 columns (in total we have 12 columns). Why does Bootstrap's grid consist of only 12 columns? 12 is dividable by 2, 3 and 4. Hence you can easily create 2, 3 or 4 columns layouts. This is enough for 90% of all typical website layouts. If you have more fine-grained grid with lots of columns, it would be more difficult to compute column spans without the calculator. Fortunately, Bootstrap allows for customizing the count of columns per row, so you can have as many columns as you wish. Defining the Grid To arrange elements in a grid on your web page, you start from defining the container by adding a <div> element having the .container CSS class. To add a new row to the grid, use a <div> element having the .row CSS class, as shown in the example below: <div class=\"container\"> <div class=\"row\"> ... </div> </div> To add columns, you use <div> elements with CSS class names varying from .col-md-1 to .col-md-12 . The number in the class name specifies how many columns each grid cell will span: <div class=\"container\"> <div class=\"row\"> <div class=\"col-md-1\">Cell 1</div> <div class=\"col-md-5\">Cell 2</div> <div class=\"col-md-6\">Cell 3</div> </div> </div> In the example above, we have three cells. The first cell has a width of 1 (it uses the .col-md-1 class), the second cell spans 5 grid columns (class .col-md-5 ) and the third cell spans 6 columns (class .col-md-6 ). As another example, let's define the layout that we saw in figure C.2. The layout has the header (logo spans 3 columns), the main content area (spans 7 columns), the sidebar (spans 3 columns), the advertisements bar (2 columns) and the footer. To produce this layout, we can use the following HTML code: <div class=\"container\"> <!-- Header --> <div class=\"row\"> <div class=\"col-md-3\">Logo</div> <div class=\"col-md-9\"></div> </div> <!-- Body--> <div class=\"row\"> <div class=\"col-md-3\">Sidebar</div> <div class=\"col-md-7\">Page Content</div> <div class=\"col-md-2\">Ads</div> </div> <!-- Footer --> <div class=\"row\"> <div class=\"col-md-12\">Page Footer</div> </div> </div> Offsetting Columns In real web pages, sometimes the grid needs to contain \"empty holes\". You can define such holes by offsetting cells to the right with the help of CSS classes named from .col-md-offset-1 to .col-md-offset-12 . The number in the class name specifies how many columns should be skipped. For example, look at figure C.4: The grid above has three cells, the latter two cells are offsetted to the right, making empty holes. To define the grid like in figure C.4, you can use the following HTML code: <div class=\"container\"> <div class=\"row\"> <div class=\"col-md-2\">Cell 1</div> <div class=\"col-md-4 col-md-offset-2\">Cell 2</div> <div class=\"col-md-2 col-md-offset-2\">Cell 3</div> </div> </div> Nesting Grids You can create complex page layouts by nesting grids (for example, look at figure C.5). To nest your content, you add a new <div> element containing .row class, and set of .col-md-* columns within an existing .col-md-* column. To produce the grid as shown in figure C.5, you can use the following HTML code: <div class=\"container\"> <div class=\"row\"> <div class=\"col-md-2\">Cell 1</div> <div class=\"col-md-8\"> <!-- Nested grid --> <div class=\"row\"> <div class=\"col-md-4\">Cell 21</div> <div class=\"col-md-4\">Cell 22</div> </div> <div class=\"row\"> <div class=\"col-md-4\">Cell 23</div> <div class=\"col-md-4\">Cell 24</div> </div> </div> <div class=\"col-md-2\">Cell 3</div> </div> </div> In the example above, we defined the grid consisting of three cells (denoted by gray color): the first cell spanning 2 columns, the second cell spanning 8 columns and the third cell spanning 2 columns. Then we put the nested grid rows inside of the second cell. Because the parent cell spans 8 columns, the child grid consists of 8 columns, too. \"Mobile First\" Concept Twitter Bootstrap is designed to support different devices varying from wide displays to tablets and mobile phones. By this reason, the layout grid is adapted to different screen resolutions. Note This is also called the responsiveness , or the \"mobile first\" concept. Bootstrap is mobile-first, which means your website will be viewable and usable on any-sized screen. However, this does not free you of painstaking preparation and planning the layout. This adaptation is performed in two ways. The first way is that the column width within the grid is flexible. For example, if you increase the size of the browser window, the grid will be scaled accordingly to fill the whole space. But what will happen if your web page is too wide for the display? To see the hidden part, the site visitor will need to scroll it to the right. For mobile phones and other low-resolution devices this is not a good approach. Instead, it would be better for the grid to become \"stacked\" below some screen width. When the grid is stacked, its rows are transformed, making cells to be positioned one below another (see figure C.6 for example). To better control when the grid becomes \"stacked\", Bootstrap provides you with additional CSS classes: .col-xs-1 to col-xs-12 (the \"xs\" abbreviation means \"extra-small\" devices, or phones), .col-sm-1 to .col-sm-12 (\"sm\" stands for \"small devices\", or tablets), and .col-lg-1 to .col-lg-12 (large devices, or wide displays). These classes can be used together with the .col-md-1 -- .col-md-12 classes, that we already used (the \"md\" abbreviation means \"medium devices\", or desktops). For example, .col-md-* classes define the grid which will become \"stacked\" when the screen is below 992 pixels wide, and horizontal for wider screens. The .col-sm-* can be used to make the grid \"stacked\" below 768 pixel screen width, and horizontal above this point. The .col-xs-* class makes the grid always horizontal, not depending on the screen width. Table C.1 provides the summary of available grid classes and their breakdown page width. Class name Breakdown width .col-xs-* <768px .col-sm-* >=768px .col-md-* >=992px .col-lg-* >=1200px Table C.1. CSS classes for defining layout grid Note Bootstrap's grid system greatly simplifies the positioning of elements on a web page. However, using the grid system is not mandatory. For example, sometimes you may need a much more complex layout, and the simple grid system will be insufficient. In such a case, you can create and use your custom layout by using <table> or <div> HTML elements. Bootstrap's Interface Components In this section, we will give a summary on useful interface components provided by Twitter Bootstrap. We plan to use some of these components in our further examples, and this section should give an idea of how you can use these widgets in your own websites. Navigation Bar Navigation bar is usually positioned on top of your website and contains the links to main pages, like Home , Download , Support , About , etc. Twitter Bootstrap provides a nice visual style for the navbar (see figure C.7 for example): As you can see from the figure above, a navbar typically has the header (brand name of your site can be placed here) and the links to main pages. To put a navbar on your page, you use the following HTML code: <nav class=\"navbar navbar-default\" role=\"navigation\"> <div class=\"navbar-header\"> <a class=\"navbar-brand\" href=\"#\">Hello World</a> </div> <ul class=\"nav navbar-nav\"> <li><a href=\"#\">Home</a></li> <li><a href=\"#\">Download</a></li> <li><a href=\"#\">Support</a></li> <li><a href=\"#\">About</a></li> </ul> </nav> In line 1 above, we used the <nav> element, which contains all the navigation bar information. The associated CSS class .navbar is defined by Bootstrap and provides the base navigation bar's appearance. The .navbar-default CSS class specifies the \"default\" theme for the navigation bar. The optional role attribute is an HTML attribute allowing to annotate the page elements with machine-extractable semantic information about the purpose of an element. In this example, the attribute tells that the <nav> element is used for navigation. In lines 2-4, we define the navbar header area, which contains the Hello World hyperlink. The brand hyperlink typically points to the main page of your site. The hyperlink has the .navbar-brand class that visually enhances the text. In lines 5-10, we specify the navigation links for the Home , Download , Support and About pages. These links are organized inside an <ul> unordered list element. The element has CSS classes .nav and .navbar-nav that place list items in line and provide the hover item state. Dropdown Menu With Bootstrap navigation bar, it is possible to use the dropdown menu as a navigation item. For example, if the Support section of your site can be subdivided into Documentation and Help pages, these can be implemented as a dropdown menu (see figure C.8). You define the dropdown menu by replacing the Support list item from the previous example in the following way: <li class=\"dropdown\"> <a href=\"#\" class=\"dropdown-toggle\" data-toggle=\"dropdown\"> Support <b class=\"caret\"></b> </a> <ul class=\"dropdown-menu\"> <li><a href=\"#\">Documentation</a></li> <li><a href=\"#\">Help</a></li> </ul> </li> In the code above, we use the <li> element with CSS class .dropdown that indicates the dropdown menu (line 1). In lines 2-4, the <a> element defines the hyperlink to show when the menu is hidden (the Support text is shown followed by the triangle caret). When the site user clicks the hyperlink, the dropdown menu (lines 5-8) appears. The <ul> unordered list element with class .dropdown-menu defines its visual appearance. The dropdown menu contains two items: the Documentation and Help hyperlinks. Collapsible Navbar As with the grid system, the navbar component supports different types of screen resolutions. On low-resolution devices, the navbar can be collapsed, as shown in figure C.9. As you can see, in the collapsed mode, only the navbar header is displayed, and the three horizontal bars at the right denote the Toggle button. Clicking the button would expand the hidden navbar items. You define the collapsible navigation bar as shown in the example below: <nav class=\"navbar navbar-default\" role=\"navigation\"> <!-- Brand and toggle get grouped for better mobile display --> <div class=\"navbar-header\"> <button type=\"button\" class=\"navbar-toggle\" data-toggle=\"collapse\" data-target=\".navbar-ex1-collapse\"> <span class=\"sr-only\">Toggle navigation</span> <span class=\"icon-bar\"></span> <span class=\"icon-bar\"></span> <span class=\"icon-bar\"></span> </button> <a class=\"navbar-brand\" href=\"#\">Hello World</a> </div> <!-- Collect the nav links, forms, and other content for toggling --> <div class=\"collapse navbar-collapse navbar-ex1-collapse\"> <ul class=\"nav navbar-nav\"> <li><a href=\"#\">Home</a></li> <li><a href=\"#\">Download</a></li> <li class=\"dropdown\"> <a href=\"#\" class=\"dropdown-toggle\" data-toggle=\"dropdown\"> Support <b class=\"caret\"></b> </a> <ul class=\"dropdown-menu\"> <li><a href=\"#\">Documentation</a></li> <li><a href=\"#\">Help</a></li> </ul> </li> <li><a href=\"#\">About</a></li> </ul> </div><!-- /.navbar-collapse --> </nav> Above in lines 3-12, we define the navbar header which will be displayed independently on screen resolution. The header contains the Toggle button with three horizontal bars and description text \"Toggle navigation\". The collapsible part of the menu can be seen in lines 15-30. In this area, we put our navigation links and the dropdown menu items. Inverse Navbar Style The navigation bar can be displayed using two standard \"themes\": the default theme (we saw it above), and the inverse theme. The inverse theme makes the navbar elements be displayed in dark colors (figure C.10). You probably saw such an inverse navbar in the Laminas Skeleton Application demo. The inverse theme is defined by simply replacing the .navbar-default class of the <nav> element by the .navbar-inverse class: <nav class=\"navbar navbar-inverse\" role=\"navigation\"> ... </nav> Breadcrumbs Breadcrumbs is a useful interface component which can be used together with the navbar to give the site visitor an idea of his current location within the site (figure C.11). In the figure above, we have an example breadcrumbs for the documentation system of our site. Because the documentation pages can have deep nesting level, the breadcrumbs tell the user which page he is visiting right now so the user will not get lost and will be able to return to the page he visited previously, and to the upper-level pages. To define the breadcrumbs, you use the ordered list <ol> element with the .breadcrumb CSS class (see an example below): <ol class=\"breadcrumb\"> <li><a href=\"#\">Home</a></li> <li><a href=\"#\">Support</a></li> <li class=\"active\">Documentation</li> </ol> Pagination The pagination component is useful when you have a long list of items for display. Such a long list, if displayed on a single page, would require the user to scroll the page down several times to see the bottom of the list. To improve user experience, you would break the output into pages, and use the pagination component for navigation between the pages (figure C.12): To define the pagination like in figure above, use the following HTML code: <ul class=\"pagination\"> <li><a href=\"#\">&laquo; Newest</a></li> <li><a href=\"#\">&lt; Newer</a></li> <li><a href=\"#\">1</a></li> <li><a href=\"#\">2</a></li> <li><a href=\"#\">3</a></li> <li><a href=\"#\">4</a></li> <li><a href=\"#\">5</a></li> <li><a href=\"#\">Older &gt;</a></li> <li><a href=\"#\">Oldest &raquo</a></li> </ul> Buttons & Glyphicons Twitter Bootstrap provides a nice visual style for button elements (figure C.13). To create the buttons like in the figure above, use the following HTML code: <p> <button type=\"button\" class=\"btn btn-primary\">Save</button> <button type=\"button\" class=\"btn btn-default\">Cancel</button> </p> In the code above, we use the .btn CSS class to assign the button its visual style. Additionally, we use the .btn-primary class for the Save button (which is typically the primary button on a form), or the btn-default class for a usual non-primary button Cancel . To better express the meaning of a button, Bootstrap provides you with several additional button classes: .btn-success (for buttons applying some change on the page), .btn-info (for informational buttons), .btn-warning (for buttons that may have an undesired effect), and .btn-danger (for buttons that may lead to irreversible consequences). For an example of using these button styles, look at the code below: <p> <button type=\"button\" class=\"btn btn-default\">Default</button> <button type=\"button\" class=\"btn btn-primary\">Primary</button> <button type=\"button\" class=\"btn btn-success\">Success</button> <button type=\"button\" class=\"btn btn-info\">Info</button> <button type=\"button\" class=\"btn btn-warning\">Warning</button> <button type=\"button\" class=\"btn btn-danger\">Danger</button> </p> Figure C.14 shows the resulting button appearance: Bootstrap includes 180 icons (called Glyphicons) that you can use together with your buttons, dropdown menus, navigation links, etc. To add an icon on a button, you can use the code like the one below: <p> <button type=\"button\" class=\"btn btn-default\"> <span class=\"glyphicon glyphicon-plus\"></span> Create </button> <button type=\"button\" class=\"btn btn-default\"> <span class=\"glyphicon glyphicon-pencil\"></span> Edit </button> <button type=\"button\" class=\"btn btn-default\"> <span class=\"glyphicon glyphicon-remove\"></span> Delete </button> </p> In the code above, we defined a simple toolbar containing three buttons: Create , Edit and Delete . We placed an icon on each button with the help of <span> element. The <span> element should have two classes: the .glyphicon class is common for all icons; the second class represents the icon name. In the example above, we used .glyphicon-plus class for the Create button, the .glyphicon-pencil for Edit button, and .glyphicon-remove for Delete button. The result of our work is presented in figure C.15. You can vary button sizes by specifying the .btn-lg class for large buttons, btn-sm for small buttons, or .btn-xs class for extra-small buttons. For example, in figure C.16, a large Download button is presented. To define such a button, you can use the following HTML code: <button type=\"button\" class=\"btn btn-success btn-lg\"> <span class=\"glyphicon glyphicon-download\"></span> Download </button> Customizing Bootstrap To finish the introduction to Twitter Bootstrap, we will describe about how to modify some aspects of Bootstrap framework. You can customize the Bootstrap look and feel using the Customize page of the Bootstrap website (figure C.17). On the Customize page you can choose which Bootstrap source files to include into the \"concatenated\" resulting file bootstrap.css . If you don't need some functionality, you can exclude it from the resulting file, thus reducing the network traffic and page load time. You can also remove some unused JavaScript code components from the resulting bootstrap.js file. Additionally, you can choose different CSS parameters like background color, base text color and font family, and so on. There are more than a hundred customizable parameters available. Note CSS customization is possible, because Bootstrap source files are stored in LESS 3 format, which allows to define variable parameters (like @bodyBackground or @textColor ). Once the parameters are defined, the LESS files are compiled into usual CSS files, minified and made available for downloading. If you would like to read more about LESS then go to the official website . When you have finished with tuning parameters, you can scroll the Customize page down and press the Compile and Download button. As a result, the bootstrap.zip archive will be downloaded, which contains all the customized Bootstrap files (both usual and minified CSS and JS files and glyphicons fonts). Summary Twitter Bootstrap is a CSS framework developed to make designing your web pages easier. It provides the default nice-looking style for typography, tables, forms, buttons, images and so on, so you can create a professionally looking page in a minute. The grid system provided by the Bootstrap allows to arrange elements on your web page in a grid with rows and columns. The grid adapts to different screen resolutions, making your page equally well-readable on mobile phones, tablets, desktops and wide screens. Twitter Bootstrap also provides useful web interface components like dropdown menus, navigation bars, breadcrumbs, etc. These components are made interactive by the JavaScript extensions bundled with the framework. Bootstrap is shipped with Laminas Skeleton Application, so you can start using it out of the box or, alternatively, you can download the newest version of Bootstrap from the project's page and customize it as you wish. After the concatenation and minification, the CSS code is difficult to read and debug. A MAP file (source map) allows to restore the minified file back to its usual state. \u21a9 You are not required to put exactly 12 columns in a row, there may be fewer columns. If you have fewer columns, the space to the right of the last column will be empty. \u21a9 LESS is a dynamic stylesheet language extending standard CSS with features like variables, mixins (embedding all the properties of a CSS class into another CSS class), code block nesting, arithmetic operations, and functions. \u21a9","title":"Appendix C. Introduction to Twitter Bootstrap"},{"location":"bootstrap/#appendix-c-introduction-to-twitter-bootstrap","text":"Twitter Bootstrap (shortly, Bootstrap) is a popular CSS framework allowing to make your web site professionally looking and visually appealing, even if you don't have advanced designer skills. In this appendix, you can find some introductory information about Bootstrap and its usage examples.","title":"Appendix C. Introduction to Twitter Bootstrap"},{"location":"bootstrap/#overview-of-bootstrap-files","text":"The source code of Bootstrap framework's components is spread across many CSS files. It is known that downloading multiple small files is typically slower than downloading a single large file. For this reason, Bootstrap CSS stylesheets are \"concatenated\" with the special tool and distributed in a form of a single file named bootstrap.css . However, this bootstrap.css file has a disadvantage: it contains many characters (white space characters, new line characters, comments, etc.) unneeded for code execution, wasting network bandwidth when downloading the file, thus increasing page load time. To fix this problem, the minification is used. The minification is the process of removing all unnecessary characters from the source code without changing its functionality. The minified Bootstrap file is called bootstrap.min.css . Note It is generally recommended to use the minified file, especially in production environment, because it reduces the page load time. However, if you plan to dig into Bootstrap code to understand how it works, you better use the usual (non-minified) file, or even download the original source files (not concatenated ones). Let's look in more details at the files stored inside the APP_DIR/public directory and its subdirectories (figure C.1). The css directory contains the CSS stylesheets: The bootstrap.css and bootstrap.min.css files are the usual and minified versions of Bootstrap, respectively. The bootstrap-theme.css is the optional Bootstrap theme file for a \"visually enhanced experience\". The bootstrap-theme.min.css is its minified version. The style.css file is the stylesheet that can be used and extended by you to define your own CSS rules which will be applied on top of Bootstrap rules. This way you can customize the appearance of your web application. You may also notice various files with .map extension, which is the MAP 1 files that can be used for debugging the CSS code. The fonts directory contains several files (e.g. glyphicons-halflings-regular.svg ) needed by Bootstrap for rendering icons. These icons (also called Glyphicons) can be used to enhance the appearance of the buttons and dropdown menus. The APP_DIR/public/js subdirectory contains JavaScript extensions of the Bootstrap framework. They are implemented as jQuery plugins: The bootstrap.js is the file containing the JavaScript code of the Bootstrap extensions. The bootstrap.min.js file is its minified version. Because Bootstrap extensions are implemented as jQuery plugins, they require the latest version of jQuery library to be present. Thus, the js directory includes the jQuery library file jquery-2.2.4.min.js .","title":"Overview of Bootstrap Files"},{"location":"bootstrap/#grid-system","text":"In most websites, content is required to be organized in a table-like structure having rows and columns. In figure C.2, you can see an example layout of a typical website: it has the header block with a logo, the sidebar at the left, page content area in the middle, the ads bar at the right, and the footer at the bottom of the page. These blocks are arranged in a grid, although grid cells have unequal width (some cells can span several columns). Bootstrap provides a simple layout grid system to make it easy to arrange content on your pages in rows and columns. Each row consists of up to 12 columns 2 (figure C.3). Column width is flexible and depends on the width of the grid container element. Column height may vary depending on the height of the content of the cell. The space between columns is 30 pixels (15 pixels padding at both sides of the column). Columns can be spanned, so a single cell takes the space of several columns. For example, in figure C.3, the upper grid row consists of 12 columns, and each cell spans a single column. In the bottom row, the first cell spans 2 columns, the second and the third ones span 4 columns each, and the fourth cell spans 2 columns (in total we have 12 columns). Why does Bootstrap's grid consist of only 12 columns? 12 is dividable by 2, 3 and 4. Hence you can easily create 2, 3 or 4 columns layouts. This is enough for 90% of all typical website layouts. If you have more fine-grained grid with lots of columns, it would be more difficult to compute column spans without the calculator. Fortunately, Bootstrap allows for customizing the count of columns per row, so you can have as many columns as you wish.","title":"Grid System"},{"location":"bootstrap/#defining-the-grid","text":"To arrange elements in a grid on your web page, you start from defining the container by adding a <div> element having the .container CSS class. To add a new row to the grid, use a <div> element having the .row CSS class, as shown in the example below: <div class=\"container\"> <div class=\"row\"> ... </div> </div> To add columns, you use <div> elements with CSS class names varying from .col-md-1 to .col-md-12 . The number in the class name specifies how many columns each grid cell will span: <div class=\"container\"> <div class=\"row\"> <div class=\"col-md-1\">Cell 1</div> <div class=\"col-md-5\">Cell 2</div> <div class=\"col-md-6\">Cell 3</div> </div> </div> In the example above, we have three cells. The first cell has a width of 1 (it uses the .col-md-1 class), the second cell spans 5 grid columns (class .col-md-5 ) and the third cell spans 6 columns (class .col-md-6 ). As another example, let's define the layout that we saw in figure C.2. The layout has the header (logo spans 3 columns), the main content area (spans 7 columns), the sidebar (spans 3 columns), the advertisements bar (2 columns) and the footer. To produce this layout, we can use the following HTML code: <div class=\"container\"> <!-- Header --> <div class=\"row\"> <div class=\"col-md-3\">Logo</div> <div class=\"col-md-9\"></div> </div> <!-- Body--> <div class=\"row\"> <div class=\"col-md-3\">Sidebar</div> <div class=\"col-md-7\">Page Content</div> <div class=\"col-md-2\">Ads</div> </div> <!-- Footer --> <div class=\"row\"> <div class=\"col-md-12\">Page Footer</div> </div> </div>","title":"Defining the Grid"},{"location":"bootstrap/#offsetting-columns","text":"In real web pages, sometimes the grid needs to contain \"empty holes\". You can define such holes by offsetting cells to the right with the help of CSS classes named from .col-md-offset-1 to .col-md-offset-12 . The number in the class name specifies how many columns should be skipped. For example, look at figure C.4: The grid above has three cells, the latter two cells are offsetted to the right, making empty holes. To define the grid like in figure C.4, you can use the following HTML code: <div class=\"container\"> <div class=\"row\"> <div class=\"col-md-2\">Cell 1</div> <div class=\"col-md-4 col-md-offset-2\">Cell 2</div> <div class=\"col-md-2 col-md-offset-2\">Cell 3</div> </div> </div>","title":"Offsetting Columns"},{"location":"bootstrap/#nesting-grids","text":"You can create complex page layouts by nesting grids (for example, look at figure C.5). To nest your content, you add a new <div> element containing .row class, and set of .col-md-* columns within an existing .col-md-* column. To produce the grid as shown in figure C.5, you can use the following HTML code: <div class=\"container\"> <div class=\"row\"> <div class=\"col-md-2\">Cell 1</div> <div class=\"col-md-8\"> <!-- Nested grid --> <div class=\"row\"> <div class=\"col-md-4\">Cell 21</div> <div class=\"col-md-4\">Cell 22</div> </div> <div class=\"row\"> <div class=\"col-md-4\">Cell 23</div> <div class=\"col-md-4\">Cell 24</div> </div> </div> <div class=\"col-md-2\">Cell 3</div> </div> </div> In the example above, we defined the grid consisting of three cells (denoted by gray color): the first cell spanning 2 columns, the second cell spanning 8 columns and the third cell spanning 2 columns. Then we put the nested grid rows inside of the second cell. Because the parent cell spans 8 columns, the child grid consists of 8 columns, too.","title":"Nesting Grids"},{"location":"bootstrap/#mobile-first-concept","text":"Twitter Bootstrap is designed to support different devices varying from wide displays to tablets and mobile phones. By this reason, the layout grid is adapted to different screen resolutions. Note This is also called the responsiveness , or the \"mobile first\" concept. Bootstrap is mobile-first, which means your website will be viewable and usable on any-sized screen. However, this does not free you of painstaking preparation and planning the layout. This adaptation is performed in two ways. The first way is that the column width within the grid is flexible. For example, if you increase the size of the browser window, the grid will be scaled accordingly to fill the whole space. But what will happen if your web page is too wide for the display? To see the hidden part, the site visitor will need to scroll it to the right. For mobile phones and other low-resolution devices this is not a good approach. Instead, it would be better for the grid to become \"stacked\" below some screen width. When the grid is stacked, its rows are transformed, making cells to be positioned one below another (see figure C.6 for example). To better control when the grid becomes \"stacked\", Bootstrap provides you with additional CSS classes: .col-xs-1 to col-xs-12 (the \"xs\" abbreviation means \"extra-small\" devices, or phones), .col-sm-1 to .col-sm-12 (\"sm\" stands for \"small devices\", or tablets), and .col-lg-1 to .col-lg-12 (large devices, or wide displays). These classes can be used together with the .col-md-1 -- .col-md-12 classes, that we already used (the \"md\" abbreviation means \"medium devices\", or desktops). For example, .col-md-* classes define the grid which will become \"stacked\" when the screen is below 992 pixels wide, and horizontal for wider screens. The .col-sm-* can be used to make the grid \"stacked\" below 768 pixel screen width, and horizontal above this point. The .col-xs-* class makes the grid always horizontal, not depending on the screen width. Table C.1 provides the summary of available grid classes and their breakdown page width. Class name Breakdown width .col-xs-* <768px .col-sm-* >=768px .col-md-* >=992px .col-lg-* >=1200px Table C.1. CSS classes for defining layout grid Note Bootstrap's grid system greatly simplifies the positioning of elements on a web page. However, using the grid system is not mandatory. For example, sometimes you may need a much more complex layout, and the simple grid system will be insufficient. In such a case, you can create and use your custom layout by using <table> or <div> HTML elements.","title":"\"Mobile First\" Concept"},{"location":"bootstrap/#bootstraps-interface-components","text":"In this section, we will give a summary on useful interface components provided by Twitter Bootstrap. We plan to use some of these components in our further examples, and this section should give an idea of how you can use these widgets in your own websites.","title":"Bootstrap's Interface Components"},{"location":"bootstrap/#navigation-bar","text":"Navigation bar is usually positioned on top of your website and contains the links to main pages, like Home , Download , Support , About , etc. Twitter Bootstrap provides a nice visual style for the navbar (see figure C.7 for example): As you can see from the figure above, a navbar typically has the header (brand name of your site can be placed here) and the links to main pages. To put a navbar on your page, you use the following HTML code: <nav class=\"navbar navbar-default\" role=\"navigation\"> <div class=\"navbar-header\"> <a class=\"navbar-brand\" href=\"#\">Hello World</a> </div> <ul class=\"nav navbar-nav\"> <li><a href=\"#\">Home</a></li> <li><a href=\"#\">Download</a></li> <li><a href=\"#\">Support</a></li> <li><a href=\"#\">About</a></li> </ul> </nav> In line 1 above, we used the <nav> element, which contains all the navigation bar information. The associated CSS class .navbar is defined by Bootstrap and provides the base navigation bar's appearance. The .navbar-default CSS class specifies the \"default\" theme for the navigation bar. The optional role attribute is an HTML attribute allowing to annotate the page elements with machine-extractable semantic information about the purpose of an element. In this example, the attribute tells that the <nav> element is used for navigation. In lines 2-4, we define the navbar header area, which contains the Hello World hyperlink. The brand hyperlink typically points to the main page of your site. The hyperlink has the .navbar-brand class that visually enhances the text. In lines 5-10, we specify the navigation links for the Home , Download , Support and About pages. These links are organized inside an <ul> unordered list element. The element has CSS classes .nav and .navbar-nav that place list items in line and provide the hover item state.","title":"Navigation Bar"},{"location":"bootstrap/#dropdown-menu","text":"With Bootstrap navigation bar, it is possible to use the dropdown menu as a navigation item. For example, if the Support section of your site can be subdivided into Documentation and Help pages, these can be implemented as a dropdown menu (see figure C.8). You define the dropdown menu by replacing the Support list item from the previous example in the following way: <li class=\"dropdown\"> <a href=\"#\" class=\"dropdown-toggle\" data-toggle=\"dropdown\"> Support <b class=\"caret\"></b> </a> <ul class=\"dropdown-menu\"> <li><a href=\"#\">Documentation</a></li> <li><a href=\"#\">Help</a></li> </ul> </li> In the code above, we use the <li> element with CSS class .dropdown that indicates the dropdown menu (line 1). In lines 2-4, the <a> element defines the hyperlink to show when the menu is hidden (the Support text is shown followed by the triangle caret). When the site user clicks the hyperlink, the dropdown menu (lines 5-8) appears. The <ul> unordered list element with class .dropdown-menu defines its visual appearance. The dropdown menu contains two items: the Documentation and Help hyperlinks.","title":"Dropdown Menu"},{"location":"bootstrap/#collapsible-navbar","text":"As with the grid system, the navbar component supports different types of screen resolutions. On low-resolution devices, the navbar can be collapsed, as shown in figure C.9. As you can see, in the collapsed mode, only the navbar header is displayed, and the three horizontal bars at the right denote the Toggle button. Clicking the button would expand the hidden navbar items. You define the collapsible navigation bar as shown in the example below: <nav class=\"navbar navbar-default\" role=\"navigation\"> <!-- Brand and toggle get grouped for better mobile display --> <div class=\"navbar-header\"> <button type=\"button\" class=\"navbar-toggle\" data-toggle=\"collapse\" data-target=\".navbar-ex1-collapse\"> <span class=\"sr-only\">Toggle navigation</span> <span class=\"icon-bar\"></span> <span class=\"icon-bar\"></span> <span class=\"icon-bar\"></span> </button> <a class=\"navbar-brand\" href=\"#\">Hello World</a> </div> <!-- Collect the nav links, forms, and other content for toggling --> <div class=\"collapse navbar-collapse navbar-ex1-collapse\"> <ul class=\"nav navbar-nav\"> <li><a href=\"#\">Home</a></li> <li><a href=\"#\">Download</a></li> <li class=\"dropdown\"> <a href=\"#\" class=\"dropdown-toggle\" data-toggle=\"dropdown\"> Support <b class=\"caret\"></b> </a> <ul class=\"dropdown-menu\"> <li><a href=\"#\">Documentation</a></li> <li><a href=\"#\">Help</a></li> </ul> </li> <li><a href=\"#\">About</a></li> </ul> </div><!-- /.navbar-collapse --> </nav> Above in lines 3-12, we define the navbar header which will be displayed independently on screen resolution. The header contains the Toggle button with three horizontal bars and description text \"Toggle navigation\". The collapsible part of the menu can be seen in lines 15-30. In this area, we put our navigation links and the dropdown menu items.","title":"Collapsible Navbar"},{"location":"bootstrap/#inverse-navbar-style","text":"The navigation bar can be displayed using two standard \"themes\": the default theme (we saw it above), and the inverse theme. The inverse theme makes the navbar elements be displayed in dark colors (figure C.10). You probably saw such an inverse navbar in the Laminas Skeleton Application demo. The inverse theme is defined by simply replacing the .navbar-default class of the <nav> element by the .navbar-inverse class: <nav class=\"navbar navbar-inverse\" role=\"navigation\"> ... </nav>","title":"Inverse Navbar Style"},{"location":"bootstrap/#breadcrumbs","text":"Breadcrumbs is a useful interface component which can be used together with the navbar to give the site visitor an idea of his current location within the site (figure C.11). In the figure above, we have an example breadcrumbs for the documentation system of our site. Because the documentation pages can have deep nesting level, the breadcrumbs tell the user which page he is visiting right now so the user will not get lost and will be able to return to the page he visited previously, and to the upper-level pages. To define the breadcrumbs, you use the ordered list <ol> element with the .breadcrumb CSS class (see an example below): <ol class=\"breadcrumb\"> <li><a href=\"#\">Home</a></li> <li><a href=\"#\">Support</a></li> <li class=\"active\">Documentation</li> </ol>","title":"Breadcrumbs"},{"location":"bootstrap/#pagination","text":"The pagination component is useful when you have a long list of items for display. Such a long list, if displayed on a single page, would require the user to scroll the page down several times to see the bottom of the list. To improve user experience, you would break the output into pages, and use the pagination component for navigation between the pages (figure C.12): To define the pagination like in figure above, use the following HTML code: <ul class=\"pagination\"> <li><a href=\"#\">&laquo; Newest</a></li> <li><a href=\"#\">&lt; Newer</a></li> <li><a href=\"#\">1</a></li> <li><a href=\"#\">2</a></li> <li><a href=\"#\">3</a></li> <li><a href=\"#\">4</a></li> <li><a href=\"#\">5</a></li> <li><a href=\"#\">Older &gt;</a></li> <li><a href=\"#\">Oldest &raquo</a></li> </ul>","title":"Pagination"},{"location":"bootstrap/#buttons-glyphicons","text":"Twitter Bootstrap provides a nice visual style for button elements (figure C.13). To create the buttons like in the figure above, use the following HTML code: <p> <button type=\"button\" class=\"btn btn-primary\">Save</button> <button type=\"button\" class=\"btn btn-default\">Cancel</button> </p> In the code above, we use the .btn CSS class to assign the button its visual style. Additionally, we use the .btn-primary class for the Save button (which is typically the primary button on a form), or the btn-default class for a usual non-primary button Cancel . To better express the meaning of a button, Bootstrap provides you with several additional button classes: .btn-success (for buttons applying some change on the page), .btn-info (for informational buttons), .btn-warning (for buttons that may have an undesired effect), and .btn-danger (for buttons that may lead to irreversible consequences). For an example of using these button styles, look at the code below: <p> <button type=\"button\" class=\"btn btn-default\">Default</button> <button type=\"button\" class=\"btn btn-primary\">Primary</button> <button type=\"button\" class=\"btn btn-success\">Success</button> <button type=\"button\" class=\"btn btn-info\">Info</button> <button type=\"button\" class=\"btn btn-warning\">Warning</button> <button type=\"button\" class=\"btn btn-danger\">Danger</button> </p> Figure C.14 shows the resulting button appearance: Bootstrap includes 180 icons (called Glyphicons) that you can use together with your buttons, dropdown menus, navigation links, etc. To add an icon on a button, you can use the code like the one below: <p> <button type=\"button\" class=\"btn btn-default\"> <span class=\"glyphicon glyphicon-plus\"></span> Create </button> <button type=\"button\" class=\"btn btn-default\"> <span class=\"glyphicon glyphicon-pencil\"></span> Edit </button> <button type=\"button\" class=\"btn btn-default\"> <span class=\"glyphicon glyphicon-remove\"></span> Delete </button> </p> In the code above, we defined a simple toolbar containing three buttons: Create , Edit and Delete . We placed an icon on each button with the help of <span> element. The <span> element should have two classes: the .glyphicon class is common for all icons; the second class represents the icon name. In the example above, we used .glyphicon-plus class for the Create button, the .glyphicon-pencil for Edit button, and .glyphicon-remove for Delete button. The result of our work is presented in figure C.15. You can vary button sizes by specifying the .btn-lg class for large buttons, btn-sm for small buttons, or .btn-xs class for extra-small buttons. For example, in figure C.16, a large Download button is presented. To define such a button, you can use the following HTML code: <button type=\"button\" class=\"btn btn-success btn-lg\"> <span class=\"glyphicon glyphicon-download\"></span> Download </button>","title":"Buttons &amp; Glyphicons"},{"location":"bootstrap/#customizing-bootstrap","text":"To finish the introduction to Twitter Bootstrap, we will describe about how to modify some aspects of Bootstrap framework. You can customize the Bootstrap look and feel using the Customize page of the Bootstrap website (figure C.17). On the Customize page you can choose which Bootstrap source files to include into the \"concatenated\" resulting file bootstrap.css . If you don't need some functionality, you can exclude it from the resulting file, thus reducing the network traffic and page load time. You can also remove some unused JavaScript code components from the resulting bootstrap.js file. Additionally, you can choose different CSS parameters like background color, base text color and font family, and so on. There are more than a hundred customizable parameters available. Note CSS customization is possible, because Bootstrap source files are stored in LESS 3 format, which allows to define variable parameters (like @bodyBackground or @textColor ). Once the parameters are defined, the LESS files are compiled into usual CSS files, minified and made available for downloading. If you would like to read more about LESS then go to the official website . When you have finished with tuning parameters, you can scroll the Customize page down and press the Compile and Download button. As a result, the bootstrap.zip archive will be downloaded, which contains all the customized Bootstrap files (both usual and minified CSS and JS files and glyphicons fonts).","title":"Customizing Bootstrap"},{"location":"bootstrap/#summary","text":"Twitter Bootstrap is a CSS framework developed to make designing your web pages easier. It provides the default nice-looking style for typography, tables, forms, buttons, images and so on, so you can create a professionally looking page in a minute. The grid system provided by the Bootstrap allows to arrange elements on your web page in a grid with rows and columns. The grid adapts to different screen resolutions, making your page equally well-readable on mobile phones, tablets, desktops and wide screens. Twitter Bootstrap also provides useful web interface components like dropdown menus, navigation bars, breadcrumbs, etc. These components are made interactive by the JavaScript extensions bundled with the framework. Bootstrap is shipped with Laminas Skeleton Application, so you can start using it out of the box or, alternatively, you can download the newest version of Bootstrap from the project's page and customize it as you wish. After the concatenation and minification, the CSS code is difficult to read and debug. A MAP file (source map) allows to restore the minified file back to its usual state. \u21a9 You are not required to put exactly 12 columns in a row, there may be fewer columns. If you have fewer columns, the space to the right of the last column will be empty. \u21a9 LESS is a dynamic stylesheet language extending standard CSS with features like variables, mixins (embedding all the properties of a CSS class into another CSS class), code block nesting, arithmetic operations, and functions. \u21a9","title":"Summary"},{"location":"devenv/","text":"Appendix A. Configuring Web Development Environment Here we will provide instructions on how to prepare your environment for developing laminas-based applications. If you already have the configured environment, you can skip this. Configuring the development environment is the first thing you have to do when beginning with creating your first web-site. This includes installing the web server, the PHP engine with required extensions and a database. For the purpose of running the code examples created in this book, we will use Apache HTTP Server (v.2.4 or later), PHP engine (v.5.6 or later) with XDebug extension and MySQL database (v.5.6 or later). We also provide instructions for installing NetBeans IDE, which is a convenient integrated development environment for PHP development. It allows for an easier navigation, editing and debugging of your PHP application. The NetBeans IDE is written in Java and can be installed in Windows, Linux and other platforms supporting a compatible Java machine. Note We also provide instructions for beginners on how to install a Laminas website to Amazon EC2 cloud in Appendix E. Installing a Laminas Web Application to Amazon EC2 . Installing Apache, PHP and MySQL in Linux Note This section is highly outdated. Most distributions by now only have 64-bit versions. Furthermore PHP 8.3 is out. (As written in January 2024.) But it gives you a general overview over the existing distributions and their versions. Furthermore it makes you aware of the fact that you need to check the PHP versions when looking at a distribution version. In general, it is recommended that you use a popular and well supported Linux distribution, either 32-bit (x86) or 64-bit (amd64). A 64-bit version can give a great performance, but deliver more problems (like driver compatibility issues). 32-bit systems are with us for a longer time and have less problems, which is important for novice users. There are two big families of Linux distributions: Debian and Red Hat . Debian is a free and open-source project, which has several branches, the most popular of which is Linux Ubuntu . Red Hat is a commercially distributed operating system, which has \"free\" branches named Linux CentOS and Linux Fedora . Red Hat Linux is being developed by Red Hat Inc. Red Hat Linux (or its \"free\" modification CentOS) is known as a \"corporate\" operating system. Its main advantage is \"stability\" (low rate of system crashes). However, this stability is achieved through carefully choosing the software which is installed out of the box. When you install such an operating system for the purpose of PHP development, this \"stability\" may become a problem, because you have access to some old (but \"stable\") version of PHP and other software. They do not include a new \"bleeding-edge\" software into their repository, so if you want to install one, you will need to download it from somewhere, read the manual, and possibly (if you are not lucky) compile it yourself. There is another Linux distribution, which, in the author's opinion, suits better for PHP development. Its name is Linux Ubuntu. Ubuntu is being developed by Canonical Ltd. Linux Ubuntu has two editions: Desktop edition and Server edition. Ubuntu Desktop is a distribution containing graphics environment, while Ubuntu Server edition has console terminal only. For the purpose of PHP development, it is recommended to use the Desktop edition. Canonical typically releases a new version of Linux Ubuntu each 6 months, in April and October, and a \"long term support\" (LTS) version each 2 years. For example, at the moment of writing this text, the latest version is Ubuntu 16.04 Xenial Xerus LTS (released in April 2016). Non-LTS releases have short support period (about 9 months), but they have the newest versions of the PHP software out of the box. On the other hand, LTS releases have longer support period (5 years), but a little outdated PHP software out of the box. For PHP development, the author would recommend to use the latest version of Ubuntu Desktop, because it has the newest version of PHP and other software available from repository. The disadvantage of using such a version is that you will need to upgrade it to the next release every 9 months (as support period expires). If you don't like the perspective of upgrading every 9 months, choose the latest LTS release. For your information, table A.1 lists PHP versions available for installation from repository in different Linux distributions: Linux Distribution PHP Version Linux Ubuntu 16.04 Xenial Xerus LTS 7.0 Linux Ubuntu 15.10 Wily Werewolf 5.6 Linux Ubuntu 15.04 Vivid Vervet 5.6 Linux Ubuntu 14.10 Utopic Unicorn 5.5 Linux Ubuntu 14.04 Trusty Tahr 5.5 Table A.1. Available PHP versions in different Linux distributions As you can see from the table above, for the purpose of Laminas development, you'll have to install Ubuntu 15.04 or later. When choosing between 32-bit and 64-bit versions of the system, remember that the 64 bit version of Linux Ubuntu will have more compatibility issues than its 32-bit counterpart. The support of drivers can also cause problems on the 64-bit platform. New to Ubuntu Linux? If you are new to Linux Ubuntu, watch these excellent video tutorials by LearnLinux.tv YouTube user: Tutorial - Installing Ubuntu 16.04 LTS (this one shows how to install Ubuntu Desktop Edition) and Tutorial - Installing Ubuntu Server 16.04 (this one shows how to install Ubuntu Server Edition which has console terminal only). Installing Apache and PHP In modern Linux distributions, you can easily download and install software from a centralized repository . The repository contains so called packages . A package has a name (for example, php , apache2 ), and a version. In general you can install a package with a single command. However the command (and a package name) may differ based on linux distribution you use. For example, to download and install packages in Debian-based Linux distributions (e.g. Ubuntu Linux), you use Advanced Packaging Tool (APT). In Red Hat provided distributions (e.g. Fedora or CentOS), you use YUM (RPM package manager). Below, detailed installation instructions for these operating systems are provided. Debian or Linux Ubuntu First of all, it is recommended that you update your system by installing the latest available updates. To do this, from a command shell, run the following commands: sudo apt-get update sudo apt-get upgrade The commands above run the APT tool and install the newest system packages updates. The sudo command (stands for \"Super User DO\") allows to run another command, apt-get in our case, as system administrator (root). You typically use sudo when you need to elevate your privileges to install a package or edit some configuration file. Note The sudo command may request you for password. When prompted, enter the password under which you log into the system and press Enter. Next, from a command shell, run the following commands: sudo apt-get install apache2 sudo apt-get install php sudo apt-get install libapache2-mod-php The commands above download from repository and install the latest available versions of Apache HTTP Server, PHP engine and PHP extension module for Apache. The commands above may ask you for confirmation when installing a package. It is recommended to answer Yes (press \"y\" and then press Enter). Fedora, CentOS or Red Hat Linux First of all, it is recommended that you update your system by installing the latest available updates. To do this, from a command shell, run the following command: sudo yum update The command above runs the YUM tool and installs the newest system package updates. Next, from a command shell, run the following commands: sudo yum install httpd sudo yum install php The commands above download from repository and install the latest available versions of Apache HTTP Server and PHP engine. Next, run the following commands to add Apache HTTP Server to system autorun and start it: sudo chkconfig --level 235 httpd on sudo service httpd start Checking Web Server Installation After you set up your Apache HTTP web server, check that it is installed correctly and that the server sees the PHP engine. To do that, create phpinfo.php file in Apache document root directory. The document root is a directory where you can (by default) store the web files. Typically, the Apache document root directory is /var/www/html . Recommendation from the author To be able to navigate the directory structure and edit files, it is recommended to install Midnight Commander (convenient file manager and text editor). To install Midnight Commander in Debian or Linux Ubuntu, type the following: sudo apt-get install mc The following command installs Midnight Commander in Fedora, CentOS or Red Hat Linux: sudo yum install mc After installation, you can launch the file manager with the mc command, and edit a text file with the command like this: mcedit /path/to/file If you need administrative permissions to edit the file, prepend the sudo command to the command above. In the phpinfo.php file, enter the PHP method phpinfo() as follows: <?php phpinfo(); ?> Open the file in your web browser. The standard PHP information page should display (see figure A.1 for example). Editing PHP Configuration To configure PHP for your development environment, you need to edit the PHP config file ( php.ini ) and adjust some parameters. Where to find the config file? In different distributions of Linux, PHP configuration file can be located in different paths. To edit the PHP config file in Debian or Linux Ubuntu, type the following: sudo mcedit /etc/php/7.0/apache2/php.ini Type the following to edit php.ini in Fedora, CentOS or Red Hat Linux: sudo mcedit /etc/php.ini For the development environment, it is recommended to set the following error handling and logging parameters as below. This will force PHP to display errors on your PHP pages to screen. error_reporting = E_ALL display_errors = On display_startup_errors = On Note To conveniently search within the file, press F7 in Midnight Commander's editor window and enter the search string (the name of the parameter to search for). Set your time zone settings (replace <your_time_zone> placeholder with your time zone, for example, UTC or America/New_York ): date.timezone = <your_time_zone> Set max_execution_time , upload_max_filesize and post_max_size parameters to allow large file uploads through POST. For example, setting upload_max_filesize with 128M allows to upload files up to 128 megabytes in size. Setting max_execution_time with zero allows to execute the PHP script indefinitely long. max_execution_time = 0 post_max_size = 128M upload_max_filesize = 128M When ready, save your changes by pressing the F2 key and then press F10 to exit from Midnight Commander's editor. Restarting Apache Web Server After editing configuration files, you usually have to restart Apache HTTP Server to apply your changes. You do this with the following command (in Debian or Linux Ubuntu): sudo service apache2 restart or the following (in Fedora, CentOS or Red Hat): sudo service httpd restart Enabling Apache's mod_rewrite module Laminas Framework requires that you have Apache's mod_rewrite module enabled. The mod_rewrite module is used to rewrite requested URLs based on some rules, redirecting site users to another URL. In Debian or Ubuntu Linux To enable Apache mod_rewrite module, type the following command: a2enmod rewrite Finally, restart Apache web server to apply your changes. In Fedora, CentOS or Red Hat Linux In these Linux distributions, mod_rewrite is enabled by default, so you don't need to do anything. Creating Apache Virtual Host Laminas Framework requires that you create a virtual host for your web site. A virtual host term means that you can run several web-sites on the same machine. The virtual sites are differentiated by domain name (like site.mydomain.com and site2.mydomain.com ). Each virtual host has its own document root directory, allowing you to place your web files anywhere on the system (not only to /var/www/html directory). Note Please note that right now you don't need to create a virtual host, we'll do that in chapter Laminas Skeleton Application . Now you just need to have an idea of how virtual hosts are created in different Linux distributions. In Debian or Ubuntu Linux You have an example default virtual host at /etc/apache2/sites-available/000-default.conf (see below). <VirtualHost *:80> # The ServerName directive sets the request scheme, hostname and port that # the server uses to identify itself. This is used when creating # redirection URLs. In the context of virtual hosts, the ServerName # specifies what hostname must appear in the request's Host: header to # match this virtual host. For the default virtual host (this file) this # value is not decisive as it is used as a last resort host regardless. # However, you must set it for any further virtual host explicitly. #ServerName www.example.com ServerAdmin webmaster@localhost DocumentRoot /var/www/html # Available loglevels: trace8, ..., trace1, debug, info, notice, warn, # error, crit, alert, emerg. # It is also possible to configure the loglevel for particular # modules, e.g. #LogLevel info ssl:warn ErrorLog ${APACHE_LOG_DIR}/error.log CustomLog ${APACHE_LOG_DIR}/access.log combined # For most configuration files from conf-available/, which are # enabled or disabled at a global level, it is possible to # include a line for only one particular virtual host. For example the # following line enables the CGI configuration for this host only # after it has been globally disabled with \"a2disconf\". #Include conf-available/serve-cgi-bin.conf </VirtualHost> # vim: syntax=apache ts=4 sw=4 sts=4 sr noet All you have to do is just to edit this virtual host file when needed and restart Apache to apply changes. You can also copy this file and create another virtual host, when you need several web sites to operate on the same machine. For example, to create another virtual host file named 001-vhost2.conf , type the following from your command shell: cd /etc/apache2/sites-available sudo cp 000-default.conf 001-vhost2.conf sudo a2ensite 001-vhost2.conf The virtual host's name starts with a prefix (like 000 , 010 , etc.), which defines the priority. Apache web server tries to direct an HTTP request to each virtual host in turn (first to 000-default , then to 001-vhost2 ), and if a certain virtual host cannot serve the request, the next one is tried and so on. In Fedora, CentOS or Red Hat Linux There is an example virtual host in /etc/httpd/conf/httpd.conf file. Scroll down to the very bottom of the document to the section called Virtual Hosts. You can edit this section as you need and restart Apache to apply your changes. Installing XDebug PHP extension To be able to debug your web sites, it is recommended that you install the XDebug extension. The XDebug extension allows to look inside a running program, see the variables passed from the client, walk the call stack and profile your PHP code. XDebug also provides the code coverage analysis capabilities, which are useful when you write unit tests for your code. In Debian or Ubuntu Linux To install XDebug, simply type the following command: sudo apt-get install php-xdebug Then edit the /etc/php/7.0/mods-available/xdebug.ini file by typing the following: sudo mcedit /etc/php/7.0/mods-available/xdebug.ini Add the following lines to the end of file (replace the remote IP address placeholder with the IP address you plan to debug your website from): xdebug.remote_enable=1 xdebug.remote_handler=dbgp xdebug.remote_mode=req xdebug.remote_host=<remote_ip_address> Finally, restart the Apache server to apply your changes. Then open the phpinfo.php in your browser and look for XDebug section (it should look like in the figure A.2): In Fedora, CentOS or Red Hat Linux In these Linux distributions, installing XDebug is a little more difficult. Install XDebug package with the following command: yum install php-pecl-xdebug After install, it is required to create the file xdebug.ini in /etc/php.d directory: mcedit /etc/php.d/xdebug.ini Add the following lines to the end of file (replace the remote IP address placeholder with the IP address you plan to debug your website from): [xdebug] Laminas_extension = /usr/lib/php/modules/xdebug.so xdebug.remote_enable=1 xdebug.remote_handler=dbgp xdebug.remote_mode=req xdebug.remote_host=<remote_ip_address> xdebug.remote_port=9000 Restart the Apache web server to apply your changes. Then check the phpinfo.php in your browser. If installation was successfull, you'll see some XDebug-related information. Installing MySQL Database Server MySQL is a free relational database management system being developed and supported by Oracle. MySQL is the most popular database system used with PHP. In this book, we will be using MySQL. Debian or Linux Ubuntu In order to install MySQL database, type the following: sudo apt-get install mysql-server sudo apt-get install mysql-client sudo apt-get install php-mysql The commands above install MySQL server component, MySQL client component and MySQL extension module for PHP, respectively. Fedora, CentOS or Red Hat Linux In order to install MySQL database, type the following: sudo yum install mysql-server sudo yum install mysql sudo yum install php-mysql The commands above install MySQL server component, MySQL client component and MySQL extension module for PHP, respectively. Run the following commands to add MySQL server to autostart and start the server: sudo chkconfig --level 235 mysqld on sudo service mysqld start Configuring the MySQL Database Server During the installation of the MySQL server, a root user is created. By default the root user has no password, so you have to set it manually. You will need that password for creating other MySQL database users. To connect to the MySQL server enter the following command: mysql -u root -p The MySQL command prompt will appear. In the command prompt enter the following command and press Enter (in the command below, replace the <your_password> placeholder with some password): SET PASSWORD FOR 'root'@'localhost' = '<insert_your_password>'; If the command is executed successfully, the following message is displayed: Query OK, 0 rows affected (0.00 sec) Now we need to create a new database that will store the tables. To do this, type the following: CREATE DATABASE test_db; The command above creates empty schema that we will populate later. Next, we want to create another database user named test_user that will be used by the laminas-based web site for connecting to the database. To create the user, type the following (in the command below, replace the <insert_your_password> placeholder with some password): GRANT ALL PRIVILEGES ON test_db.* TO 'test_user'@'localhost' IDENTIFIED BY '<insert_your_password>'; The command above creates the user named 'test_user' and grants the user all privileges on the 'test_db' database. Finally, type quit to exit the MySQL prompt. Installing Apache, PHP and MySQL in Windows We strongly recommend to use Linux for the purposes of PHP development. Most server systems have Linux installed. If you are using Windows for your everyday tasks, you still can install Linux on a virtual machine (for example, on VirtualBox ) and run Apache, PHP and MySQL on that virtual machine. If at the same time you would like to use NetBeans in Windows, you can do that - just configure a shared directory (for example, set up Samba server on your virtual machine). In case you strongly wish to install Apache, PHP and MySQL in Windows (which we do not recommend), here are some instructions (but note that installing those in Windows may be more difficult than in Linux). There are a couple of most popular Apache + MySQL + PHP distributions: WampServer XAMPP Choose one and install it on your Windows server machine. Checking Web Server Installation After you set up your web server, check that it is installed correctly and that your Apache server recognizes the PHP engine. To check that Apache and PHP are installed correctly, create phpinfo.php file in Apache document root directory. In the phpinfo.php file, enter the PHP method phpinfo() as follows: <?php phpinfo(); ?> Open the file in your browser. The standard PHP information page should display (figure A.3). Enabling Apache's mod_rewrite module Laminas Framework requires that you have Apache's mod_rewrite module enabled. To enable mod_rewrite , open your the Apache config file (typically httpd.conf ), then find the following line: #LoadModule rewrite_module modules/mod_rewrite.so and remove the hash (#) sign from the beginning to uncomment the line. It should now look like this: LoadModule rewrite_module modules/mod_rewrite.so Finally, restart Apache web server to apply your changes. Creating Apache Virtual Host A virtual host term means that you can run several web-sites on the same machine. The virtual sites are differentiated by domain name (like site.mydomain.com and site2.mydomain.com ) Please consult to your WAMP or XAMPP documentation for information on how to create virtual hosts. Note Right now, you don't need to edit virtual host file, we'll do that in chapter Laminas Skeleton Application when installing the Hello World application. Now you just need to understand how to create virtual hosts. Installing XDebug PHP extension To be able to debug your web sites in NetBeans IDE, it is recommended that you install the XDebug extension of your PHP engine. Download an appropriate DLL from this site . Then edit your php.ini file and add the following line: Laminas_extension=\"C:/path/to/your/xdebug.dll\" Add the following lines to the end of file (replace the remote IP address placeholder with the IP address you plan to debug your website from): xdebug.remote_enable=on xdebug.remote_handler=dbgp xdebug.remote_host=<remote_ip_address> Finally, restart the Apache server to apply your changes. Then open the phpinfo.php in your browser and look for XDebug section (it should look like in the figure A.4): Configuring the MySQL Database Server Now we want to create a database schema and a database user. We will use MySQL Command Line Client. Consult your WAMP or XAMPP documentation on how to do that. The MySQL Command Line Client console looks like follows (see the figure A.5): Now we need to create a new database that will store the tables. To do this, type the following in the MySQL client window: CREATE DATABASE test_db; The command above creates an empty database that we will populate later. If the command is executed successfully, the following message is displayed: Query OK, 1 rows affected (0.05 sec) Next, we want to create another database user named test_user that will be used by the web site for connecting to the database. To create the user, type the following (in the command below, replace the <your_password> placeholder with some password): GRANT ALL PRIVILEGES ON test_db.* TO 'test_user'@'localhost' IDENTIFIED BY '<your_password>'; The command above creates the user named test_user and grants the user all privileges on the test_db database schema. Installing NetBeans IDE in Linux You can install NetBeans IDE using two methods: either from repository, as you did with Apache, PHP and MySQL, or by downloading the installer from NetBeans web site and running it. The first method is simpler, so we recommend to use it. To install NetBeans IDE in Debian or Linux Ubuntu, type the following command from your command shell: sudo apt-get install netbeans or the following command to install it in Fedora, CentOS or Red Hat Linux: sudo yum install netbeans The command above downloads from repository and installs NetBeans and all its dependent packages. After the installation is complete, you can run netbeans by typing: netbeans The NetBeans IDE window is shown in figure A.6. To be able to create PHP projects, you need to activate PHP plugin for NetBeans. To do that, open menu Tools->Plugins , the Plugins dialog appears. In the appeared dialog, click Settings tab and set check marks to all Update Centers (see the figure A.7). Then click the Available Plugins tab. On that tab, click the Check for Newest button to build the list of all available plugins. Then in the list, set check mark to PHP plugin and click the Install button (see the figure A.8). When the PHP plugin installation is complete, restart the IDE. Then you should be able to create new PHP projects from menu New->New Project... . Note It is also recommended to update NetBeans IDE to the latest version by opening menu Help->Check for updates . Installing NetBeans IDE in Windows Installing NetBeans in Windows is strightforward. You just need to download the installer from NetBeans site and run it. You may encounter several bundles of NetBeans available for download, and you should download the bundle that is intended for PHP development (see the figure A.9 for example). Summary In this appendix, we've provided instructions on how to install and configure Apache HTTP Server, PHP engine and MySQL database in both Linux and Windows platforms. We've also provided instructions for installing NetBeans integrated development environment (IDE), which is a convenient integrated development environment for PHP development. It allows you to navigate, edit and debug your laminas-based application in an effective manner.","title":"Appendix A. Configuring Web Development Environment"},{"location":"devenv/#appendix-a-configuring-web-development-environment","text":"Here we will provide instructions on how to prepare your environment for developing laminas-based applications. If you already have the configured environment, you can skip this. Configuring the development environment is the first thing you have to do when beginning with creating your first web-site. This includes installing the web server, the PHP engine with required extensions and a database. For the purpose of running the code examples created in this book, we will use Apache HTTP Server (v.2.4 or later), PHP engine (v.5.6 or later) with XDebug extension and MySQL database (v.5.6 or later). We also provide instructions for installing NetBeans IDE, which is a convenient integrated development environment for PHP development. It allows for an easier navigation, editing and debugging of your PHP application. The NetBeans IDE is written in Java and can be installed in Windows, Linux and other platforms supporting a compatible Java machine. Note We also provide instructions for beginners on how to install a Laminas website to Amazon EC2 cloud in Appendix E. Installing a Laminas Web Application to Amazon EC2 .","title":"Appendix A. Configuring Web Development Environment"},{"location":"devenv/#installing-apache-php-and-mysql-in-linux","text":"Note This section is highly outdated. Most distributions by now only have 64-bit versions. Furthermore PHP 8.3 is out. (As written in January 2024.) But it gives you a general overview over the existing distributions and their versions. Furthermore it makes you aware of the fact that you need to check the PHP versions when looking at a distribution version. In general, it is recommended that you use a popular and well supported Linux distribution, either 32-bit (x86) or 64-bit (amd64). A 64-bit version can give a great performance, but deliver more problems (like driver compatibility issues). 32-bit systems are with us for a longer time and have less problems, which is important for novice users. There are two big families of Linux distributions: Debian and Red Hat . Debian is a free and open-source project, which has several branches, the most popular of which is Linux Ubuntu . Red Hat is a commercially distributed operating system, which has \"free\" branches named Linux CentOS and Linux Fedora . Red Hat Linux is being developed by Red Hat Inc. Red Hat Linux (or its \"free\" modification CentOS) is known as a \"corporate\" operating system. Its main advantage is \"stability\" (low rate of system crashes). However, this stability is achieved through carefully choosing the software which is installed out of the box. When you install such an operating system for the purpose of PHP development, this \"stability\" may become a problem, because you have access to some old (but \"stable\") version of PHP and other software. They do not include a new \"bleeding-edge\" software into their repository, so if you want to install one, you will need to download it from somewhere, read the manual, and possibly (if you are not lucky) compile it yourself. There is another Linux distribution, which, in the author's opinion, suits better for PHP development. Its name is Linux Ubuntu. Ubuntu is being developed by Canonical Ltd. Linux Ubuntu has two editions: Desktop edition and Server edition. Ubuntu Desktop is a distribution containing graphics environment, while Ubuntu Server edition has console terminal only. For the purpose of PHP development, it is recommended to use the Desktop edition. Canonical typically releases a new version of Linux Ubuntu each 6 months, in April and October, and a \"long term support\" (LTS) version each 2 years. For example, at the moment of writing this text, the latest version is Ubuntu 16.04 Xenial Xerus LTS (released in April 2016). Non-LTS releases have short support period (about 9 months), but they have the newest versions of the PHP software out of the box. On the other hand, LTS releases have longer support period (5 years), but a little outdated PHP software out of the box. For PHP development, the author would recommend to use the latest version of Ubuntu Desktop, because it has the newest version of PHP and other software available from repository. The disadvantage of using such a version is that you will need to upgrade it to the next release every 9 months (as support period expires). If you don't like the perspective of upgrading every 9 months, choose the latest LTS release. For your information, table A.1 lists PHP versions available for installation from repository in different Linux distributions: Linux Distribution PHP Version Linux Ubuntu 16.04 Xenial Xerus LTS 7.0 Linux Ubuntu 15.10 Wily Werewolf 5.6 Linux Ubuntu 15.04 Vivid Vervet 5.6 Linux Ubuntu 14.10 Utopic Unicorn 5.5 Linux Ubuntu 14.04 Trusty Tahr 5.5 Table A.1. Available PHP versions in different Linux distributions As you can see from the table above, for the purpose of Laminas development, you'll have to install Ubuntu 15.04 or later. When choosing between 32-bit and 64-bit versions of the system, remember that the 64 bit version of Linux Ubuntu will have more compatibility issues than its 32-bit counterpart. The support of drivers can also cause problems on the 64-bit platform. New to Ubuntu Linux? If you are new to Linux Ubuntu, watch these excellent video tutorials by LearnLinux.tv YouTube user: Tutorial - Installing Ubuntu 16.04 LTS (this one shows how to install Ubuntu Desktop Edition) and Tutorial - Installing Ubuntu Server 16.04 (this one shows how to install Ubuntu Server Edition which has console terminal only).","title":"Installing Apache, PHP and MySQL in Linux"},{"location":"devenv/#installing-apache-and-php","text":"In modern Linux distributions, you can easily download and install software from a centralized repository . The repository contains so called packages . A package has a name (for example, php , apache2 ), and a version. In general you can install a package with a single command. However the command (and a package name) may differ based on linux distribution you use. For example, to download and install packages in Debian-based Linux distributions (e.g. Ubuntu Linux), you use Advanced Packaging Tool (APT). In Red Hat provided distributions (e.g. Fedora or CentOS), you use YUM (RPM package manager). Below, detailed installation instructions for these operating systems are provided. Debian or Linux Ubuntu First of all, it is recommended that you update your system by installing the latest available updates. To do this, from a command shell, run the following commands: sudo apt-get update sudo apt-get upgrade The commands above run the APT tool and install the newest system packages updates. The sudo command (stands for \"Super User DO\") allows to run another command, apt-get in our case, as system administrator (root). You typically use sudo when you need to elevate your privileges to install a package or edit some configuration file. Note The sudo command may request you for password. When prompted, enter the password under which you log into the system and press Enter. Next, from a command shell, run the following commands: sudo apt-get install apache2 sudo apt-get install php sudo apt-get install libapache2-mod-php The commands above download from repository and install the latest available versions of Apache HTTP Server, PHP engine and PHP extension module for Apache. The commands above may ask you for confirmation when installing a package. It is recommended to answer Yes (press \"y\" and then press Enter). Fedora, CentOS or Red Hat Linux First of all, it is recommended that you update your system by installing the latest available updates. To do this, from a command shell, run the following command: sudo yum update The command above runs the YUM tool and installs the newest system package updates. Next, from a command shell, run the following commands: sudo yum install httpd sudo yum install php The commands above download from repository and install the latest available versions of Apache HTTP Server and PHP engine. Next, run the following commands to add Apache HTTP Server to system autorun and start it: sudo chkconfig --level 235 httpd on sudo service httpd start","title":"Installing Apache and PHP"},{"location":"devenv/#checking-web-server-installation","text":"After you set up your Apache HTTP web server, check that it is installed correctly and that the server sees the PHP engine. To do that, create phpinfo.php file in Apache document root directory. The document root is a directory where you can (by default) store the web files. Typically, the Apache document root directory is /var/www/html . Recommendation from the author To be able to navigate the directory structure and edit files, it is recommended to install Midnight Commander (convenient file manager and text editor). To install Midnight Commander in Debian or Linux Ubuntu, type the following: sudo apt-get install mc The following command installs Midnight Commander in Fedora, CentOS or Red Hat Linux: sudo yum install mc After installation, you can launch the file manager with the mc command, and edit a text file with the command like this: mcedit /path/to/file If you need administrative permissions to edit the file, prepend the sudo command to the command above. In the phpinfo.php file, enter the PHP method phpinfo() as follows: <?php phpinfo(); ?> Open the file in your web browser. The standard PHP information page should display (see figure A.1 for example).","title":"Checking Web Server Installation"},{"location":"devenv/#editing-php-configuration","text":"To configure PHP for your development environment, you need to edit the PHP config file ( php.ini ) and adjust some parameters. Where to find the config file? In different distributions of Linux, PHP configuration file can be located in different paths. To edit the PHP config file in Debian or Linux Ubuntu, type the following: sudo mcedit /etc/php/7.0/apache2/php.ini Type the following to edit php.ini in Fedora, CentOS or Red Hat Linux: sudo mcedit /etc/php.ini For the development environment, it is recommended to set the following error handling and logging parameters as below. This will force PHP to display errors on your PHP pages to screen. error_reporting = E_ALL display_errors = On display_startup_errors = On Note To conveniently search within the file, press F7 in Midnight Commander's editor window and enter the search string (the name of the parameter to search for). Set your time zone settings (replace <your_time_zone> placeholder with your time zone, for example, UTC or America/New_York ): date.timezone = <your_time_zone> Set max_execution_time , upload_max_filesize and post_max_size parameters to allow large file uploads through POST. For example, setting upload_max_filesize with 128M allows to upload files up to 128 megabytes in size. Setting max_execution_time with zero allows to execute the PHP script indefinitely long. max_execution_time = 0 post_max_size = 128M upload_max_filesize = 128M When ready, save your changes by pressing the F2 key and then press F10 to exit from Midnight Commander's editor.","title":"Editing PHP Configuration"},{"location":"devenv/#restarting-apache-web-server","text":"After editing configuration files, you usually have to restart Apache HTTP Server to apply your changes. You do this with the following command (in Debian or Linux Ubuntu): sudo service apache2 restart or the following (in Fedora, CentOS or Red Hat): sudo service httpd restart","title":"Restarting Apache Web Server"},{"location":"devenv/#enabling-apaches-mod_rewrite-module","text":"Laminas Framework requires that you have Apache's mod_rewrite module enabled. The mod_rewrite module is used to rewrite requested URLs based on some rules, redirecting site users to another URL. In Debian or Ubuntu Linux To enable Apache mod_rewrite module, type the following command: a2enmod rewrite Finally, restart Apache web server to apply your changes. In Fedora, CentOS or Red Hat Linux In these Linux distributions, mod_rewrite is enabled by default, so you don't need to do anything.","title":"Enabling Apache's mod_rewrite module"},{"location":"devenv/#creating-apache-virtual-host","text":"Laminas Framework requires that you create a virtual host for your web site. A virtual host term means that you can run several web-sites on the same machine. The virtual sites are differentiated by domain name (like site.mydomain.com and site2.mydomain.com ). Each virtual host has its own document root directory, allowing you to place your web files anywhere on the system (not only to /var/www/html directory). Note Please note that right now you don't need to create a virtual host, we'll do that in chapter Laminas Skeleton Application . Now you just need to have an idea of how virtual hosts are created in different Linux distributions. In Debian or Ubuntu Linux You have an example default virtual host at /etc/apache2/sites-available/000-default.conf (see below). <VirtualHost *:80> # The ServerName directive sets the request scheme, hostname and port that # the server uses to identify itself. This is used when creating # redirection URLs. In the context of virtual hosts, the ServerName # specifies what hostname must appear in the request's Host: header to # match this virtual host. For the default virtual host (this file) this # value is not decisive as it is used as a last resort host regardless. # However, you must set it for any further virtual host explicitly. #ServerName www.example.com ServerAdmin webmaster@localhost DocumentRoot /var/www/html # Available loglevels: trace8, ..., trace1, debug, info, notice, warn, # error, crit, alert, emerg. # It is also possible to configure the loglevel for particular # modules, e.g. #LogLevel info ssl:warn ErrorLog ${APACHE_LOG_DIR}/error.log CustomLog ${APACHE_LOG_DIR}/access.log combined # For most configuration files from conf-available/, which are # enabled or disabled at a global level, it is possible to # include a line for only one particular virtual host. For example the # following line enables the CGI configuration for this host only # after it has been globally disabled with \"a2disconf\". #Include conf-available/serve-cgi-bin.conf </VirtualHost> # vim: syntax=apache ts=4 sw=4 sts=4 sr noet All you have to do is just to edit this virtual host file when needed and restart Apache to apply changes. You can also copy this file and create another virtual host, when you need several web sites to operate on the same machine. For example, to create another virtual host file named 001-vhost2.conf , type the following from your command shell: cd /etc/apache2/sites-available sudo cp 000-default.conf 001-vhost2.conf sudo a2ensite 001-vhost2.conf The virtual host's name starts with a prefix (like 000 , 010 , etc.), which defines the priority. Apache web server tries to direct an HTTP request to each virtual host in turn (first to 000-default , then to 001-vhost2 ), and if a certain virtual host cannot serve the request, the next one is tried and so on. In Fedora, CentOS or Red Hat Linux There is an example virtual host in /etc/httpd/conf/httpd.conf file. Scroll down to the very bottom of the document to the section called Virtual Hosts. You can edit this section as you need and restart Apache to apply your changes.","title":"Creating Apache Virtual Host"},{"location":"devenv/#installing-xdebug-php-extension","text":"To be able to debug your web sites, it is recommended that you install the XDebug extension. The XDebug extension allows to look inside a running program, see the variables passed from the client, walk the call stack and profile your PHP code. XDebug also provides the code coverage analysis capabilities, which are useful when you write unit tests for your code. In Debian or Ubuntu Linux To install XDebug, simply type the following command: sudo apt-get install php-xdebug Then edit the /etc/php/7.0/mods-available/xdebug.ini file by typing the following: sudo mcedit /etc/php/7.0/mods-available/xdebug.ini Add the following lines to the end of file (replace the remote IP address placeholder with the IP address you plan to debug your website from): xdebug.remote_enable=1 xdebug.remote_handler=dbgp xdebug.remote_mode=req xdebug.remote_host=<remote_ip_address> Finally, restart the Apache server to apply your changes. Then open the phpinfo.php in your browser and look for XDebug section (it should look like in the figure A.2): In Fedora, CentOS or Red Hat Linux In these Linux distributions, installing XDebug is a little more difficult. Install XDebug package with the following command: yum install php-pecl-xdebug After install, it is required to create the file xdebug.ini in /etc/php.d directory: mcedit /etc/php.d/xdebug.ini Add the following lines to the end of file (replace the remote IP address placeholder with the IP address you plan to debug your website from): [xdebug] Laminas_extension = /usr/lib/php/modules/xdebug.so xdebug.remote_enable=1 xdebug.remote_handler=dbgp xdebug.remote_mode=req xdebug.remote_host=<remote_ip_address> xdebug.remote_port=9000 Restart the Apache web server to apply your changes. Then check the phpinfo.php in your browser. If installation was successfull, you'll see some XDebug-related information.","title":"Installing XDebug PHP extension"},{"location":"devenv/#installing-mysql-database-server","text":"MySQL is a free relational database management system being developed and supported by Oracle. MySQL is the most popular database system used with PHP. In this book, we will be using MySQL. Debian or Linux Ubuntu In order to install MySQL database, type the following: sudo apt-get install mysql-server sudo apt-get install mysql-client sudo apt-get install php-mysql The commands above install MySQL server component, MySQL client component and MySQL extension module for PHP, respectively. Fedora, CentOS or Red Hat Linux In order to install MySQL database, type the following: sudo yum install mysql-server sudo yum install mysql sudo yum install php-mysql The commands above install MySQL server component, MySQL client component and MySQL extension module for PHP, respectively. Run the following commands to add MySQL server to autostart and start the server: sudo chkconfig --level 235 mysqld on sudo service mysqld start","title":"Installing MySQL Database Server"},{"location":"devenv/#configuring-the-mysql-database-server","text":"During the installation of the MySQL server, a root user is created. By default the root user has no password, so you have to set it manually. You will need that password for creating other MySQL database users. To connect to the MySQL server enter the following command: mysql -u root -p The MySQL command prompt will appear. In the command prompt enter the following command and press Enter (in the command below, replace the <your_password> placeholder with some password): SET PASSWORD FOR 'root'@'localhost' = '<insert_your_password>'; If the command is executed successfully, the following message is displayed: Query OK, 0 rows affected (0.00 sec) Now we need to create a new database that will store the tables. To do this, type the following: CREATE DATABASE test_db; The command above creates empty schema that we will populate later. Next, we want to create another database user named test_user that will be used by the laminas-based web site for connecting to the database. To create the user, type the following (in the command below, replace the <insert_your_password> placeholder with some password): GRANT ALL PRIVILEGES ON test_db.* TO 'test_user'@'localhost' IDENTIFIED BY '<insert_your_password>'; The command above creates the user named 'test_user' and grants the user all privileges on the 'test_db' database. Finally, type quit to exit the MySQL prompt.","title":"Configuring the MySQL Database Server"},{"location":"devenv/#installing-apache-php-and-mysql-in-windows","text":"We strongly recommend to use Linux for the purposes of PHP development. Most server systems have Linux installed. If you are using Windows for your everyday tasks, you still can install Linux on a virtual machine (for example, on VirtualBox ) and run Apache, PHP and MySQL on that virtual machine. If at the same time you would like to use NetBeans in Windows, you can do that - just configure a shared directory (for example, set up Samba server on your virtual machine). In case you strongly wish to install Apache, PHP and MySQL in Windows (which we do not recommend), here are some instructions (but note that installing those in Windows may be more difficult than in Linux). There are a couple of most popular Apache + MySQL + PHP distributions: WampServer XAMPP Choose one and install it on your Windows server machine.","title":"Installing Apache, PHP and MySQL in Windows"},{"location":"devenv/#checking-web-server-installation_1","text":"After you set up your web server, check that it is installed correctly and that your Apache server recognizes the PHP engine. To check that Apache and PHP are installed correctly, create phpinfo.php file in Apache document root directory. In the phpinfo.php file, enter the PHP method phpinfo() as follows: <?php phpinfo(); ?> Open the file in your browser. The standard PHP information page should display (figure A.3).","title":"Checking Web Server Installation"},{"location":"devenv/#enabling-apaches-mod_rewrite-module_1","text":"Laminas Framework requires that you have Apache's mod_rewrite module enabled. To enable mod_rewrite , open your the Apache config file (typically httpd.conf ), then find the following line: #LoadModule rewrite_module modules/mod_rewrite.so and remove the hash (#) sign from the beginning to uncomment the line. It should now look like this: LoadModule rewrite_module modules/mod_rewrite.so Finally, restart Apache web server to apply your changes.","title":"Enabling Apache's mod_rewrite module"},{"location":"devenv/#creating-apache-virtual-host_1","text":"A virtual host term means that you can run several web-sites on the same machine. The virtual sites are differentiated by domain name (like site.mydomain.com and site2.mydomain.com ) Please consult to your WAMP or XAMPP documentation for information on how to create virtual hosts. Note Right now, you don't need to edit virtual host file, we'll do that in chapter Laminas Skeleton Application when installing the Hello World application. Now you just need to understand how to create virtual hosts.","title":"Creating Apache Virtual Host"},{"location":"devenv/#installing-xdebug-php-extension_1","text":"To be able to debug your web sites in NetBeans IDE, it is recommended that you install the XDebug extension of your PHP engine. Download an appropriate DLL from this site . Then edit your php.ini file and add the following line: Laminas_extension=\"C:/path/to/your/xdebug.dll\" Add the following lines to the end of file (replace the remote IP address placeholder with the IP address you plan to debug your website from): xdebug.remote_enable=on xdebug.remote_handler=dbgp xdebug.remote_host=<remote_ip_address> Finally, restart the Apache server to apply your changes. Then open the phpinfo.php in your browser and look for XDebug section (it should look like in the figure A.4):","title":"Installing XDebug PHP extension"},{"location":"devenv/#configuring-the-mysql-database-server_1","text":"Now we want to create a database schema and a database user. We will use MySQL Command Line Client. Consult your WAMP or XAMPP documentation on how to do that. The MySQL Command Line Client console looks like follows (see the figure A.5): Now we need to create a new database that will store the tables. To do this, type the following in the MySQL client window: CREATE DATABASE test_db; The command above creates an empty database that we will populate later. If the command is executed successfully, the following message is displayed: Query OK, 1 rows affected (0.05 sec) Next, we want to create another database user named test_user that will be used by the web site for connecting to the database. To create the user, type the following (in the command below, replace the <your_password> placeholder with some password): GRANT ALL PRIVILEGES ON test_db.* TO 'test_user'@'localhost' IDENTIFIED BY '<your_password>'; The command above creates the user named test_user and grants the user all privileges on the test_db database schema.","title":"Configuring the MySQL Database Server"},{"location":"devenv/#installing-netbeans-ide-in-linux","text":"You can install NetBeans IDE using two methods: either from repository, as you did with Apache, PHP and MySQL, or by downloading the installer from NetBeans web site and running it. The first method is simpler, so we recommend to use it. To install NetBeans IDE in Debian or Linux Ubuntu, type the following command from your command shell: sudo apt-get install netbeans or the following command to install it in Fedora, CentOS or Red Hat Linux: sudo yum install netbeans The command above downloads from repository and installs NetBeans and all its dependent packages. After the installation is complete, you can run netbeans by typing: netbeans The NetBeans IDE window is shown in figure A.6. To be able to create PHP projects, you need to activate PHP plugin for NetBeans. To do that, open menu Tools->Plugins , the Plugins dialog appears. In the appeared dialog, click Settings tab and set check marks to all Update Centers (see the figure A.7). Then click the Available Plugins tab. On that tab, click the Check for Newest button to build the list of all available plugins. Then in the list, set check mark to PHP plugin and click the Install button (see the figure A.8). When the PHP plugin installation is complete, restart the IDE. Then you should be able to create new PHP projects from menu New->New Project... . Note It is also recommended to update NetBeans IDE to the latest version by opening menu Help->Check for updates .","title":"Installing NetBeans IDE in Linux"},{"location":"devenv/#installing-netbeans-ide-in-windows","text":"Installing NetBeans in Windows is strightforward. You just need to download the installer from NetBeans site and run it. You may encounter several bundles of NetBeans available for download, and you should download the bundle that is intended for PHP development (see the figure A.9 for example).","title":"Installing NetBeans IDE in Windows"},{"location":"devenv/#summary","text":"In this appendix, we've provided instructions on how to install and configure Apache HTTP Server, PHP engine and MySQL database in both Linux and Windows platforms. We've also provided instructions for installing NetBeans integrated development environment (IDE), which is a convenient integrated development environment for PHP development. It allows you to navigate, edit and debug your laminas-based application in an effective manner.","title":"Summary"},{"location":"doctrine/","text":"Database Management with Doctrine ORM Doctrine is an open-source PHP library providing convenient methods for managing your database in an object-oriented way. For working with relational databases, Doctrine provides a component named Object Relational Mapper (ORM for short). With Doctrine ORM you map your database table to a PHP class (in terms of Domain Driven Design, it is also called an entity class) and a row from that table is mapped to an instance of the entity class. If you are new to Doctrine, it is recommended that you also refer to Appendix D. Introduction to Doctrine for introductory information about the Doctrine library architecture. Note Doctrine is a third-party library, it is not part of Laminas Framework. We cover it in this book because it provides an easy way of adding database support to your laminas-based web application. Components covered in this chapter: Component Description Doctrine\\ORM Implements Object-Relational Mapper. DoctrineORMModule Easy integration of Doctrine ORM with Laminas. @ Laminas\\Paginator Support of pagination. Get Blog Example from GitHub For demonstration of Doctrine ORM usage, in this chapter, we will create a real-life Blog website. Its main features are the following: It will store blog posts in a database and provide a user interface for accessing and managing those posts. It is assumed that the blog has the single author of its posts, while comments can be added by multiple blog readers. The website will have two pages: Home page and Admin page. The first one will display the list of recently added posts, while the latter one will allow to add, edit, view and delete posts. For example screen shots of the Blog website, please look at the figures 12.1 and 12.2 below: To download the Blog application, visit this page and click the Clone or Download button to download the code as a ZIP archive. When download is complete, unpack the archive to some directory. Then navigate to the blog directory containing the source code of the Blog web application: /using-laminas-book-samples /blog ... The Blog is a sample website which can be installed on your machine. To install the sample, you can either edit your default Apache virtual host file or create a new one. After editing the file, restart the Apache HTTP Server and open the website in your web browser. For detailed installation instructions, please refer to the README.md file located in the blog directory. For the Blog sample to work, you have to create a MySQL database. Instructions on how to do that are provided in the next section. Creating a Simple MySQL Database For the Blog sample to work, we need to have a database. In this book, we use MySQL database management system, which is very simple in installation and administration. Note For OS-specific instructions on how to install MySQL server and client, please refer to Appendix A. Configuring Web Development Environment . Once you install MySQL, type the following command from your command shell to log into MySQL client console: mysql -u root -p When asked for, type the password of the root user (the password of the root user is the one you've specified during MySQL server installation). On successful login, you should see the following welcome message: Welcome to the MySQL monitor. Commands end with ; or \\g. Your MySQL connection id is 4 Server version: 5.7.13-0ubuntu0.16.04.2 (Ubuntu) Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved. Oracle is a registered trademark of Oracle Corporation and/or its affiliates. Other names may be trademarks of their respective owners. Type 'help;' or '\\h' for help. Type '\\c' to clear the current input statement. mysql> Now you are able to type MySQL client commands (like show databases , show tables , etc.) or SQL queries (like SELECT or INSERT ) at the MySQL prompt and see their output. If you want to quit of the MySQL prompt, type quit and press Enter. Creating New Database Let's create a database and name it blog . To do that, type the following SQL statement and press Enter: CREATE DATABASE blog; The expected output of this command is the following: Query OK, 1 row affected (0.01 sec) Note MySQL commands are case insensitive, so you could type create database blog; with the same result. We recommend using upper case for SQL queries, since this is a common convention. Next, we create the user named blog and grant it all privileges for accessing and modifying the blog database and all its tables: GRANT ALL PRIVILEGES ON blog.* TO blog@localhost IDENTIFIED BY '<passwd>'; In the command above, replace the password placeholder with the new password for the blog user. This password should be different than the password of the root user. Important Here, we create the second user blog , because it is not recommended to give the web application ability to log into database under the root user. The root user has unlimited rights and it is poor security practice to give an application the ability to do any actions it wants. The blog user will have permissions to modify the blog database only, which is sufficient in our case. You can check that the database has been created by typing the following command and pressing Enter: show databases; You should be able to see the output like below (note the blog line in the list of databases): +--------------------+ | Database | +--------------------+ | information_schema | | blog | | mysql | | performance_schema | +--------------------+ Creating Tables Next, we will create three tables typical for any simple blog: the post table will contain posts, the comment table will contain comments to posts, and, finally, the tag table will contain tags (a tag is some kind of a key word describing a blog post well). Additionally, we will create the fourth auxiliary table post_tag that will be used to create many-to-many relationship between the post and the tag tables. Make the blog database current by typing the following from MySQL command prompt: use blog; To create the post table, type the following SQL statement: CREATE TABLE `post` ( `id` int(11) PRIMARY KEY AUTO_INCREMENT, `title` text NOT NULL, `content` text NOT NULL, `status` int(11) NOT NULL, `date_created` datetime NOT NULL ); Note MySQL client allows easy entering of multi-line commands. Just press Enter when you want to move the caret to the next line. The command is considered to be fully entered when the semicolon (;) character is encountered. The expected output of this command is the following: Query OK, 0 rows affected (0.22 sec) Next, create the comment table by typing the following: CREATE TABLE `comment` ( `id` int(11) PRIMARY KEY AUTO_INCREMENT, `post_id` int(11) NOT NULL, `content` text NOT NULL, `author` varchar(128) NOT NULL, `date_created` datetime NOT NULL ); Then, create the tag table: CREATE TABLE `tag` ( `id` int(11) PRIMARY KEY AUTO_INCREMENT, `name` VARCHAR(128) ); And finally, create the post_tag table: CREATE TABLE `post_tag` ( `id` int(11) PRIMARY KEY AUTO_INCREMENT, `post_id` int(11) NOT NULL, `tag_id` int(11) NOT NULL ); Let's fill the tables we have created with some sample data: INSERT INTO tag(`name`) VALUES('Laminas'); INSERT INTO tag(`name`) VALUES('book'); INSERT INTO tag(`name`) VALUES('magento'); INSERT INTO tag(`name`) VALUES('bootstrap'); INSERT INTO post(`title`, `content`, `status`, `date_created`) VALUES( 'A Free Book about Laminas Framework', 'I''m pleased to announce that now you can read my new book \"Using Laminas Framework\" absolutely for free! Moreover, the book is an open-source project hosted on GitHub, so you are encouraged to contribute.', 2, '2016-08-09 18:49'); INSERT INTO post(`title`, `content`, `status`, `date_created`) VALUES( 'Getting Started with Magento Extension Development - Book Review', 'Recently, I needed some good resource to start learning Magento e-Commerce system for one of my current web projects. For this project, I was required to write an extension module that would implement a customer-specific payment method.', 2, '2016-08-10 18:51'); INSERT INTO post(`title`, `content`, `status`, `date_created`) VALUES( 'Twitter Bootstrap - Making a Professionaly Looking Site', 'Twitter Bootstrap (shortly, Bootstrap) is a popular CSS framework allowing to make your website professionally looking and visually appealing, even if you don''t have advanced designer skills.', 2, '2016-08-11 13:01'); INSERT INTO post_tag(`post_id`, `tag_id`) VALUES(1, 1); INSERT INTO post_tag(`post_id`, `tag_id`) VALUES(1, 2); INSERT INTO post_tag(`post_id`, `tag_id`) VALUES(2, 2); INSERT INTO post_tag(`post_id`, `tag_id`) VALUES(2, 3); INSERT INTO post_tag(`post_id`, `tag_id`) VALUES(3, 4); INSERT INTO comment(`post_id`, `content`, `author`, `date_created`) VALUES( 1, 'Excellent post!', 'Oleg Krivtsov', '2016-08-09 19:20'); Note If necessary, you can easily remove the database and all tables and data it contains by typing the following command from MySQL prompt: DROP DATABASE blog; Figure 12.3 graphically illustrates what entities we have in the database and what relationships between those entities present. As you can see from figure 12.3, the post table is related to comment table as one-to-many , because a single post may have many comments. This is also called the \"one-to-many\" relationship. The post table is also related to the tag table as many-to-many . A single post may have many tags, and a single tag may belong to many posts as well. Many-to-many relationship is typically implemented through an auxiliary table ( post_tag table in our case). Importing Ready Database Schema In the previous section, we've shown how to create the complete database schema that is used in the Blog sample web application. In the real life, you typically do not type all those SQL statements at the MySQL prompt. Instead, you could type the CREATE TABLE statements to a file and save it to disk. Then you could just import that file and have the ready schema. For your convenience, the ready schema for Blog sample can be found in APP_DIR/data/schema.mysql.sql file. The file is a plain text file containing SQL statements. To import the file, go to the APP_DIR/data/ directory and type the following command from your command shell (but not from MySQL prompt): mysql -u root -p blog < schema.mysql.sql When prompted for password, enter the password of the root user and press Enter. Once this is done, log into the MySQL client and type the following commands: use blog; show tables; You should see the list of tables created, something like below: +----------------+ | Tables_in_blog | +----------------+ | comment | | post | | post_tag | | tag | +----------------+ 4 rows in set (0.00 sec) Note Also consider using database migrations for initializing database schema. For additional info about migrations, please refer to Database Migrations chapter. Integrating Doctrine ORM with Laminas Framework For easy integration with Laminas Framework, Doctrine project provides the following two components (that are actually Laminas modules): DoctrineModule is a Laminas module that provides Doctrine basic functionality required by the ORM component; DoctrineORMModule integrates Doctrine Object Relational Mapper (ORM) with Laminas Framework. Each of the above Doctrine components is distributed as a Composer-installable package and is registered in Packagist.org catalogue. This is very similar to the way that Laminas Framework uses for installing its components. Since Composer packages may depend on each other, it is enough to declare dependency only on DoctrineORMModule . This package depends on DoctrineModule and on some other Doctrine components ( Doctrine\\ORM , Doctrine\\DBAL , Doctrine\\Common , Doctrine\\Annotations , etc.). So, when you install this component, Composer will install other required components automatically. Installing Doctrine Components with Composer In order to install required Doctrine components, we first add a dependency to the composer.json file located in the root directory of the web application (in this book, we typically denote that directory as APP_DIR ). To add the dependency, type the following commands from your command shell (replace the APP_DIR placeholder with the actual directory name of your application): cd APP_DIR php composer.phar require doctrine/doctrine-orm-module The cd command above is used to make the APP_DIR directory current working directory. And the require command tells Composer to add the package doctrine/doctrine-orm-module as a dependency to your web application, and to download and install that dependency. Once you run the commands above, Composer will first modify the composer.json file and create the line like below under its require key: { ... \"require\": { \"doctrine/doctrine-orm-module\": \"^1.0.9\", ... }, ... } Then Composer will try to locate the dependency packages, download them to the local machine and install the files into the APP_DIR/vendor directory. Composer will output lines indicating installation process to the terminal. As you can see from the Composer output, when you install DoctrineORMModule component, Composer automatically installs the DoctrineModule and all necessary Doctrine components ( Doctrine\\DBAL , Doctrine\\ORM , etc.) Note As a bonus, at the end of installation, Composer \"suggests\" you to install some additional packages that might be useful for you ( doctrine/migrations , doctrine/data-fixtures , etc.) If you strongly wish, you may add those dependencies with the Composer's require command as well. When the installation has been finished, you can find the Doctrine files in your APP_DIR/vendor directory (see the figure 12.4 below). Note You use the php composer.phar require command for the first time you install Doctrine. Once the composer.json (and composer.lock ) files have been modified by Composer, you are able to install (or update) all dependencies as usual by typing the php composer.phar install or php composer.phar update commands, respectively, from your command shell. Loading Doctrine Integration Modules on Application Start Up Once you have installed the DoctrineORMModule and all its dependencies, you need to add the following lines to your APP_DIR/config/modules.config.php file to enable the modules: <?php return [ // Add the Doctrine integration modules. 'DoctrineModule', 'DoctrineORMModule', //... ); The lines above let Laminas know that it should load the DoctrineModule module and DoctrineORMModule module on application start up. Doctrine Configuration Overview To use Doctrine with your laminas-based web application, you have to provide its configuration. The configuration tells Doctrine what databases present, how to connect to a database (what database driver, host, user name and password to use), where to locate entity classes and how to extract their annotations (metadata), how to store cached data (in the file system or to use a caching extension), and so on. This section's goal is to give you a general idea of how Doctrine configuration looks like. The default Doctrine configuration is located in the module.config.php config file of the DoctrineORMModule . Look at the figure 12.5 below to have an idea of how the Doctrine config \"tree\" may look like 1 . You may also refer to the module.config.php file of DoctrineORMModule for the same reason. As you can see from the figure 12.5, there is the top-level key named doctrine . Under that key, there is a number of subkeys containing the following settings: the connection key contains the list of all databases that the web application is able to connect to. For each database connection it contains parameters like driver class name, host, user name, password and database name. Note By default, there is only one connection named orm_default , and you may add more database connections if required. the configuration key contains ORM settings like caching configuration and locations of auto-generated entity proxy classes for each available connection. the driver key contains the information about where to locate entity classes for each available database connection. the entitymanager key contains settings used for instantiating an entity manager for each database connection. the eventmanager key contains settings for Doctrine event manager for each available connection. Note Doctrine uses its own implementation of event manager. If you want, you can create an event listener class and hooks some events. However, this is an advanced topic and we do not cover it in this book. the migrations_configuration key contains settings for database migrations. Database migrations are used for initializing and updating database schema in a standard and consistent way. Overriding the Default Doctrine Configuration As you already know from Website Operation chapter, in a laminas-based web application configuration is typically divided into two categories: application-wide configuration and module-specific configuration. For storing application-wide Doctrine settings, you typically use the APP_DIR/config/autoload/global.php or APP_DIR/config/autoload/local.php config files. The first one suits well for storing settings not depending on particular environment, while the latter one suits well for storing environment-dependent settings (like database connection parameters). For storing Doctrine settings specific to certain module, you use the module.config.php config file located inside the config directory of that module. This is suitable, for example, for storing the entity location settings. When laminas-based website loads its configuration, it merges all configs into a single big array, thus forming the final Doctrine config \"tree\". By adding your application-specific Doctrine configuration, you extend and/or override the default configuration tree provided by the DoctrineORMModule . Specifying Database Connection Parameters Below we provide content of the autoload/local.php file of the Blog web application. This config file contains the application-wide database connection settings for the blog MySQL database that we created earlier in this chapter: Note This connection is shared between all modules of the web application. If you want to create module-specific connection, consider adding the key to the module.config.php file instead. <?php use Doctrine\\DBAL\\Driver\\PDOMySql\\Driver as PDOMySqlDriver; return [ 'doctrine' => [ 'connection' => [ 'orm_default' => [ 'driverClass' => PDOMySqlDriver::class, 'params' => [ 'host' => '127.0.0.1', 'user' => 'blog', 'password' => '<password>', 'dbname' => 'blog', ] ], ], ], ]; Above, we have the doctrine key and connection subkey. The connection subkey contains the orm_default subkey which is the default connection. The driverClass key provides the class name to use as a driver to the database. Since we use MySQL database, we specify the Doctrine\\DBAL\\Driver\\PDOMySql\\Driver class name. For your reference, in table 12.1, you can find several other often used database drivers. Each driver class supports its own set of parameters, so please refer to certain driver's code (and related documentation) for additional information. The params key contains the connection parameters: host may be either the domain name or IP address of the database server; user is the MySQL user name with granted permissions to the database; password is the secret word for the user name; dbname is the name of the database. Method Description Doctrine\\DBAL\\Driver\\PDOSqlite\\Driver SQLite driver using PDO PHP extension. Doctrine\\DBAL\\Driver\\PDOMySql\\Driver MySQL driver using PDO PHP extension. Doctrine\\DBAL\\Driver\\PDOOracle\\Driver Oracle driver using PDO PHP extension. Doctrine\\DBAL\\Driver\\PDOPgSql\\Driver PostgreSQL driver using PDO PHP extension. Doctrine\\DBAL\\Driver\\PDOSqlsrv\\Driver MS SQL Server driver using PDO PHP extension. Table 12.1. Often Used Database Driver Classes Important Because the autoload/local.php file contains environment-specific parameters, you only store its \"distribution template\", local.php.dist file, in version control. Each developer in your team then renames the local.php.dist file to local.php and enters his own password instead of the placeholder. The local.php file should not be version controlled, because you usually do not want other people on your team (or other people having access to your code repository) seeing the actual password. What happens if I need several database connections? You can easily add more database connections by adding other keys below the orm_default key. For example, let's assume that you have another database for testing purposes. To let Doctrine know about this database, you create the orm_test subkey below the orm_default key and fill it with connection parameters. About Doctrine Entities An entity is a PHP class that is designed for storing data. For example, below you can find several often used examples of entities: User entity is designed to store information about a website visitor. It may contain properties like username, password, first name, last name, etc. License entity is designed to store information about a software license. It may contain data like unique license key, reference to user who purchased the license, license creation date, etc. Payment entity may contain properties related to a purchase of some goods. The properties are: transaction ID, money amount, money currency, etc. Note In terms of Domain Driven Design pattern, entities are a kind of models designed for storing data. For additional examples of entities and other types of models, please refer to Model-View-Controller . In Doctrine ORM, an entity class is mapped on a certain database table. For example, the User entity is usually mapped on the user table (if needed, the table name may be arbitrary). For our Blog example application, we will create three entity classes: Post entity will contain data related to specific blog post. Its properties are exactly the same that we used when defining the post table in blog database schema. The entity class will also have public getter and setter methods designed for retrieving/setting the data. by analogy, Comment entity will contain data related to a comment to blog post. and Tag entity will contain data related to a tag. Annotations An annotation is a special kind of a PHP comment that is preprocessed by Doctrine ORM. In other words, annotations is metadata attached to an entity class that can be read by the Doctrine ORM at run-time. Annotations provide verbose information about an entity. Annotations describe an entity and tell Doctrine ORM how to map it on a database table. A Docblock annotation is a C++ style comment starting with slash (/) and two asterisks (*). This \"starter\" characters are required, otherwise Doctrine won't recognize the annotation. An example of annotation can be found below: /** * This is Docblock annotation comment. */ Doctrine reads Docblock annotations with the help of its Doctrine\\Annotations component. Note You might have already seen Docblock annotations if you've used phpDocumentor or Doxygen documentation generation tools. In those tools, annotation comments are serving the same goal: to describe a PHP class and its properties and methods. Then the tool goes through your code and builds HTML documentation automatically based entirely on code and annotations analysis. For example, below, we provide the basic example of a Doctrine entity class. You can see that the class and its properties are marked with Docblock annotations with special tags (a tag starts with '@' character). <?php namespace Application\\Entity; use Doctrine\\ORM\\Mapping as ORM; /** * @ORM\\Entity * @ORM\\Table(name=\"post\") */ class Post { /** * @ORM\\Id * @ORM\\GeneratedValue * @ORM\\Column(name=\"id\") */ protected $id; /** * @ORM\\Column(name=\"title\") */ protected $title; /** * @ORM\\Column(name=\"content\") */ protected $content; /** * @ORM\\Column(name=\"status\") */ protected $status; /** * @ORM\\Column(name=\"date_created\") */ protected $dateCreated; } Let's review the code above: In line 2, we declared the Application\\Entity namespace in which entity classes for the Application module live. In line 4, you may notice that we use the Doctrine\\ORM\\Mapping class and its short ORM alias for Doctrine annotations 2 . In lines 6-9, you can see a Docblock annotation for the Post class. Each annotation tag begins with the @ character, has the name and (optional) parameters enclosed into the round braces. Doctrine-provided tags used in annotations may be of two types: class-level and property-level. In the code above, we use the following class-level tags (describing the whole entity class): @ORM\\Entity tag (line 7) declares that this class is a Doctrine ORM entity; @ORM\\Table(name=\"post\") tag (line 8) tells Doctrine ORM that this entity class is mapped on the post database table; Entity's properties are described with the following property-level tags: @ORM\\Id tells that this property is actually a unique identifier of the entity (see line 13); @ORM\\GeneratedValue is used to tell Doctrine ORM that this property uses some auto-generated sequence for initializing itself (line 14). In MySQL, this typically means that the corresponding table column uses AUTO_INCREMENT initializer. @ORM\\Column(name=\"<column_name>\") is used to tell Doctrine ORM on which table column to map this particular property (lines 15, 20, 25, 30, 35). Note The complete list of Doctrine-provided tags used in annotations can be found by the following link . Creating Entities For the Application module, entities are (by convention) stored inside the Entity directory under the module's source directory. Entity classes live inside the Application\\Entity namespace. Adding Post Entity We start with creating the Post entity. Create the Post.php file under module's Entity directory. (If you haven't created the Entity directory yet, its the right time to do that.) Put the following code into the file: <?php namespace Application\\Entity; use Doctrine\\ORM\\Mapping as ORM; /** * This class represents a single post in a blog. * @ORM\\Entity * @ORM\\Table(name=\"post\") */ class Post { // Post status constants. const STATUS_DRAFT = 1; // Draft. const STATUS_PUBLISHED = 2; // Published. /** * @ORM\\Id * @ORM\\GeneratedValue * @ORM\\Column(name=\"id\") */ protected $id; /** * @ORM\\Column(name=\"title\") */ protected $title; /** * @ORM\\Column(name=\"content\") */ protected $content; /** * @ORM\\Column(name=\"status\") */ protected $status; /** * @ORM\\Column(name=\"date_created\") */ protected $dateCreated; // Returns ID of this post. public function getId() { return $this->id; } // Sets ID of this post. public function setId($id) { $this->id = $id; } // Returns title. public function getTitle() { return $this->title; } // Sets title. public function setTitle($title) { $this->title = $title; } // Returns status. public function getStatus() { return $this->status; } // Sets status. public function setStatus($status) { $this->status = $status; } // Returns post content. public function getContent() { return $this->content; } // Sets post content. public function setContent($content) { $this->content = $content; } // Returns the date when this post was created. public function getDateCreated() { return $this->dateCreated; } // Sets the date when this post was created. public function setDateCreated($dateCreated) { $this->dateCreated = $dateCreated; } } In the code above, we have the following things: Status constants (lines 14 and 15). These constants conveniently represent possible values the $status property may receive (1 for Draft, 2 for Published). Protected properties ( $title , $content , $dateCreated , etc.). These are data that a typical blog post has (see table 12.2 below for reference of properties together with their brief descriptions). Note Please note that for properties we (by convention) use camel-case names (like $dateCreated ), while for database columns we use \"canonicalized\" names (in lower-case and with underscores separating words in a name, like date_created ). Property Mapped on Column Description $id id Unique ID of this post. $title title Title of this post. $content content Content of this post. $status status Status (draft/published) of this post. $dateCreated date_created Date when this post was created. Table 12.2. Properties of the Post entity Entity class and its properties are marked with Docblock annotations read by Doctrine ORM at run-time allowing it to know how to map this entity and its properties on the database table and its columns. Entity class has getter and setter methods (lines 45-102) allowing to access/modify the protected properties (see the table 12.3 for reference of methods and their brief descriptions). Method Description getId() Returns ID of this post. setId($id) Sets ID of this post. getTitle() Returns title. setTitle($title) Sets title. getStatus() Returns status (draft/published). setStatus($status) Sets status. getContent() Returns post content. setContent($content) Sets post content. getDateCreated() Returns the date when this post was created. setDateCreated() Sets the date when this post was created. Table 12.3. Getter and setter methods of the Post entity Note Note that we do not mark entity class methods with Doctrine annotations. There is just no need to do that. However, you may mark methods with usual comments and non-Doctrine Docblock annotations, if you strongly wish. Adding the Comment and Tag Entities By analogy with the Post entity, we next create the Comment and the Tag entity classes in the Entity directory. To do that, first, create Comment.php file and put the following code inside of it: <?php namespace Application\\Entity; use Doctrine\\ORM\\Mapping as ORM; /** * This class represents a comment related to a blog post. * @ORM\\Entity * @ORM\\Table(name=\"comment\") */ class Comment { /** * @ORM\\Id * @ORM\\Column(name=\"id\") * @ORM\\GeneratedValue */ protected $id; /** * @ORM\\Column(name=\"content\") */ protected $content; /** * @ORM\\Column(name=\"author\") */ protected $author; /** * @ORM\\Column(name=\"date_created\") */ protected $dateCreated; // Returns ID of this comment. public function getId() { return $this->id; } // Sets ID of this comment. public function setId($id) { $this->id = $id; } // Returns comment text. public function getContent() { return $this->content; } // Sets status. public function setContent($content) { $this->content = $content; } // Returns author's name. public function getAuthor() { return $this->author; } // Sets author's name. public function setAuthor($author) { $this->author = $author; } // Returns the date when this comment was created. public function getDateCreated() { return $this->dateCreated; } // Sets the date when this comment was created. public function setDateCreated($dateCreated) { $this->dateCreated = $dateCreated; } } Next, create Tag.php file and put the following code inside of it: <?php namespace Application\\Entity; use Doctrine\\ORM\\Mapping as ORM; /** * This class represents a tag. * @ORM\\Entity * @ORM\\Table(name=\"tag\") */ class Tag { /** * @ORM\\Id * @ORM\\GeneratedValue * @ORM\\Column(name=\"id\") */ protected $id; /** * @ORM\\Column(name=\"name\") */ protected $name; // Returns ID of this tag. public function getId() { return $this->id; } // Sets ID of this tag. public function setId($id) { $this->id = $id; } // Returns name. public function getName() { return $this->name; } // Sets name. public function setName($name) { $this->name = $name; } } Since the Comment and Tag entities are analogous to the Post entity, we don't provide detailed description of the code above. Note Please note that we do not create an entity for the fourth auxiliary table post_tag . That table will be indirectly used further in this chapter when defining relationships between entities. Specifying Relationships between Entities Now it is time to use annotations to define relationships between entities. If you remember, we have two relationships between our entities: the Post and Comment entities are related as \"one-to-many\"; and the Post and Tag entities are related as \"many-to-many\". In Doctrine, to express a relationship between two entities, you add a private property paired with Docblock annotation. For detailed information about relationships between entities in Doctrine, please read this page of Doctrine documentation. OneToMany/ManyToOne First, let's define one-to-many relationship between the Post and Comment entities. Modify the Post.php file and add the following lines: <?php // ... use Doctrine\\Common\\Collections\\ArrayCollection; use Application\\Entity\\Comment; /** * This class represents a single post in a blog. * @ORM\\Entity * @ORM\\Table(name=\"post\") */ class Post { // ... /** * @ORM\\OneToMany(targetEntity=\"\\Application\\Entity\\Comment\", mappedBy=\"post\") * @ORM\\JoinColumn(name=\"id\", referencedColumnName=\"post_id\") */ protected $comments; /** * Constructor. */ public function __construct() { $this->comments = new ArrayCollection(); } /** * Returns comments for this post. * @return array */ public function getComments() { return $this->comments; } /** * Adds a new comment to this post. * @param $comment */ public function addComment($comment) { $this->comments[] = $comment; } } As you can see from the code above, we added the $comments property (line 19). This property will be the collection of comments related to certain post. We initialize the $comments property in class constructor (lines 24-27). By assigning it with a new instance of Doctrine\\Common\\Collections\\ArrayCollection class. Note A Doctrine ArrayCollection is an array of objects, like usual PHP array , but with additional features required by Doctrine. It is implemented in Doctrine\\Common component. In lines 15-18, we add Doctrine annotations to the $comments property, so Doctrine knows how to get all comments associated with the post: the @ORM\\OneToMany tag defines that this is the one-to-many relationship between the Post entity and the (target) Comment entity. the @ORM\\JoinColumn tag specifies which column to use for joining the tables associated with the entities. The getComments() method (lines 33-36) allows getting all comments associated with the post. We also added the addComment() method (lines 42-45) for adding new comment to post. You can notice that we use the [] operator, just like we do with a typical PHP array. Vice versa, we define the other side of this relationship by modifying the Comment entity as follows: <?php // ... use Doctrine\\Common\\Collections\\ArrayCollection; // ... class Comment { /** * @ORM\\ManyToOne(targetEntity=\"\\Application\\Entity\\Post\", inversedBy=\"comments\") * @ORM\\JoinColumn(name=\"post_id\", referencedColumnName=\"id\") */ protected $post; /* * Returns associated post. * @return \\Application\\Entity\\Post */ public function getPost() { return $this->post; } /** * Sets associated post. * @param \\Application\\Entity\\Post $post */ public function setPost($post) { $this->post = $post; $post->addComment($this); } } In the code above, we added the $post private property to the entity class. This is not a collection, but a single instance of Post class, because single comment always belongs to single post. The annotation tags @ORM\\ManyToOne and @ORM\\JoinColumn are analogous to those we covered before. ManyToMany Let's now express the many-to-many relationship between the Post and Tag entities. For this relationship, we indirectly use the auxiliary post_tag table. Modify the Post entity as follows: <?php //... use Application\\Entity\\Tag; //... class Post { //... /** * @ORM\\ManyToMany(targetEntity=\"\\Application\\Entity\\Tag\", inversedBy=\"posts\") * @ORM\\JoinTable(name=\"post_tag\", * joinColumns={@ORM\\JoinColumn(name=\"post_id\", referencedColumnName=\"id\")}, * inverseJoinColumns={@ORM\\JoinColumn(name=\"tag_id\", referencedColumnName=\"id\")} * ) */ protected $tags; // Constructor. public function __construct() { //... $this->tags = new ArrayCollection(); } // Returns tags for this post. public function getTags() { return $this->tags; } // Adds a new tag to this post. public function addTag($tag) { $this->tags[] = $tag; } // Removes association between this post and the given tag. public function removeTagAssociation($tag) { $this->tags->removeElement($tag); } } In the code above, we do the following: add $tags private property mark the $tags property with Docblock annotations with @ORM\\ManyToMany and @ORM\\JoinTable annotation tags initialize the property in constructor; add three methods getTags() , addTag() and removeTagAssociation() allowing to get/modify the property's value. Finally, modify the Tag entity as follows: <?php //... use Doctrine\\Common\\Collections\\ArrayCollection; class Tag { // ... /** * @ORM\\ManyToMany(targetEntity=\"\\Application\\Entity\\Post\", mappedBy=\"tags\") */ protected $posts; // Constructor. public function __construct() { $this->posts = new ArrayCollection(); } // Returns posts associated with this tag. public function getPosts() { return $this->posts; } // Adds a post into collection of posts related to this tag. public function addPost($post) { $this->posts[] = $post; } } In the code above, we by analogy define the other side of the relationship and getter/setter methods for retrieving the collection of posts associated with the tag, and adding posts associated with the given tag. Specifying Entity Locations To let Doctrine know where to find entities for your Application module (or for another module you have), you add the following lines into your module.config.php file: <?php namespace Application; use Doctrine\\ORM\\Mapping\\Driver\\AnnotationDriver; return [ // ... 'doctrine' => [ 'driver' => [ __NAMESPACE__ . '_driver' => [ 'class' => AnnotationDriver::class, 'cache' => 'array', 'paths' => [__DIR__ . '/../src/Entity'] ], 'orm_default' => [ 'drivers' => [ __NAMESPACE__ . '\\Entity' => __NAMESPACE__ . '_driver' ] ] ] ] ]; Above, in line 2, we specify the namespace Application . This should be the name of the current module. Note Note that usually we do not specify namespace in config files, but in this particular case it is convenient to do. When we have namespace defined, we can use the __NAMESPACE__ placeholder which expands into that namespace. In line 8, we have doctrine key, under which we have the driver subkey. In line 13, we tell Doctrine ORM that our entities are stored inside of Entity directory under the module's src directory. About Entity Manager Entity manager is the primary access point to ORM functionality provided by Doctrine. EntityManager is a Doctrine class that lives in Doctrine\\ORM namespace and used to retrieve entities from their repositories using search criteria and save entities back to database. EntityManager is registered as a service in the Laminas Framework service manager. In your factory class, you retrieve the EntityManager from service manager as follows (if you need a different connection than orm_default , just replace the orm_default with the required connection name): // Get Doctrine entity manager $entityManager = $container->get('doctrine.entitymanager.orm_default'); The most used methods provided by the EntityManager class are listed in table 12.4 below. Method Description persist($entity) Places new entity into entity manager (makes it managed). remove($entity) Removes an entity from database. flush() Flushes all changes to objects that have been queued up to now to the database. createQuery($dql) Creates a new Query object. getRepository($entityName) Gets the repository for an entity class. Table 12.4. Methods of the EntityManager Let's review the methods from table 12.4. To add a newly created entity to entity manager (to make the entity \"managed\"), you use entity manager's persist() method. To remove an entity from database, you use entity manager's remove() method. When you call persist() or remove() , EntityManager remembers your changes in memory, but doesn't apply changes to database automatically (by performance reasons). To apply changes to database in a single transaction, you use the flush() method. For example, look at the code example below that shows how to create an instance of the Post entity and save it to database: // Create new Post entity. $post = new Post(); $post->setTitle('Top 10+ Books about Laminas Framework'); $post->setContent('Post body goes here'); $post->setStatus(Post::STATUS_PUBLISHED); $currentDate = date('Y-m-d H:i:s'); $post->setDateCreated($currentDate); // Add the entity to entity manager. $entityManager->persist($post); // Apply changes to database. $entityManager->flush(); The createQuery() method of the entity manager is designed for creating a query from a DQL string. It returns the Query object. You then execute the query and get results (an array of entities matching search conditions). The getRepository() method of the entity manager is designed to get repository by entity class name. Please look below for example where we get the repository for our Post entity: $repository = $entityManager->getRepository(Post::class); Entity Repositories Conceptually, each entity class has its own repository. The repository provides methods for retrieving entities from database. The repository can be considered as a collection of all available entities of certain class. For example, there are repositories for our Post , Comment , and Tag entities. To load data from the database, you retrieve an entity from its repository. When you request the repository for an entity, it loads the data from the table mapped to the entity, and assigns entity's fields with the data. Note The Doctrine\\ORM\\EntityRepository class implements the default repository. If needed, you can, by extending the EntityRepository , create your own repository for certain entity class. We will show how to do that later. The most used methods provided by the EntityRepository class are listed in table 12.5. Method Description findAll() Finds all entities in the repository. find($id) Finds an entity by its identifier. findBy($criteria, $orderBy, $limit, $offset) Finds entities by a set of criteria. findOneBy($criteria, $orderBy) Finds a single entity by a set of criteria. createQueryBuilder($alias) Creates a new QueryBuilder instance that is prepopulated for this entity name. Table 12.5. Methods of the EntityRepository The findAll() method gets all entities from repository. For simple example of its usage, look below: // Find all posts from repository $posts = $entityManager->getRepository(Post::class)->findAll(); The find() method is the simplest method of searching for an entity. It retrieves an entity by its ID (primary key). In the example below, we select post with ID = 1. // Find post by primary key (ID) $post = $entityManager->getRepository(Post::class)->find(1); The findBy() takes a search criteria (and optional sorting order and limit) arguments and returns a collection of entities matching criteria. The findOneBy() method is very similar to findBy() , but it returns the first entity matching the criteria. In the code example below, we use the findBy() method for selecting 50 most recent published posts: // Find 50 most recent published posts $posts = $entityManager->getRepository(Post::class)->findBy( ['status'=>Post::STATUS_PUBLISHED], ['dateCreated'=>'DESC'], 50); For your convenience, the EntityRepository class also provides magic methods allowing you to query entities by attribute name with the findByX and findOneByX methods, as follows (just substitute the X placeholder with an attribute name): // Query a single post by ID attribute $post = $entityManager->getRepository(Post::class)->findOneById(1); // Query posts by status attribute $posts = $entityManager->getRepository(Post::class) ->findByStatus(Post::STATUS_PUBLISHED); And the most complex search method is the createQueryBuilder() . That method allows to create complex DQL queries. If standard find methods are not sufficient (or if you have complex search criteria and DQL queries), you can create your own repository by extending the standard EntityRepository class and encapsulate the search logic there. We will show how to do that later when implementing tag cloud feature for our Blog sample. Adding Blog Home Page To show how to use EntityManager class, we will create the main page for the Blog web application. This page will display the list of posts sorted by date in descending order. To do that, add the constructor method and indexAction() method to the IndexController controller class, as follows: <?php namespace Application\\Controller; use Laminas\\Mvc\\Controller\\AbstractActionController; use Laminas\\View\\Model\\ViewModel; use Application\\Entity\\Post; class IndexController extends AbstractActionController { /** * Entity manager. * @var Doctrine\\ORM\\EntityManager */ private $entityManager; // Constructor method is used to inject dependencies to the controller. public function __construct($entityManager) { $this->entityManager = $entityManager; } // This is the default \"index\" action of the controller. It displays the // Posts page containing the recent blog posts. public function indexAction() { // Get recent posts $posts = $this->entityManager->getRepository(Post::class) ->findBy(['status'=>Post::STATUS_PUBLISHED], ['dateCreated'=>'DESC']); // Render the view template return new ViewModel([ 'posts' => $posts ]); } } In the code above, we first add the __construct() constructor method which is used to inject the Doctrine entity manager into the controller (lines 17-20). Inside of the indexAction() method, we get the repository of the Post entities with entity manager's getRepository() method (line 27). With the findBy() method provided by repository, we select published posts sorted by date in descending order. And, in line 32 we pass the selected posts to the view for rendering. Next, create the factory for the IndexController . To do that, add the IndexControllerFactory.php file inside of Controller/Factory directory under module's source directory. Put the following content to the file: <?php namespace Application\\Controller\\Factory; use Interop\\Container\\ContainerInterface; use Laminas\\ServiceManager\\Factory\\FactoryInterface; use Application\\Controller\\IndexController; /** * This is the factory for IndexController. Its purpose is to instantiate the * controller. */ class IndexControllerFactory implements FactoryInterface { public function __invoke(ContainerInterface $container, $requestedName, array $options = null) { $entityManager = $container->get('doctrine.entitymanager.orm_default'); // Instantiate the controller and inject dependencies return new IndexController($entityManager); } } In the code above, you can see how we instantiate the Doctrine entity manager and inject it into the controller. Do not forget to register our controller's factory inside module.config.php file. To do that, add the following: //... return [ //... 'controllers' => [ //... 'factories' => [ Controller\\IndexController::class => Controller\\Factory\\IndexControllerFactory::class, ], ], //... ]; Next, modify the index.phtml view template file in application/index directory under module's view directory and put the following content into it: <h1>Posts</h1> <?php foreach($posts as $post): ?> <h3> <a href=\"#\"> <?= $this->escapeHtml($post->getTitle()); ?> </a> </h3> <p> <?= $this->escapeHtml($post->getContent()); ?> </p> <?php endforeach; ?> In the view template above, we go in turn through the posts we selected and render each one's title and content. That simple! Now, if you open the Blog web application in your browser, you should be able to see the following page containing the list of posts (look at figure 12.6 below). Adding New Post In this section, we will create the Add New Post web page that will allow to add a new post to blog. For this, we will need four things: the PostForm form model will be used for entering and validation of post title, content, status and tags; the PostManager service model will contain business logic for saving new post to database; the PostController controller and its PostController::addAction() action method will be used for getting form data, and calling PostManager for saving the data to database. and add.phtml view template will render the form. Adding PostForm First, we add the PostForm form that will allow to enter data of a single post: its title, content, comma-separated list of tags associated with the post, and status (Published or Draft). To do that, create the PostForm.php file in Form directory under module's source directory. Put the following content into the file: <?php namespace Application\\Form; use Laminas\\Form\\Form; use Laminas\\InputFilter\\InputFilter; use Application\\Entity\\Post; /** * This form is used to collect post data. */ class PostForm extends Form { /** * Constructor. */ public function __construct() { // Define form name parent::__construct('post-form'); // Set POST method for this form $this->setAttribute('method', 'post'); $this->addElements(); $this->addInputFilter(); } /** * This method adds elements to form (input fields and submit button). */ protected function addElements() { // Add \"title\" field $this->add([ 'type' => 'text', 'name' => 'title', 'attributes' => [ 'id' => 'title' ], 'options' => [ 'label' => 'Title', ], ]); // Add \"content\" field $this->add([ 'type' => 'textarea', 'name' => 'content', 'attributes' => [ 'id' => 'content' ], 'options' => [ 'label' => 'Content', ], ]); // Add \"tags\" field $this->add([ 'type' => 'text', 'name' => 'tags', 'attributes' => [ 'id' => 'tags' ], 'options' => [ 'label' => 'Tags', ], ]); // Add \"status\" field $this->add([ 'type' => 'select', 'name' => 'status', 'attributes' => [ 'id' => 'status' ], 'options' => [ 'label' => 'Status', 'value_options' => [ Post::STATUS_PUBLISHED => 'Published', Post::STATUS_DRAFT => 'Draft', ] ], ]); // Add the submit button $this->add([ 'type' => 'submit', 'name' => 'submit', 'attributes' => [ 'value' => 'Create', 'id' => 'submitbutton', ], ]); } /** * This method creates input filter (used for form filtering/validation). */ private function addInputFilter() { $inputFilter = new InputFilter(); $this->setInputFilter($inputFilter); $inputFilter->add([ 'name' => 'title', 'required' => true, 'filters' => [ ['name' => 'StringTrim'], ['name' => 'StripTags'], ['name' => 'StripNewlines'], ], 'validators' => [ [ 'name' => 'StringLength', 'options' => [ 'min' => 1, 'max' => 1024 ], ], ], ]); $inputFilter->add([ 'name' => 'content', 'required' => true, 'filters' => [ ['name' => 'StripTags'], ], 'validators' => [ [ 'name' => 'StringLength', 'options' => [ 'min' => 1, 'max' => 4096 ], ], ], ]); $inputFilter->add([ 'name' => 'tags', 'required' => true, 'filters' => [ ['name' => 'StringTrim'], ['name' => 'StripTags'], ['name' => 'StripNewlines'], ], 'validators' => [ [ 'name' => 'StringLength', 'options' => [ 'min' => 1, 'max' => 1024 ], ], ], ]); $inputFilter->add([ 'name' => 'status', 'required' => true, 'validators' => [ [ 'name' => 'InArray', 'options'=> [ 'haystack' => [Post::STATUS_PUBLISHED, Post::STATUS_DRAFT], ] ], ], ]); } } As you can see from the code above, the PostForm class defines a Laminas form with title, content, tags, and status fields. It also has the Submit button. Since we covered forms in details in previous chapters, here we do not explain the code presented above deeply. Adding PostManager Service According to Domain Driven Design pattern, we put business logic into service models. In our Blog sample, we will create and register the PostManager service. This service will have the addNewPost() public method that will contain business logic of adding Post entity to database and associating it with one or several Tag entities. The PostManager service will contain business logic of the Blog sample. This business logic includes, but not limited to, adding new post to the blog. Create the PostManager.php file inside the Service directory under the module's source directory. Put the following content into that file: <?php namespace Application\\Service; use Application\\Entity\\Post; use Application\\Entity\\Comment; use Application\\Entity\\Tag; use Laminas\\Filter\\StaticFilter; // The PostManager service is responsible for adding new posts. class PostManager { /** * Doctrine entity manager. * @var Doctrine\\ORM\\EntityManager */ private $entityManager; // Constructor is used to inject dependencies into the service. public function __construct($entityManager) { $this->entityManager = $entityManager; } // This method adds a new post. public function addNewPost($data) { // Create new Post entity. $post = new Post(); $post->setTitle($data['title']); $post->setContent($data['content']); $post->setStatus($data['status']); $currentDate = date('Y-m-d H:i:s'); $post->setDateCreated($currentDate); // Add the entity to entity manager. $this->entityManager->persist($post); // Add tags to post $this->addTagsToPost($data['tags'], $post); // Apply changes to database. $this->entityManager->flush(); } // Adds/updates tags in the given post. private function addTagsToPost($tagsStr, $post) { // Remove tag associations (if any) $tags = $post->getTags(); foreach ($tags as $tag) { $post->removeTagAssociation($tag); } // Add tags to post $tags = explode(',', $tagsStr); foreach ($tags as $tagName) { $tagName = StaticFilter::execute($tagName, 'StringTrim'); if (empty($tagName)) { continue; } $tag = $this->entityManager->getRepository(Tag::class) ->findOneByName($tagName); if ($tag == null) $tag = new Tag(); $tag->setName($tagName); $tag->addPost($post); $this->entityManager->persist($tag); $post->addTag($tag); } } } In lines 25-43, we have the addNewPost() public method which takes the $data variable as argument (this variable should contain the data entered by the website user into the form). We create a new instance of Post entity (line 28) and fill its properties with user-provided data. We use the EntityManager 's persist() method (line 36) to add the newly created entity to entity manager. The addTagsToPost() private method is called (line 39) to assign the post with one or several tags. And the flush() method is used for applying changes to database in a single transaction (line 42). The addTagsToPost() private method contains logic for removing old associations between the post and tags (lines 49-52), then parsing comma-separated list of tags (line 55), and assigning new tags to the post (lines 56-73). Next, add a factory for the PostManager service. To do that, add the PostManagerFactory.php file under the Service/Factory directory under the module's source directory. Put the following content into that file: <?php namespace Application\\Service\\Factory; use Interop\\Container\\ContainerInterface; use Laminas\\ServiceManager\\Factory\\FactoryInterface; use Application\\Service\\PostManager; /** * This is the factory for PostManager. Its purpose is to instantiate the * service. */ class PostManagerFactory implements FactoryInterface { public function __invoke(ContainerInterface $container, $requestedName, array $options = null) { $entityManager = $container->get('doctrine.entitymanager.orm_default'); // Instantiate the service and inject dependencies return new PostManager($entityManager); } } Finally, we register PostManager service by modifying module.config.php configuration file as follows: <?php //... return [ //... 'service_manager' => [ //... 'factories' => [ Service\\PostManager::class => Service\\Factory\\PostManagerFactory::class, ], ], //... ]; Creating Controller Action and View Template For post management (e.g. adding, editing, viewing and removing posts), we will create the PostController controller class. We create the addAction() action method inside the PostController controller class that will allow to add a new post to blog (see code below): class PostController extends AbstractActionController { /** * Entity manager. * @var Doctrine\\ORM\\EntityManager */ private $entityManager; /** * Post manager. * @var Application\\Service\\PostManager */ private $postManager; /** * Constructor is used for injecting dependencies into the controller. */ public function __construct($entityManager, $postManager) { $this->entityManager = $entityManager; $this->postManager = $postManager; } /** * This action displays the \"New Post\" page. The page contains * a form allowing to enter post title, content and tags. When * the user clicks the Submit button, a new Post entity will * be created. */ public function addAction() { // Create the form. $form = new PostForm(); // Check whether this post is a POST request. if ($this->getRequest()->isPost()) { // Get POST data. $data = $this->params()->fromPost(); // Fill form with data. $form->setData($data); if ($form->isValid()) { // Get validated form data. $data = $form->getData(); // Use post manager service to add new post to database. $this->postManager->addNewPost($data); // Redirect the user to \"index\" page. return $this->redirect()->toRoute('application'); } } // Render the view template. return new ViewModel([ 'form' => $form ]); } } Above, in line 33, we create an instance of PostForm form. In line 36, we check whether this is a POST request. If the request is a POST request, we fill the form with input data and validate the data. In case of valid data, we call the addNewPost() method on the PostManager service (line 49), and redirect the user to the list of posts. To instantiate the PostController , we will need a factory. Create the controller factory by adding the PostControllerFactory.php file to the Controller/Factory directory under the module's source directory: <?php namespace Application\\Controller\\Factory; use Interop\\Container\\ContainerInterface; use Laminas\\ServiceManager\\Factory\\FactoryInterface; use Application\\Service\\PostManager; use Application\\Controller\\PostController; /** * This is the factory for PostController. Its purpose is to instantiate the * controller. */ class PostControllerFactory implements FactoryInterface { public function __invoke(ContainerInterface $container, $requestedName, array $options = null) { $entityManager = $container->get('doctrine.entitymanager.orm_default'); $postManager = $container->get(PostManager::class); // Instantiate the controller and inject dependencies return new PostController($entityManager, $postManager); } } Next, register the PostController controller inside the module.config.php file: <?php //... return [ //... 'controllers' => [ //... 'factories' => [ Controller\\PostController::class => Controller\\Factory\\PostControllerFactory::class, ], ], //... ]; Then, add the posts route for the new controller (modify the module.config.php as follows): <?php //... return [ //... 'router' => [ 'routes' => [ //... 'posts' => [ 'type' => Segment::class, 'options' => [ 'route' => '/posts[/:action[/:id]]', 'constraints' => [ 'action' => '[a-zA-Z][a-zA-Z0-9_-]*', 'id' => '[0-9]*' ], 'defaults' => [ 'controller' => Controller\\PostController::class, 'action' => 'index', ], ], ], ], ], //... ]; Finally, we add the view template. Create the add.phtml file in application/post directory under module's view directory and put the following content into it: <?php $form = $this->form; $form->get('title')->setAttributes([ 'class'=>'form-control', 'placeholder'=>'Enter post title here' ]); $form->get('content')->setAttributes([ 'class'=>'form-control', 'placeholder'=>'Type content here', 'rows'=>6 ]); $form->get('tags')->setAttributes([ 'class'=>'form-control', 'placeholder'=>'comma, separated, list, of, tags' ]); $form->get('status')->setAttributes([ 'class'=>'form-control' ]); $form->get('submit')->setAttributes(['class'=>'btn btn-primary']); $form->prepare(); ?> <h1>Add New Post</h1> <p> Please fill out the following form and click the <i>Create</i> button. </p> <div class=\"row\"> <div class=\"col-md-6\"> <?= $this->form()->openTag($form); ?> <div class=\"form-group\"> <?= $this->formLabel($form->get('title')); ?> <?= $this->formElement($form->get('title')); ?> <?= $this->formElementErrors($form->get('title')); ?> </div> <div class=\"form-group\"> <?= $this->formLabel($form->get('content')); ?> <?= $this->formElement($form->get('content')); ?> <?= $this->formElementErrors($form->get('content')); ?> </div> <div class=\"form-group\"> <?= $this->formLabel($form->get('tags')); ?> <?= $this->formElement($form->get('tags')); ?> <?= $this->formElementErrors($form->get('tags')); ?> <p class=\"help-block\">Separate tags with comma.</p> </div> <div class=\"form-group\"> <?= $this->formLabel($form->get('status')); ?> <?= $this->formElement($form->get('status')); ?> <?= $this->formElementErrors($form->get('status')); ?> </div> <?= $this->formElement($form->get('submit')); ?> <?= $this->form()->closeTag(); ?> </div> </div> Now, if you open the URL http://localhost/posts/add in your web browser, you should see the Add New Post page like shown in figure 12.7 below: Filling the form and clicking the Create button results in saving the new post to database. Then you are able to see the newly created post in the list of posts at the Home page. Editing Existing Post In this section, we will implement the Edit Post page which contains the form allowing to edit the data of existing post, send new data to server and apply changes to database. Site visitor will be able to see the page by entering the following URL in browser's navigation bar: http://localhost/posts/edit/<id> , where <id> is the unique identifier of the post. To implement this page we need the following things: create a form that would allow to enter post title, content, etc. For this page, we can successfully reuse the PostForm form we created earlier (we just rename the Create button caption into Save ). add updatePost() method to the PostManager service. The method would find the post by ID in database and update its data; add convertTagsToString() method to the PostManager service. This method would take the post entity, and on output produce string containing comma-separated list of tags; add the PostController::editAction() action method that would take user input, pass it to models and return data for rendering; and add the edit.phtml view template file that would render the form. Modifying PostManager First, we add the updatePost() and convertTagsToString() methods to the PostManager service model as follows: <?php //... class PostManager { //... // This method allows to update data of a single post. public function updatePost($post, $data) { $post->setTitle($data['title']); $post->setContent($data['content']); $post->setStatus($data['status']); // Add tags to post $this->addTagsToPost($data['tags'], $post); // Apply changes to database. $this->entityManager->flush(); } // Converts tags of the given post to comma separated list (string). public function convertTagsToString($post) { $tags = $post->getTags(); $tagCount = count($tags); $tagsStr = ''; $i = 0; foreach ($tags as $tag) { $i ++; $tagsStr .= $tag->getName(); if ($i < $tagCount) $tagsStr .= ', '; } return $tagsStr; } } Above, we have the updatePost() method (lines 8-19) that takes an existing Post entity, the new title, content, status and the list of tags. It then updates entity's properties and saves changes to database using flush() method. Note Note that the updatePost() method doesn't use the persist() method of entity manager, because here we have existing post, not a new one. Then, we have the convertTagsToString() method (lines 22-36) which takes the post, goes through Tag entities associated with the post and formats and returns the comma-separated list of tags. Adding Controller Action and View Template Next, add the editAction() to PostController controller class as follows: <?php namespace Application\\Controller; //... use Application\\Form\\PostForm; use Application\\Entity\\Post; class PostController extends AbstractActionController { // This action displays the page allowing to edit a post. public function editAction() { // Create the form. $form = new PostForm(); // Get post ID. $postId = $this->params()->fromRoute('id', -1); // Find existing post in the database. $post = $this->entityManager->getRepository(Post::class) ->findOneById($postId); if ($post == null) { $this->getResponse()->setStatusCode(404); return; } // Check whether this post is a POST request. if ($this->getRequest()->isPost()) { // Get POST data. $data = $this->params()->fromPost(); // Fill form with data. $form->setData($data); if ($form->isValid()) { // Get validated form data. $data = $form->getData(); // Use post manager service to add new post to database. $this->postManager->updatePost($post, $data); // Redirect the user to \"admin\" page. return $this->redirect()->toRoute('posts', ['action'=>'admin']); } } else { $data = [ 'title' => $post->getTitle(), 'content' => $post->getContent(), 'tags' => $this->postManager->convertTagsToString($post), 'status' => $post->getStatus() ]; $form->setData($data); } // Render the view template. return new ViewModel([ 'form' => $form, 'post' => $post ]); } } In the code above, we extract the post ID using the fromRoute() method of the params() controller plugin. Then we search for post having such ID using the findOneBy() method provided by the entity repository. Then we check if this is a POST request. If this is the POST request, we fill in and validate the form with POST data. Then we use the updatePost() method of the PostManager service. Finally, create the application/post/edit.phtml file under the module's view directory. Place the following content there: <?php $form = $this->form; $form->get('title')->setAttributes([ 'class'=>'form-control', 'placeholder'=>'Enter post title here' ]); $form->get('content')->setAttributes([ 'class'=>'form-control', 'placeholder'=>'Type content here', 'rows'=>6 ]); $form->get('tags')->setAttributes([ 'class'=>'form-control', 'placeholder'=>'comma, separated, list, of, tags' ]); $form->get('status')->setAttributes([ 'class'=>'form-control' ]); $form->get('submit')->setAttributes(['class'=>'btn btn-primary']); $form->get('submit')->setValue('Save'); $form->prepare(); ?> <h1>Edit Post</h1> <p> Please fill out the following form and click the *Save* button. </p> <div class=\"row\"> <div class=\"col-md-6\"> <?= $this->form()->openTag($form); ?> <div class=\"form-group\"> <?= $this->formLabel($form->get('title')); ?> <?= $this->formElement($form->get('title')); ?> <?= $this->formElementErrors($form->get('title')); ?> </div> <div class=\"form-group\"> <?= $this->formLabel($form->get('content')); ?> <?= $this->formElement($form->get('content')); ?> <?= $this->formElementErrors($form->get('content')); ?> </div> <div class=\"form-group\"> <?= $this->formLabel($form->get('tags')); ?> <?= $this->formElement($form->get('tags')); ?> <?= $this->formElementErrors($form->get('tags')); ?> <p class=\"help-block\">Separate tags with comma.</p> </div> <div class=\"form-group\"> <?= $this->formLabel($form->get('status')); ?> <?= $this->formElement($form->get('status')); ?> <?= $this->formElementErrors($form->get('status')); ?> </div> <?= $this->formElement($form->get('submit')); ?> <?= $this->form()->closeTag(); ?> </div> </div> Now, if you open the URL http://localhost/posts/edit/<id> in your web browser, you should be able to see the Edit Post page that allows to edit an existing post (see the figure 12.8 below): Clicking the Save button results in saving the changes to database. Deleting a Post In this section, we will implement the deleteAction() action of the PostController . This action will allow to delete certain post given its ID. The action will take ID as a GET variable, look if a post with such ID exists, and if exists, deletes the post, its related comments and tag associations. Site visitor will be able to trigger the action by entering the following URL in browser's navigation bar: http://localhost/posts/delete/<id> , where <id> is the unique identifier of the post. Finally, the action redirects the site visitor to the Admin page. Modifying PostManager First, we'll add the removePost() method to the PostManager service. This method will remove the post and its associated comments. It will also remove associations between post and tags. <?php //... class PostManager { //... // Removes post and all associated comments. public function removePost($post) { // Remove associated comments $comments = $post->getComments(); foreach ($comments as $comment) { $this->entityManager->remove($comment); } // Remove tag associations (if any) $tags = $post->getTags(); foreach ($tags as $tag) { $post->removeTagAssociation($tag); } $this->entityManager->remove($post); $this->entityManager->flush(); } } In the code above, we first retrieve all comments associated with the post using the getComments() method of the Post entity. Then we call EntityManager 's remove() method and pass it each comment that we want to remove. Next, we get all tags associated with the post by calling Post 's getTags() method. We remove association between the post and tag (but not tag itself!) with the help of the Post 's removeTagAssociation() method (see below for the code of the method). Finally, we remove the post itself by calling the EntityManager 's remove() method. We apply changes to database with the flush() method. And here is the code of the Post::removeTagAssociation() method: // Removes association between this post and the given tag. public function removeTagAssociation($tag) { $this->tags->removeElement($tag); } Adding Controller Action The PostController::deleteAction() method retrieves the ID of the post to be removed, checks whether this is a valid post ID. If so, it calls the PostManager::removePost() method to remove the post and apply changes to database. Finally, it redirects the site visitor to the Admin page. <?php //.. class PostController extends AbstractActionController { // This \"delete\" action displays the Delete Post page. public function deleteAction() { $postId = $this->params()->fromRoute('id', -1); $post = $this->entityManager->getRepository(Post::class) ->findOneById($postId); if ($post == null) { $this->getResponse()->setStatusCode(404); return; } $this->postManager->removePost($post); // Redirect the user to \"index\" page. return $this->redirect()->toRoute('posts', ['action'=>'admin']); } } Implementing Post Preview In this section, we will create controller's action and its corresponding view template that would allow site visitors to preview certain post by entering the following URL in browser's navigation bar: http://localhost/posts/view/<id> , where <id> is the unique identifier of the post. The page will also allow to add comments to the post using the form located at the bottom of the page. For example of what we are trying to achive, please look at the figure 12.9 below: So, for this we need four things: to create the form that would allow to enter the comment and its author's name; to modify the PostManager and add all necessary business logic; to create PostController::viewAction() controller's action; and to create the view.phtml view template. Adding CommentForm First, we implement the CommentForm form that will allow to add a comment to a post. Create the CommentForm.php file in Form directory under module's source directory. Put the following content into the file: <?php namespace Application\\Form; use Laminas\\Form\\Form; use Laminas\\InputFilter\\InputFilter; /** * This form is used to collect comment data. */ class CommentForm extends Form { // Constructor. public function __construct() { // Define form name parent::__construct('comment-form'); // Set POST method for this form $this->setAttribute('method', 'post'); $this->addElements(); $this->addInputFilter(); } // This method adds elements to form (input fields and submit button). protected function addElements() { // Add \"author\" field $this->add([ 'type' => 'text', 'name' => 'author', 'attributes' => [ 'id' => 'author' ], 'options' => [ 'label' => 'Author', ], ]); // Add \"comment\" field $this->add([ 'type' => 'textarea', 'name' => 'comment', 'attributes' => [ 'id' => 'comment' ], 'options' => [ 'label' => 'Comment', ], ]); // Add the submit button $this->add([ 'type' => 'submit', 'name' => 'submit', 'attributes' => [ 'value' => 'Save', 'id' => 'submitbutton', ], ]); } // This method creates input filter (used for form filtering/validation). private function addInputFilter() { $inputFilter = new InputFilter(); $this->setInputFilter($inputFilter); $inputFilter->add([ 'name' => 'author', 'required' => true, 'filters' => [ ['name' => 'StringTrim'], ], 'validators' => [ [ 'name' => 'StringLength', 'options' => [ 'min' => 1, 'max' => 128 ], ], ], ]); $inputFilter->add([ 'name' => 'comment', 'required' => true, 'filters' => [ ['name' => 'StripTags'], ], 'validators' => [ [ 'name' => 'StringLength', 'options' => [ 'min' => 1, 'max' => 4096 ], ], ], ]); } } As you see from the code above, the CommentForm form contains the author, comment fields, and the Submit button. Since we covered forms in details in previous chapters, here we do not explain the code presented above deeply. Modifying PostManager Here, we add two methods: the getCommentCountStr() method will format the comment count string for the given post (e.g., \"No comments\", \"1 comment\", \"2 comments\", etc.) and the addCommentToPost() method will be used for adding a new comment to post. <?php //... /** * The PostManager service is responsible for adding new posts. */ class PostManager { //... // Returns count of comments for given post as properly formatted string. public function getCommentCountStr($post) { $commentCount = count($post->getComments()); if ($commentCount == 0) return 'No comments'; else if ($commentCount == 1) return '1 comment'; else return $commentCount . ' comments'; } // This method adds a new comment to post. public function addCommentToPost($post, $data) { // Create new Comment entity. $comment = new Comment(); $comment->setPost($post); $comment->setAuthor($data['author']); $comment->setContent($data['comment']); $currentDate = date('Y-m-d H:i:s'); $comment->setDateCreated($currentDate); // Add the entity to entity manager. $this->entityManager->persist($comment); // Apply changes. $this->entityManager->flush(); } } Adding Controller Action and View Template Now, add the PostController::viewAction() method and put the following code there: <?php //... use Application\\Form\\CommentForm; use Application\\Entity\\Comment; class PostController extends AbstractActionController { /** * This action displays the \"View Post\" page allowing to see the post title * and content. The page also contains a form allowing * to add a comment to post. */ public function viewAction() { $postId = $this->params()->fromRoute('id', -1); $post = $this->entityManager->getRepository(Post::class) ->findOneById($postId); if ($post == null) { $this->getResponse()->setStatusCode(404); return; } $commentCount = $this->postManager->getCommentCountStr($post); // Create the form. $form = new CommentForm(); // Check whether this post is a POST request. if($this->getRequest()->isPost()) { // Get POST data. $data = $this->params()->fromPost(); // Fill form with data. $form->setData($data); if($form->isValid()) { // Get validated form data. $data = $form->getData(); // Use post manager service to add new comment to post. $this->postManager->addCommentToPost($post, $data); // Redirect the user again to \"view\" page. return $this->redirect()->toRoute('posts', ['action'=>'view', 'id'=>$postId]); } } // Render the view template. return new ViewModel([ 'post' => $post, 'commentCount' => $commentCount, 'form' => $form, 'postManager' => $this->postManager ]); } } Finally, add the view.phtml view template file and put the following content there: <?php $form = $this->form; $form->get('author')->setAttributes([ 'class'=>'form-control', 'placeholder'=>'Author\\'s name' ]); $form->get('comment')->setAttributes([ 'class'=>'form-control', 'rows'=>6, 'placeholder'=>'Text' ]); $form->get('submit')->setAttributes(['class'=>'btn btn-primary']); $form->prepare(); ?> <a href=\" <?= $this->url('application', ['action'=>'index']); ?>\"> &lt;&lt; Back to list of posts </a> <h1> <?= $this->escapeHtml($post->getTitle()); ?> </h1> <p class=\"comments-header\"> <?= $this->escapeHtml($postManager->getCommentCountStr($post)); ?> | <a href=\"#comment\"> Add new comment </a> </p> <p> Published: <?= $this->escapeHtml(date('jS \\of F Y', strtotime($post->getDateCreated()))); ?> | Tags: <?= $this->escapeHtml($postManager->convertTagsToString($post)); ?> </p> <p> <?= $this->escapeHtml($post->getContent()); ?> </p> <h3><?= $this->escapeHtml($postManager->getCommentCountStr($post)); ?></h3> <?php foreach ($post->getComments() as $comment): ?> <hr> <p> <?= $this->escapeHtml($comment->getAuthor()) ?> on <?= $this->escapeHtml($comment->getDateCreated()); ?> </p> <p> <?= $this->escapeHtml($comment->getContent()); ?> </p> <?php endforeach; ?> <hr> <a name=\"comment\"></a> <h3>Leave Reply</h3> <div class=\"row\"> <div class=\"col-md-8\"> <?= $this->form()->openTag($form); ?> <div class=\"form-group\"> <?= $this->formLabel($form->get('author')); ?> <?= $this->formElement($form->get('author')); ?> <?= $this->formElementErrors($form->get('author')); ?> </div> <div class=\"form-group\"> <?= $this->formLabel($form->get('comment')); ?> <?= $this->formElement($form->get('comment')); ?> <?= $this->formElementErrors($form->get('comment')); ?> </div> <?= $this->formElement($form->get('submit')); ?> <?= $this->form()->closeTag(); ?> </div> </div> Implementing Admin Page Admin page of the Blog sample web application contains the list of all blog posts (either published or drafts), and allows to view, edit and delete posts. To implement this page, add the adminAction() action method to the PostController class, as follows: <?php //.. class PostController extends AbstractActionController { /** * This \"admin\" action displays the Manage Posts page. This page contains * the list of posts with an ability to edit/delete any post. */ public function adminAction() { // Get posts $posts = $this->entityManager->getRepository(Post::class) ->findBy([], ['dateCreated'=>'DESC']); // Render the view template return new ViewModel([ 'posts' => $posts, 'postManager' => $this->postManager ]); } } We will also need to show a post status in text form ('Draft' or 'Published'). Conversion of integer post status to string can be implemented in the getPostStatusAsString() method of PostManager service. Add the getPostStatusAsString() method to PostManager class as follows: /** * Returns status as a string. */ public function getPostStatusAsString($post) { switch ($post->getStatus()) { case Post::STATUS_DRAFT: return 'Draft'; case Post::STATUS_PUBLISHED: return 'Published'; } return 'Unknown'; } Finally, add the corresponding view template file admin.phtml to the application/post directory under module's view directory: <h1>Manage Posts</h1> <p> <a class=\"btn btn-default\" href=\" <?= $this->url('posts', ['action'=>'add']); ?>\"> New Post </a> </p> <table class=\"table table-striped\"> <tr> <th>ID</th> <th>Post Title</th> <th>Date Created</th> <th>Status</th> <th>Actions</th> </tr> <?php foreach ($posts as $post): ?> <tr> <td><?= $this->escapeHtml($post->getId()); ?></td> <td> <a href=\"<?= $this->url('posts', ['action'=>'view', 'id'=>$post->getId()]); ?>\"> <?= $this->escapeHtml($post->getTitle()); ?> </a> </td> <td><?= $this->escapeHtml($post->getDateCreated()); ?></td> <td><?= $this->escapeHtml($postManager->getPostStatusAsString($post)); ?></td> <td> <a class=\"btn btn-info\" href=\"<?= $this->url('posts', ['action'=>'edit', 'id'=>$post->getId()]); ?>\"> <span class=\"glyphicon glyphicon-pencil\" ></span> Edit </a> <a class=\"btn btn-danger\" href=\"<?= $this->url('posts', ['action'=>'delete', 'id'=>$post->getId()]); ?>\"> <span class=\"glyphicon glyphicon-remove\"></span> Delete </a> </td> </tr> <?php endforeach; ?> </table> Now, if you open the URL http://localhost/posts/admin in web browser's navigation bar, you should be able to see the page like in figure 12.10 below: Implementing Tag Cloud Another major feature we implement in the Blog sample will be the tag cloud. The tag cloud appears on the Home page. The tag cloud contains most popular tags, and tag's font size varies depending on popularity of the tag: most popular tags appear larger than less popular ones. Clicking the tag in the tag cloud results in filtering posts by this tag. For example of what we are trying to achieve, please look at the right side of the figure 12.11 below: For this feature, we need the following things: to create the PostRepository custom entity repository class that would encapsulate the complex logic of filtering posts by tag; to modify the PostManager and add functionality for calculating font sizes for the tag cloud; to add controller's action and corresponding view template. Adding Custom Post Repository Earlier we mentioned that by default Doctrine uses the Doctrine\\ORM\\EntityRepository as the default repository class. Custom repository is a class extended from EntityRepository class. It is typically used when you need to encapsulate complex DQL queries and search logic in a single place in your code. Note It is also possible to put the DQL queries to controller class, but that would make controllers \"fat\". Since we use MVC pattern, we strive to avoid that. What is DQL? DQL is similar to SQL in sense that it allows to write and execute queries to database, but the result of a query is an array of objects rather than an array of table rows. For more information on DQL and its usage examples, please refer to this page . For our Blog sample web application, we need a custom repository which allows to find published posts having at least one tag (to calculate total count of tagged posts), and, to find published posts filtered by particular tag. We plan to encapsulate this search logic into the custom PostRepository repository. Note Doctrine works with custom repositories transparently. This means, that you retrieve the repository from EntityManager as usual and still can use its findBy() , findOneBy() and other methods. Create the PostRepository.php file inside the Repository directory under the module's source directory. Below, you can find the code of PostRepository class that has two public methods: the findPostsHavingAnyTag() method is designed to select all posts that have status Published and have one or more tags assigned; and the findPostsByTag() method is designed to return all published posts that have the particular tag assigned (to filter posts by the given tag). <?php namespace Application\\Repository; use Doctrine\\ORM\\EntityRepository; use Application\\Entity\\Post; // This is the custom repository class for Post entity. class PostRepository extends EntityRepository { // Finds all published posts having any tag. public function findPostsHavingAnyTag() { $entityManager = $this->getEntityManager(); $queryBuilder = $entityManager->createQueryBuilder(); $queryBuilder->select('p') ->from(Post::class, 'p') ->join('p.tags', 't') ->where('p.status = ?1') ->orderBy('p.dateCreated', 'DESC') ->setParameter('1', Post::STATUS_PUBLISHED); $posts = $queryBuilder->getQuery()->getResult(); return $posts; } // Finds all published posts having the given tag. public function findPostsByTag($tagName) { $entityManager = $this->getEntityManager(); $queryBuilder = $entityManager->createQueryBuilder(); $queryBuilder->select('p') ->from(Post::class, 'p') ->join('p.tags', 't') ->where('p.status = ?1') ->andWhere('t.name = ?2') ->orderBy('p.dateCreated', 'DESC') ->setParameter('1', Post::STATUS_PUBLISHED) ->setParameter('2', $tagName); $posts = $queryBuilder->getQuery()->getResult(); return $posts; } } In the code above, we use the query builder to conveniently create complex DQL queries. In lines 17-22, we create a query which selects all published posts ordering them by date created in descending order. Because we join posts with tags, here we only select posts which have at least one tag. In line 24, we execute the query. If you are curious what DQL the query builder creates, here it is: SELECT p FROM \\Application\\Entity\\Post p JOIN p.tags t WHERE p.status=?1 ORDER BY p.dateCreated DESC In lines 36-43, we create a query that filters posts by tag name. An analogous DQL is presented below: SELECT p FROM \\Application\\Entity\\Post p JOIN p.tags t WHERE p.status=?1 AND t.name=?2 ORDER BY p.dateCreated DESC Note To learn more about Doctrine query builder, please refer to this page . To let Doctrine know that it should use the custom repository for Post entity, modify the Post entity's annotation as follows: <?php //... /** * This class represents a single post in a blog. * @ORM\\Entity(repositoryClass=\"\\Application\\Repository\\PostRepository\") * @ORM\\Table(name=\"post\") */ class Post { //... } Above, in line 6, we use the repositoryClass parameter of the @ORM\\Entity tag to tell Doctrine that it should use PostRepository repository. Calculating Tag Cloud Business logic for the tag cloud feature will be stored inside of the PostManager::getTagCloud() method, as follows: <?php //... class PostManager { //... // Calculates frequencies of tag usage. public function getTagCloud() { $tagCloud = []; $posts = $this->entityManager->getRepository(Post::class) ->findPostsHavingAnyTag(); $totalPostCount = count($posts); $tags = $this->entityManager->getRepository(Tag::class) ->findAll(); foreach ($tags as $tag) { $postsByTag = $this->entityManager->getRepository(Post::class) ->findPostsByTag($tag->getName()); $postCount = count($postsByTag); if ($postCount > 0) { $tagCloud[$tag->getName()] = $postCount; } } $normalizedTagCloud = []; // Normalize foreach ($tagCloud as $name=>$postCount) { $normalizedTagCloud[$name] = $postCount/$totalPostCount; } return $normalizedTagCloud; } } In the code above, we have the getTagCloud() method that selects all post having at least one tag attached and calculates the \"frequency\" of each available tag (how often the tag appears). Then it normalizes the frequency values (makes them to be between 0 and 1.0). Modifying Controller Action Here we will modify the IndexController to implement tag filter. <?php //... class IndexController extends AbstractActionController { /** * Post manager. * @var Application\\Service\\PostManager */ private $postManager; // Constructor is used for injecting dependencies into the controller. public function __construct($entityManager, $postManager) { $this->entityManager = $entityManager; $this->postManager = $postManager; } public function indexAction() { $tagFilter = $this->params()->fromQuery('tag', null); if ($tagFilter) { // Filter posts by tag $posts = $this->entityManager->getRepository(Post::class) ->findPostsByTag($tagFilter); } else { // Get recent posts $posts = $this->entityManager->getRepository(Post::class) ->findBy(['status'=>Post::STATUS_PUBLISHED], ['dateCreated'=>'DESC']); } // Get popular tags. $tagCloud = $this->postManager->getTagCloud(); // Render the view template. return new ViewModel([ 'posts' => $posts, 'postManager' => $this->postManager, 'tagCloud' => $tagCloud ]); } } The action method will retrieve the tag from the GET variable tag if the variable doesn't present in HTTP request, all posts are retrieved as usual. If the variable present, we use our custom repository's findPostsByTag() method to filter posts. In line 36, we call the PostManager::getTagCloud() that returns array of tags and their frequencies. We use this information for rendering the cloud. Note Please note that we are now using the PostManager service in our controller and have to inject it into the constructor. Do not forget to modify the controller factory to do that. Rendering Tag Cloud Finally, modify the index.phtml file to make it look like follows: <h1>Posts</h1> <div class=\"row\"> <div class=\"col-md-8\"> <?php foreach($posts as $post): ?> <h3> <a href=\"<?= $this->url('posts', ['action'=>'view', 'id'=>$post->getId()]); ?>\"> <?= $this->escapeHtml($post->getTitle()); ?> </a> </h3> <p> Published: <?= $this->escapeHtml(date('jS \\of F Y', strtotime($post->getDateCreated()))); ?> | Tags: <?= $this->escapeHtml($postManager->convertTagsToString($post)); ?> </p> <p class=\"comments-header\"> <?= $this->escapeHtml($postManager->getCommentCountStr($post)); ?> | <a href=\"<?= $this->url('posts', ['action'=>'view', 'id'=>$post->getId()], ['fragment'=>'comment']); ?>\"> Add new comment </a> </p> <p> <?= $this->escapeHtml($post->getContent()); ?> </p> <?php endforeach; ?> </div> <div class=\"col-md-4\"> <div class=\"panel panel-default\"> <div class=\"panel-heading\"> <h3 class=\"panel-title\">Popular Tags</h3> </div> <div class=\"panel-body\"> <?php foreach($this->tagCloud as $tagName=>$frequency): ?> <a href=\"<?= $this->url('application', ['action'=>'index'], ['query'=>['tag'=>$tagName]]); ?>\"> <span style=\"font-size:<?= $this->escapeHtml(0.9 + $frequency*3) ?>em\"> <?= $this->escapeHtml($tagName); ?> </span> </a> <?php endforeach; ?> </div> </div> </div> </div> Implementing Pagination For now we have only several posts on our Posts page. But assume there are many (hundreds of) posts. The page will be loading very slowly. Also, it would be very inconvenient to scroll the page to read all posts. In this situation, pagination would help. Note Pagination is when you divide your results into pages and navigate through pages by clicking page number links on pagination widget. An example of pagination widget styled with Twitter Bootstrap is presented below: Doctrine ORM Paginator The Doctrine\\ORM component provides a paginator class named Paginator living in Doctrine\\ORM\\Tools\\Pagination namespace. It can take a Doctrine Query object as input and provides several methods for getting paged results (we won't discuss those methods here for simplicity). But, Doctrine ORM module doesn't provide any view helpers to visualize the pagination widget. For that, we can use the pagination functionality provided by Laminas Framework. Note Although we plan to use Laminas pagination component, we will still use Doctrine ORM paginator internally for consuming data. Laminas paginator will be just a wrapper for Doctrine ORM paginator. Laminas Paginator In Laminas Framework, pagination is implemented in @ Laminas\\Paginator component. If you haven't installed this component, do so by typing the following command: php composer.phar require laminas/laminas-paginator The @ Laminas\\Paginator component provides the @ Paginator class. Its most useful methods are listed in table 12.6: Method Description setDefaultScrollingStyle($scrollingStyle = 'Sliding') Sets scrolling style. setDefaultItemCountPerPage($count) Sets maximum count of results per page. setCurrentPageNumber($pageNumber) Sets current page number. count() Retuns number of pages. getTotalItemCount() Returns total number of results. getCurrentItems() Gets items on the current page. Table 12.6. Methods of Laminas Paginator class The @ Paginator class is very generic and doesn't know the underlying data model, so you need to have an adapter which provides the data to paginator. The DoctrineORMModule module provides such adapter ( DoctrineORMModule\\Paginator\\Adapter\\DoctrinePaginator class) which we can use to get data from ORM paginator and pass it to Laminas paginator. For example, assume we have a Query with a DQL that selects all published posts. To get the paginated results with this query, we can use the following code: <?php use DoctrineORMModule\\Paginator\\Adapter\\DoctrinePaginator as DoctrineAdapter; use Doctrine\\ORM\\Tools\\Pagination\\Paginator as ORMPaginator; use Laminas\\Paginator\\Paginator; // Create Laminas paginator. $adapter = new DoctrineAdapter(new ORMPaginator($query, false)); $paginator = new Paginator($adapter); // Set page number and page size. $paginator->setDefaultItemCountPerPage(10); $paginator->setCurrentPageNumber(1); // Walk through the current page of results. foreach ($paginator as $post) { // Do something with the current post. } Now let's apply this example to our Blog application. We want to display the paginated posts on the main page of the Blog website. Modifying PostRepository First of all, we'll have to slightly modify the way we get the list of posts. Previously, we used the findBy() method of the EntityRepository , which returns array of posts. But now we'll have to do that with our custom repository class PostRepository , because Doctrine ORM paginator takes Query object on input, not an array of posts. Add the following method to PostRepository class: public function findPublishedPosts() { $entityManager = $this->getEntityManager(); $queryBuilder = $entityManager->createQueryBuilder(); $queryBuilder->select('p') ->from(Post::class, 'p') ->where('p.status = ?1') ->orderBy('p.dateCreated', 'DESC') ->setParameter('1', Post::STATUS_PUBLISHED); return $queryBuilder->getQuery(); } And change the findPostsByTag() method, because we want it to also return Query instead of array : public function findPostsByTag($tagName) { $entityManager = $this->getEntityManager(); $queryBuilder = $entityManager->createQueryBuilder(); $queryBuilder->select('p') ->from(Post::class, 'p') ->join('p.tags', 't') ->where('p.status = ?1') ->andWhere('t.name = ?2') ->orderBy('p.dateCreated', 'DESC') ->setParameter('1', Post::STATUS_PUBLISHED) ->setParameter('2', $tagName); return $queryBuilder->getQuery(); } You will also need to slightly modify the PostManager::getTagCloud() method, because it expects an array of posts, but now it will receive the Query . It is a simple and obvious modification, so we won't describe how to do that (refer to Blog sample for the complete code). Modifying IndexController Next, modify the indexAction() method of the IndexController as follows: <?php namespace Application\\Controller; // Add aliases for paginator classes use DoctrineORMModule\\Paginator\\Adapter\\DoctrinePaginator as DoctrineAdapter; use Doctrine\\ORM\\Tools\\Pagination\\Paginator as ORMPaginator; use Laminas\\Paginator\\Paginator; // ... class IndexController extends AbstractActionController { // ... public function indexAction() { $page = $this->params()->fromQuery('page', 1); $tagFilter = $this->params()->fromQuery('tag', null); if ($tagFilter) { // Filter posts by tag $query = $this->entityManager->getRepository(Post::class) ->findPostsByTag($tagFilter); } else { // Get recent posts $query = $this->entityManager->getRepository(Post::class) ->findPublishedPosts(); } $adapter = new DoctrineAdapter(new ORMPaginator($query, false)); $paginator = new Paginator($adapter); $paginator->setDefaultItemCountPerPage(1); $paginator->setCurrentPageNumber($page); // Get popular tags. $tagCloud = $this->postManager->getTagCloud(); // Render the view template. return new ViewModel([ 'posts' => $paginator, 'postManager' => $this->postManager, 'tagCloud' => $tagCloud ]); } } You can notice that in line 16 we get the current page number from a GET parameter. So, you can set the page of results by entering the following URL in your browser: http://localhost/application/index?page=<page> \". The default page number is 1. In lines 22 and 27, we retrieve the Query object from our PostRepository instead of array of posts. We then pass this Query object to the Laminas paginator in line 31. In lines 33-34 we set current page number and page size on the paginator. In line 41, we pass the paginator (!) instead of array of posts for rendering to view template. Visualizing the Pagination Widget Now it's left the last but not least part of our work. We need to display the pagination widget in our view template. To do that with nice Bootstrap styling, we will need to first create a partial view template view/application/partial/paginator.phtml and put the following code into that file: <?php if ($this->pageCount): ?> <nav> <ul class=\"pagination\"> <!-- Previous page link --> <?php if (isset($this->previous)): ?> <li> <a href=\"<?= $this->url($this->route, [], ['query'=>['page'=>$this->previous]]); ?>\" aria-label=\"Previous\"> <span aria-hidden=\"true\">&laquo;</span> </a> </li> <?php else: ?> <li> <span aria-hidden=\"true\">&laquo;</span> </li> <?php endif; ?> <!-- Numbered page links --> <?php foreach ($this->pagesInRange as $page): ?> <?php if ($page != $this->current): ?> <li> <a href=\"<?= $this->url($this->route, [], ['query'=>['page'=>$page]]); ?>\"><?= $this->escapeHtml($page); ?></a> </li> <?php else: ?> <li> <span aria-hidden=\"true\"><b><?= $this->escapeHtml($page); ?></b></span> </li> <?php endif; ?> <?php endforeach; ?> <!-- Next page link --> <?php if (isset($this->next)): ?> <li> <a href=\"<?php echo $this->url($this->route, [], ['query'=>['page'=>$this->next]]); ?>\" aria-label=\"Next\"> <span aria-hidden=\"true\">&raquo;</span> </a> </li> <?php else: ?> <li> <span aria-hidden=\"true\">&raquo;</span> </li> <?php endif; ?> </ul> </nav> <?php endif; ?> The partial view template will be used by the Laminas @ PaginationControl view helper to visualize the pagination widget. As you can see, this partial view template takes several input variables ( $pageCount , pagesInRange , $current , $previous , $next , $route ) that are used to control how the widget will look like. Now let's display the widget on our view/application/index/index.phtml view template below the list of posts, as follows: <?= $this->paginationControl($posts, 'Sliding', 'application/partial/paginator', ['route' => 'application']); ?> The @ PaginationControl view helper accepts four arguments: the $posts is the @ Paginator object that we passed from controller's action with the @ ViewModel [Laminas\\View\\Model\\ViewModel] variable container. the \"Sliding\" argument is the style of pagination. For additional info on available pagination styles, please refer to Laminas Framework documentation. the \"application/partial/paginator\" is the name of the partial view template containing the markup for the pagination widget. the fourth argument can be used to pass parameters to the partial view template. For example we pass it the route parameter, which is used to generate clickable page links. Results Hooray! Our blog application is ready now. The main page of the website now contains a nice looking pagination widget (see the figure 12.13 below): Note In this chapter we implemented only the simplest pagination. For real websites, in addition to pagination, you might also want to allow interactively sorting your results by certain fields. For such complex tabular data display, consider using the DataTables or BootGrid jQuery plugins. Summary Doctrine is not part of Laminas Framework, but we cover its usage in this book because it provides an easy way of accessing a database and providing object persistence to your application. In this chapter, we've covered the usage of the Object Relational Mapper (ORM) component of the Doctrine library. The ORM is designed for database management in an object-oriented style. With ORM, you map a database table to a PHP class known as an entity. Columns of that table are mapped to the properties of the entity class. To load data from the database, you retrieve an entity from its repository. The repository is a class that can be considered as a collection of all available entities. The repository loads data from the corresponding database table, and fills one or more entity instance's fields with that data. The tree in figure 12.5 may be different than you have in your own application, because some keys were omitted here for simplicity. \u21a9 Doctrine-provided annotation tags are implemented as classes living inside of Doctrine\\ORM\\Mapping namespace. This is to avoid annotation naming collisions (assume the case when some other component has an annotation named Entity or Table , the collision would happen). \u21a9","title":"Database Management with Doctrine ORM"},{"location":"doctrine/#database-management-with-doctrine-orm","text":"Doctrine is an open-source PHP library providing convenient methods for managing your database in an object-oriented way. For working with relational databases, Doctrine provides a component named Object Relational Mapper (ORM for short). With Doctrine ORM you map your database table to a PHP class (in terms of Domain Driven Design, it is also called an entity class) and a row from that table is mapped to an instance of the entity class. If you are new to Doctrine, it is recommended that you also refer to Appendix D. Introduction to Doctrine for introductory information about the Doctrine library architecture. Note Doctrine is a third-party library, it is not part of Laminas Framework. We cover it in this book because it provides an easy way of adding database support to your laminas-based web application. Components covered in this chapter: Component Description Doctrine\\ORM Implements Object-Relational Mapper. DoctrineORMModule Easy integration of Doctrine ORM with Laminas. @ Laminas\\Paginator Support of pagination.","title":"Database Management with Doctrine ORM"},{"location":"doctrine/#get-blog-example-from-github","text":"For demonstration of Doctrine ORM usage, in this chapter, we will create a real-life Blog website. Its main features are the following: It will store blog posts in a database and provide a user interface for accessing and managing those posts. It is assumed that the blog has the single author of its posts, while comments can be added by multiple blog readers. The website will have two pages: Home page and Admin page. The first one will display the list of recently added posts, while the latter one will allow to add, edit, view and delete posts. For example screen shots of the Blog website, please look at the figures 12.1 and 12.2 below: To download the Blog application, visit this page and click the Clone or Download button to download the code as a ZIP archive. When download is complete, unpack the archive to some directory. Then navigate to the blog directory containing the source code of the Blog web application: /using-laminas-book-samples /blog ... The Blog is a sample website which can be installed on your machine. To install the sample, you can either edit your default Apache virtual host file or create a new one. After editing the file, restart the Apache HTTP Server and open the website in your web browser. For detailed installation instructions, please refer to the README.md file located in the blog directory. For the Blog sample to work, you have to create a MySQL database. Instructions on how to do that are provided in the next section.","title":"Get Blog Example from GitHub"},{"location":"doctrine/#creating-a-simple-mysql-database","text":"For the Blog sample to work, we need to have a database. In this book, we use MySQL database management system, which is very simple in installation and administration. Note For OS-specific instructions on how to install MySQL server and client, please refer to Appendix A. Configuring Web Development Environment . Once you install MySQL, type the following command from your command shell to log into MySQL client console: mysql -u root -p When asked for, type the password of the root user (the password of the root user is the one you've specified during MySQL server installation). On successful login, you should see the following welcome message: Welcome to the MySQL monitor. Commands end with ; or \\g. Your MySQL connection id is 4 Server version: 5.7.13-0ubuntu0.16.04.2 (Ubuntu) Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved. Oracle is a registered trademark of Oracle Corporation and/or its affiliates. Other names may be trademarks of their respective owners. Type 'help;' or '\\h' for help. Type '\\c' to clear the current input statement. mysql> Now you are able to type MySQL client commands (like show databases , show tables , etc.) or SQL queries (like SELECT or INSERT ) at the MySQL prompt and see their output. If you want to quit of the MySQL prompt, type quit and press Enter.","title":"Creating a Simple MySQL Database"},{"location":"doctrine/#creating-new-database","text":"Let's create a database and name it blog . To do that, type the following SQL statement and press Enter: CREATE DATABASE blog; The expected output of this command is the following: Query OK, 1 row affected (0.01 sec) Note MySQL commands are case insensitive, so you could type create database blog; with the same result. We recommend using upper case for SQL queries, since this is a common convention. Next, we create the user named blog and grant it all privileges for accessing and modifying the blog database and all its tables: GRANT ALL PRIVILEGES ON blog.* TO blog@localhost IDENTIFIED BY '<passwd>'; In the command above, replace the password placeholder with the new password for the blog user. This password should be different than the password of the root user. Important Here, we create the second user blog , because it is not recommended to give the web application ability to log into database under the root user. The root user has unlimited rights and it is poor security practice to give an application the ability to do any actions it wants. The blog user will have permissions to modify the blog database only, which is sufficient in our case. You can check that the database has been created by typing the following command and pressing Enter: show databases; You should be able to see the output like below (note the blog line in the list of databases): +--------------------+ | Database | +--------------------+ | information_schema | | blog | | mysql | | performance_schema | +--------------------+","title":"Creating New Database"},{"location":"doctrine/#creating-tables","text":"Next, we will create three tables typical for any simple blog: the post table will contain posts, the comment table will contain comments to posts, and, finally, the tag table will contain tags (a tag is some kind of a key word describing a blog post well). Additionally, we will create the fourth auxiliary table post_tag that will be used to create many-to-many relationship between the post and the tag tables. Make the blog database current by typing the following from MySQL command prompt: use blog; To create the post table, type the following SQL statement: CREATE TABLE `post` ( `id` int(11) PRIMARY KEY AUTO_INCREMENT, `title` text NOT NULL, `content` text NOT NULL, `status` int(11) NOT NULL, `date_created` datetime NOT NULL ); Note MySQL client allows easy entering of multi-line commands. Just press Enter when you want to move the caret to the next line. The command is considered to be fully entered when the semicolon (;) character is encountered. The expected output of this command is the following: Query OK, 0 rows affected (0.22 sec) Next, create the comment table by typing the following: CREATE TABLE `comment` ( `id` int(11) PRIMARY KEY AUTO_INCREMENT, `post_id` int(11) NOT NULL, `content` text NOT NULL, `author` varchar(128) NOT NULL, `date_created` datetime NOT NULL ); Then, create the tag table: CREATE TABLE `tag` ( `id` int(11) PRIMARY KEY AUTO_INCREMENT, `name` VARCHAR(128) ); And finally, create the post_tag table: CREATE TABLE `post_tag` ( `id` int(11) PRIMARY KEY AUTO_INCREMENT, `post_id` int(11) NOT NULL, `tag_id` int(11) NOT NULL ); Let's fill the tables we have created with some sample data: INSERT INTO tag(`name`) VALUES('Laminas'); INSERT INTO tag(`name`) VALUES('book'); INSERT INTO tag(`name`) VALUES('magento'); INSERT INTO tag(`name`) VALUES('bootstrap'); INSERT INTO post(`title`, `content`, `status`, `date_created`) VALUES( 'A Free Book about Laminas Framework', 'I''m pleased to announce that now you can read my new book \"Using Laminas Framework\" absolutely for free! Moreover, the book is an open-source project hosted on GitHub, so you are encouraged to contribute.', 2, '2016-08-09 18:49'); INSERT INTO post(`title`, `content`, `status`, `date_created`) VALUES( 'Getting Started with Magento Extension Development - Book Review', 'Recently, I needed some good resource to start learning Magento e-Commerce system for one of my current web projects. For this project, I was required to write an extension module that would implement a customer-specific payment method.', 2, '2016-08-10 18:51'); INSERT INTO post(`title`, `content`, `status`, `date_created`) VALUES( 'Twitter Bootstrap - Making a Professionaly Looking Site', 'Twitter Bootstrap (shortly, Bootstrap) is a popular CSS framework allowing to make your website professionally looking and visually appealing, even if you don''t have advanced designer skills.', 2, '2016-08-11 13:01'); INSERT INTO post_tag(`post_id`, `tag_id`) VALUES(1, 1); INSERT INTO post_tag(`post_id`, `tag_id`) VALUES(1, 2); INSERT INTO post_tag(`post_id`, `tag_id`) VALUES(2, 2); INSERT INTO post_tag(`post_id`, `tag_id`) VALUES(2, 3); INSERT INTO post_tag(`post_id`, `tag_id`) VALUES(3, 4); INSERT INTO comment(`post_id`, `content`, `author`, `date_created`) VALUES( 1, 'Excellent post!', 'Oleg Krivtsov', '2016-08-09 19:20'); Note If necessary, you can easily remove the database and all tables and data it contains by typing the following command from MySQL prompt: DROP DATABASE blog; Figure 12.3 graphically illustrates what entities we have in the database and what relationships between those entities present. As you can see from figure 12.3, the post table is related to comment table as one-to-many , because a single post may have many comments. This is also called the \"one-to-many\" relationship. The post table is also related to the tag table as many-to-many . A single post may have many tags, and a single tag may belong to many posts as well. Many-to-many relationship is typically implemented through an auxiliary table ( post_tag table in our case).","title":"Creating Tables"},{"location":"doctrine/#importing-ready-database-schema","text":"In the previous section, we've shown how to create the complete database schema that is used in the Blog sample web application. In the real life, you typically do not type all those SQL statements at the MySQL prompt. Instead, you could type the CREATE TABLE statements to a file and save it to disk. Then you could just import that file and have the ready schema. For your convenience, the ready schema for Blog sample can be found in APP_DIR/data/schema.mysql.sql file. The file is a plain text file containing SQL statements. To import the file, go to the APP_DIR/data/ directory and type the following command from your command shell (but not from MySQL prompt): mysql -u root -p blog < schema.mysql.sql When prompted for password, enter the password of the root user and press Enter. Once this is done, log into the MySQL client and type the following commands: use blog; show tables; You should see the list of tables created, something like below: +----------------+ | Tables_in_blog | +----------------+ | comment | | post | | post_tag | | tag | +----------------+ 4 rows in set (0.00 sec) Note Also consider using database migrations for initializing database schema. For additional info about migrations, please refer to Database Migrations chapter.","title":"Importing Ready Database Schema"},{"location":"doctrine/#integrating-doctrine-orm-with-laminas-framework","text":"For easy integration with Laminas Framework, Doctrine project provides the following two components (that are actually Laminas modules): DoctrineModule is a Laminas module that provides Doctrine basic functionality required by the ORM component; DoctrineORMModule integrates Doctrine Object Relational Mapper (ORM) with Laminas Framework. Each of the above Doctrine components is distributed as a Composer-installable package and is registered in Packagist.org catalogue. This is very similar to the way that Laminas Framework uses for installing its components. Since Composer packages may depend on each other, it is enough to declare dependency only on DoctrineORMModule . This package depends on DoctrineModule and on some other Doctrine components ( Doctrine\\ORM , Doctrine\\DBAL , Doctrine\\Common , Doctrine\\Annotations , etc.). So, when you install this component, Composer will install other required components automatically.","title":"Integrating Doctrine ORM with Laminas Framework"},{"location":"doctrine/#installing-doctrine-components-with-composer","text":"In order to install required Doctrine components, we first add a dependency to the composer.json file located in the root directory of the web application (in this book, we typically denote that directory as APP_DIR ). To add the dependency, type the following commands from your command shell (replace the APP_DIR placeholder with the actual directory name of your application): cd APP_DIR php composer.phar require doctrine/doctrine-orm-module The cd command above is used to make the APP_DIR directory current working directory. And the require command tells Composer to add the package doctrine/doctrine-orm-module as a dependency to your web application, and to download and install that dependency. Once you run the commands above, Composer will first modify the composer.json file and create the line like below under its require key: { ... \"require\": { \"doctrine/doctrine-orm-module\": \"^1.0.9\", ... }, ... } Then Composer will try to locate the dependency packages, download them to the local machine and install the files into the APP_DIR/vendor directory. Composer will output lines indicating installation process to the terminal. As you can see from the Composer output, when you install DoctrineORMModule component, Composer automatically installs the DoctrineModule and all necessary Doctrine components ( Doctrine\\DBAL , Doctrine\\ORM , etc.) Note As a bonus, at the end of installation, Composer \"suggests\" you to install some additional packages that might be useful for you ( doctrine/migrations , doctrine/data-fixtures , etc.) If you strongly wish, you may add those dependencies with the Composer's require command as well. When the installation has been finished, you can find the Doctrine files in your APP_DIR/vendor directory (see the figure 12.4 below). Note You use the php composer.phar require command for the first time you install Doctrine. Once the composer.json (and composer.lock ) files have been modified by Composer, you are able to install (or update) all dependencies as usual by typing the php composer.phar install or php composer.phar update commands, respectively, from your command shell.","title":"Installing Doctrine Components with Composer"},{"location":"doctrine/#loading-doctrine-integration-modules-on-application-start-up","text":"Once you have installed the DoctrineORMModule and all its dependencies, you need to add the following lines to your APP_DIR/config/modules.config.php file to enable the modules: <?php return [ // Add the Doctrine integration modules. 'DoctrineModule', 'DoctrineORMModule', //... ); The lines above let Laminas know that it should load the DoctrineModule module and DoctrineORMModule module on application start up.","title":"Loading Doctrine Integration Modules on Application Start Up"},{"location":"doctrine/#doctrine-configuration-overview","text":"To use Doctrine with your laminas-based web application, you have to provide its configuration. The configuration tells Doctrine what databases present, how to connect to a database (what database driver, host, user name and password to use), where to locate entity classes and how to extract their annotations (metadata), how to store cached data (in the file system or to use a caching extension), and so on. This section's goal is to give you a general idea of how Doctrine configuration looks like. The default Doctrine configuration is located in the module.config.php config file of the DoctrineORMModule . Look at the figure 12.5 below to have an idea of how the Doctrine config \"tree\" may look like 1 . You may also refer to the module.config.php file of DoctrineORMModule for the same reason. As you can see from the figure 12.5, there is the top-level key named doctrine . Under that key, there is a number of subkeys containing the following settings: the connection key contains the list of all databases that the web application is able to connect to. For each database connection it contains parameters like driver class name, host, user name, password and database name. Note By default, there is only one connection named orm_default , and you may add more database connections if required. the configuration key contains ORM settings like caching configuration and locations of auto-generated entity proxy classes for each available connection. the driver key contains the information about where to locate entity classes for each available database connection. the entitymanager key contains settings used for instantiating an entity manager for each database connection. the eventmanager key contains settings for Doctrine event manager for each available connection. Note Doctrine uses its own implementation of event manager. If you want, you can create an event listener class and hooks some events. However, this is an advanced topic and we do not cover it in this book. the migrations_configuration key contains settings for database migrations. Database migrations are used for initializing and updating database schema in a standard and consistent way.","title":"Doctrine Configuration Overview"},{"location":"doctrine/#overriding-the-default-doctrine-configuration","text":"As you already know from Website Operation chapter, in a laminas-based web application configuration is typically divided into two categories: application-wide configuration and module-specific configuration. For storing application-wide Doctrine settings, you typically use the APP_DIR/config/autoload/global.php or APP_DIR/config/autoload/local.php config files. The first one suits well for storing settings not depending on particular environment, while the latter one suits well for storing environment-dependent settings (like database connection parameters). For storing Doctrine settings specific to certain module, you use the module.config.php config file located inside the config directory of that module. This is suitable, for example, for storing the entity location settings. When laminas-based website loads its configuration, it merges all configs into a single big array, thus forming the final Doctrine config \"tree\". By adding your application-specific Doctrine configuration, you extend and/or override the default configuration tree provided by the DoctrineORMModule .","title":"Overriding the Default Doctrine Configuration"},{"location":"doctrine/#specifying-database-connection-parameters","text":"Below we provide content of the autoload/local.php file of the Blog web application. This config file contains the application-wide database connection settings for the blog MySQL database that we created earlier in this chapter: Note This connection is shared between all modules of the web application. If you want to create module-specific connection, consider adding the key to the module.config.php file instead. <?php use Doctrine\\DBAL\\Driver\\PDOMySql\\Driver as PDOMySqlDriver; return [ 'doctrine' => [ 'connection' => [ 'orm_default' => [ 'driverClass' => PDOMySqlDriver::class, 'params' => [ 'host' => '127.0.0.1', 'user' => 'blog', 'password' => '<password>', 'dbname' => 'blog', ] ], ], ], ]; Above, we have the doctrine key and connection subkey. The connection subkey contains the orm_default subkey which is the default connection. The driverClass key provides the class name to use as a driver to the database. Since we use MySQL database, we specify the Doctrine\\DBAL\\Driver\\PDOMySql\\Driver class name. For your reference, in table 12.1, you can find several other often used database drivers. Each driver class supports its own set of parameters, so please refer to certain driver's code (and related documentation) for additional information. The params key contains the connection parameters: host may be either the domain name or IP address of the database server; user is the MySQL user name with granted permissions to the database; password is the secret word for the user name; dbname is the name of the database. Method Description Doctrine\\DBAL\\Driver\\PDOSqlite\\Driver SQLite driver using PDO PHP extension. Doctrine\\DBAL\\Driver\\PDOMySql\\Driver MySQL driver using PDO PHP extension. Doctrine\\DBAL\\Driver\\PDOOracle\\Driver Oracle driver using PDO PHP extension. Doctrine\\DBAL\\Driver\\PDOPgSql\\Driver PostgreSQL driver using PDO PHP extension. Doctrine\\DBAL\\Driver\\PDOSqlsrv\\Driver MS SQL Server driver using PDO PHP extension. Table 12.1. Often Used Database Driver Classes Important Because the autoload/local.php file contains environment-specific parameters, you only store its \"distribution template\", local.php.dist file, in version control. Each developer in your team then renames the local.php.dist file to local.php and enters his own password instead of the placeholder. The local.php file should not be version controlled, because you usually do not want other people on your team (or other people having access to your code repository) seeing the actual password. What happens if I need several database connections? You can easily add more database connections by adding other keys below the orm_default key. For example, let's assume that you have another database for testing purposes. To let Doctrine know about this database, you create the orm_test subkey below the orm_default key and fill it with connection parameters.","title":"Specifying Database Connection Parameters"},{"location":"doctrine/#about-doctrine-entities","text":"An entity is a PHP class that is designed for storing data. For example, below you can find several often used examples of entities: User entity is designed to store information about a website visitor. It may contain properties like username, password, first name, last name, etc. License entity is designed to store information about a software license. It may contain data like unique license key, reference to user who purchased the license, license creation date, etc. Payment entity may contain properties related to a purchase of some goods. The properties are: transaction ID, money amount, money currency, etc. Note In terms of Domain Driven Design pattern, entities are a kind of models designed for storing data. For additional examples of entities and other types of models, please refer to Model-View-Controller . In Doctrine ORM, an entity class is mapped on a certain database table. For example, the User entity is usually mapped on the user table (if needed, the table name may be arbitrary). For our Blog example application, we will create three entity classes: Post entity will contain data related to specific blog post. Its properties are exactly the same that we used when defining the post table in blog database schema. The entity class will also have public getter and setter methods designed for retrieving/setting the data. by analogy, Comment entity will contain data related to a comment to blog post. and Tag entity will contain data related to a tag.","title":"About Doctrine Entities"},{"location":"doctrine/#annotations","text":"An annotation is a special kind of a PHP comment that is preprocessed by Doctrine ORM. In other words, annotations is metadata attached to an entity class that can be read by the Doctrine ORM at run-time. Annotations provide verbose information about an entity. Annotations describe an entity and tell Doctrine ORM how to map it on a database table. A Docblock annotation is a C++ style comment starting with slash (/) and two asterisks (*). This \"starter\" characters are required, otherwise Doctrine won't recognize the annotation. An example of annotation can be found below: /** * This is Docblock annotation comment. */ Doctrine reads Docblock annotations with the help of its Doctrine\\Annotations component. Note You might have already seen Docblock annotations if you've used phpDocumentor or Doxygen documentation generation tools. In those tools, annotation comments are serving the same goal: to describe a PHP class and its properties and methods. Then the tool goes through your code and builds HTML documentation automatically based entirely on code and annotations analysis. For example, below, we provide the basic example of a Doctrine entity class. You can see that the class and its properties are marked with Docblock annotations with special tags (a tag starts with '@' character). <?php namespace Application\\Entity; use Doctrine\\ORM\\Mapping as ORM; /** * @ORM\\Entity * @ORM\\Table(name=\"post\") */ class Post { /** * @ORM\\Id * @ORM\\GeneratedValue * @ORM\\Column(name=\"id\") */ protected $id; /** * @ORM\\Column(name=\"title\") */ protected $title; /** * @ORM\\Column(name=\"content\") */ protected $content; /** * @ORM\\Column(name=\"status\") */ protected $status; /** * @ORM\\Column(name=\"date_created\") */ protected $dateCreated; } Let's review the code above: In line 2, we declared the Application\\Entity namespace in which entity classes for the Application module live. In line 4, you may notice that we use the Doctrine\\ORM\\Mapping class and its short ORM alias for Doctrine annotations 2 . In lines 6-9, you can see a Docblock annotation for the Post class. Each annotation tag begins with the @ character, has the name and (optional) parameters enclosed into the round braces. Doctrine-provided tags used in annotations may be of two types: class-level and property-level. In the code above, we use the following class-level tags (describing the whole entity class): @ORM\\Entity tag (line 7) declares that this class is a Doctrine ORM entity; @ORM\\Table(name=\"post\") tag (line 8) tells Doctrine ORM that this entity class is mapped on the post database table; Entity's properties are described with the following property-level tags: @ORM\\Id tells that this property is actually a unique identifier of the entity (see line 13); @ORM\\GeneratedValue is used to tell Doctrine ORM that this property uses some auto-generated sequence for initializing itself (line 14). In MySQL, this typically means that the corresponding table column uses AUTO_INCREMENT initializer. @ORM\\Column(name=\"<column_name>\") is used to tell Doctrine ORM on which table column to map this particular property (lines 15, 20, 25, 30, 35). Note The complete list of Doctrine-provided tags used in annotations can be found by the following link .","title":"Annotations"},{"location":"doctrine/#creating-entities","text":"For the Application module, entities are (by convention) stored inside the Entity directory under the module's source directory. Entity classes live inside the Application\\Entity namespace.","title":"Creating Entities"},{"location":"doctrine/#adding-post-entity","text":"We start with creating the Post entity. Create the Post.php file under module's Entity directory. (If you haven't created the Entity directory yet, its the right time to do that.) Put the following code into the file: <?php namespace Application\\Entity; use Doctrine\\ORM\\Mapping as ORM; /** * This class represents a single post in a blog. * @ORM\\Entity * @ORM\\Table(name=\"post\") */ class Post { // Post status constants. const STATUS_DRAFT = 1; // Draft. const STATUS_PUBLISHED = 2; // Published. /** * @ORM\\Id * @ORM\\GeneratedValue * @ORM\\Column(name=\"id\") */ protected $id; /** * @ORM\\Column(name=\"title\") */ protected $title; /** * @ORM\\Column(name=\"content\") */ protected $content; /** * @ORM\\Column(name=\"status\") */ protected $status; /** * @ORM\\Column(name=\"date_created\") */ protected $dateCreated; // Returns ID of this post. public function getId() { return $this->id; } // Sets ID of this post. public function setId($id) { $this->id = $id; } // Returns title. public function getTitle() { return $this->title; } // Sets title. public function setTitle($title) { $this->title = $title; } // Returns status. public function getStatus() { return $this->status; } // Sets status. public function setStatus($status) { $this->status = $status; } // Returns post content. public function getContent() { return $this->content; } // Sets post content. public function setContent($content) { $this->content = $content; } // Returns the date when this post was created. public function getDateCreated() { return $this->dateCreated; } // Sets the date when this post was created. public function setDateCreated($dateCreated) { $this->dateCreated = $dateCreated; } } In the code above, we have the following things: Status constants (lines 14 and 15). These constants conveniently represent possible values the $status property may receive (1 for Draft, 2 for Published). Protected properties ( $title , $content , $dateCreated , etc.). These are data that a typical blog post has (see table 12.2 below for reference of properties together with their brief descriptions). Note Please note that for properties we (by convention) use camel-case names (like $dateCreated ), while for database columns we use \"canonicalized\" names (in lower-case and with underscores separating words in a name, like date_created ). Property Mapped on Column Description $id id Unique ID of this post. $title title Title of this post. $content content Content of this post. $status status Status (draft/published) of this post. $dateCreated date_created Date when this post was created. Table 12.2. Properties of the Post entity Entity class and its properties are marked with Docblock annotations read by Doctrine ORM at run-time allowing it to know how to map this entity and its properties on the database table and its columns. Entity class has getter and setter methods (lines 45-102) allowing to access/modify the protected properties (see the table 12.3 for reference of methods and their brief descriptions). Method Description getId() Returns ID of this post. setId($id) Sets ID of this post. getTitle() Returns title. setTitle($title) Sets title. getStatus() Returns status (draft/published). setStatus($status) Sets status. getContent() Returns post content. setContent($content) Sets post content. getDateCreated() Returns the date when this post was created. setDateCreated() Sets the date when this post was created. Table 12.3. Getter and setter methods of the Post entity Note Note that we do not mark entity class methods with Doctrine annotations. There is just no need to do that. However, you may mark methods with usual comments and non-Doctrine Docblock annotations, if you strongly wish.","title":"Adding Post Entity"},{"location":"doctrine/#adding-the-comment-and-tag-entities","text":"By analogy with the Post entity, we next create the Comment and the Tag entity classes in the Entity directory. To do that, first, create Comment.php file and put the following code inside of it: <?php namespace Application\\Entity; use Doctrine\\ORM\\Mapping as ORM; /** * This class represents a comment related to a blog post. * @ORM\\Entity * @ORM\\Table(name=\"comment\") */ class Comment { /** * @ORM\\Id * @ORM\\Column(name=\"id\") * @ORM\\GeneratedValue */ protected $id; /** * @ORM\\Column(name=\"content\") */ protected $content; /** * @ORM\\Column(name=\"author\") */ protected $author; /** * @ORM\\Column(name=\"date_created\") */ protected $dateCreated; // Returns ID of this comment. public function getId() { return $this->id; } // Sets ID of this comment. public function setId($id) { $this->id = $id; } // Returns comment text. public function getContent() { return $this->content; } // Sets status. public function setContent($content) { $this->content = $content; } // Returns author's name. public function getAuthor() { return $this->author; } // Sets author's name. public function setAuthor($author) { $this->author = $author; } // Returns the date when this comment was created. public function getDateCreated() { return $this->dateCreated; } // Sets the date when this comment was created. public function setDateCreated($dateCreated) { $this->dateCreated = $dateCreated; } } Next, create Tag.php file and put the following code inside of it: <?php namespace Application\\Entity; use Doctrine\\ORM\\Mapping as ORM; /** * This class represents a tag. * @ORM\\Entity * @ORM\\Table(name=\"tag\") */ class Tag { /** * @ORM\\Id * @ORM\\GeneratedValue * @ORM\\Column(name=\"id\") */ protected $id; /** * @ORM\\Column(name=\"name\") */ protected $name; // Returns ID of this tag. public function getId() { return $this->id; } // Sets ID of this tag. public function setId($id) { $this->id = $id; } // Returns name. public function getName() { return $this->name; } // Sets name. public function setName($name) { $this->name = $name; } } Since the Comment and Tag entities are analogous to the Post entity, we don't provide detailed description of the code above. Note Please note that we do not create an entity for the fourth auxiliary table post_tag . That table will be indirectly used further in this chapter when defining relationships between entities.","title":"Adding the Comment and Tag Entities"},{"location":"doctrine/#specifying-relationships-between-entities","text":"Now it is time to use annotations to define relationships between entities. If you remember, we have two relationships between our entities: the Post and Comment entities are related as \"one-to-many\"; and the Post and Tag entities are related as \"many-to-many\". In Doctrine, to express a relationship between two entities, you add a private property paired with Docblock annotation. For detailed information about relationships between entities in Doctrine, please read this page of Doctrine documentation.","title":"Specifying Relationships between Entities"},{"location":"doctrine/#onetomanymanytoone","text":"First, let's define one-to-many relationship between the Post and Comment entities. Modify the Post.php file and add the following lines: <?php // ... use Doctrine\\Common\\Collections\\ArrayCollection; use Application\\Entity\\Comment; /** * This class represents a single post in a blog. * @ORM\\Entity * @ORM\\Table(name=\"post\") */ class Post { // ... /** * @ORM\\OneToMany(targetEntity=\"\\Application\\Entity\\Comment\", mappedBy=\"post\") * @ORM\\JoinColumn(name=\"id\", referencedColumnName=\"post_id\") */ protected $comments; /** * Constructor. */ public function __construct() { $this->comments = new ArrayCollection(); } /** * Returns comments for this post. * @return array */ public function getComments() { return $this->comments; } /** * Adds a new comment to this post. * @param $comment */ public function addComment($comment) { $this->comments[] = $comment; } } As you can see from the code above, we added the $comments property (line 19). This property will be the collection of comments related to certain post. We initialize the $comments property in class constructor (lines 24-27). By assigning it with a new instance of Doctrine\\Common\\Collections\\ArrayCollection class. Note A Doctrine ArrayCollection is an array of objects, like usual PHP array , but with additional features required by Doctrine. It is implemented in Doctrine\\Common component. In lines 15-18, we add Doctrine annotations to the $comments property, so Doctrine knows how to get all comments associated with the post: the @ORM\\OneToMany tag defines that this is the one-to-many relationship between the Post entity and the (target) Comment entity. the @ORM\\JoinColumn tag specifies which column to use for joining the tables associated with the entities. The getComments() method (lines 33-36) allows getting all comments associated with the post. We also added the addComment() method (lines 42-45) for adding new comment to post. You can notice that we use the [] operator, just like we do with a typical PHP array. Vice versa, we define the other side of this relationship by modifying the Comment entity as follows: <?php // ... use Doctrine\\Common\\Collections\\ArrayCollection; // ... class Comment { /** * @ORM\\ManyToOne(targetEntity=\"\\Application\\Entity\\Post\", inversedBy=\"comments\") * @ORM\\JoinColumn(name=\"post_id\", referencedColumnName=\"id\") */ protected $post; /* * Returns associated post. * @return \\Application\\Entity\\Post */ public function getPost() { return $this->post; } /** * Sets associated post. * @param \\Application\\Entity\\Post $post */ public function setPost($post) { $this->post = $post; $post->addComment($this); } } In the code above, we added the $post private property to the entity class. This is not a collection, but a single instance of Post class, because single comment always belongs to single post. The annotation tags @ORM\\ManyToOne and @ORM\\JoinColumn are analogous to those we covered before.","title":"OneToMany/ManyToOne"},{"location":"doctrine/#manytomany","text":"Let's now express the many-to-many relationship between the Post and Tag entities. For this relationship, we indirectly use the auxiliary post_tag table. Modify the Post entity as follows: <?php //... use Application\\Entity\\Tag; //... class Post { //... /** * @ORM\\ManyToMany(targetEntity=\"\\Application\\Entity\\Tag\", inversedBy=\"posts\") * @ORM\\JoinTable(name=\"post_tag\", * joinColumns={@ORM\\JoinColumn(name=\"post_id\", referencedColumnName=\"id\")}, * inverseJoinColumns={@ORM\\JoinColumn(name=\"tag_id\", referencedColumnName=\"id\")} * ) */ protected $tags; // Constructor. public function __construct() { //... $this->tags = new ArrayCollection(); } // Returns tags for this post. public function getTags() { return $this->tags; } // Adds a new tag to this post. public function addTag($tag) { $this->tags[] = $tag; } // Removes association between this post and the given tag. public function removeTagAssociation($tag) { $this->tags->removeElement($tag); } } In the code above, we do the following: add $tags private property mark the $tags property with Docblock annotations with @ORM\\ManyToMany and @ORM\\JoinTable annotation tags initialize the property in constructor; add three methods getTags() , addTag() and removeTagAssociation() allowing to get/modify the property's value. Finally, modify the Tag entity as follows: <?php //... use Doctrine\\Common\\Collections\\ArrayCollection; class Tag { // ... /** * @ORM\\ManyToMany(targetEntity=\"\\Application\\Entity\\Post\", mappedBy=\"tags\") */ protected $posts; // Constructor. public function __construct() { $this->posts = new ArrayCollection(); } // Returns posts associated with this tag. public function getPosts() { return $this->posts; } // Adds a post into collection of posts related to this tag. public function addPost($post) { $this->posts[] = $post; } } In the code above, we by analogy define the other side of the relationship and getter/setter methods for retrieving the collection of posts associated with the tag, and adding posts associated with the given tag.","title":"ManyToMany"},{"location":"doctrine/#specifying-entity-locations","text":"To let Doctrine know where to find entities for your Application module (or for another module you have), you add the following lines into your module.config.php file: <?php namespace Application; use Doctrine\\ORM\\Mapping\\Driver\\AnnotationDriver; return [ // ... 'doctrine' => [ 'driver' => [ __NAMESPACE__ . '_driver' => [ 'class' => AnnotationDriver::class, 'cache' => 'array', 'paths' => [__DIR__ . '/../src/Entity'] ], 'orm_default' => [ 'drivers' => [ __NAMESPACE__ . '\\Entity' => __NAMESPACE__ . '_driver' ] ] ] ] ]; Above, in line 2, we specify the namespace Application . This should be the name of the current module. Note Note that usually we do not specify namespace in config files, but in this particular case it is convenient to do. When we have namespace defined, we can use the __NAMESPACE__ placeholder which expands into that namespace. In line 8, we have doctrine key, under which we have the driver subkey. In line 13, we tell Doctrine ORM that our entities are stored inside of Entity directory under the module's src directory.","title":"Specifying Entity Locations"},{"location":"doctrine/#about-entity-manager","text":"Entity manager is the primary access point to ORM functionality provided by Doctrine. EntityManager is a Doctrine class that lives in Doctrine\\ORM namespace and used to retrieve entities from their repositories using search criteria and save entities back to database. EntityManager is registered as a service in the Laminas Framework service manager. In your factory class, you retrieve the EntityManager from service manager as follows (if you need a different connection than orm_default , just replace the orm_default with the required connection name): // Get Doctrine entity manager $entityManager = $container->get('doctrine.entitymanager.orm_default'); The most used methods provided by the EntityManager class are listed in table 12.4 below. Method Description persist($entity) Places new entity into entity manager (makes it managed). remove($entity) Removes an entity from database. flush() Flushes all changes to objects that have been queued up to now to the database. createQuery($dql) Creates a new Query object. getRepository($entityName) Gets the repository for an entity class. Table 12.4. Methods of the EntityManager Let's review the methods from table 12.4. To add a newly created entity to entity manager (to make the entity \"managed\"), you use entity manager's persist() method. To remove an entity from database, you use entity manager's remove() method. When you call persist() or remove() , EntityManager remembers your changes in memory, but doesn't apply changes to database automatically (by performance reasons). To apply changes to database in a single transaction, you use the flush() method. For example, look at the code example below that shows how to create an instance of the Post entity and save it to database: // Create new Post entity. $post = new Post(); $post->setTitle('Top 10+ Books about Laminas Framework'); $post->setContent('Post body goes here'); $post->setStatus(Post::STATUS_PUBLISHED); $currentDate = date('Y-m-d H:i:s'); $post->setDateCreated($currentDate); // Add the entity to entity manager. $entityManager->persist($post); // Apply changes to database. $entityManager->flush(); The createQuery() method of the entity manager is designed for creating a query from a DQL string. It returns the Query object. You then execute the query and get results (an array of entities matching search conditions). The getRepository() method of the entity manager is designed to get repository by entity class name. Please look below for example where we get the repository for our Post entity: $repository = $entityManager->getRepository(Post::class);","title":"About Entity Manager"},{"location":"doctrine/#entity-repositories","text":"Conceptually, each entity class has its own repository. The repository provides methods for retrieving entities from database. The repository can be considered as a collection of all available entities of certain class. For example, there are repositories for our Post , Comment , and Tag entities. To load data from the database, you retrieve an entity from its repository. When you request the repository for an entity, it loads the data from the table mapped to the entity, and assigns entity's fields with the data. Note The Doctrine\\ORM\\EntityRepository class implements the default repository. If needed, you can, by extending the EntityRepository , create your own repository for certain entity class. We will show how to do that later. The most used methods provided by the EntityRepository class are listed in table 12.5. Method Description findAll() Finds all entities in the repository. find($id) Finds an entity by its identifier. findBy($criteria, $orderBy, $limit, $offset) Finds entities by a set of criteria. findOneBy($criteria, $orderBy) Finds a single entity by a set of criteria. createQueryBuilder($alias) Creates a new QueryBuilder instance that is prepopulated for this entity name. Table 12.5. Methods of the EntityRepository The findAll() method gets all entities from repository. For simple example of its usage, look below: // Find all posts from repository $posts = $entityManager->getRepository(Post::class)->findAll(); The find() method is the simplest method of searching for an entity. It retrieves an entity by its ID (primary key). In the example below, we select post with ID = 1. // Find post by primary key (ID) $post = $entityManager->getRepository(Post::class)->find(1); The findBy() takes a search criteria (and optional sorting order and limit) arguments and returns a collection of entities matching criteria. The findOneBy() method is very similar to findBy() , but it returns the first entity matching the criteria. In the code example below, we use the findBy() method for selecting 50 most recent published posts: // Find 50 most recent published posts $posts = $entityManager->getRepository(Post::class)->findBy( ['status'=>Post::STATUS_PUBLISHED], ['dateCreated'=>'DESC'], 50); For your convenience, the EntityRepository class also provides magic methods allowing you to query entities by attribute name with the findByX and findOneByX methods, as follows (just substitute the X placeholder with an attribute name): // Query a single post by ID attribute $post = $entityManager->getRepository(Post::class)->findOneById(1); // Query posts by status attribute $posts = $entityManager->getRepository(Post::class) ->findByStatus(Post::STATUS_PUBLISHED); And the most complex search method is the createQueryBuilder() . That method allows to create complex DQL queries. If standard find methods are not sufficient (or if you have complex search criteria and DQL queries), you can create your own repository by extending the standard EntityRepository class and encapsulate the search logic there. We will show how to do that later when implementing tag cloud feature for our Blog sample.","title":"Entity Repositories"},{"location":"doctrine/#adding-blog-home-page","text":"To show how to use EntityManager class, we will create the main page for the Blog web application. This page will display the list of posts sorted by date in descending order. To do that, add the constructor method and indexAction() method to the IndexController controller class, as follows: <?php namespace Application\\Controller; use Laminas\\Mvc\\Controller\\AbstractActionController; use Laminas\\View\\Model\\ViewModel; use Application\\Entity\\Post; class IndexController extends AbstractActionController { /** * Entity manager. * @var Doctrine\\ORM\\EntityManager */ private $entityManager; // Constructor method is used to inject dependencies to the controller. public function __construct($entityManager) { $this->entityManager = $entityManager; } // This is the default \"index\" action of the controller. It displays the // Posts page containing the recent blog posts. public function indexAction() { // Get recent posts $posts = $this->entityManager->getRepository(Post::class) ->findBy(['status'=>Post::STATUS_PUBLISHED], ['dateCreated'=>'DESC']); // Render the view template return new ViewModel([ 'posts' => $posts ]); } } In the code above, we first add the __construct() constructor method which is used to inject the Doctrine entity manager into the controller (lines 17-20). Inside of the indexAction() method, we get the repository of the Post entities with entity manager's getRepository() method (line 27). With the findBy() method provided by repository, we select published posts sorted by date in descending order. And, in line 32 we pass the selected posts to the view for rendering. Next, create the factory for the IndexController . To do that, add the IndexControllerFactory.php file inside of Controller/Factory directory under module's source directory. Put the following content to the file: <?php namespace Application\\Controller\\Factory; use Interop\\Container\\ContainerInterface; use Laminas\\ServiceManager\\Factory\\FactoryInterface; use Application\\Controller\\IndexController; /** * This is the factory for IndexController. Its purpose is to instantiate the * controller. */ class IndexControllerFactory implements FactoryInterface { public function __invoke(ContainerInterface $container, $requestedName, array $options = null) { $entityManager = $container->get('doctrine.entitymanager.orm_default'); // Instantiate the controller and inject dependencies return new IndexController($entityManager); } } In the code above, you can see how we instantiate the Doctrine entity manager and inject it into the controller. Do not forget to register our controller's factory inside module.config.php file. To do that, add the following: //... return [ //... 'controllers' => [ //... 'factories' => [ Controller\\IndexController::class => Controller\\Factory\\IndexControllerFactory::class, ], ], //... ]; Next, modify the index.phtml view template file in application/index directory under module's view directory and put the following content into it: <h1>Posts</h1> <?php foreach($posts as $post): ?> <h3> <a href=\"#\"> <?= $this->escapeHtml($post->getTitle()); ?> </a> </h3> <p> <?= $this->escapeHtml($post->getContent()); ?> </p> <?php endforeach; ?> In the view template above, we go in turn through the posts we selected and render each one's title and content. That simple! Now, if you open the Blog web application in your browser, you should be able to see the following page containing the list of posts (look at figure 12.6 below).","title":"Adding Blog Home Page"},{"location":"doctrine/#adding-new-post","text":"In this section, we will create the Add New Post web page that will allow to add a new post to blog. For this, we will need four things: the PostForm form model will be used for entering and validation of post title, content, status and tags; the PostManager service model will contain business logic for saving new post to database; the PostController controller and its PostController::addAction() action method will be used for getting form data, and calling PostManager for saving the data to database. and add.phtml view template will render the form.","title":"Adding New Post"},{"location":"doctrine/#adding-postform","text":"First, we add the PostForm form that will allow to enter data of a single post: its title, content, comma-separated list of tags associated with the post, and status (Published or Draft). To do that, create the PostForm.php file in Form directory under module's source directory. Put the following content into the file: <?php namespace Application\\Form; use Laminas\\Form\\Form; use Laminas\\InputFilter\\InputFilter; use Application\\Entity\\Post; /** * This form is used to collect post data. */ class PostForm extends Form { /** * Constructor. */ public function __construct() { // Define form name parent::__construct('post-form'); // Set POST method for this form $this->setAttribute('method', 'post'); $this->addElements(); $this->addInputFilter(); } /** * This method adds elements to form (input fields and submit button). */ protected function addElements() { // Add \"title\" field $this->add([ 'type' => 'text', 'name' => 'title', 'attributes' => [ 'id' => 'title' ], 'options' => [ 'label' => 'Title', ], ]); // Add \"content\" field $this->add([ 'type' => 'textarea', 'name' => 'content', 'attributes' => [ 'id' => 'content' ], 'options' => [ 'label' => 'Content', ], ]); // Add \"tags\" field $this->add([ 'type' => 'text', 'name' => 'tags', 'attributes' => [ 'id' => 'tags' ], 'options' => [ 'label' => 'Tags', ], ]); // Add \"status\" field $this->add([ 'type' => 'select', 'name' => 'status', 'attributes' => [ 'id' => 'status' ], 'options' => [ 'label' => 'Status', 'value_options' => [ Post::STATUS_PUBLISHED => 'Published', Post::STATUS_DRAFT => 'Draft', ] ], ]); // Add the submit button $this->add([ 'type' => 'submit', 'name' => 'submit', 'attributes' => [ 'value' => 'Create', 'id' => 'submitbutton', ], ]); } /** * This method creates input filter (used for form filtering/validation). */ private function addInputFilter() { $inputFilter = new InputFilter(); $this->setInputFilter($inputFilter); $inputFilter->add([ 'name' => 'title', 'required' => true, 'filters' => [ ['name' => 'StringTrim'], ['name' => 'StripTags'], ['name' => 'StripNewlines'], ], 'validators' => [ [ 'name' => 'StringLength', 'options' => [ 'min' => 1, 'max' => 1024 ], ], ], ]); $inputFilter->add([ 'name' => 'content', 'required' => true, 'filters' => [ ['name' => 'StripTags'], ], 'validators' => [ [ 'name' => 'StringLength', 'options' => [ 'min' => 1, 'max' => 4096 ], ], ], ]); $inputFilter->add([ 'name' => 'tags', 'required' => true, 'filters' => [ ['name' => 'StringTrim'], ['name' => 'StripTags'], ['name' => 'StripNewlines'], ], 'validators' => [ [ 'name' => 'StringLength', 'options' => [ 'min' => 1, 'max' => 1024 ], ], ], ]); $inputFilter->add([ 'name' => 'status', 'required' => true, 'validators' => [ [ 'name' => 'InArray', 'options'=> [ 'haystack' => [Post::STATUS_PUBLISHED, Post::STATUS_DRAFT], ] ], ], ]); } } As you can see from the code above, the PostForm class defines a Laminas form with title, content, tags, and status fields. It also has the Submit button. Since we covered forms in details in previous chapters, here we do not explain the code presented above deeply.","title":"Adding PostForm"},{"location":"doctrine/#adding-postmanager-service","text":"According to Domain Driven Design pattern, we put business logic into service models. In our Blog sample, we will create and register the PostManager service. This service will have the addNewPost() public method that will contain business logic of adding Post entity to database and associating it with one or several Tag entities. The PostManager service will contain business logic of the Blog sample. This business logic includes, but not limited to, adding new post to the blog. Create the PostManager.php file inside the Service directory under the module's source directory. Put the following content into that file: <?php namespace Application\\Service; use Application\\Entity\\Post; use Application\\Entity\\Comment; use Application\\Entity\\Tag; use Laminas\\Filter\\StaticFilter; // The PostManager service is responsible for adding new posts. class PostManager { /** * Doctrine entity manager. * @var Doctrine\\ORM\\EntityManager */ private $entityManager; // Constructor is used to inject dependencies into the service. public function __construct($entityManager) { $this->entityManager = $entityManager; } // This method adds a new post. public function addNewPost($data) { // Create new Post entity. $post = new Post(); $post->setTitle($data['title']); $post->setContent($data['content']); $post->setStatus($data['status']); $currentDate = date('Y-m-d H:i:s'); $post->setDateCreated($currentDate); // Add the entity to entity manager. $this->entityManager->persist($post); // Add tags to post $this->addTagsToPost($data['tags'], $post); // Apply changes to database. $this->entityManager->flush(); } // Adds/updates tags in the given post. private function addTagsToPost($tagsStr, $post) { // Remove tag associations (if any) $tags = $post->getTags(); foreach ($tags as $tag) { $post->removeTagAssociation($tag); } // Add tags to post $tags = explode(',', $tagsStr); foreach ($tags as $tagName) { $tagName = StaticFilter::execute($tagName, 'StringTrim'); if (empty($tagName)) { continue; } $tag = $this->entityManager->getRepository(Tag::class) ->findOneByName($tagName); if ($tag == null) $tag = new Tag(); $tag->setName($tagName); $tag->addPost($post); $this->entityManager->persist($tag); $post->addTag($tag); } } } In lines 25-43, we have the addNewPost() public method which takes the $data variable as argument (this variable should contain the data entered by the website user into the form). We create a new instance of Post entity (line 28) and fill its properties with user-provided data. We use the EntityManager 's persist() method (line 36) to add the newly created entity to entity manager. The addTagsToPost() private method is called (line 39) to assign the post with one or several tags. And the flush() method is used for applying changes to database in a single transaction (line 42). The addTagsToPost() private method contains logic for removing old associations between the post and tags (lines 49-52), then parsing comma-separated list of tags (line 55), and assigning new tags to the post (lines 56-73). Next, add a factory for the PostManager service. To do that, add the PostManagerFactory.php file under the Service/Factory directory under the module's source directory. Put the following content into that file: <?php namespace Application\\Service\\Factory; use Interop\\Container\\ContainerInterface; use Laminas\\ServiceManager\\Factory\\FactoryInterface; use Application\\Service\\PostManager; /** * This is the factory for PostManager. Its purpose is to instantiate the * service. */ class PostManagerFactory implements FactoryInterface { public function __invoke(ContainerInterface $container, $requestedName, array $options = null) { $entityManager = $container->get('doctrine.entitymanager.orm_default'); // Instantiate the service and inject dependencies return new PostManager($entityManager); } } Finally, we register PostManager service by modifying module.config.php configuration file as follows: <?php //... return [ //... 'service_manager' => [ //... 'factories' => [ Service\\PostManager::class => Service\\Factory\\PostManagerFactory::class, ], ], //... ];","title":"Adding PostManager Service"},{"location":"doctrine/#creating-controller-action-and-view-template","text":"For post management (e.g. adding, editing, viewing and removing posts), we will create the PostController controller class. We create the addAction() action method inside the PostController controller class that will allow to add a new post to blog (see code below): class PostController extends AbstractActionController { /** * Entity manager. * @var Doctrine\\ORM\\EntityManager */ private $entityManager; /** * Post manager. * @var Application\\Service\\PostManager */ private $postManager; /** * Constructor is used for injecting dependencies into the controller. */ public function __construct($entityManager, $postManager) { $this->entityManager = $entityManager; $this->postManager = $postManager; } /** * This action displays the \"New Post\" page. The page contains * a form allowing to enter post title, content and tags. When * the user clicks the Submit button, a new Post entity will * be created. */ public function addAction() { // Create the form. $form = new PostForm(); // Check whether this post is a POST request. if ($this->getRequest()->isPost()) { // Get POST data. $data = $this->params()->fromPost(); // Fill form with data. $form->setData($data); if ($form->isValid()) { // Get validated form data. $data = $form->getData(); // Use post manager service to add new post to database. $this->postManager->addNewPost($data); // Redirect the user to \"index\" page. return $this->redirect()->toRoute('application'); } } // Render the view template. return new ViewModel([ 'form' => $form ]); } } Above, in line 33, we create an instance of PostForm form. In line 36, we check whether this is a POST request. If the request is a POST request, we fill the form with input data and validate the data. In case of valid data, we call the addNewPost() method on the PostManager service (line 49), and redirect the user to the list of posts. To instantiate the PostController , we will need a factory. Create the controller factory by adding the PostControllerFactory.php file to the Controller/Factory directory under the module's source directory: <?php namespace Application\\Controller\\Factory; use Interop\\Container\\ContainerInterface; use Laminas\\ServiceManager\\Factory\\FactoryInterface; use Application\\Service\\PostManager; use Application\\Controller\\PostController; /** * This is the factory for PostController. Its purpose is to instantiate the * controller. */ class PostControllerFactory implements FactoryInterface { public function __invoke(ContainerInterface $container, $requestedName, array $options = null) { $entityManager = $container->get('doctrine.entitymanager.orm_default'); $postManager = $container->get(PostManager::class); // Instantiate the controller and inject dependencies return new PostController($entityManager, $postManager); } } Next, register the PostController controller inside the module.config.php file: <?php //... return [ //... 'controllers' => [ //... 'factories' => [ Controller\\PostController::class => Controller\\Factory\\PostControllerFactory::class, ], ], //... ]; Then, add the posts route for the new controller (modify the module.config.php as follows): <?php //... return [ //... 'router' => [ 'routes' => [ //... 'posts' => [ 'type' => Segment::class, 'options' => [ 'route' => '/posts[/:action[/:id]]', 'constraints' => [ 'action' => '[a-zA-Z][a-zA-Z0-9_-]*', 'id' => '[0-9]*' ], 'defaults' => [ 'controller' => Controller\\PostController::class, 'action' => 'index', ], ], ], ], ], //... ]; Finally, we add the view template. Create the add.phtml file in application/post directory under module's view directory and put the following content into it: <?php $form = $this->form; $form->get('title')->setAttributes([ 'class'=>'form-control', 'placeholder'=>'Enter post title here' ]); $form->get('content')->setAttributes([ 'class'=>'form-control', 'placeholder'=>'Type content here', 'rows'=>6 ]); $form->get('tags')->setAttributes([ 'class'=>'form-control', 'placeholder'=>'comma, separated, list, of, tags' ]); $form->get('status')->setAttributes([ 'class'=>'form-control' ]); $form->get('submit')->setAttributes(['class'=>'btn btn-primary']); $form->prepare(); ?> <h1>Add New Post</h1> <p> Please fill out the following form and click the <i>Create</i> button. </p> <div class=\"row\"> <div class=\"col-md-6\"> <?= $this->form()->openTag($form); ?> <div class=\"form-group\"> <?= $this->formLabel($form->get('title')); ?> <?= $this->formElement($form->get('title')); ?> <?= $this->formElementErrors($form->get('title')); ?> </div> <div class=\"form-group\"> <?= $this->formLabel($form->get('content')); ?> <?= $this->formElement($form->get('content')); ?> <?= $this->formElementErrors($form->get('content')); ?> </div> <div class=\"form-group\"> <?= $this->formLabel($form->get('tags')); ?> <?= $this->formElement($form->get('tags')); ?> <?= $this->formElementErrors($form->get('tags')); ?> <p class=\"help-block\">Separate tags with comma.</p> </div> <div class=\"form-group\"> <?= $this->formLabel($form->get('status')); ?> <?= $this->formElement($form->get('status')); ?> <?= $this->formElementErrors($form->get('status')); ?> </div> <?= $this->formElement($form->get('submit')); ?> <?= $this->form()->closeTag(); ?> </div> </div> Now, if you open the URL http://localhost/posts/add in your web browser, you should see the Add New Post page like shown in figure 12.7 below: Filling the form and clicking the Create button results in saving the new post to database. Then you are able to see the newly created post in the list of posts at the Home page.","title":"Creating Controller Action and View Template"},{"location":"doctrine/#editing-existing-post","text":"In this section, we will implement the Edit Post page which contains the form allowing to edit the data of existing post, send new data to server and apply changes to database. Site visitor will be able to see the page by entering the following URL in browser's navigation bar: http://localhost/posts/edit/<id> , where <id> is the unique identifier of the post. To implement this page we need the following things: create a form that would allow to enter post title, content, etc. For this page, we can successfully reuse the PostForm form we created earlier (we just rename the Create button caption into Save ). add updatePost() method to the PostManager service. The method would find the post by ID in database and update its data; add convertTagsToString() method to the PostManager service. This method would take the post entity, and on output produce string containing comma-separated list of tags; add the PostController::editAction() action method that would take user input, pass it to models and return data for rendering; and add the edit.phtml view template file that would render the form.","title":"Editing Existing Post"},{"location":"doctrine/#modifying-postmanager","text":"First, we add the updatePost() and convertTagsToString() methods to the PostManager service model as follows: <?php //... class PostManager { //... // This method allows to update data of a single post. public function updatePost($post, $data) { $post->setTitle($data['title']); $post->setContent($data['content']); $post->setStatus($data['status']); // Add tags to post $this->addTagsToPost($data['tags'], $post); // Apply changes to database. $this->entityManager->flush(); } // Converts tags of the given post to comma separated list (string). public function convertTagsToString($post) { $tags = $post->getTags(); $tagCount = count($tags); $tagsStr = ''; $i = 0; foreach ($tags as $tag) { $i ++; $tagsStr .= $tag->getName(); if ($i < $tagCount) $tagsStr .= ', '; } return $tagsStr; } } Above, we have the updatePost() method (lines 8-19) that takes an existing Post entity, the new title, content, status and the list of tags. It then updates entity's properties and saves changes to database using flush() method. Note Note that the updatePost() method doesn't use the persist() method of entity manager, because here we have existing post, not a new one. Then, we have the convertTagsToString() method (lines 22-36) which takes the post, goes through Tag entities associated with the post and formats and returns the comma-separated list of tags.","title":"Modifying PostManager"},{"location":"doctrine/#adding-controller-action-and-view-template","text":"Next, add the editAction() to PostController controller class as follows: <?php namespace Application\\Controller; //... use Application\\Form\\PostForm; use Application\\Entity\\Post; class PostController extends AbstractActionController { // This action displays the page allowing to edit a post. public function editAction() { // Create the form. $form = new PostForm(); // Get post ID. $postId = $this->params()->fromRoute('id', -1); // Find existing post in the database. $post = $this->entityManager->getRepository(Post::class) ->findOneById($postId); if ($post == null) { $this->getResponse()->setStatusCode(404); return; } // Check whether this post is a POST request. if ($this->getRequest()->isPost()) { // Get POST data. $data = $this->params()->fromPost(); // Fill form with data. $form->setData($data); if ($form->isValid()) { // Get validated form data. $data = $form->getData(); // Use post manager service to add new post to database. $this->postManager->updatePost($post, $data); // Redirect the user to \"admin\" page. return $this->redirect()->toRoute('posts', ['action'=>'admin']); } } else { $data = [ 'title' => $post->getTitle(), 'content' => $post->getContent(), 'tags' => $this->postManager->convertTagsToString($post), 'status' => $post->getStatus() ]; $form->setData($data); } // Render the view template. return new ViewModel([ 'form' => $form, 'post' => $post ]); } } In the code above, we extract the post ID using the fromRoute() method of the params() controller plugin. Then we search for post having such ID using the findOneBy() method provided by the entity repository. Then we check if this is a POST request. If this is the POST request, we fill in and validate the form with POST data. Then we use the updatePost() method of the PostManager service. Finally, create the application/post/edit.phtml file under the module's view directory. Place the following content there: <?php $form = $this->form; $form->get('title')->setAttributes([ 'class'=>'form-control', 'placeholder'=>'Enter post title here' ]); $form->get('content')->setAttributes([ 'class'=>'form-control', 'placeholder'=>'Type content here', 'rows'=>6 ]); $form->get('tags')->setAttributes([ 'class'=>'form-control', 'placeholder'=>'comma, separated, list, of, tags' ]); $form->get('status')->setAttributes([ 'class'=>'form-control' ]); $form->get('submit')->setAttributes(['class'=>'btn btn-primary']); $form->get('submit')->setValue('Save'); $form->prepare(); ?> <h1>Edit Post</h1> <p> Please fill out the following form and click the *Save* button. </p> <div class=\"row\"> <div class=\"col-md-6\"> <?= $this->form()->openTag($form); ?> <div class=\"form-group\"> <?= $this->formLabel($form->get('title')); ?> <?= $this->formElement($form->get('title')); ?> <?= $this->formElementErrors($form->get('title')); ?> </div> <div class=\"form-group\"> <?= $this->formLabel($form->get('content')); ?> <?= $this->formElement($form->get('content')); ?> <?= $this->formElementErrors($form->get('content')); ?> </div> <div class=\"form-group\"> <?= $this->formLabel($form->get('tags')); ?> <?= $this->formElement($form->get('tags')); ?> <?= $this->formElementErrors($form->get('tags')); ?> <p class=\"help-block\">Separate tags with comma.</p> </div> <div class=\"form-group\"> <?= $this->formLabel($form->get('status')); ?> <?= $this->formElement($form->get('status')); ?> <?= $this->formElementErrors($form->get('status')); ?> </div> <?= $this->formElement($form->get('submit')); ?> <?= $this->form()->closeTag(); ?> </div> </div> Now, if you open the URL http://localhost/posts/edit/<id> in your web browser, you should be able to see the Edit Post page that allows to edit an existing post (see the figure 12.8 below): Clicking the Save button results in saving the changes to database.","title":"Adding Controller Action and View Template"},{"location":"doctrine/#deleting-a-post","text":"In this section, we will implement the deleteAction() action of the PostController . This action will allow to delete certain post given its ID. The action will take ID as a GET variable, look if a post with such ID exists, and if exists, deletes the post, its related comments and tag associations. Site visitor will be able to trigger the action by entering the following URL in browser's navigation bar: http://localhost/posts/delete/<id> , where <id> is the unique identifier of the post. Finally, the action redirects the site visitor to the Admin page.","title":"Deleting a Post"},{"location":"doctrine/#modifying-postmanager_1","text":"First, we'll add the removePost() method to the PostManager service. This method will remove the post and its associated comments. It will also remove associations between post and tags. <?php //... class PostManager { //... // Removes post and all associated comments. public function removePost($post) { // Remove associated comments $comments = $post->getComments(); foreach ($comments as $comment) { $this->entityManager->remove($comment); } // Remove tag associations (if any) $tags = $post->getTags(); foreach ($tags as $tag) { $post->removeTagAssociation($tag); } $this->entityManager->remove($post); $this->entityManager->flush(); } } In the code above, we first retrieve all comments associated with the post using the getComments() method of the Post entity. Then we call EntityManager 's remove() method and pass it each comment that we want to remove. Next, we get all tags associated with the post by calling Post 's getTags() method. We remove association between the post and tag (but not tag itself!) with the help of the Post 's removeTagAssociation() method (see below for the code of the method). Finally, we remove the post itself by calling the EntityManager 's remove() method. We apply changes to database with the flush() method. And here is the code of the Post::removeTagAssociation() method: // Removes association between this post and the given tag. public function removeTagAssociation($tag) { $this->tags->removeElement($tag); }","title":"Modifying PostManager"},{"location":"doctrine/#adding-controller-action","text":"The PostController::deleteAction() method retrieves the ID of the post to be removed, checks whether this is a valid post ID. If so, it calls the PostManager::removePost() method to remove the post and apply changes to database. Finally, it redirects the site visitor to the Admin page. <?php //.. class PostController extends AbstractActionController { // This \"delete\" action displays the Delete Post page. public function deleteAction() { $postId = $this->params()->fromRoute('id', -1); $post = $this->entityManager->getRepository(Post::class) ->findOneById($postId); if ($post == null) { $this->getResponse()->setStatusCode(404); return; } $this->postManager->removePost($post); // Redirect the user to \"index\" page. return $this->redirect()->toRoute('posts', ['action'=>'admin']); } }","title":"Adding Controller Action"},{"location":"doctrine/#implementing-post-preview","text":"In this section, we will create controller's action and its corresponding view template that would allow site visitors to preview certain post by entering the following URL in browser's navigation bar: http://localhost/posts/view/<id> , where <id> is the unique identifier of the post. The page will also allow to add comments to the post using the form located at the bottom of the page. For example of what we are trying to achive, please look at the figure 12.9 below: So, for this we need four things: to create the form that would allow to enter the comment and its author's name; to modify the PostManager and add all necessary business logic; to create PostController::viewAction() controller's action; and to create the view.phtml view template.","title":"Implementing Post Preview"},{"location":"doctrine/#adding-commentform","text":"First, we implement the CommentForm form that will allow to add a comment to a post. Create the CommentForm.php file in Form directory under module's source directory. Put the following content into the file: <?php namespace Application\\Form; use Laminas\\Form\\Form; use Laminas\\InputFilter\\InputFilter; /** * This form is used to collect comment data. */ class CommentForm extends Form { // Constructor. public function __construct() { // Define form name parent::__construct('comment-form'); // Set POST method for this form $this->setAttribute('method', 'post'); $this->addElements(); $this->addInputFilter(); } // This method adds elements to form (input fields and submit button). protected function addElements() { // Add \"author\" field $this->add([ 'type' => 'text', 'name' => 'author', 'attributes' => [ 'id' => 'author' ], 'options' => [ 'label' => 'Author', ], ]); // Add \"comment\" field $this->add([ 'type' => 'textarea', 'name' => 'comment', 'attributes' => [ 'id' => 'comment' ], 'options' => [ 'label' => 'Comment', ], ]); // Add the submit button $this->add([ 'type' => 'submit', 'name' => 'submit', 'attributes' => [ 'value' => 'Save', 'id' => 'submitbutton', ], ]); } // This method creates input filter (used for form filtering/validation). private function addInputFilter() { $inputFilter = new InputFilter(); $this->setInputFilter($inputFilter); $inputFilter->add([ 'name' => 'author', 'required' => true, 'filters' => [ ['name' => 'StringTrim'], ], 'validators' => [ [ 'name' => 'StringLength', 'options' => [ 'min' => 1, 'max' => 128 ], ], ], ]); $inputFilter->add([ 'name' => 'comment', 'required' => true, 'filters' => [ ['name' => 'StripTags'], ], 'validators' => [ [ 'name' => 'StringLength', 'options' => [ 'min' => 1, 'max' => 4096 ], ], ], ]); } } As you see from the code above, the CommentForm form contains the author, comment fields, and the Submit button. Since we covered forms in details in previous chapters, here we do not explain the code presented above deeply.","title":"Adding CommentForm"},{"location":"doctrine/#modifying-postmanager_2","text":"Here, we add two methods: the getCommentCountStr() method will format the comment count string for the given post (e.g., \"No comments\", \"1 comment\", \"2 comments\", etc.) and the addCommentToPost() method will be used for adding a new comment to post. <?php //... /** * The PostManager service is responsible for adding new posts. */ class PostManager { //... // Returns count of comments for given post as properly formatted string. public function getCommentCountStr($post) { $commentCount = count($post->getComments()); if ($commentCount == 0) return 'No comments'; else if ($commentCount == 1) return '1 comment'; else return $commentCount . ' comments'; } // This method adds a new comment to post. public function addCommentToPost($post, $data) { // Create new Comment entity. $comment = new Comment(); $comment->setPost($post); $comment->setAuthor($data['author']); $comment->setContent($data['comment']); $currentDate = date('Y-m-d H:i:s'); $comment->setDateCreated($currentDate); // Add the entity to entity manager. $this->entityManager->persist($comment); // Apply changes. $this->entityManager->flush(); } }","title":"Modifying PostManager"},{"location":"doctrine/#adding-controller-action-and-view-template_1","text":"Now, add the PostController::viewAction() method and put the following code there: <?php //... use Application\\Form\\CommentForm; use Application\\Entity\\Comment; class PostController extends AbstractActionController { /** * This action displays the \"View Post\" page allowing to see the post title * and content. The page also contains a form allowing * to add a comment to post. */ public function viewAction() { $postId = $this->params()->fromRoute('id', -1); $post = $this->entityManager->getRepository(Post::class) ->findOneById($postId); if ($post == null) { $this->getResponse()->setStatusCode(404); return; } $commentCount = $this->postManager->getCommentCountStr($post); // Create the form. $form = new CommentForm(); // Check whether this post is a POST request. if($this->getRequest()->isPost()) { // Get POST data. $data = $this->params()->fromPost(); // Fill form with data. $form->setData($data); if($form->isValid()) { // Get validated form data. $data = $form->getData(); // Use post manager service to add new comment to post. $this->postManager->addCommentToPost($post, $data); // Redirect the user again to \"view\" page. return $this->redirect()->toRoute('posts', ['action'=>'view', 'id'=>$postId]); } } // Render the view template. return new ViewModel([ 'post' => $post, 'commentCount' => $commentCount, 'form' => $form, 'postManager' => $this->postManager ]); } } Finally, add the view.phtml view template file and put the following content there: <?php $form = $this->form; $form->get('author')->setAttributes([ 'class'=>'form-control', 'placeholder'=>'Author\\'s name' ]); $form->get('comment')->setAttributes([ 'class'=>'form-control', 'rows'=>6, 'placeholder'=>'Text' ]); $form->get('submit')->setAttributes(['class'=>'btn btn-primary']); $form->prepare(); ?> <a href=\" <?= $this->url('application', ['action'=>'index']); ?>\"> &lt;&lt; Back to list of posts </a> <h1> <?= $this->escapeHtml($post->getTitle()); ?> </h1> <p class=\"comments-header\"> <?= $this->escapeHtml($postManager->getCommentCountStr($post)); ?> | <a href=\"#comment\"> Add new comment </a> </p> <p> Published: <?= $this->escapeHtml(date('jS \\of F Y', strtotime($post->getDateCreated()))); ?> | Tags: <?= $this->escapeHtml($postManager->convertTagsToString($post)); ?> </p> <p> <?= $this->escapeHtml($post->getContent()); ?> </p> <h3><?= $this->escapeHtml($postManager->getCommentCountStr($post)); ?></h3> <?php foreach ($post->getComments() as $comment): ?> <hr> <p> <?= $this->escapeHtml($comment->getAuthor()) ?> on <?= $this->escapeHtml($comment->getDateCreated()); ?> </p> <p> <?= $this->escapeHtml($comment->getContent()); ?> </p> <?php endforeach; ?> <hr> <a name=\"comment\"></a> <h3>Leave Reply</h3> <div class=\"row\"> <div class=\"col-md-8\"> <?= $this->form()->openTag($form); ?> <div class=\"form-group\"> <?= $this->formLabel($form->get('author')); ?> <?= $this->formElement($form->get('author')); ?> <?= $this->formElementErrors($form->get('author')); ?> </div> <div class=\"form-group\"> <?= $this->formLabel($form->get('comment')); ?> <?= $this->formElement($form->get('comment')); ?> <?= $this->formElementErrors($form->get('comment')); ?> </div> <?= $this->formElement($form->get('submit')); ?> <?= $this->form()->closeTag(); ?> </div> </div>","title":"Adding Controller Action and View Template"},{"location":"doctrine/#implementing-admin-page","text":"Admin page of the Blog sample web application contains the list of all blog posts (either published or drafts), and allows to view, edit and delete posts. To implement this page, add the adminAction() action method to the PostController class, as follows: <?php //.. class PostController extends AbstractActionController { /** * This \"admin\" action displays the Manage Posts page. This page contains * the list of posts with an ability to edit/delete any post. */ public function adminAction() { // Get posts $posts = $this->entityManager->getRepository(Post::class) ->findBy([], ['dateCreated'=>'DESC']); // Render the view template return new ViewModel([ 'posts' => $posts, 'postManager' => $this->postManager ]); } } We will also need to show a post status in text form ('Draft' or 'Published'). Conversion of integer post status to string can be implemented in the getPostStatusAsString() method of PostManager service. Add the getPostStatusAsString() method to PostManager class as follows: /** * Returns status as a string. */ public function getPostStatusAsString($post) { switch ($post->getStatus()) { case Post::STATUS_DRAFT: return 'Draft'; case Post::STATUS_PUBLISHED: return 'Published'; } return 'Unknown'; } Finally, add the corresponding view template file admin.phtml to the application/post directory under module's view directory: <h1>Manage Posts</h1> <p> <a class=\"btn btn-default\" href=\" <?= $this->url('posts', ['action'=>'add']); ?>\"> New Post </a> </p> <table class=\"table table-striped\"> <tr> <th>ID</th> <th>Post Title</th> <th>Date Created</th> <th>Status</th> <th>Actions</th> </tr> <?php foreach ($posts as $post): ?> <tr> <td><?= $this->escapeHtml($post->getId()); ?></td> <td> <a href=\"<?= $this->url('posts', ['action'=>'view', 'id'=>$post->getId()]); ?>\"> <?= $this->escapeHtml($post->getTitle()); ?> </a> </td> <td><?= $this->escapeHtml($post->getDateCreated()); ?></td> <td><?= $this->escapeHtml($postManager->getPostStatusAsString($post)); ?></td> <td> <a class=\"btn btn-info\" href=\"<?= $this->url('posts', ['action'=>'edit', 'id'=>$post->getId()]); ?>\"> <span class=\"glyphicon glyphicon-pencil\" ></span> Edit </a> <a class=\"btn btn-danger\" href=\"<?= $this->url('posts', ['action'=>'delete', 'id'=>$post->getId()]); ?>\"> <span class=\"glyphicon glyphicon-remove\"></span> Delete </a> </td> </tr> <?php endforeach; ?> </table> Now, if you open the URL http://localhost/posts/admin in web browser's navigation bar, you should be able to see the page like in figure 12.10 below:","title":"Implementing Admin Page"},{"location":"doctrine/#implementing-tag-cloud","text":"Another major feature we implement in the Blog sample will be the tag cloud. The tag cloud appears on the Home page. The tag cloud contains most popular tags, and tag's font size varies depending on popularity of the tag: most popular tags appear larger than less popular ones. Clicking the tag in the tag cloud results in filtering posts by this tag. For example of what we are trying to achieve, please look at the right side of the figure 12.11 below: For this feature, we need the following things: to create the PostRepository custom entity repository class that would encapsulate the complex logic of filtering posts by tag; to modify the PostManager and add functionality for calculating font sizes for the tag cloud; to add controller's action and corresponding view template.","title":"Implementing Tag Cloud"},{"location":"doctrine/#adding-custom-post-repository","text":"Earlier we mentioned that by default Doctrine uses the Doctrine\\ORM\\EntityRepository as the default repository class. Custom repository is a class extended from EntityRepository class. It is typically used when you need to encapsulate complex DQL queries and search logic in a single place in your code. Note It is also possible to put the DQL queries to controller class, but that would make controllers \"fat\". Since we use MVC pattern, we strive to avoid that. What is DQL? DQL is similar to SQL in sense that it allows to write and execute queries to database, but the result of a query is an array of objects rather than an array of table rows. For more information on DQL and its usage examples, please refer to this page . For our Blog sample web application, we need a custom repository which allows to find published posts having at least one tag (to calculate total count of tagged posts), and, to find published posts filtered by particular tag. We plan to encapsulate this search logic into the custom PostRepository repository. Note Doctrine works with custom repositories transparently. This means, that you retrieve the repository from EntityManager as usual and still can use its findBy() , findOneBy() and other methods. Create the PostRepository.php file inside the Repository directory under the module's source directory. Below, you can find the code of PostRepository class that has two public methods: the findPostsHavingAnyTag() method is designed to select all posts that have status Published and have one or more tags assigned; and the findPostsByTag() method is designed to return all published posts that have the particular tag assigned (to filter posts by the given tag). <?php namespace Application\\Repository; use Doctrine\\ORM\\EntityRepository; use Application\\Entity\\Post; // This is the custom repository class for Post entity. class PostRepository extends EntityRepository { // Finds all published posts having any tag. public function findPostsHavingAnyTag() { $entityManager = $this->getEntityManager(); $queryBuilder = $entityManager->createQueryBuilder(); $queryBuilder->select('p') ->from(Post::class, 'p') ->join('p.tags', 't') ->where('p.status = ?1') ->orderBy('p.dateCreated', 'DESC') ->setParameter('1', Post::STATUS_PUBLISHED); $posts = $queryBuilder->getQuery()->getResult(); return $posts; } // Finds all published posts having the given tag. public function findPostsByTag($tagName) { $entityManager = $this->getEntityManager(); $queryBuilder = $entityManager->createQueryBuilder(); $queryBuilder->select('p') ->from(Post::class, 'p') ->join('p.tags', 't') ->where('p.status = ?1') ->andWhere('t.name = ?2') ->orderBy('p.dateCreated', 'DESC') ->setParameter('1', Post::STATUS_PUBLISHED) ->setParameter('2', $tagName); $posts = $queryBuilder->getQuery()->getResult(); return $posts; } } In the code above, we use the query builder to conveniently create complex DQL queries. In lines 17-22, we create a query which selects all published posts ordering them by date created in descending order. Because we join posts with tags, here we only select posts which have at least one tag. In line 24, we execute the query. If you are curious what DQL the query builder creates, here it is: SELECT p FROM \\Application\\Entity\\Post p JOIN p.tags t WHERE p.status=?1 ORDER BY p.dateCreated DESC In lines 36-43, we create a query that filters posts by tag name. An analogous DQL is presented below: SELECT p FROM \\Application\\Entity\\Post p JOIN p.tags t WHERE p.status=?1 AND t.name=?2 ORDER BY p.dateCreated DESC Note To learn more about Doctrine query builder, please refer to this page . To let Doctrine know that it should use the custom repository for Post entity, modify the Post entity's annotation as follows: <?php //... /** * This class represents a single post in a blog. * @ORM\\Entity(repositoryClass=\"\\Application\\Repository\\PostRepository\") * @ORM\\Table(name=\"post\") */ class Post { //... } Above, in line 6, we use the repositoryClass parameter of the @ORM\\Entity tag to tell Doctrine that it should use PostRepository repository.","title":"Adding Custom Post Repository"},{"location":"doctrine/#calculating-tag-cloud","text":"Business logic for the tag cloud feature will be stored inside of the PostManager::getTagCloud() method, as follows: <?php //... class PostManager { //... // Calculates frequencies of tag usage. public function getTagCloud() { $tagCloud = []; $posts = $this->entityManager->getRepository(Post::class) ->findPostsHavingAnyTag(); $totalPostCount = count($posts); $tags = $this->entityManager->getRepository(Tag::class) ->findAll(); foreach ($tags as $tag) { $postsByTag = $this->entityManager->getRepository(Post::class) ->findPostsByTag($tag->getName()); $postCount = count($postsByTag); if ($postCount > 0) { $tagCloud[$tag->getName()] = $postCount; } } $normalizedTagCloud = []; // Normalize foreach ($tagCloud as $name=>$postCount) { $normalizedTagCloud[$name] = $postCount/$totalPostCount; } return $normalizedTagCloud; } } In the code above, we have the getTagCloud() method that selects all post having at least one tag attached and calculates the \"frequency\" of each available tag (how often the tag appears). Then it normalizes the frequency values (makes them to be between 0 and 1.0).","title":"Calculating Tag Cloud"},{"location":"doctrine/#modifying-controller-action","text":"Here we will modify the IndexController to implement tag filter. <?php //... class IndexController extends AbstractActionController { /** * Post manager. * @var Application\\Service\\PostManager */ private $postManager; // Constructor is used for injecting dependencies into the controller. public function __construct($entityManager, $postManager) { $this->entityManager = $entityManager; $this->postManager = $postManager; } public function indexAction() { $tagFilter = $this->params()->fromQuery('tag', null); if ($tagFilter) { // Filter posts by tag $posts = $this->entityManager->getRepository(Post::class) ->findPostsByTag($tagFilter); } else { // Get recent posts $posts = $this->entityManager->getRepository(Post::class) ->findBy(['status'=>Post::STATUS_PUBLISHED], ['dateCreated'=>'DESC']); } // Get popular tags. $tagCloud = $this->postManager->getTagCloud(); // Render the view template. return new ViewModel([ 'posts' => $posts, 'postManager' => $this->postManager, 'tagCloud' => $tagCloud ]); } } The action method will retrieve the tag from the GET variable tag if the variable doesn't present in HTTP request, all posts are retrieved as usual. If the variable present, we use our custom repository's findPostsByTag() method to filter posts. In line 36, we call the PostManager::getTagCloud() that returns array of tags and their frequencies. We use this information for rendering the cloud. Note Please note that we are now using the PostManager service in our controller and have to inject it into the constructor. Do not forget to modify the controller factory to do that.","title":"Modifying Controller Action"},{"location":"doctrine/#rendering-tag-cloud","text":"Finally, modify the index.phtml file to make it look like follows: <h1>Posts</h1> <div class=\"row\"> <div class=\"col-md-8\"> <?php foreach($posts as $post): ?> <h3> <a href=\"<?= $this->url('posts', ['action'=>'view', 'id'=>$post->getId()]); ?>\"> <?= $this->escapeHtml($post->getTitle()); ?> </a> </h3> <p> Published: <?= $this->escapeHtml(date('jS \\of F Y', strtotime($post->getDateCreated()))); ?> | Tags: <?= $this->escapeHtml($postManager->convertTagsToString($post)); ?> </p> <p class=\"comments-header\"> <?= $this->escapeHtml($postManager->getCommentCountStr($post)); ?> | <a href=\"<?= $this->url('posts', ['action'=>'view', 'id'=>$post->getId()], ['fragment'=>'comment']); ?>\"> Add new comment </a> </p> <p> <?= $this->escapeHtml($post->getContent()); ?> </p> <?php endforeach; ?> </div> <div class=\"col-md-4\"> <div class=\"panel panel-default\"> <div class=\"panel-heading\"> <h3 class=\"panel-title\">Popular Tags</h3> </div> <div class=\"panel-body\"> <?php foreach($this->tagCloud as $tagName=>$frequency): ?> <a href=\"<?= $this->url('application', ['action'=>'index'], ['query'=>['tag'=>$tagName]]); ?>\"> <span style=\"font-size:<?= $this->escapeHtml(0.9 + $frequency*3) ?>em\"> <?= $this->escapeHtml($tagName); ?> </span> </a> <?php endforeach; ?> </div> </div> </div> </div>","title":"Rendering Tag Cloud"},{"location":"doctrine/#implementing-pagination","text":"For now we have only several posts on our Posts page. But assume there are many (hundreds of) posts. The page will be loading very slowly. Also, it would be very inconvenient to scroll the page to read all posts. In this situation, pagination would help. Note Pagination is when you divide your results into pages and navigate through pages by clicking page number links on pagination widget. An example of pagination widget styled with Twitter Bootstrap is presented below:","title":"Implementing Pagination"},{"location":"doctrine/#doctrine-orm-paginator","text":"The Doctrine\\ORM component provides a paginator class named Paginator living in Doctrine\\ORM\\Tools\\Pagination namespace. It can take a Doctrine Query object as input and provides several methods for getting paged results (we won't discuss those methods here for simplicity). But, Doctrine ORM module doesn't provide any view helpers to visualize the pagination widget. For that, we can use the pagination functionality provided by Laminas Framework. Note Although we plan to use Laminas pagination component, we will still use Doctrine ORM paginator internally for consuming data. Laminas paginator will be just a wrapper for Doctrine ORM paginator.","title":"Doctrine ORM Paginator"},{"location":"doctrine/#laminas-paginator","text":"In Laminas Framework, pagination is implemented in @ Laminas\\Paginator component. If you haven't installed this component, do so by typing the following command: php composer.phar require laminas/laminas-paginator The @ Laminas\\Paginator component provides the @ Paginator class. Its most useful methods are listed in table 12.6: Method Description setDefaultScrollingStyle($scrollingStyle = 'Sliding') Sets scrolling style. setDefaultItemCountPerPage($count) Sets maximum count of results per page. setCurrentPageNumber($pageNumber) Sets current page number. count() Retuns number of pages. getTotalItemCount() Returns total number of results. getCurrentItems() Gets items on the current page. Table 12.6. Methods of Laminas Paginator class The @ Paginator class is very generic and doesn't know the underlying data model, so you need to have an adapter which provides the data to paginator. The DoctrineORMModule module provides such adapter ( DoctrineORMModule\\Paginator\\Adapter\\DoctrinePaginator class) which we can use to get data from ORM paginator and pass it to Laminas paginator. For example, assume we have a Query with a DQL that selects all published posts. To get the paginated results with this query, we can use the following code: <?php use DoctrineORMModule\\Paginator\\Adapter\\DoctrinePaginator as DoctrineAdapter; use Doctrine\\ORM\\Tools\\Pagination\\Paginator as ORMPaginator; use Laminas\\Paginator\\Paginator; // Create Laminas paginator. $adapter = new DoctrineAdapter(new ORMPaginator($query, false)); $paginator = new Paginator($adapter); // Set page number and page size. $paginator->setDefaultItemCountPerPage(10); $paginator->setCurrentPageNumber(1); // Walk through the current page of results. foreach ($paginator as $post) { // Do something with the current post. } Now let's apply this example to our Blog application. We want to display the paginated posts on the main page of the Blog website.","title":"Laminas Paginator"},{"location":"doctrine/#modifying-postrepository","text":"First of all, we'll have to slightly modify the way we get the list of posts. Previously, we used the findBy() method of the EntityRepository , which returns array of posts. But now we'll have to do that with our custom repository class PostRepository , because Doctrine ORM paginator takes Query object on input, not an array of posts. Add the following method to PostRepository class: public function findPublishedPosts() { $entityManager = $this->getEntityManager(); $queryBuilder = $entityManager->createQueryBuilder(); $queryBuilder->select('p') ->from(Post::class, 'p') ->where('p.status = ?1') ->orderBy('p.dateCreated', 'DESC') ->setParameter('1', Post::STATUS_PUBLISHED); return $queryBuilder->getQuery(); } And change the findPostsByTag() method, because we want it to also return Query instead of array : public function findPostsByTag($tagName) { $entityManager = $this->getEntityManager(); $queryBuilder = $entityManager->createQueryBuilder(); $queryBuilder->select('p') ->from(Post::class, 'p') ->join('p.tags', 't') ->where('p.status = ?1') ->andWhere('t.name = ?2') ->orderBy('p.dateCreated', 'DESC') ->setParameter('1', Post::STATUS_PUBLISHED) ->setParameter('2', $tagName); return $queryBuilder->getQuery(); } You will also need to slightly modify the PostManager::getTagCloud() method, because it expects an array of posts, but now it will receive the Query . It is a simple and obvious modification, so we won't describe how to do that (refer to Blog sample for the complete code).","title":"Modifying PostRepository"},{"location":"doctrine/#modifying-indexcontroller","text":"Next, modify the indexAction() method of the IndexController as follows: <?php namespace Application\\Controller; // Add aliases for paginator classes use DoctrineORMModule\\Paginator\\Adapter\\DoctrinePaginator as DoctrineAdapter; use Doctrine\\ORM\\Tools\\Pagination\\Paginator as ORMPaginator; use Laminas\\Paginator\\Paginator; // ... class IndexController extends AbstractActionController { // ... public function indexAction() { $page = $this->params()->fromQuery('page', 1); $tagFilter = $this->params()->fromQuery('tag', null); if ($tagFilter) { // Filter posts by tag $query = $this->entityManager->getRepository(Post::class) ->findPostsByTag($tagFilter); } else { // Get recent posts $query = $this->entityManager->getRepository(Post::class) ->findPublishedPosts(); } $adapter = new DoctrineAdapter(new ORMPaginator($query, false)); $paginator = new Paginator($adapter); $paginator->setDefaultItemCountPerPage(1); $paginator->setCurrentPageNumber($page); // Get popular tags. $tagCloud = $this->postManager->getTagCloud(); // Render the view template. return new ViewModel([ 'posts' => $paginator, 'postManager' => $this->postManager, 'tagCloud' => $tagCloud ]); } } You can notice that in line 16 we get the current page number from a GET parameter. So, you can set the page of results by entering the following URL in your browser: http://localhost/application/index?page=<page> \". The default page number is 1. In lines 22 and 27, we retrieve the Query object from our PostRepository instead of array of posts. We then pass this Query object to the Laminas paginator in line 31. In lines 33-34 we set current page number and page size on the paginator. In line 41, we pass the paginator (!) instead of array of posts for rendering to view template.","title":"Modifying IndexController"},{"location":"doctrine/#visualizing-the-pagination-widget","text":"Now it's left the last but not least part of our work. We need to display the pagination widget in our view template. To do that with nice Bootstrap styling, we will need to first create a partial view template view/application/partial/paginator.phtml and put the following code into that file: <?php if ($this->pageCount): ?> <nav> <ul class=\"pagination\"> <!-- Previous page link --> <?php if (isset($this->previous)): ?> <li> <a href=\"<?= $this->url($this->route, [], ['query'=>['page'=>$this->previous]]); ?>\" aria-label=\"Previous\"> <span aria-hidden=\"true\">&laquo;</span> </a> </li> <?php else: ?> <li> <span aria-hidden=\"true\">&laquo;</span> </li> <?php endif; ?> <!-- Numbered page links --> <?php foreach ($this->pagesInRange as $page): ?> <?php if ($page != $this->current): ?> <li> <a href=\"<?= $this->url($this->route, [], ['query'=>['page'=>$page]]); ?>\"><?= $this->escapeHtml($page); ?></a> </li> <?php else: ?> <li> <span aria-hidden=\"true\"><b><?= $this->escapeHtml($page); ?></b></span> </li> <?php endif; ?> <?php endforeach; ?> <!-- Next page link --> <?php if (isset($this->next)): ?> <li> <a href=\"<?php echo $this->url($this->route, [], ['query'=>['page'=>$this->next]]); ?>\" aria-label=\"Next\"> <span aria-hidden=\"true\">&raquo;</span> </a> </li> <?php else: ?> <li> <span aria-hidden=\"true\">&raquo;</span> </li> <?php endif; ?> </ul> </nav> <?php endif; ?> The partial view template will be used by the Laminas @ PaginationControl view helper to visualize the pagination widget. As you can see, this partial view template takes several input variables ( $pageCount , pagesInRange , $current , $previous , $next , $route ) that are used to control how the widget will look like. Now let's display the widget on our view/application/index/index.phtml view template below the list of posts, as follows: <?= $this->paginationControl($posts, 'Sliding', 'application/partial/paginator', ['route' => 'application']); ?> The @ PaginationControl view helper accepts four arguments: the $posts is the @ Paginator object that we passed from controller's action with the @ ViewModel [Laminas\\View\\Model\\ViewModel] variable container. the \"Sliding\" argument is the style of pagination. For additional info on available pagination styles, please refer to Laminas Framework documentation. the \"application/partial/paginator\" is the name of the partial view template containing the markup for the pagination widget. the fourth argument can be used to pass parameters to the partial view template. For example we pass it the route parameter, which is used to generate clickable page links.","title":"Visualizing the Pagination Widget"},{"location":"doctrine/#results","text":"Hooray! Our blog application is ready now. The main page of the website now contains a nice looking pagination widget (see the figure 12.13 below): Note In this chapter we implemented only the simplest pagination. For real websites, in addition to pagination, you might also want to allow interactively sorting your results by certain fields. For such complex tabular data display, consider using the DataTables or BootGrid jQuery plugins.","title":"Results"},{"location":"doctrine/#summary","text":"Doctrine is not part of Laminas Framework, but we cover its usage in this book because it provides an easy way of accessing a database and providing object persistence to your application. In this chapter, we've covered the usage of the Object Relational Mapper (ORM) component of the Doctrine library. The ORM is designed for database management in an object-oriented style. With ORM, you map a database table to a PHP class known as an entity. Columns of that table are mapped to the properties of the entity class. To load data from the database, you retrieve an entity from its repository. The repository is a class that can be considered as a collection of all available entities. The repository loads data from the corresponding database table, and fills one or more entity instance's fields with that data. The tree in figure 12.5 may be different than you have in your own application, because some keys were omitted here for simplicity. \u21a9 Doctrine-provided annotation tags are implemented as classes living inside of Doctrine\\ORM\\Mapping namespace. This is to avoid annotation naming collisions (assume the case when some other component has an annotation named Entity or Table , the collision would happen). \u21a9","title":"Summary"},{"location":"doctrine_intro/","text":"Appendix D. Introduction to Doctrine In this appendix, we provide overview of the Doctrine library, such as its architecture and components. Since in this book we concentrate mainly on Doctrine's Object Relational Mapper (ORM) component, reading this appendix may give you the bigger picture of other Doctrine capabilities. Doctrine and Database Management Systems There are many database management systems (DBMS) on the market. Those systems can be divided into two groups: traditional relational databases utilizing SQL language for querying and manipulating data, and NoSQL databases utilizing \"not only SQL\" methods for accessing and managing the data. In each particular project you may prefer certain DBMS because of its capabilities and competitive advantages. Relational Databases In a relational database , you have a collection of tables (relations) consisting of rows. A row may have one or several columns. A row (or several rows) of a table may be linked to a row (or several rows) of another table, thus forming a relationship between data. For example, assume you have a blog website whose database contains two tables: the post table and the comment table. The post table would have columns named id , title , content , author , date_created ; and the comment table would have columns named id , post_id , author , content , and date_created . The post table is related to comment table as one-to-many, because one post has zero or more (many) comments, while a certain comment may belong to a single post only. Graphically, the above mentioned tables, their columns and relationship are shown in figure D.1 below. On the market, there is a number of major relational databases. Among them: SQLite , MySQL , PostgreSQL , Oracle , Microsoft SQL Server , etc. Each database system has its own features specific to that DBMS and which are not part of other systems. For example: SQLite is designed as an embed extension of PHP engine and doesn't require installation, however it works well for simple sites only; MySQL is a free system which is very simple in installation and administration and good for using in systems varying from small to middle scale; Commercial Oracle DBMS is mainly targeted on large-scale systems and has sophisticated administrative tools; PostgreSQL supports indefinitely large databases and can be considered as an open-source replacement of Oracle. Doctrine library is designed to work with all major databases using a unified programming interface. This programming interface is implemented in two levels: At the lower level, Doctrine provides the unified mechanism for building SQL queries to any supported relational database and manipulating database schema. This mechanism is implemented in the Database Abstraction Layer (DBAL) component. At the higher level, the Object Relational Mapper (ORM) component of Doctrine provides an ability to query and manage database data in object-oriented way, by mapping the tables to PHP classes. This component also provides its custom database query language called DQL allowing to build queries in object-oriented style. Typically, you use the API provided by high-level ORM component. At the same time, you can easily work with lower-level DBAL component, if you find that more suitable for your particular needs. Note Doctrine is database-agnostic. In theory, when you use Doctrine you are able to abstract of database type and switch between databases more easily than when you use your database-dependent solution. SQL vs. DQL When using a relational database system, you typically use SQL language as a standard way for accessing database data and managing database schema. However, each DBMS usually has it own specific SQL language extensions (dialects). Note Doctrine library is designed to work with all major relational database systems that use SQL language, but it is obvious that it supports only some subset of their functionality and SQL language capabilities. Doctrine is built on top of PHP PDO extension (and other database-specific PHP extensions, like sqlite , mysqli , oci8 , etc.). Those extensions provide drivers for all major relational database systems. You specify which driver to use when configuring a database connection. Need to learn SQL first? If you are not familiar with SQL, a good point for learning its syntax is W3Schools Tutorials . Since the Object Relational Mapper component of Doctrine is designed to work with objects instead of tables, it provides its own \"object-oriented\" query language called DQL 2 . It is similar to SQL in sense that it allows to write and execute queries to database, but result of a query is an array of objects rather than an array of table rows. NoSQL Databases In contrast to a relational database system, a NoSQL database system - as its name assumes - uses a not-only-SQL method of accessing the data. This means that each NoSQL system may provide its own custom methods and API for accessing and manipulating the data. Technically, NoSQL databases can be divided in the following groups: Document Store . A document database operates the concept of documents and their fields . This is useful, for example, if you have an hierarchical document tree in a content management (CMS) system. Documents are addressed in the database via a unique key that represents that document. One of the other defining characteristics of a document-oriented database is that, beyond the simple key-document lookup that you can use to retrieve a document, the database will offer an API or query language that will allow retrieval of documents based on their contents. Column Store . Frequently used in web indexing. A column-oriented DBMS is a database management system that stores data tables as sections of columns of data rather than as rows of data. In comparison, most relational DBMSs store data in rows. This column-oriented DBMS has advantages for data warehouses, customer relationship management (CRM) systems, and library card catalogues, and other ad hoc inquiry systems where aggregates are computed over large numbers of similar data items. Key-Value Store . This is the simplest data storage using unique keys for accessing certain data. Such database systems provide a simple key-value lookup mechanism. and others. Note Doctrine provides support only to the Document Store subset of the NoSQL database systems. Column store and key-value store database systems typically have very specific field of applications, and not covered by Doctrine. Document Databases Doctrine supports a number of NoSQL document store databases: MongoDB , CouchDB , OrientDB and PHPCR . For example, in a blog website, you would have a document named post and a document named comment . The post document would have fields named id , title , content , author , date_created ; and the comment document would have fields named id , author , content and date_created . This is very similar to the tables you would have in a relational database. Note In this book, we do not address the Doctrine-provided API to the NoSQL document databases. If you want to learn about these capabilities, please refer to the corresponding sections of Doctrine project documentation. Doctrine Architecture The Doctrine Project consists of several libraries (components). Each Doctrine component is distributed as a Composer-installable package and registered in Packagist.org catalogue. This is very similar to the way that Laminas Framework uses for installing its components. Here we will provide you with a brief description of Doctrine library architecture to let you a general idea of its capabilities. Components Supporting Relational Databases Main Doctrine components designed for working with relational databases are shown in figure D.2 and marked with green. Blue blocks denote the PHP engine and PHP extensions Doctrine is built on top of. As you can see from the figure, Doctrine is based on PHP engine features and on PHP extensions that are actually used as drivers to particular database management systems. Above that base layer, there are core Doctrine components (like Annotations , Common , etc.) providing essential functionality for other top-level components. The DBAL component provides an abstraction layer of database type. And on top of all that there is the ORM component providing API for working with data in object-oriented way. DoctrineModule and DoctrineORMModule components are designed for integration with Laminas Framework. Note Doctrine ORM component uses the so called Data Mapper pattern. This pattern tells that a database table can be represented as a PHP entity class. The database in this pattern is considered as some kind of repository (storage of entities). When you retrieve an entity from the repository, an SQL query is performed internally, and an instance of the PHP entity class is constructed and its properties are filled with data. By analogy with Laminas components, Doctrine component names consist of two parts: the vendor name (\"Doctrine\") and the component name (e.g. \"Common\"). Below, you can find the list of Doctrine components together with their Composer-installable package names and brief descriptions: Doctrine\\Common . Common Library for Doctrine projects. This component contains commonly used functionality. Its Composer-installable package name is doctrine/common . Doctrine\\Annotations . Docblock Annotations Parser. Its Composer-installable package name is doctrine/annotations . Doctrine\\Inflector . Common String Manipulations with regard to casing and singular/plural rules. Its Composer-installable package name is doctrine/inflector . Doctrine\\Lexer . Base library for a lexer that can be used in Top-Down, Recursive Descent Parsers. Its Composer-installable package name is doctrine/lexer . Doctrine\\Cache . Caching library offering an object-oriented API for many cache backends. Its Composer-installable package name is doctrine/cache . Doctrine\\DBAL . Database Abstraction Layer. This is a lightweight and thin runtime layer around a PDO-like API and a lot of additional, horizontal features like database schema introspection and manipulation through an object oriented API. Its Composer-installable package name is doctrine/dbal . Doctrine\\Collections . Collections Abstraction library. Its Composer-installable package name is doctrine/collections . Doctrine\\ORM . Object-Relational-Mapper for PHP. This is a Doctrine component providing a way to work with entity models in object-oriented way instead of raw SQL queries. Its composer installable package name is doctrine/orm . Doctrine\\Migrations . Database Schema migrations using Doctrine DBAL. Provides a consistent way to manage database schema and update it. Its composer installable package name is doctrine/migrations . Doctrine\\DataFixtures . Data Fixtures for all Doctrine Object Managers. Provides a framework for making database fixtures. Its composer installable package name is doctrine/data-fixtures . Since Doctrine uses PHP autoloading and PSR-4 standard, classes belonging to certain component live in that component's namespace. For example, the EntityManager class belonging to Doctrine\\ORM component, lives in Doctrine\\ORM namespace. Components Supporting NoSQL Document Databases Doctrine components designed for working with NoSQL document databases (MongoDB, CouchDB, etc.) are shown in figure D.3 and marked with green. Blue blocks denote the PHP engine and PHP extensions Doctrine is built on top of. As you can see from the figure D.3, Doctrine NoSQL components are based on PHP engine features and on PHP extensions that can be considered as \"drivers\" to particular database management systems. Above that base layer, there are middle level components. The Common component is the same component that was shown in figure D.2; it provides commonly used functionality. The MongoDB and CouchDB are components providing low-level API to corresponding databases. The MongodbODM , CouchdbODM , OrientdbODM and PhpcrODM components provide Object Document Mappers (ODM) for corresponding databases. ODM concept is very similar to ORM in sense that it provides an ability to work with a NoSQL database in object oriented way by mapping a document to a PHP entity class. The DoctrineMongoODMModule component is intended for integration with Laminas. Below, you can find the list of components together with their Composer-installable package names and brief descriptions: Doctrine\\MongoDB is Doctrine MongoDB Abstraction Layer. Its Composer-installable package name is doctrine/mongodb . Doctrine\\MongodbODM (Object Document Mapper) provides a way to map NoSQL documents to PHP entity models. Its Composer-installable package name is doctrine/mongodb-odm . Doctrine\\MongoODMModule is Laminas Framework Module that provides Doctrine MongoDB ODM functionality. It serves for easy integration with Laminas. Its Composer-installable package name is doctrine/doctrine-mongo-odm-module . Doctrine\\CouchDB component provides Simple API that wraps around CouchDBs HTTP API. Its Composer-installable package name is doctrine/couchdb . Doctrine\\CouchdbODM component is CouchDB Document Object Mapper. It is analogous to Doctrine ORM in sence that it provides the way to access database in object oriented way. Its Composer-installable package name is doctrine/couchdb-odm . Doctrine\\OrientdbODM is a set of PHP libraries in order to use OrientDB from PHP. Its Composer-installable package name is doctrine/orientdb-odm . Doctrine\\PhpcrODM is Object-Document-Mapper for PHPCR. Its Composer-installable package name is doctrine/phpcr-odm . Summary In this appendix, we've provided the overview of Doctrine library architecture and components. Doctrine is a large project consisting of multiple components mainly targeted on data persistence. On the market, there are two big groups of database management systems: traditional relational databases and so called NoSQL databases. Although most relational databases use SQL language for querying and manipulating data, each particular database system has its own specific features. The same thing can be seen with NoSQL databases, where each system provides its own custom method for accessing data. Doctrine is designed to work with data in database-agnostic way by providing sophisticated abstraction layers. The most useful component of Doctrine, Object Relational Mapper (ORM) is designed to let the developer an ability to work with data in object oriented way. This is when instead of writing an SQL query, you load an entity object (or an array of entity objects) from a repository. With this approach, a database table is mapped to a PHP class (also called an entity), and a row from that table is mapped to an instance of that entity class. The PHP Data Objects (PDO) extension defines a lightweight, consistent interface for accessing databases in PHP. To make it in database-agnostic way, PDO uses the concept of database drivers. Each database driver that implements the PDO interface can expose database-specific features as regular extension functions. \u21a9 DQL stands for Doctrine Query Language. \u21a9","title":"Appendix D. Introduction to Doctrine"},{"location":"doctrine_intro/#appendix-d-introduction-to-doctrine","text":"In this appendix, we provide overview of the Doctrine library, such as its architecture and components. Since in this book we concentrate mainly on Doctrine's Object Relational Mapper (ORM) component, reading this appendix may give you the bigger picture of other Doctrine capabilities.","title":"Appendix D. Introduction to Doctrine"},{"location":"doctrine_intro/#doctrine-and-database-management-systems","text":"There are many database management systems (DBMS) on the market. Those systems can be divided into two groups: traditional relational databases utilizing SQL language for querying and manipulating data, and NoSQL databases utilizing \"not only SQL\" methods for accessing and managing the data. In each particular project you may prefer certain DBMS because of its capabilities and competitive advantages.","title":"Doctrine and Database Management Systems"},{"location":"doctrine_intro/#relational-databases","text":"In a relational database , you have a collection of tables (relations) consisting of rows. A row may have one or several columns. A row (or several rows) of a table may be linked to a row (or several rows) of another table, thus forming a relationship between data. For example, assume you have a blog website whose database contains two tables: the post table and the comment table. The post table would have columns named id , title , content , author , date_created ; and the comment table would have columns named id , post_id , author , content , and date_created . The post table is related to comment table as one-to-many, because one post has zero or more (many) comments, while a certain comment may belong to a single post only. Graphically, the above mentioned tables, their columns and relationship are shown in figure D.1 below. On the market, there is a number of major relational databases. Among them: SQLite , MySQL , PostgreSQL , Oracle , Microsoft SQL Server , etc. Each database system has its own features specific to that DBMS and which are not part of other systems. For example: SQLite is designed as an embed extension of PHP engine and doesn't require installation, however it works well for simple sites only; MySQL is a free system which is very simple in installation and administration and good for using in systems varying from small to middle scale; Commercial Oracle DBMS is mainly targeted on large-scale systems and has sophisticated administrative tools; PostgreSQL supports indefinitely large databases and can be considered as an open-source replacement of Oracle. Doctrine library is designed to work with all major databases using a unified programming interface. This programming interface is implemented in two levels: At the lower level, Doctrine provides the unified mechanism for building SQL queries to any supported relational database and manipulating database schema. This mechanism is implemented in the Database Abstraction Layer (DBAL) component. At the higher level, the Object Relational Mapper (ORM) component of Doctrine provides an ability to query and manage database data in object-oriented way, by mapping the tables to PHP classes. This component also provides its custom database query language called DQL allowing to build queries in object-oriented style. Typically, you use the API provided by high-level ORM component. At the same time, you can easily work with lower-level DBAL component, if you find that more suitable for your particular needs. Note Doctrine is database-agnostic. In theory, when you use Doctrine you are able to abstract of database type and switch between databases more easily than when you use your database-dependent solution.","title":"Relational Databases"},{"location":"doctrine_intro/#sql-vs-dql","text":"When using a relational database system, you typically use SQL language as a standard way for accessing database data and managing database schema. However, each DBMS usually has it own specific SQL language extensions (dialects). Note Doctrine library is designed to work with all major relational database systems that use SQL language, but it is obvious that it supports only some subset of their functionality and SQL language capabilities. Doctrine is built on top of PHP PDO extension (and other database-specific PHP extensions, like sqlite , mysqli , oci8 , etc.). Those extensions provide drivers for all major relational database systems. You specify which driver to use when configuring a database connection. Need to learn SQL first? If you are not familiar with SQL, a good point for learning its syntax is W3Schools Tutorials . Since the Object Relational Mapper component of Doctrine is designed to work with objects instead of tables, it provides its own \"object-oriented\" query language called DQL 2 . It is similar to SQL in sense that it allows to write and execute queries to database, but result of a query is an array of objects rather than an array of table rows.","title":"SQL vs. DQL"},{"location":"doctrine_intro/#nosql-databases","text":"In contrast to a relational database system, a NoSQL database system - as its name assumes - uses a not-only-SQL method of accessing the data. This means that each NoSQL system may provide its own custom methods and API for accessing and manipulating the data. Technically, NoSQL databases can be divided in the following groups: Document Store . A document database operates the concept of documents and their fields . This is useful, for example, if you have an hierarchical document tree in a content management (CMS) system. Documents are addressed in the database via a unique key that represents that document. One of the other defining characteristics of a document-oriented database is that, beyond the simple key-document lookup that you can use to retrieve a document, the database will offer an API or query language that will allow retrieval of documents based on their contents. Column Store . Frequently used in web indexing. A column-oriented DBMS is a database management system that stores data tables as sections of columns of data rather than as rows of data. In comparison, most relational DBMSs store data in rows. This column-oriented DBMS has advantages for data warehouses, customer relationship management (CRM) systems, and library card catalogues, and other ad hoc inquiry systems where aggregates are computed over large numbers of similar data items. Key-Value Store . This is the simplest data storage using unique keys for accessing certain data. Such database systems provide a simple key-value lookup mechanism. and others. Note Doctrine provides support only to the Document Store subset of the NoSQL database systems. Column store and key-value store database systems typically have very specific field of applications, and not covered by Doctrine.","title":"NoSQL Databases"},{"location":"doctrine_intro/#document-databases","text":"Doctrine supports a number of NoSQL document store databases: MongoDB , CouchDB , OrientDB and PHPCR . For example, in a blog website, you would have a document named post and a document named comment . The post document would have fields named id , title , content , author , date_created ; and the comment document would have fields named id , author , content and date_created . This is very similar to the tables you would have in a relational database. Note In this book, we do not address the Doctrine-provided API to the NoSQL document databases. If you want to learn about these capabilities, please refer to the corresponding sections of Doctrine project documentation.","title":"Document Databases"},{"location":"doctrine_intro/#doctrine-architecture","text":"The Doctrine Project consists of several libraries (components). Each Doctrine component is distributed as a Composer-installable package and registered in Packagist.org catalogue. This is very similar to the way that Laminas Framework uses for installing its components. Here we will provide you with a brief description of Doctrine library architecture to let you a general idea of its capabilities.","title":"Doctrine Architecture"},{"location":"doctrine_intro/#components-supporting-relational-databases","text":"Main Doctrine components designed for working with relational databases are shown in figure D.2 and marked with green. Blue blocks denote the PHP engine and PHP extensions Doctrine is built on top of. As you can see from the figure, Doctrine is based on PHP engine features and on PHP extensions that are actually used as drivers to particular database management systems. Above that base layer, there are core Doctrine components (like Annotations , Common , etc.) providing essential functionality for other top-level components. The DBAL component provides an abstraction layer of database type. And on top of all that there is the ORM component providing API for working with data in object-oriented way. DoctrineModule and DoctrineORMModule components are designed for integration with Laminas Framework. Note Doctrine ORM component uses the so called Data Mapper pattern. This pattern tells that a database table can be represented as a PHP entity class. The database in this pattern is considered as some kind of repository (storage of entities). When you retrieve an entity from the repository, an SQL query is performed internally, and an instance of the PHP entity class is constructed and its properties are filled with data. By analogy with Laminas components, Doctrine component names consist of two parts: the vendor name (\"Doctrine\") and the component name (e.g. \"Common\"). Below, you can find the list of Doctrine components together with their Composer-installable package names and brief descriptions: Doctrine\\Common . Common Library for Doctrine projects. This component contains commonly used functionality. Its Composer-installable package name is doctrine/common . Doctrine\\Annotations . Docblock Annotations Parser. Its Composer-installable package name is doctrine/annotations . Doctrine\\Inflector . Common String Manipulations with regard to casing and singular/plural rules. Its Composer-installable package name is doctrine/inflector . Doctrine\\Lexer . Base library for a lexer that can be used in Top-Down, Recursive Descent Parsers. Its Composer-installable package name is doctrine/lexer . Doctrine\\Cache . Caching library offering an object-oriented API for many cache backends. Its Composer-installable package name is doctrine/cache . Doctrine\\DBAL . Database Abstraction Layer. This is a lightweight and thin runtime layer around a PDO-like API and a lot of additional, horizontal features like database schema introspection and manipulation through an object oriented API. Its Composer-installable package name is doctrine/dbal . Doctrine\\Collections . Collections Abstraction library. Its Composer-installable package name is doctrine/collections . Doctrine\\ORM . Object-Relational-Mapper for PHP. This is a Doctrine component providing a way to work with entity models in object-oriented way instead of raw SQL queries. Its composer installable package name is doctrine/orm . Doctrine\\Migrations . Database Schema migrations using Doctrine DBAL. Provides a consistent way to manage database schema and update it. Its composer installable package name is doctrine/migrations . Doctrine\\DataFixtures . Data Fixtures for all Doctrine Object Managers. Provides a framework for making database fixtures. Its composer installable package name is doctrine/data-fixtures . Since Doctrine uses PHP autoloading and PSR-4 standard, classes belonging to certain component live in that component's namespace. For example, the EntityManager class belonging to Doctrine\\ORM component, lives in Doctrine\\ORM namespace.","title":"Components Supporting Relational Databases"},{"location":"doctrine_intro/#components-supporting-nosql-document-databases","text":"Doctrine components designed for working with NoSQL document databases (MongoDB, CouchDB, etc.) are shown in figure D.3 and marked with green. Blue blocks denote the PHP engine and PHP extensions Doctrine is built on top of. As you can see from the figure D.3, Doctrine NoSQL components are based on PHP engine features and on PHP extensions that can be considered as \"drivers\" to particular database management systems. Above that base layer, there are middle level components. The Common component is the same component that was shown in figure D.2; it provides commonly used functionality. The MongoDB and CouchDB are components providing low-level API to corresponding databases. The MongodbODM , CouchdbODM , OrientdbODM and PhpcrODM components provide Object Document Mappers (ODM) for corresponding databases. ODM concept is very similar to ORM in sense that it provides an ability to work with a NoSQL database in object oriented way by mapping a document to a PHP entity class. The DoctrineMongoODMModule component is intended for integration with Laminas. Below, you can find the list of components together with their Composer-installable package names and brief descriptions: Doctrine\\MongoDB is Doctrine MongoDB Abstraction Layer. Its Composer-installable package name is doctrine/mongodb . Doctrine\\MongodbODM (Object Document Mapper) provides a way to map NoSQL documents to PHP entity models. Its Composer-installable package name is doctrine/mongodb-odm . Doctrine\\MongoODMModule is Laminas Framework Module that provides Doctrine MongoDB ODM functionality. It serves for easy integration with Laminas. Its Composer-installable package name is doctrine/doctrine-mongo-odm-module . Doctrine\\CouchDB component provides Simple API that wraps around CouchDBs HTTP API. Its Composer-installable package name is doctrine/couchdb . Doctrine\\CouchdbODM component is CouchDB Document Object Mapper. It is analogous to Doctrine ORM in sence that it provides the way to access database in object oriented way. Its Composer-installable package name is doctrine/couchdb-odm . Doctrine\\OrientdbODM is a set of PHP libraries in order to use OrientDB from PHP. Its Composer-installable package name is doctrine/orientdb-odm . Doctrine\\PhpcrODM is Object-Document-Mapper for PHPCR. Its Composer-installable package name is doctrine/phpcr-odm .","title":"Components Supporting NoSQL Document Databases"},{"location":"doctrine_intro/#summary","text":"In this appendix, we've provided the overview of Doctrine library architecture and components. Doctrine is a large project consisting of multiple components mainly targeted on data persistence. On the market, there are two big groups of database management systems: traditional relational databases and so called NoSQL databases. Although most relational databases use SQL language for querying and manipulating data, each particular database system has its own specific features. The same thing can be seen with NoSQL databases, where each system provides its own custom method for accessing data. Doctrine is designed to work with data in database-agnostic way by providing sophisticated abstraction layers. The most useful component of Doctrine, Object Relational Mapper (ORM) is designed to let the developer an ability to work with data in object oriented way. This is when instead of writing an SQL query, you load an entity object (or an array of entity objects) from a repository. With this approach, a database table is mapped to a PHP class (also called an entity), and a row from that table is mapped to an instance of that entity class. The PHP Data Objects (PDO) extension defines a lightweight, consistent interface for accessing databases in PHP. To make it in database-agnostic way, PDO uses the concept of database drivers. Each database driver that implements the PDO interface can expose database-specific features as regular extension functions. \u21a9 DQL stands for Doctrine Query Language. \u21a9","title":"Summary"},{"location":"doctrine_migrations/","text":"Database Migrations When you are developing your website, you are constantly modifying your database schema: some tables are being added, others are being modified, unneeded tables are being deleted. Managing database schema may become a very complex task, because you need to keep it up-to-date on your development, testing and production servers. You can greatly simplify the task of managing database schema with the concept of migrations . A migration is some kind of atomic change of state of the database schema. You can apply a migration to upgrade the schema to its newer state, or you can revert a migration to downgrade schema to its previous state. You create new migrations as you develop your website, and you can have as many migrations as you need. All migrations form a database schema change history, which is very convenient, because you know when and for what purpose you changed the schema. Installing Doctrine\\Migrations Component Doctrine provides a special component Doctrine\\Migrations that you can use for implementing database migrations in your website. To install Doctrine\\Migrations component, type the following command: php composer.phar require doctrine/migrations The command above will download and install the component files to the vendor directory and modify your composer.json file as follows: { ... \"require\": { ... \"doctrine/migrations\": \"^1.4\", ... }, ... } Configuring Migrations Before you can use migrations, you'll need to provide the configuration describing what database connection to use, in which table to store migration history, where to store migration classes, etc. To do that, add the following lines to your config/autoload/global.php file: <?php return [ 'doctrine' => [ // migrations configuration 'migrations_configuration' => [ 'orm_default' => [ 'directory' => 'data/Migrations', 'name' => 'Doctrine Database Migrations', 'namespace' => 'Migrations', 'table' => 'migrations', ], ], ], // ... ]; As you can see, we have the doctrine key and its migrations_configuration subkey (line 5). Under this subkey we provide the configuration for migrations: In line 6, we provide the name of entity manager to use ( orm_default ). In line 7, we tell Doctrine that we want to store migrations under the APP_DIR/data/Migrations directory. In line 8, we provide a user-friendly name for our migrations. In line 9, we tell Doctrine that we want that our migration classes live in Migrations namespace. You can specify a namespace of your choice. In line 10, we tell Doctrine that want to store migration history inside of migrations database table. Doctrine will create and manage that table automatically. Creating Migrations A migration is a change set upgrading or downgrading the schema to its next or previous state, respectively. You generate a new empty migration with the help of the following commands: cd APP_DIR ./vendor/bin/doctrine-module migrations:generate The commands above make the application directory the current working directory and then run the migrations:generate console command. Note DoctrineModule and DoctrineORMModule provide several console commands that you can use for various database maintenance tasks (like generating or executing migrations). For the list of available commands, you can use the list command: ./vendor/bin/doctrine-module list Once you run the migrations:generate command, you will be able to find the newly created migration under the APP_DIR/data/Migrations directory. The file has a name like VersionYYYYMMDDHHIISS.php , where YYYY is current year, MM is current month, DD is current day, HH , II and SS represent current hour, minute and second, respectively. If you look into the newly created file, you will find the following content: <?php namespace Migrations; use Doctrine\\DBAL\\Migrations\\AbstractMigration; use Doctrine\\DBAL\\Schema\\Schema; /** * Auto-generated Migration: Please modify to your needs! */ class Version20160901114333 extends AbstractMigration { /** * @param Schema $schema */ public function up(Schema $schema) { // this up() migration is auto-generated, please modify it to your needs } /** * @param Schema $schema */ public function down(Schema $schema) { // this down() migration is auto-generated, please modify it to your needs } } Note If you do not see the newly created migration in NetBeans IDE, you need to open the menu Source and select the Scan for external changes menu item. As you can see from the code above, a migration is a usual PHP class inherited from Doctrine\\DBAL\\Migrations\\AbstractMigration base class. Every migration should have at least two methods: up() and down() . The up() method upgrades the schema to a newer state, the down() method downgrades the schema from its newer state to the previous state. Both up() and down() methods have a single argument of type Doctrine\\DBAL\\Schema\\Schema , which can be used for actual database schema modifications. Note The Schema class is a part of Doctrine\\DBAL component. For more information about the methods it provides, please refer to Doctrine DBAL documentation. Another, even better way is to look at the code inside your vendor/doctrine/dbal directory. A migration class may optionally have the following (overridden) methods (table 13.1): Method Description isTransactional() If this function returns true (default) the migration will be executed in one transaction, otherwise non-transactional state will be used to execute each of the migration SQLs. getDescription() This method should return a string describing the migration (for what purpose this schema change is done) preUp(Schema $schema) This method will be executed before upgrading the schema. postUp(Schema $schema) This method will be executed after upgrading the schema. preDown(Schema $schema) This method will be executed before downgrading the schema. postDown(Schema $schema) This method will be executed after downgrading the schema. Table 13.1. Methods a migration class may have The AbstractMigration base class also provides the following useful methods (table 13.2): Method Description addSql($sql, array $params = [], array $types = []) This method allows to execute an arbitrary SQL request. write($message) This helper method prints a (debug or explanatory) message to screen. throwIrreversibleMigrationException($message = null) This helper method is typically called inside of down() method to signal that the migration cannot be undone. Table 13.2. Methods provided by the base migration class As you can see from table 13.2, you can also modify the schema by calling addSql() method. This method can be used to create a table, to update a table or to remove a table. It can also be used, for example, to insert some data to a table (however, inserting data is not a schema change). Note Doctrine migrations are designed for schema changes, not for inserting data to the database. Although, inserting some initial data to database is useful in some cases. Now that you know how to create a migration, let's create a couple of migrations for our Blog sample. Creating the Initial Migration The first migration we will create is the initial migration. This migration will be applied to empty database schema and will create four tables: post , comment , tag and post_tag . Modify the migration class we have created in the previous section to look like below: <?php namespace Migrations; use Doctrine\\DBAL\\Migrations\\AbstractMigration; use Doctrine\\DBAL\\Schema\\Schema; /** * A migration class. It either upgrades the databases schema (moves it to new state) * or downgrades it to the previous state. */ class Version20160901114333 extends AbstractMigration { /** * Returns the description of this migration. */ public function getDescription() { $description = 'This is the initial migration which creates blog tables.'; return $description; } /** * @param Schema $schema */ public function up(Schema $schema) { // Create 'post' table $table = $schema->createTable('post'); $table->addColumn('id', 'integer', ['autoincrement'=>true]); $table->addColumn('title', 'text', ['notnull'=>true]); $table->addColumn('content', 'text', ['notnull'=>true]); $table->addColumn('status', 'integer', ['notnull'=>true]); $table->addColumn('date_created', 'datetime', ['notnull'=>true]); $table->setPrimaryKey(['id']); $table->addOption('engine' , 'InnoDB'); // Create 'comment' table $table = $schema->createTable('comment'); $table->addColumn('id', 'integer', ['autoincrement'=>true]); $table->addColumn('post_id', 'integer', ['notnull'=>true]); $table->addColumn('content', 'text', ['notnull'=>true]); $table->addColumn('author', 'string', ['notnull'=>true, 'lenght'=>128]); $table->addColumn('date_created', 'datetime', ['notnull'=>true]); $table->setPrimaryKey(['id']); $table->addOption('engine' , 'InnoDB'); // Create 'tag' table $table = $schema->createTable('tag'); $table->addColumn('id', 'integer', ['autoincrement'=>true]); $table->addColumn('name', 'string', ['notnull'=>true, 'lenght'=>128]); $table->setPrimaryKey(['id']); $table->addOption('engine' , 'InnoDB'); // Create 'post_tag' table $table = $schema->createTable('post_tag'); $table->addColumn('id', 'integer', ['autoincrement'=>true]); $table->addColumn('post_id', 'integer', ['notnull'=>true]); $table->addColumn('tag_id', 'integer', ['notnull'=>true]); $table->setPrimaryKey(['id']); $table->addOption('engine' , 'InnoDB'); } /** * @param Schema $schema */ public function down(Schema $schema) { $schema->dropTable('post_tag'); $schema->dropTable('tag'); $schema->dropTable('comment'); $schema->dropTable('post'); } } In the code above we have three methods: the getDescription() method provides the description of the migration. the up() method upgrades the schema to its newer state by adding new tables. the down() method drops tables thus downgrading the schema to its previous state. Adding Another Migration Now assume we decided to improve the performance of our database by adding indexes to our tables. Note If you want to learn about database indexes in more details and why indexes are so helpful, you can refer to an excellent tutorial called Use the Index, Luke . We can also improve data integrity by adding foreign keys. To do this, we have to add another migration. Generate another empty migration with the migrations:generate console command. Modify the code to look like below: <?php namespace Migrations; use Doctrine\\DBAL\\Migrations\\AbstractMigration; use Doctrine\\DBAL\\Schema\\Schema; /** * A migration class. It either upgrades the databases schema (moves it to new state) * or downgrades it to the previous state. */ class Version20160901114938 extends AbstractMigration { /** * Returns the description of this migration. */ public function getDescription() { $description = 'This migration adds indexes and foreign key constraints.'; return $description; } /** * @param Schema $schema */ public function up(Schema $schema) { // Add index to post table $table = $schema->getTable('post'); $table->addIndex(['date_created'], 'date_created_index'); // Add index and foreign key to comment table $table = $schema->getTable('comment'); $table->addIndex(['post_id'], 'post_id_index'); $table->addForeignKeyConstraint('post', ['post_id'], ['id'], [], 'comment_post_id_fk'); // Add indexes and foreign keys to post_tag table $table = $schema->getTable('post_tag'); $table->addIndex(['post_id'], 'post_id_index'); $table->addIndex(['tag_id'], 'tag_id_index'); $table->addForeignKeyConstraint('post', ['post_id'], ['id'], [], 'post_tag_post_id_fk'); $table->addForeignKeyConstraint('tag', ['tag_id'], ['id'], [], 'post_tag_tag_id_fk'); } /** * @param Schema $schema */ public function down(Schema $schema) { $table = $schema->getTable('post_tag'); $table->removeForeignKey('post_tag_post_id_fk'); $table->removeForeignKey('post_tag_tag_id_fk'); $table->dropIndex('post_id_index'); $table->dropIndex('tag_id_index'); $table = $schema->getTable('comment'); $table->dropIndex('post_id_index'); $table->removeForeignKey('comment_post_id_fk'); $table = $schema->getTable('post'); $table->dropIndex('date_created_index'); } } You can find the migrations we have just created inside of the Blog sample bundled with this book. Executing Migrations Once our migration classes are ready, you can apply the migrations to database. To do that, you use the migrations:migrate console command as follows: ./vendor/bin/doctrine-module migrations:migrate The command above applies all available migrations in turn. It writes the IDs of the applied migration to the migrations database table. After that, the migrations table will look as follows: mysql> select * from migrations; +----------------+ | version | +----------------+ | 20160901114333 | | 20160901114938 | +----------------+ 2 rows in set (0.00 sec) If you want to upgrade or downgrade to some specific version, specify the migration ID as the migrations:migrate command's argument as follows: ./vendor/bin/doctrine-module migrations:migrate 20160901114333 You can also use 'prev', 'next' and 'first' aliases as version IDs which respectively move database to its previous state, next state or to the state before the first migration (empty database). So, with migrations you can easily move through migration history and change the database schema as needed. Be careful though that migrations may remove some of your data, so apply them wisely. Summary In this chapter, we have learned about database migrations. Doctrine library provides you a component called Doctrine\\Migrations which allows to implement and apply migrations. A migration is some kind of change set which can be applied to database schema. You can apply a migration to upgrade the schema to its newer state, or you can revert a migration to downgrade schema to its previous state. Migrations are useful, because they allow to store the history of schema changes and apply changes in a standard way. With migrations, you can easily keep your schema up-to-date on every development machine, and on testing, staging and production servers.","title":"Database Migrations"},{"location":"doctrine_migrations/#database-migrations","text":"When you are developing your website, you are constantly modifying your database schema: some tables are being added, others are being modified, unneeded tables are being deleted. Managing database schema may become a very complex task, because you need to keep it up-to-date on your development, testing and production servers. You can greatly simplify the task of managing database schema with the concept of migrations . A migration is some kind of atomic change of state of the database schema. You can apply a migration to upgrade the schema to its newer state, or you can revert a migration to downgrade schema to its previous state. You create new migrations as you develop your website, and you can have as many migrations as you need. All migrations form a database schema change history, which is very convenient, because you know when and for what purpose you changed the schema.","title":"Database Migrations"},{"location":"doctrine_migrations/#installing-doctrinemigrations-component","text":"Doctrine provides a special component Doctrine\\Migrations that you can use for implementing database migrations in your website. To install Doctrine\\Migrations component, type the following command: php composer.phar require doctrine/migrations The command above will download and install the component files to the vendor directory and modify your composer.json file as follows: { ... \"require\": { ... \"doctrine/migrations\": \"^1.4\", ... }, ... }","title":"Installing Doctrine\\Migrations Component"},{"location":"doctrine_migrations/#configuring-migrations","text":"Before you can use migrations, you'll need to provide the configuration describing what database connection to use, in which table to store migration history, where to store migration classes, etc. To do that, add the following lines to your config/autoload/global.php file: <?php return [ 'doctrine' => [ // migrations configuration 'migrations_configuration' => [ 'orm_default' => [ 'directory' => 'data/Migrations', 'name' => 'Doctrine Database Migrations', 'namespace' => 'Migrations', 'table' => 'migrations', ], ], ], // ... ]; As you can see, we have the doctrine key and its migrations_configuration subkey (line 5). Under this subkey we provide the configuration for migrations: In line 6, we provide the name of entity manager to use ( orm_default ). In line 7, we tell Doctrine that we want to store migrations under the APP_DIR/data/Migrations directory. In line 8, we provide a user-friendly name for our migrations. In line 9, we tell Doctrine that we want that our migration classes live in Migrations namespace. You can specify a namespace of your choice. In line 10, we tell Doctrine that want to store migration history inside of migrations database table. Doctrine will create and manage that table automatically.","title":"Configuring Migrations"},{"location":"doctrine_migrations/#creating-migrations","text":"A migration is a change set upgrading or downgrading the schema to its next or previous state, respectively. You generate a new empty migration with the help of the following commands: cd APP_DIR ./vendor/bin/doctrine-module migrations:generate The commands above make the application directory the current working directory and then run the migrations:generate console command. Note DoctrineModule and DoctrineORMModule provide several console commands that you can use for various database maintenance tasks (like generating or executing migrations). For the list of available commands, you can use the list command: ./vendor/bin/doctrine-module list Once you run the migrations:generate command, you will be able to find the newly created migration under the APP_DIR/data/Migrations directory. The file has a name like VersionYYYYMMDDHHIISS.php , where YYYY is current year, MM is current month, DD is current day, HH , II and SS represent current hour, minute and second, respectively. If you look into the newly created file, you will find the following content: <?php namespace Migrations; use Doctrine\\DBAL\\Migrations\\AbstractMigration; use Doctrine\\DBAL\\Schema\\Schema; /** * Auto-generated Migration: Please modify to your needs! */ class Version20160901114333 extends AbstractMigration { /** * @param Schema $schema */ public function up(Schema $schema) { // this up() migration is auto-generated, please modify it to your needs } /** * @param Schema $schema */ public function down(Schema $schema) { // this down() migration is auto-generated, please modify it to your needs } } Note If you do not see the newly created migration in NetBeans IDE, you need to open the menu Source and select the Scan for external changes menu item. As you can see from the code above, a migration is a usual PHP class inherited from Doctrine\\DBAL\\Migrations\\AbstractMigration base class. Every migration should have at least two methods: up() and down() . The up() method upgrades the schema to a newer state, the down() method downgrades the schema from its newer state to the previous state. Both up() and down() methods have a single argument of type Doctrine\\DBAL\\Schema\\Schema , which can be used for actual database schema modifications. Note The Schema class is a part of Doctrine\\DBAL component. For more information about the methods it provides, please refer to Doctrine DBAL documentation. Another, even better way is to look at the code inside your vendor/doctrine/dbal directory. A migration class may optionally have the following (overridden) methods (table 13.1): Method Description isTransactional() If this function returns true (default) the migration will be executed in one transaction, otherwise non-transactional state will be used to execute each of the migration SQLs. getDescription() This method should return a string describing the migration (for what purpose this schema change is done) preUp(Schema $schema) This method will be executed before upgrading the schema. postUp(Schema $schema) This method will be executed after upgrading the schema. preDown(Schema $schema) This method will be executed before downgrading the schema. postDown(Schema $schema) This method will be executed after downgrading the schema. Table 13.1. Methods a migration class may have The AbstractMigration base class also provides the following useful methods (table 13.2): Method Description addSql($sql, array $params = [], array $types = []) This method allows to execute an arbitrary SQL request. write($message) This helper method prints a (debug or explanatory) message to screen. throwIrreversibleMigrationException($message = null) This helper method is typically called inside of down() method to signal that the migration cannot be undone. Table 13.2. Methods provided by the base migration class As you can see from table 13.2, you can also modify the schema by calling addSql() method. This method can be used to create a table, to update a table or to remove a table. It can also be used, for example, to insert some data to a table (however, inserting data is not a schema change). Note Doctrine migrations are designed for schema changes, not for inserting data to the database. Although, inserting some initial data to database is useful in some cases. Now that you know how to create a migration, let's create a couple of migrations for our Blog sample.","title":"Creating Migrations"},{"location":"doctrine_migrations/#creating-the-initial-migration","text":"The first migration we will create is the initial migration. This migration will be applied to empty database schema and will create four tables: post , comment , tag and post_tag . Modify the migration class we have created in the previous section to look like below: <?php namespace Migrations; use Doctrine\\DBAL\\Migrations\\AbstractMigration; use Doctrine\\DBAL\\Schema\\Schema; /** * A migration class. It either upgrades the databases schema (moves it to new state) * or downgrades it to the previous state. */ class Version20160901114333 extends AbstractMigration { /** * Returns the description of this migration. */ public function getDescription() { $description = 'This is the initial migration which creates blog tables.'; return $description; } /** * @param Schema $schema */ public function up(Schema $schema) { // Create 'post' table $table = $schema->createTable('post'); $table->addColumn('id', 'integer', ['autoincrement'=>true]); $table->addColumn('title', 'text', ['notnull'=>true]); $table->addColumn('content', 'text', ['notnull'=>true]); $table->addColumn('status', 'integer', ['notnull'=>true]); $table->addColumn('date_created', 'datetime', ['notnull'=>true]); $table->setPrimaryKey(['id']); $table->addOption('engine' , 'InnoDB'); // Create 'comment' table $table = $schema->createTable('comment'); $table->addColumn('id', 'integer', ['autoincrement'=>true]); $table->addColumn('post_id', 'integer', ['notnull'=>true]); $table->addColumn('content', 'text', ['notnull'=>true]); $table->addColumn('author', 'string', ['notnull'=>true, 'lenght'=>128]); $table->addColumn('date_created', 'datetime', ['notnull'=>true]); $table->setPrimaryKey(['id']); $table->addOption('engine' , 'InnoDB'); // Create 'tag' table $table = $schema->createTable('tag'); $table->addColumn('id', 'integer', ['autoincrement'=>true]); $table->addColumn('name', 'string', ['notnull'=>true, 'lenght'=>128]); $table->setPrimaryKey(['id']); $table->addOption('engine' , 'InnoDB'); // Create 'post_tag' table $table = $schema->createTable('post_tag'); $table->addColumn('id', 'integer', ['autoincrement'=>true]); $table->addColumn('post_id', 'integer', ['notnull'=>true]); $table->addColumn('tag_id', 'integer', ['notnull'=>true]); $table->setPrimaryKey(['id']); $table->addOption('engine' , 'InnoDB'); } /** * @param Schema $schema */ public function down(Schema $schema) { $schema->dropTable('post_tag'); $schema->dropTable('tag'); $schema->dropTable('comment'); $schema->dropTable('post'); } } In the code above we have three methods: the getDescription() method provides the description of the migration. the up() method upgrades the schema to its newer state by adding new tables. the down() method drops tables thus downgrading the schema to its previous state.","title":"Creating the Initial Migration"},{"location":"doctrine_migrations/#adding-another-migration","text":"Now assume we decided to improve the performance of our database by adding indexes to our tables. Note If you want to learn about database indexes in more details and why indexes are so helpful, you can refer to an excellent tutorial called Use the Index, Luke . We can also improve data integrity by adding foreign keys. To do this, we have to add another migration. Generate another empty migration with the migrations:generate console command. Modify the code to look like below: <?php namespace Migrations; use Doctrine\\DBAL\\Migrations\\AbstractMigration; use Doctrine\\DBAL\\Schema\\Schema; /** * A migration class. It either upgrades the databases schema (moves it to new state) * or downgrades it to the previous state. */ class Version20160901114938 extends AbstractMigration { /** * Returns the description of this migration. */ public function getDescription() { $description = 'This migration adds indexes and foreign key constraints.'; return $description; } /** * @param Schema $schema */ public function up(Schema $schema) { // Add index to post table $table = $schema->getTable('post'); $table->addIndex(['date_created'], 'date_created_index'); // Add index and foreign key to comment table $table = $schema->getTable('comment'); $table->addIndex(['post_id'], 'post_id_index'); $table->addForeignKeyConstraint('post', ['post_id'], ['id'], [], 'comment_post_id_fk'); // Add indexes and foreign keys to post_tag table $table = $schema->getTable('post_tag'); $table->addIndex(['post_id'], 'post_id_index'); $table->addIndex(['tag_id'], 'tag_id_index'); $table->addForeignKeyConstraint('post', ['post_id'], ['id'], [], 'post_tag_post_id_fk'); $table->addForeignKeyConstraint('tag', ['tag_id'], ['id'], [], 'post_tag_tag_id_fk'); } /** * @param Schema $schema */ public function down(Schema $schema) { $table = $schema->getTable('post_tag'); $table->removeForeignKey('post_tag_post_id_fk'); $table->removeForeignKey('post_tag_tag_id_fk'); $table->dropIndex('post_id_index'); $table->dropIndex('tag_id_index'); $table = $schema->getTable('comment'); $table->dropIndex('post_id_index'); $table->removeForeignKey('comment_post_id_fk'); $table = $schema->getTable('post'); $table->dropIndex('date_created_index'); } } You can find the migrations we have just created inside of the Blog sample bundled with this book.","title":"Adding Another Migration"},{"location":"doctrine_migrations/#executing-migrations","text":"Once our migration classes are ready, you can apply the migrations to database. To do that, you use the migrations:migrate console command as follows: ./vendor/bin/doctrine-module migrations:migrate The command above applies all available migrations in turn. It writes the IDs of the applied migration to the migrations database table. After that, the migrations table will look as follows: mysql> select * from migrations; +----------------+ | version | +----------------+ | 20160901114333 | | 20160901114938 | +----------------+ 2 rows in set (0.00 sec) If you want to upgrade or downgrade to some specific version, specify the migration ID as the migrations:migrate command's argument as follows: ./vendor/bin/doctrine-module migrations:migrate 20160901114333 You can also use 'prev', 'next' and 'first' aliases as version IDs which respectively move database to its previous state, next state or to the state before the first migration (empty database). So, with migrations you can easily move through migration history and change the database schema as needed. Be careful though that migrations may remove some of your data, so apply them wisely.","title":"Executing Migrations"},{"location":"doctrine_migrations/#summary","text":"In this chapter, we have learned about database migrations. Doctrine library provides you a component called Doctrine\\Migrations which allows to implement and apply migrations. A migration is some kind of change set which can be applied to database schema. You can apply a migration to upgrade the schema to its newer state, or you can revert a migration to downgrade schema to its previous state. Migrations are useful, because they allow to store the history of schema changes and apply changes in a standard way. With migrations, you can easily keep your schema up-to-date on every development machine, and on testing, staging and production servers.","title":"Summary"},{"location":"ec2_tutorial/","text":"Appendix E. Installing a Laminas Web Application to Amazon EC2 Once you have developed a laminas-based website, you'll need to install it on some publicly acessible web server to make it visible to other people. If you want to install a Laminas Framework based web application, but do not have a web server yet, this tutorial is for you. In this tutorial, we will show how to create a virtual Linux machine in the Amazon Web Services Cloud for free and how to install the Hello World application on that machine. What is Amazon Web Services? Amazon Web Services (AWS) is a cloud platform providing scalable and reliable web hosting services. Cloud computing is the delivery of computing and storage capacity as a service to a community of end-recipients. With AWS, you can easily set up a web server and access it in a few minutes. For new users, Amazon provides a free usage tier: you are able to run a web server for one year absolutely for free. So, with AWS free usage tier you have: virtual Linux server (613 MB of memory and 32-bit and 64-bit platform support); 30 GB of storage; 15 GB of traffic per month; a dedicated external IP address. And all this you can register and prepare for work in half an hour, if you have a credit card that Amazon accepts (Amazon will charge $2 during registration) and a phone (Amazon may request your identity verification). Creating Amazon Web Services Account To create new AWS account, you need to open Amazon Web Services page in your browser and click the Sign Up button. The Sign In or Create an AWS Account page appears (shown in the figure below): You need to enter your E-mail address, select the I am a new user option and click the Sign in using our secure server button. Then you have to pass through several registration steps: account creation, payment method choice, identity verification and confirmation. When you are ready with registration, sign into your AWS account, click the My Account/Console button and select AWS Management Console from drop-down menu. AWS Management Console page appears (shown in the figure below): The AWS Management Console displays the products currently accessible by you. You are interested in EC2 product (Elastic Compute Cloud, shortly EC2), because EC2 allows to run a virtual Linux server. In terms of AWS, such a virtual server is also called an EC2 Instance. Creating a Key Pair A key pair is used by AWS to authenticate you when you will connect to the EC2 virtual machine. The key pair consists of two keys: the public key and the private key. The private key should be stored in a secret place, and you should not give it to anyone. Click EC2 icon in your AWS Management Console window. EC2 Console page appears. The page has a side bar menu where you can find several sections like INSTANCES , IMAGES , ELASTIC BLOCK STORE , NETWORK & SECURITY . In order to securely connect to your virtual server through SSH protocol, you need to create a key pair. To do this, in the EC2 Console side bar menu, under NETWORK & SECURITY section, click the Key Pairs link. On the page that appears, click the Create Key Pair button and enter the name for your new key pair (for example, enter \u2018test\u2019) and press the Create button. When your key pair has been generated, you are offered to download the key as a PEM file. Save the file to some folder \u2013 you will need it later. Launching EC2 Linux Instance On the EC2 Console side bar menu, under the INSTANCES section, click the Instances link, and on the page that appears, click the Launch Instance button. Then you will have to pass through several Wizard-like pages. Step 1 \u2013 Choose an Amazon Machine Image (AMI) The first of them is the Choose an Amazon Machine Image (AMI) page (shown in the figure below). On the page that appears, you need to select the Linux distribution you want to run on the virutal machine. In this tutorial, we choose Amazon Linux AMI, 64-bit . Note Amazon Linux is a distribution from Red Hat Linux and Cent OS family. The installation instructions are common between these distributions. For example, all these distributions use the yum package manager. So, if you know how to install a program in Cent OS, you will be able to apply the same steps to install it in Amazon Linux. In this tutorial, we use Amazon Linux, but you may select another distribution, if you wish. Click the Select button at the right side of the Amazon Linux AMI option. Step 2 \u2014 Choose an Instance Type Next, the Choose an Instance Type page appears (see the figure below). On that page, you can choose the parameters of the virtual machine which affect its performance. In this tutorial, we will use the Micro Instance type, which is available for free usage. Please note that the Micro Instance type is limited in CPU and memory resources, so it is not well suitable for high-load production systems. Now click the Next button to proceed to the next page. Step 3 \u2014 Configure Instance The Configure Instance page appears (shown in figure below). On that page, you can edit instance details. It will be enough to set check on the Enable termination protection check box (this will protect the virtual machine from accidental termination). Step 4 \u2014 Add Storage Click the Next button to go to the Add Storage page (see figure below for example). On that page, you can adjust the size of the virtual hard disk drive attached to your virtual machine (for the free usage, you are able to allocate up to 30 GB of storage space). This disk drive is part of EBS service (Elastic Block Storage). It is very reliable and automatically backed up to protect your data from accidental loss. Step 5 \u2014 Tag Instance Click the Next button to go to the next page called Tag Instance . On that page, you will be able to add one or several tags to distinguish this EC2 instance from the others (in the future, you may launch more instances in your account). For example, add the Name tag and set its value to \"Webserver\". This will help you to remember that this instance's purpose is to run the Apache Web Server. Step 6 \u2014 Security Group Click the Next button to go to the next page called Security Group (see below). On the Security Group page, you need to configure the security group rules (firewall) for the EC2 instance. The rules define what ports will be open for inbound access. By default, your EC2 instance allows access through SSH (port 22). You also need to add a rule allowing to access port 80 (HTTP). To do this, click the Add Rule button and enter 80 into the Port range field. Step 7 \u2014 Review Instance Launch Click the Next button to go to the last page named Review Instance Launch. On this page you are able to review the virtual machine settings before you launch it. When you are ready, click the Launch button. The Select an existing keypair of create a new keypair pop-up window appears. In this window, select the 'test' keypair from the list of existing keypairs (we have created the 'test' keypair earlier) and click the Launch Instances button to trigger the instance launch process. Now you should be able to see your instance on the Instances page (see the figure below). Assigning an IP Address to the Instance Every web server on the Internet has a dedicated IP address by which others can refer to it. Next, you need to assign an IP address to the EC2 instance you have just created. To do this, click the Elastic IPs link in the side bar menu (under NETWORK & SECURITY section). On the page that appears, click Allocate New Address button. In the appeared window, click the Allocate button. The new IP address is now displayed in the list of Elastic IPs. You must immediately assign the created IP address to your instance. To do this, click the check box to the left of your IP address and click the Associate Address button above the IP address list. In the window that appears, select the instance name and click the Yes, Associate button. Connecting to EC2 Instance through SSH Next we want to connect to the virtual server we\u2019ve just created. In this tutorial, we will use PuTTY \u2013 a free implementation of Telnet and SSH for Windows and Unix platforms. Download PuTTY archive from this link . Then unzip it to some folder. You need to import the key pair you have downloaded earlier as a PEM file. To do this, run PUTTYGEN.EXE from PuTTY distribution. PuTTY Key Generator window appears. In this window, click the Load button and choose your PEM file to load your existing key pair. Next enter some password to protect your key (see the image below). Remember the password, because it will be needed later. Finally, click the Save private key button to save your password-protected key as a PPK file. Now you are ready to connect to your EC2 instance. Run PUTTY.EXE from PuTTY distribution. The PuTTY Configuration window appears. In that window, select the Connection->SSH->Auth category from the side bar menu and enter the path to your PPK file into the Private key for connection field (see the figure below). Select Window->Translation category from side bar menu and select the UTF-8 encoding from drop-down list (see the figure below for example): Select Session category from side bar menu. Into the Host name (or IP address) field, enter the IP address you assigned to your EC2 instance. In the Saved sessions field, enter 'webserver' and press Save button. Now the information you entered is saved, so you don't have to enter it each time you connect. Now double-click the webserver item in the list of saved sessions. Terminal window appears. You need to enter 'ec2-user' as your login and press Enter. Then enter the password that you used when creating the PPK file and press Enter again. If everything is OK, you should be able to see the prompt like in the figure below: In the shell terminal window, you can type commands and see the results of the command execution. Installing Apache HTTP Server and PHP Engine For Laminas Framework based website to run, you need to have a web server and the PHP engine installed. The next thing we plan to do is installing Apache Web Server and PHP. First, it is recommended that you update the system by typing the following shell command: sudo yum update You do not have to type all commands manually, instead you can copy and paste them. Select the command in this window and copy it into the clipboard (CTRL+C), then click your mouse's right button over the PuTTY terminal window to insert the text. To install Apache HTTP Server, type the following command: sudo yum install httpd Install the PHP engine: sudo yum install php And finally, install the PHP engine\u2019s GD extension (this extension is required by the Hello World web application to run correctly): sudo yum install php-gd Add Apache HTTP Server to system autorun and start it: sudo chkconfig --level 235 httpd on sudo service httpd start To check that Apache Web Server works, enter the IP address of your EC2 instance in your web browser\u2019s navigation bar. If everything is OK, you should see the page like below: Next, we will edit the PHP config file to set the time zone settings (in this tutorial, we will use our favorite Midnight Commander editor for this purpose). Install MC: sudo yum install mc Open the php.ini file with MC: sudo mcedit /etc/php.ini Set your time zone settings (replace YOUR_TIMEZONE placeholder with your time zone, for example, UTC or America/New_York): date.timezone = YOUR_TIMEZONE When ready, save your changes by pressing the F2 key and then press F10 to exit from Midnight Commander\u2019s editor. Installing the Hello World Web Application To get the Hello World application code, we will download the code samples archive bundled with this book from GitHub. The following shell commands will create directory for downloads and make it current: mkdir ~/downloads cd ~/downloads Download the code samples archive bundled with the book by typing the following: wget https://github.com/olegkrivtsov/using-laminas-book-samples/archive/master.zip Unpack the archive with the unzip command and move the files to web server\u2019s document root directory: unzip master.zip sudo mv using-laminas-book-samples-master/* /var/www/html Next, set file and directory permissions to allow Apache read and write access to the Hello World application files: sudo chmod -R 755 /var/www/html/helloworld sudo chown -R apache:apache /var/www/html/helloworld Creating Virtual Host Now we are almost ready to get our Hello World website live! The last thing we are going to do is configuring an Apache virtual host. To do that, we will edit the httpd.conf file: sudo mcedit /etc/httpd/conf/httpd.conf If you scroll the file down to its end, you may encounter the commented text block as follows: # # Use name-based virtual hosting. # #NameVirtualHost *:80 # # NOTE: NameVirtualHost cannot be used without a port specifier. # (e.g. :80) if mod_ssl is being used, due to the nature of the # SSL protocol. # # # VirtualHost example: # Almost any Apache directive may go into a VirtualHost container. # The first VirtualHost section is used for requests without a known # server name. # #<VirtualHost *:80> # ServerAdmin webmaster@dummy-host.example.com # DocumentRoot /www/docs/dummy-host.example.com # ServerName dummy-host.example.com # ErrorLog logs/dummy-host.example.com-error_log # CustomLog logs/dummy-host.example.com-access_log common #</VirtualHost> To add a virtual host, you\u2019ll have to uncomment this block and add some rules in it. After your changes, this text block will look like below: # # Use name-based virtual hosting. # NameVirtualHost *:80 # # NOTE: NameVirtualHost cannot be used without a port specifier. # (e.g. :80) if mod_ssl is being used, due to the nature of the # SSL protocol. # # # VirtualHost example: # Almost any Apache directive may go into a VirtualHost container. # The first VirtualHost section is used for requests without a known # server name. # <VirtualHost *:80> ServerAdmin yourname@yourserver.com DocumentRoot /var/www/html/helloworld/public <Directory /var/www/html/helloworld/public> DirectoryIndex index.php AllowOverride All Require all granted </Directory> </VirtualHost> When ready, press F2 to save changes and F10 to exit from Midnight Commander. Restart Apache to apply your changes: sudo service httpd restart Installing Laminas Framework with Composer Now we will use Composer to install Laminas Framework code and initialize autoloader. First, go to the directory where you installed the Hello World web application and type the self-update command to update the Composer: cd /var/www/html/helloworld sudo php composer.phar self-update The expected output of this command is the following: Updating to version 604a65cc31f3e5d8a2b96802135ac24434e87678. Downloading: 100% Next, type the install command to make Composer to download and install Laminas Framework code: sudo php composer.phar install The expected output will look like as the following: Loading composer repositories with package information Installing dependencies (including require-dev) from lock file Warning: The lock file is not up to date with the latest changes in composer.json. You may be getting outdated dependencies. Run update to update them. - Installing laminas/laminas (2.2.4) Downloading: 100% Skipped installation of bin/classmap_generator.php for package laminas/laminas: name conflicts with an existing file Skipped installation of bin/pluginmap_generator.php for package laminas/laminas: name conflicts with an existing file Skipped installation of bin/templatemap_generator.php for package laminas/laminas: name conflicts with an existing file laminas/laminas suggests installing doctrine/annotations (Doctrine Annotations >=1.0 for annotation features) laminas/laminas suggests installing ext-intl (ext/intl for i18n features (included in default builds of PHP)) laminas/laminas suggests installing ircmaxell/random-lib (Fallback random byte generator for Laminas\\Math\\Rand if OpenSSL/Mcrypt extensions are unavailable) laminas/laminas suggests installing ocramius/proxy-manager (ProxyManager to handle lazy initialization of services) laminas/laminas suggests installing laminas/Laminaspdf (LaminasPdf for creating PDF representations of barcodes) laminas/laminas suggests installing laminas/Laminasservice-recaptcha (LaminasService\\ReCaptcha for rendering ReCaptchas in Laminas\\Captcha and/or Laminas\\Form) Generating autoload files Results Once the above steps are done, you will be able to open the Hello World website in your web browser. If you type the IP address of your EC2 instance in the browser, you should be able to see the following page: Congratulations! You have completed this tutorial and now you should be able to install any Laminas Framework based website to an Amazon EC2 instance. Summary When your laminas-based website is ready, you'll need to install it on a publicly acessible web server to make it visible to other people. In this tutorial, we have shown how to install a laminas-based website to a Amazon EC2 virtual machine. First, you log in to Amazon Management Console and create a EC2 instanse. Then you connect to the newly created VM and install Apache HTTP server and PHP engine. Finally, you copy your website files and install dependencies with Composer. That simple!","title":"Appendix E. Installing a Laminas Web Application to Amazon EC2"},{"location":"ec2_tutorial/#appendix-e-installing-a-laminas-web-application-to-amazon-ec2","text":"Once you have developed a laminas-based website, you'll need to install it on some publicly acessible web server to make it visible to other people. If you want to install a Laminas Framework based web application, but do not have a web server yet, this tutorial is for you. In this tutorial, we will show how to create a virtual Linux machine in the Amazon Web Services Cloud for free and how to install the Hello World application on that machine.","title":"Appendix E. Installing a Laminas Web Application to Amazon EC2"},{"location":"ec2_tutorial/#what-is-amazon-web-services","text":"Amazon Web Services (AWS) is a cloud platform providing scalable and reliable web hosting services. Cloud computing is the delivery of computing and storage capacity as a service to a community of end-recipients. With AWS, you can easily set up a web server and access it in a few minutes. For new users, Amazon provides a free usage tier: you are able to run a web server for one year absolutely for free. So, with AWS free usage tier you have: virtual Linux server (613 MB of memory and 32-bit and 64-bit platform support); 30 GB of storage; 15 GB of traffic per month; a dedicated external IP address. And all this you can register and prepare for work in half an hour, if you have a credit card that Amazon accepts (Amazon will charge $2 during registration) and a phone (Amazon may request your identity verification).","title":"What is Amazon Web Services?"},{"location":"ec2_tutorial/#creating-amazon-web-services-account","text":"To create new AWS account, you need to open Amazon Web Services page in your browser and click the Sign Up button. The Sign In or Create an AWS Account page appears (shown in the figure below): You need to enter your E-mail address, select the I am a new user option and click the Sign in using our secure server button. Then you have to pass through several registration steps: account creation, payment method choice, identity verification and confirmation. When you are ready with registration, sign into your AWS account, click the My Account/Console button and select AWS Management Console from drop-down menu. AWS Management Console page appears (shown in the figure below): The AWS Management Console displays the products currently accessible by you. You are interested in EC2 product (Elastic Compute Cloud, shortly EC2), because EC2 allows to run a virtual Linux server. In terms of AWS, such a virtual server is also called an EC2 Instance.","title":"Creating Amazon Web Services Account"},{"location":"ec2_tutorial/#creating-a-key-pair","text":"A key pair is used by AWS to authenticate you when you will connect to the EC2 virtual machine. The key pair consists of two keys: the public key and the private key. The private key should be stored in a secret place, and you should not give it to anyone. Click EC2 icon in your AWS Management Console window. EC2 Console page appears. The page has a side bar menu where you can find several sections like INSTANCES , IMAGES , ELASTIC BLOCK STORE , NETWORK & SECURITY . In order to securely connect to your virtual server through SSH protocol, you need to create a key pair. To do this, in the EC2 Console side bar menu, under NETWORK & SECURITY section, click the Key Pairs link. On the page that appears, click the Create Key Pair button and enter the name for your new key pair (for example, enter \u2018test\u2019) and press the Create button. When your key pair has been generated, you are offered to download the key as a PEM file. Save the file to some folder \u2013 you will need it later.","title":"Creating a Key Pair"},{"location":"ec2_tutorial/#launching-ec2-linux-instance","text":"On the EC2 Console side bar menu, under the INSTANCES section, click the Instances link, and on the page that appears, click the Launch Instance button. Then you will have to pass through several Wizard-like pages.","title":"Launching EC2 Linux Instance"},{"location":"ec2_tutorial/#step-1-choose-an-amazon-machine-image-ami","text":"The first of them is the Choose an Amazon Machine Image (AMI) page (shown in the figure below). On the page that appears, you need to select the Linux distribution you want to run on the virutal machine. In this tutorial, we choose Amazon Linux AMI, 64-bit . Note Amazon Linux is a distribution from Red Hat Linux and Cent OS family. The installation instructions are common between these distributions. For example, all these distributions use the yum package manager. So, if you know how to install a program in Cent OS, you will be able to apply the same steps to install it in Amazon Linux. In this tutorial, we use Amazon Linux, but you may select another distribution, if you wish. Click the Select button at the right side of the Amazon Linux AMI option.","title":"Step 1 \u2013 Choose an Amazon Machine Image (AMI)"},{"location":"ec2_tutorial/#step-2-choose-an-instance-type","text":"Next, the Choose an Instance Type page appears (see the figure below). On that page, you can choose the parameters of the virtual machine which affect its performance. In this tutorial, we will use the Micro Instance type, which is available for free usage. Please note that the Micro Instance type is limited in CPU and memory resources, so it is not well suitable for high-load production systems. Now click the Next button to proceed to the next page.","title":"Step 2 \u2014 Choose an Instance Type"},{"location":"ec2_tutorial/#step-3-configure-instance","text":"The Configure Instance page appears (shown in figure below). On that page, you can edit instance details. It will be enough to set check on the Enable termination protection check box (this will protect the virtual machine from accidental termination).","title":"Step 3 \u2014 Configure Instance"},{"location":"ec2_tutorial/#step-4-add-storage","text":"Click the Next button to go to the Add Storage page (see figure below for example). On that page, you can adjust the size of the virtual hard disk drive attached to your virtual machine (for the free usage, you are able to allocate up to 30 GB of storage space). This disk drive is part of EBS service (Elastic Block Storage). It is very reliable and automatically backed up to protect your data from accidental loss.","title":"Step 4 \u2014 Add Storage"},{"location":"ec2_tutorial/#step-5-tag-instance","text":"Click the Next button to go to the next page called Tag Instance . On that page, you will be able to add one or several tags to distinguish this EC2 instance from the others (in the future, you may launch more instances in your account). For example, add the Name tag and set its value to \"Webserver\". This will help you to remember that this instance's purpose is to run the Apache Web Server.","title":"Step 5 \u2014 Tag Instance"},{"location":"ec2_tutorial/#step-6-security-group","text":"Click the Next button to go to the next page called Security Group (see below). On the Security Group page, you need to configure the security group rules (firewall) for the EC2 instance. The rules define what ports will be open for inbound access. By default, your EC2 instance allows access through SSH (port 22). You also need to add a rule allowing to access port 80 (HTTP). To do this, click the Add Rule button and enter 80 into the Port range field.","title":"Step 6 \u2014 Security Group"},{"location":"ec2_tutorial/#step-7-review-instance-launch","text":"Click the Next button to go to the last page named Review Instance Launch. On this page you are able to review the virtual machine settings before you launch it. When you are ready, click the Launch button. The Select an existing keypair of create a new keypair pop-up window appears. In this window, select the 'test' keypair from the list of existing keypairs (we have created the 'test' keypair earlier) and click the Launch Instances button to trigger the instance launch process. Now you should be able to see your instance on the Instances page (see the figure below).","title":"Step 7 \u2014 Review Instance Launch"},{"location":"ec2_tutorial/#assigning-an-ip-address-to-the-instance","text":"Every web server on the Internet has a dedicated IP address by which others can refer to it. Next, you need to assign an IP address to the EC2 instance you have just created. To do this, click the Elastic IPs link in the side bar menu (under NETWORK & SECURITY section). On the page that appears, click Allocate New Address button. In the appeared window, click the Allocate button. The new IP address is now displayed in the list of Elastic IPs. You must immediately assign the created IP address to your instance. To do this, click the check box to the left of your IP address and click the Associate Address button above the IP address list. In the window that appears, select the instance name and click the Yes, Associate button.","title":"Assigning an IP Address to the Instance"},{"location":"ec2_tutorial/#connecting-to-ec2-instance-through-ssh","text":"Next we want to connect to the virtual server we\u2019ve just created. In this tutorial, we will use PuTTY \u2013 a free implementation of Telnet and SSH for Windows and Unix platforms. Download PuTTY archive from this link . Then unzip it to some folder. You need to import the key pair you have downloaded earlier as a PEM file. To do this, run PUTTYGEN.EXE from PuTTY distribution. PuTTY Key Generator window appears. In this window, click the Load button and choose your PEM file to load your existing key pair. Next enter some password to protect your key (see the image below). Remember the password, because it will be needed later. Finally, click the Save private key button to save your password-protected key as a PPK file. Now you are ready to connect to your EC2 instance. Run PUTTY.EXE from PuTTY distribution. The PuTTY Configuration window appears. In that window, select the Connection->SSH->Auth category from the side bar menu and enter the path to your PPK file into the Private key for connection field (see the figure below). Select Window->Translation category from side bar menu and select the UTF-8 encoding from drop-down list (see the figure below for example): Select Session category from side bar menu. Into the Host name (or IP address) field, enter the IP address you assigned to your EC2 instance. In the Saved sessions field, enter 'webserver' and press Save button. Now the information you entered is saved, so you don't have to enter it each time you connect. Now double-click the webserver item in the list of saved sessions. Terminal window appears. You need to enter 'ec2-user' as your login and press Enter. Then enter the password that you used when creating the PPK file and press Enter again. If everything is OK, you should be able to see the prompt like in the figure below: In the shell terminal window, you can type commands and see the results of the command execution.","title":"Connecting to EC2 Instance through SSH"},{"location":"ec2_tutorial/#installing-apache-http-server-and-php-engine","text":"For Laminas Framework based website to run, you need to have a web server and the PHP engine installed. The next thing we plan to do is installing Apache Web Server and PHP. First, it is recommended that you update the system by typing the following shell command: sudo yum update You do not have to type all commands manually, instead you can copy and paste them. Select the command in this window and copy it into the clipboard (CTRL+C), then click your mouse's right button over the PuTTY terminal window to insert the text. To install Apache HTTP Server, type the following command: sudo yum install httpd Install the PHP engine: sudo yum install php And finally, install the PHP engine\u2019s GD extension (this extension is required by the Hello World web application to run correctly): sudo yum install php-gd Add Apache HTTP Server to system autorun and start it: sudo chkconfig --level 235 httpd on sudo service httpd start To check that Apache Web Server works, enter the IP address of your EC2 instance in your web browser\u2019s navigation bar. If everything is OK, you should see the page like below: Next, we will edit the PHP config file to set the time zone settings (in this tutorial, we will use our favorite Midnight Commander editor for this purpose). Install MC: sudo yum install mc Open the php.ini file with MC: sudo mcedit /etc/php.ini Set your time zone settings (replace YOUR_TIMEZONE placeholder with your time zone, for example, UTC or America/New_York): date.timezone = YOUR_TIMEZONE When ready, save your changes by pressing the F2 key and then press F10 to exit from Midnight Commander\u2019s editor.","title":"Installing Apache HTTP Server and PHP Engine"},{"location":"ec2_tutorial/#installing-the-hello-world-web-application","text":"To get the Hello World application code, we will download the code samples archive bundled with this book from GitHub. The following shell commands will create directory for downloads and make it current: mkdir ~/downloads cd ~/downloads Download the code samples archive bundled with the book by typing the following: wget https://github.com/olegkrivtsov/using-laminas-book-samples/archive/master.zip Unpack the archive with the unzip command and move the files to web server\u2019s document root directory: unzip master.zip sudo mv using-laminas-book-samples-master/* /var/www/html Next, set file and directory permissions to allow Apache read and write access to the Hello World application files: sudo chmod -R 755 /var/www/html/helloworld sudo chown -R apache:apache /var/www/html/helloworld","title":"Installing the Hello World Web Application"},{"location":"ec2_tutorial/#creating-virtual-host","text":"Now we are almost ready to get our Hello World website live! The last thing we are going to do is configuring an Apache virtual host. To do that, we will edit the httpd.conf file: sudo mcedit /etc/httpd/conf/httpd.conf If you scroll the file down to its end, you may encounter the commented text block as follows: # # Use name-based virtual hosting. # #NameVirtualHost *:80 # # NOTE: NameVirtualHost cannot be used without a port specifier. # (e.g. :80) if mod_ssl is being used, due to the nature of the # SSL protocol. # # # VirtualHost example: # Almost any Apache directive may go into a VirtualHost container. # The first VirtualHost section is used for requests without a known # server name. # #<VirtualHost *:80> # ServerAdmin webmaster@dummy-host.example.com # DocumentRoot /www/docs/dummy-host.example.com # ServerName dummy-host.example.com # ErrorLog logs/dummy-host.example.com-error_log # CustomLog logs/dummy-host.example.com-access_log common #</VirtualHost> To add a virtual host, you\u2019ll have to uncomment this block and add some rules in it. After your changes, this text block will look like below: # # Use name-based virtual hosting. # NameVirtualHost *:80 # # NOTE: NameVirtualHost cannot be used without a port specifier. # (e.g. :80) if mod_ssl is being used, due to the nature of the # SSL protocol. # # # VirtualHost example: # Almost any Apache directive may go into a VirtualHost container. # The first VirtualHost section is used for requests without a known # server name. # <VirtualHost *:80> ServerAdmin yourname@yourserver.com DocumentRoot /var/www/html/helloworld/public <Directory /var/www/html/helloworld/public> DirectoryIndex index.php AllowOverride All Require all granted </Directory> </VirtualHost> When ready, press F2 to save changes and F10 to exit from Midnight Commander. Restart Apache to apply your changes: sudo service httpd restart","title":"Creating Virtual Host"},{"location":"ec2_tutorial/#installing-laminas-framework-with-composer","text":"Now we will use Composer to install Laminas Framework code and initialize autoloader. First, go to the directory where you installed the Hello World web application and type the self-update command to update the Composer: cd /var/www/html/helloworld sudo php composer.phar self-update The expected output of this command is the following: Updating to version 604a65cc31f3e5d8a2b96802135ac24434e87678. Downloading: 100% Next, type the install command to make Composer to download and install Laminas Framework code: sudo php composer.phar install The expected output will look like as the following: Loading composer repositories with package information Installing dependencies (including require-dev) from lock file Warning: The lock file is not up to date with the latest changes in composer.json. You may be getting outdated dependencies. Run update to update them. - Installing laminas/laminas (2.2.4) Downloading: 100% Skipped installation of bin/classmap_generator.php for package laminas/laminas: name conflicts with an existing file Skipped installation of bin/pluginmap_generator.php for package laminas/laminas: name conflicts with an existing file Skipped installation of bin/templatemap_generator.php for package laminas/laminas: name conflicts with an existing file laminas/laminas suggests installing doctrine/annotations (Doctrine Annotations >=1.0 for annotation features) laminas/laminas suggests installing ext-intl (ext/intl for i18n features (included in default builds of PHP)) laminas/laminas suggests installing ircmaxell/random-lib (Fallback random byte generator for Laminas\\Math\\Rand if OpenSSL/Mcrypt extensions are unavailable) laminas/laminas suggests installing ocramius/proxy-manager (ProxyManager to handle lazy initialization of services) laminas/laminas suggests installing laminas/Laminaspdf (LaminasPdf for creating PDF representations of barcodes) laminas/laminas suggests installing laminas/Laminasservice-recaptcha (LaminasService\\ReCaptcha for rendering ReCaptchas in Laminas\\Captcha and/or Laminas\\Form) Generating autoload files","title":"Installing Laminas Framework with Composer"},{"location":"ec2_tutorial/#results","text":"Once the above steps are done, you will be able to open the Hello World website in your web browser. If you type the IP address of your EC2 instance in the browser, you should be able to see the following page: Congratulations! You have completed this tutorial and now you should be able to install any Laminas Framework based website to an Amazon EC2 instance.","title":"Results"},{"location":"ec2_tutorial/#summary","text":"When your laminas-based website is ready, you'll need to install it on a publicly acessible web server to make it visible to other people. In this tutorial, we have shown how to install a laminas-based website to a Amazon EC2 virtual machine. First, you log in to Amazon Management Console and create a EC2 instanse. Then you connect to the newly created VM and install Apache HTTP server and PHP engine. Finally, you copy your website files and install dependencies with Composer. That simple!","title":"Summary"},{"location":"filters/","text":"Transforming Input Data with Filters In this chapter, we will provide an overview of standard filters that can be used with your web forms. A filter is a class which takes some input data, processes it, and produces some output data. We will also show how to write a custom filter. Note In general, you can even use filters outside forms to process an arbitrary data. For example, filters may be used in a controller action to transform the data passed as GET and/or POST variables to certain format. Laminas components covered in this chapter: Component Description @ Laminas\\Filter Contains various filters classes. @ Laminas\\InputFilter Implements a container for filters/validators. About Filters Filters are designed to take some input data, process it, and produce some output data. Laminas Framework provides a lot of standard filters that can be used for creating filtering rules of your forms (or, if you wish, to filter an arbitrary data outside of forms). FilterInterface Technically, a filter is a PHP class implementing the @ FilterInterface [Laminas\\Filter\\FilterInterface] interface (it belongs to @ Laminas\\Filter namespace). The interface definition is presented below: <?php namespace Laminas\\Filter; interface FilterInterface { // Returns the result of filtering $value. public function filter($value); } As you can see, the @ FilterInterface [Laminas\\Filter\\FilterInterface] interface has the single method filter() (line 7), which takes the single parameter $value . The method transforms the input data and finally returns the resulting (filtered) value. A concrete filter class implementing the @ FilterInterface [Laminas\\Filter\\FilterInterface] interface may have additional methods. For example, many filter classes have methods allowing configuration of the filter (set filtering options). Standard Filters Overview Standard filters implementing the @ FilterInterface [Laminas\\Filter\\FilterInterface] interface belong to @ Laminas\\Filter namespace 1 . A filter class inheritance diagram is shown in figure 8.1. From that figure, you can see that base concrete class for most standard filters is the @ AbstractFilter class, which implements the @ FilterInterface [Laminas\\Filter\\FilterInterface] interface 2 . Note You may notice that there is a strange filter called @ StaticFilter which does not inherit from @ AbstractFilter base class. This is because the @ StaticFilter class is actually a \"wrapper\" (it is designed to be a proxy to another filter without explicit instantiation of that filter). Standard filters provided by the @ Laminas\\Filter component, along with a brief description of each, are listed in table 8.1. As you can see from the table, the standard filters can be roughly divided into the following groups: filters casting input data to a specified type (integer, boolean, date-time, etc.); filters performing manipulations on a file path (getting the base name, parent directory name, etc.); filters performing compression and encryption of input data; filters manipulating string data (case conversion, trimming, character replacement and removal, URL normalizing, etc.); and proxy filters wrapping other filters (@ Callback [Laminas\\Filter\\Callback], @ FilterChain [Laminas\\Filter\\FilterChain] and @ StaticFilter ). Class name Description @ Boolean [Laminas\\Filter\\Boolean] Returns a boolean representation of $value . @ ToInt Casts the input $value to int . @ Digits [Laminas\\Filter\\Digits] Returns the string $value , removing all but digit characters. @ ToNull Returns null if the input value can be treated as null; otherwise returns the $value itself. @ DateTimeFormatter Takes a date & time string in an arbitrary format and produces a date & time string in a given format. @ BaseName Given a string containing the path to a file or directory, this filter will return the trailing name component. @ Dir Given a string containing the path of a file or directory, this filter will return the parent directory's path. @ RealPath Returns canonicalized absolute pathname. @ Compress Compresses the input data with the specified algorithm (GZ by default). @ Decompress Decompresses the input data with the specified algorithm (the effect is inverse to the Compress filter). @ Encrypt [Laminas\\Filter\\Encrypt] Encrypts the input data with the specified cryptographic algorithm. @ Decrypt [Laminas\\Filter\\Decrypt] Decrypts the input data previously encrypted with the specified cryptographic algorithm. @ Inflector Performs the modification of a word to express different grammatical categories such as tense, mood, voice, aspect, person, number, gender, and case. @ PregReplace Performs a regular expression search and replace. @ StringToLower Converts the string to lowercase letters. @ StringToUpper Converts the string to uppercase letters. @ StringTrim Removes white spaces (space, tabs, etc.) from the beginning and the end of the string. @ StripNewlines Removes new line characters from string (ASCII codes #13, #10). @ HtmlEntities Returns the string, converting characters to their corresponding HTML entity equivalents where they exist. @ StripTags Removes tags (e.g., <a></a> ) and comments (e.g., <!-- --> ). @ UriNormalize Converts a URL string to the \"normalized\" form and prepends the schema part (e.g., converts www.example.com to http://www.example.com ). @ Callback [Laminas\\Filter\\Callback] Allows to use a callback function as a filter. @ FilterChain [Laminas\\Filter\\FilterChain] Allows to organize several filters in a chain. @ StaticFilter Returns a value filtered through a specified filter class without requiring separate instantiation of the filter object. Table 8.1. Standard filters Instantiating a Filter In Laminas Framework, you can use several methods of creating a filter: instantiating it manually (with the new operator); creating it with a factory class (by passing an array configuration), a method most frequently used when adding filtering and validation rules in a form; and instantiating it implicitly with the @ StaticFilter wrapper class. Next, we will cover these three methods in more details. Method 1: Instantiating a Filter Manually As we previously said, a filter in general can be used not only with forms but also for filtering an arbitrary data. To do that, you simply create an instance of the filter class, configure the filter by using the methods it provides, and call the filter() method on the filter. For example, let's consider the usage of the @ StringTrim filter which removes the white space characters from the beginning and the end of a string. The @ StringTrim filter is useful for filtering user-entered string data (E-mail addresses, user names, etc.) because site visitors tend to make typos in those data. For example, a user may unintentionally enter a trailing space in an E-mail field, thus making an E-mail invalid. With the @ StringTrim filter, you will easily cope with such input errors and improve user experience. The methods provided by the filter are listed in table 8.2: Method name Description __construct($charlistOrOptions) Constructs the filter. Accepts the list of options. filter($value) Removes the predefined characters from the beginning and the end of the string. setCharList($charList) Defines the list of characters to strip off. getCharList() Returns the list of characters to strip off. Table 8.2. Public methods of the StringTrim filter As you can see from the table, the @ StringTrim filter, in addition to the filter() method, provides the constructor method which you can (optionally) pass with the complete list of options to initialize the filter, and the setCharList() and getCharList() methods which can be used for setting specific filter options. Note All standard filters have the constructor method (optionally) accepting an array of options for configuring the filter when instantiating it manually. Below, we provide two code examples showing equivalent methods of manually creating an instance of the @ StringTrim filter, setting its options, and filtering a value. Example 1. Passing options to the constructor method. <?php // Optionally, define a short alias for the filter class name. use Laminas\\Filter\\StringTrim; // Create an instance of the filter, passing options to the constructor. $filter = new StringTrim(['charlist'=>\"\\r\\n\\t \"]); // Perform the trimming operation on the string. $filteredValue = $filter->filter(' name@example.com '); // The expected output of the filter is the 'name@example.com' string. In the code above, we create the @ StringTrim filter object with the help of the new operator (line 6). We pass the array of options to the constructor to set the list of characters the filter will remove (here, we tell the filter to remove the new line characters, the tabulation character, and the space character). Actually, passing the array of options to this filter can be omitted because the filter already has some default character list to strip off. In line 9, we call the filter() method and pass it the string value \" name@example.com \" to be trimmed. The expected output of this call is the \"name@example.com\" string. Example 2. Without passing options to the constructor. <?php // Optionally, define a short alias for the filter class name. use Laminas\\Filter\\StringTrim; // Create an instance of the filter. $filter = new StringTrim(); // Specify which characters to remove. $filter->setCharList(\"\\r\\n\\t \"); // Perform the trimming operation on the string $filteredValue = $filter->filter(' name@example.com '); // The expected output of the filter is the 'name@example.com' string In the code above, we create the @ StringTrim filter object with the help of the new operator (line 6). In line 9, we (optionally) call the @ StringTrim filter's setCharList() method to set the list of characters the filter will remove (here, we tell the filter to remove the new line characters, the tabulation character, and the space character). This call is optional because the filter already has some default character list for stripping off. And, in line 12, we call the filter() method and pass it the string value \" name@example.com \" to be trimmed. The expected output of this call is the \"name@example.com\" string. Method 2: Constructing a Filter with StaticFilter An alternative way of manual filter instantiation is by using the @ StaticFilter class. The @ StaticFilter class is some kind of a \"proxy\" designed for automatic filter instantiation, configuration, and execution. For example, let's consider how to create the same @ StringTrim filter, configure it, and call its filter() method: <?php // Create and execute the StringTrim filter through the StaticFilter proxy. $filteredValue = \\Laminas\\Filter\\StaticFilter::execute(' name@example.com ', 'StringTrim', ['charlist' => \"\\r\\n\\t \"]); // The expected output of the filter is the 'name@example.com' string. The @ StaticFilter class provides the execute() static method, which takes three arguments: the input value, the name of the filter to apply, and the array of filter-specific options. In line 3, we call the execute() method to automatically create the @ StringTrim filter, call its setCharList() method, and pass the input value to its filter() method. This is very useful because it can be accomplished in a single line of code. Method 3: Constructing a Filter From Array When using filters with form's validation rules, you typically do not construct a filter object explicitly as we did in the previous section; instead, you pass an array configuration to the factory class, which automatically constructs the filter for you and (optionally) configures it. We already saw how this works when adding validation rules for the feedback form in Collecting User Input with Forms . For example, let's show how to construct the same @ StringTrim filter with the help of the factory: <?php // It is assumed that you call the following code inside of the form model's // addInputFilter() method. $inputFilter->add([ // ... 'filters' => [ [ 'name' => 'StringTrim', 'options' => [ 'charlist' => \"\\r\\n\\t \" ] ], ], // ... ]; In the code above, we call the add() method provided by the @ InputFilter [Laminas\\InputFilter\\InputFilter] container class (line 5). The add() method takes an array which has the filters key. You typically register the filters under that key (line 7). Filters registered under that key are inserted in a filter chain in the order they appear in the list. A filter configuration typically consists of the name (line 9) and options (line 10). The name is a fully qualified filter class name (e.g., @ Laminas\\Filter\\StringTrim ) or its short alias (@ StringTrim ). The options is an array consisting of filter-specific options. When the factory class instantiates the filter, it passes the list of options to the filter's constructor method, and the constructor initializes the filter as needed. About Filter Plugin Manager In the previous example, you saw that you can use either the fully qualified filter class name or its short alias when instantiating the filter from the array. The short aliases for the standard filters are defined by the @ FilterPluginManager [Laminas\\Filter\\FilterPluginManager] class. A standard filter's alias is typically the same as the class name. For example, the class @ Laminas\\Filter\\StringTrim has the short alias @ StringTrim . The filter plugin manager is internally used by the @ InputFilter [Laminas\\InputFilter\\InputFilter] container class for instantiating the standard filters. Filter's Behavior in Case of Incorrect Input Data Different filters behave differently if you pass it input data that the filter cannot process correctly. Some filters (such as the @ ToInt filter) will process only scalar data. If you pass an array to such filter, it will return the array as is. Some filters can work with data in certain format only (e.g., with dates only). If filtering of input data is impossible (for example, when you pass the filter some wrong data that it is unable to process), the filter() method may throw a @ Laminas\\Filter\\Exception\\RuntimeException exception. This behavior can be seen in @ DateTimeFormatter filter. Some filters (e.g., @ ToInt or @ StringToLower ) may rise a PHP warning if the value provided is in incorrect format and cannot be filtered. Note It is recommended to read filter's documentation carefully to know what to expect of the filter you plan to use in your form. Filter Usage Examples Next, we will consider the usage of the most important standard filters. These describe the methods (and options) a filter has and provide code examples showing how to instantiate the filter and apply it to input data. If you need to use a filter not covered in this section, please refer to Standard Filters section of the Laminas Framework Reference Manual . Filters Casting Input Data to a Specified Type In this section, we will consider several filters from the group of filters related to casting input data to the specified type and provide their usage examples. ToInt Filter The @ ToInt filter is a very simple filter that is designed to cast an arbitrary scalar data to an integer. This filter may be useful when adding validation rules for form fields that must contain an integer numeric values (e.g., a drop-down list or a text field containing an amount of something). The @ ToInt class has the single filter() method. Note The @ ToInt filter will not cast a non-scalar value. If you pass it an array, it will return it as is. Below, you can find a code example illustrating the usage of the @ ToInt filter. <?php // Create ToInt filter. $filter = new \\Laminas\\Filter\\ToInt(); // Filter a value casting it to an integer number. $filteredValue = $filter->filter('10'); // Returns (int) 10. $filteredValue2 = $filter->filter(['10', '20']); // Returns array as is. In the code above, we pass the string \"10\" to the filter (line 6). The expected return value is the integer 10. In line 7, we pass an array to the filter. Because the @ ToInt filter works with scalar values only, it returns the array as is (without changes) and raises a PHP warning. Boolean Filter The @ Boolean [Laminas\\Filter\\Boolean] class is a filter that is designed to cast an arbitrary data to a boolean value ( true or false ). This filter can be used for filtering check box form fields. Its public methods are listed in table 8.3. Method name Description filter($value) Returns a boolean representation of $value . setCasting($flag) Sets casting flag. getCasting() Returns the casting flag. setType($type) Sets types from which to cast. getType() Returns types. setTranslations($translations) Sets translations. getTranslations() Returns the translations. Table 8.3. Public methods of the Boolean filter The filter provides several methods allowing to set filtering options ( setCasting() , setType() , and setTranslations() ). The setCasting() method allows to choose one of two modes in which the filter may operate. If the flag is true , the filter will behave like the PHP (boolean) cast operator. Otherwise (if the flag is set to false ), it will cast only from types defined by the setType() method, and all other values will be returned as is. The setType() filter's method allows to define from which types to cast. This method accepts the single argument $type , which can be either an OR combination of TYPE_ -prefixed constants or an array containing the literal equivalents of the constants. Possible constants accepted by the setType() method and their literal equivalents are listed in table 8.4: Constant Numeric Value Literal Equivalent Description TYPE_BOOLEAN 1 \"boolean\" Returns a boolean value as is. TYPE_INTEGER 2 \"integer\" Converts an integer 0 value to false . TYPE_FLOAT 4 \"float\" Converts a float 0.0 value to false . TYPE_STRING 8 \"string\" Converts an empty string '' to false . TYPE_ZERO_STRING 16 \"zero\" Converts a string containing the single character zero ('0') to false . TYPE_EMPTY_ARRAY 32 \"array\" Converts an empty array to false . TYPE_NULL 64 \"null\" Converts a null value to false . TYPE_PHP 127 \"php\" Converts values according to PHP when casting them to boolean. (This is the default behavior.) TYPE_FALSE_STRING 128 \"false\" Converts a string containing the word \"false\" to a boolean false . TYPE_LOCALIZED 256 \"localized\" Converts a localized string which contains certain word to boolean. TYPE_ALL 511 \"all\" Converts all above types to boolean. Table 8.4. Type constants The following code example shows two equivalent ways you can call the setType() method: <?php use Laminas\\Filter\\Boolean; // Call the setType() and pass it a combination of constants. $filter->setType(Boolean::TYPE_BOOLEAN| Boolean::TYPE_INTEGER| Boolean::TYPE_STRING); // Call the setType() and pass it an array with literal equivalents. $filter->setType(['boolean', 'integer', 'string']); The setTranslations() method allows to define localized equivalents of boolean true and false values. This method accepts a single parameter, which must be an array in the form of key=>value pairs, where the key is a localized string and the value is its boolean representation. The following code example shows how to use the setTranlsations() method: <?php $filter->setTranslations([ 'yes' => true, // English 'yes' 'no' => false, // English 'no' 'ja' => true, // German 'yes' 'nicht' => false, // German 'no' '\u0434\u0430' => true, // Russian 'yes' '\u043d\u0435\u0442' => false // Russian 'no' ]); Below, we provide a code example illustrating the usage of the @ Boolean [Laminas\\Filter\\Boolean] filter. <?php // Create ToBoolean filter. $filter = new \\Laminas\\Filter\\Boolean(); // Optionally configure the filter. $filter->setCasting(true); $filter->setType(\\Laminas\\Filter\\Boolean::TYPE_ALL); $filter->setTranslations(['yes'=>true, 'no'=>false]); // Filter a value casting it to a boolean number. $filteredValue = $filter->filter('false'); // Returns boolean false. $filteredValue2 = $filter->filter('1'); // Returns boolean true. $filteredValue3 = $filter->filter('false'); // Returns boolean false. $filteredValue4 = $filter->filter('yes'); // Returns boolean true. ToNull Filter The @ ToNull filter is designed to cast an arbitrary data to a null value if it meets specific criteria. This may be useful when you work with a database and want to have a null value instead of any other type. If the value cannot be treated as null , the filter will return the value as is. The @ ToNull filter's public methods are listed in table 8.5. Method name Description filter($value) Casts the $value to null , if possible; otherwise returns values as is. setType($type) Defines from which types to cast. getType() Returns defined types. Table 8.5. Public methods of the ToNull filter By default, the ToNull filter behaves like PHP's empty() function: if the empty() function returns a boolean true on the input data, then the filter will return the null value on that data, as well. The setType() method can be used to set the type from which the filter will cast to null . This method takes a single parameter, which can either be a combination of TYPE_ -prefixed constants listed in table 8.6 or an array of their literal equivalents. Constant Numeric Value Literal Equivalent Description TYPE_BOOLEAN 1 \"boolean\" Converts a boolean false value to null . TYPE_INTEGER 2 \"integer\" Converts an integer 0 value to null . TYPE_EMPTY_ARRAY 4 \"array\" Converts an empty array to null . TYPE_STRING 8 \"string\" Converts an empty string '' to null . TYPE_ZERO_STRING 16 \"zero\" Converts a string containing the single character zero ('0') to null . TYPE_FLOAT 32 \"float\" Converts a float 0.0 value to null . TYPE_ALL 63 \"all\" Converts all above types to null . This is the default behavior. Table 8.6. Type constants The following code example illustrates two equivalent ways you can call the setType() method: <?php use Laminas\\Filter\\ToNull; // Call the setType() and pass it a combination of constants. $filter->setType(ToNull::TYPE_ZERO_STRING|ToNull::TYPE_STRING); // Call the setType() and pass it an array with literal equivalents. $filter->setType(['zero', 'string']); Below, a code example showing how to use the @ ToNull filter is provided: <?php // Create ToNull filter. $filter = new \\Laminas\\Filter\\ToNull(); // Optionally configure the filter. $filter->setType(\\Laminas\\Filter\\ToNull::TYPE_ALL); $filteredValue = $filter->filter('0'); // Returns null. $filteredValue2 = $filter->filter('1'); // Returns string '1'. $filteredValue3 = $filter->filter(false); // Returns null. DateTimeFormatter Filter The @ DateTimeFormatter filter accepts a date in an arbitrary format and converts it into the desired format. This filter can accept a string (e.g., '2014-03-22 15:36'), an integer timestamp (like the time() PHP function returns) or an instance of the DateTime PHP class. The @ DateTimeFormatter filter may throw a @ Laminas\\Filter\\Exception\\InvalidArgumentException exception if you pass it a date in an incorrect format. Filter's public methods are listed in table 8.7. Method name Description __construct($options) Constructs the filter. filter($value) Transforms the date into the desired format. setFormat($format) Sets the date format. Table 8.7. Public methods of the DateTimeFormatter filter In the code example below, we show how to create the filter, pass it a string date, and convert it to the desired format: <?php // Create DateTimeFormatter filter. $filter = new \\Laminas\\Filter\\DateTimeFormatter(); // Set filter's format (optional). $filter->setFormat('F j, Y g:i A'); // Transform the date to the specified format. $filteredValue = $filter->filter('2014-03-22 15:36'); // The expected output is 'March 22, 2014 3:36 PM'. Note Internally, the @ DateTimeFormatter filter uses the DateTime class from the PHP standard library for converting and formatting dates. For available date formats, please refer to the PHP documentation for the DateTime class. Filters Performing Manipulations on a File Path In this section, we will consider usage examples of the filters from the group of filters related to manipulating file paths. BaseName Filter The @ BaseName filter class is just a wrapper on the basename() PHP function. It takes a string containing the path to a file or directory and returns the trailing name component. Below, you can find an example of the @ BaseName filter usage: <?php // Create BaseName filter. $filter = new \\Laminas\\Filter\\BaseName(); // Filter a file path and return its last part. $filteredValue = $filter->filter('/var/log/httpd/error.log'); // The expected filter's output is the 'error.log'. Note The @ BaseName filter will not process a non-scalar value. If you pass it an array, it will return the array as is and raise a PHP warning. Dir Filter The @ Dir filter class is just a wrapper on the dirname() PHP function. It takes a string containing the path to a file or directory and returns the parent directory's path. Note The @ Dir filter will not process a non-scalar value. If you pass it an array, it will return the array as is. Below, a code example demonstrating the usage of the @ Dir filter is provided. <?php // Create Dir filter. $filter = new \\Laminas\\Filter\\Dir(); // Filter a file path and return its directory name part. $filteredValue = $filter->filter('/var/log/httpd/error.log'); // The expected filter's output is the '/var/log/httpd'. RealPath Filter The @ RealPath filter takes an absolute or a relative file path as a string input argument. It expands all symbolic links and resolves references to '/./', '/../' and extra '/' characters in the input path and returns the canonicalized absolute pathname. Note The @ RealPath filter is a wrapper over the realpath() PHP function. Filter's public methods are listed in table 8.8. Method name Description __construct($options) Constructs the filter. filter($value) Returns canonicalized absolute pathname. setExists($flag) Specifies if the path must exist for this filter to succeed. The value true means the path must exist; the value false means a nonexisting path can be given. getExists() Returns true if the filtered path must exist. Table 8.8. Public methods of the RealPath filter The @ RealPath filter returns a boolean false on failure, e.g., if the file does not exist. If a nonexisting path is allowed, you can call the setExists() method with the false parameter. Below, a code example demonstrating the usage of the @ RealPath filter is provided. <?php // Create RealPath filter. $filter = new \\Laminas\\Filter\\RealPath(); // Filter a file path (it is assumed that the current // working directory is /var/log/httpd and that it contains // the error.log file). $filteredValue = $filter->filter('./error.log'); // The expected filter's output is the '/var/log/httpd/error.log'. Note The @ RealPath filter will not process a non-scalar value. If you pass it an array, it will return the array as is. Filters Performing Compression and Encryption of Input Data In this section, we will consider several filters from the group of filters related to compressing and encrypting the input data. These filters are not very usable for filtering form data but can be used outside of forms with a great success. Compress Filter The @ Compress filter is designed to compress input data with some compression algorithm. For example, you can use this filter to compress the data and save it as an archive file. Filter's public methods are listed in table 8.9. Method name Description __construct($options) Constructs the filter. filter($value) Performs data compression using the specified algorithm. getAdapter() Returns the current adapter, instantiating it if necessary. getAdapterName() Retrieves adapter name. setAdapter($adapter) Sets compression adapter. getAdapterOptions() Retrieves adapter options. setAdapterOptions($options) Sets adapter options. getOptions($option) Gets individual or all options from underlying adapter. Table 8.9. Public methods of the Compress filter The @ Compress filter itself cannot compress data. Instead, it uses a so-called adapter class. The adapter class must implement the @ CompressionAlgorithmInterface interface. You attach an adapter to the @ Compress filter, and the adapter implements the concrete compression algorithm. There are several standard adapter classes available (see figure 8.2 and table 8.10 below). Those classes live in the @ Laminas\\Filter\\Compress [Laminas\\Filter] namespace. Class name Description @ Bz2 Bzip2 (Burrows\u2013Wheeler) compression algorithm. @ Gz Gzip compression algorithm is based on the Deflate algorithm, which is a combination of LZ77 and Huffman coding. @ Zip ZIP is a compression algorithm widely used in Windows operating system. @ Tar Tarball file format is now commonly used to collect many files into one larger file for archiving while preserving file system information such as user and group permissions, dates, and directory structures. Widely used in Linux operating system. @ Lzf LZF is a very fast compression algorithm, ideal for saving space with only slight speed cost. @ Snappy Snappy is a fast data compression and decompression library developed by Google based on ideas from LZ77. @ Rar RAR is an archive file format that supports data compression, error recovery, and file spanning. Table 8.10. Compression adapters Below, a code example demonstrating the usage of the @ Compress filter is provided. <?php // Create Compress filter. $filter = new \\Laminas\\Filter\\Compress(); // Configure the adapter. $filter->setAdapter('Zip'); $filter->setAdapterOptions([ 'archive' => 'example.zip', ]); // Compress an input data (it is assumed that you have the testfile.txt // file in the current working directory. $filter->filter('testfile.txt'); In the code above, we create the instance of the @ Compress filter (line 3), set its adapter (line 6), set adapter's options (line 7), and finally, compress the input file (line 13). The expected result, the example.zip archive file, will be created in the current directory. The archive will contain the testfile.txt file. Note The @ Decompress filter is a \"mirror reflection\" of the @ Compress filter and can be used by analogy. By that reason, we do not cover the @ Decompress filter in this section. Encrypt Filter The @ Encrypt [Laminas\\Filter\\Decrypt] filter's purpose is encrypting the input data with the specified algorithm. Filter's public methods are listed in table 8.11. Method name Description __construct($options) Constructs the filter. filter($value) Performs data encrypting using the specified algorithm. getAdapter() Returns the current adapter, instantiating it if necessary. setAdapter($adapter) Sets encrypting adapter. Table 8.11. Public methods of the Encrypt filter The @ Encrypt [Laminas\\Filter\\Encrypt] filter uses adapter classes to perform actual data encryption. You attach an adapter to the @ Encrypt [Laminas\\Filter\\Encrypt] filter with the setAdapter() method, and the adapter performs the concrete encryption. An adapter class must implement the @ EncryptionAlgorithmInterface interface. There are several standard adapter classes available (see figure 8.3 below). Those classes live in the @ Laminas\\Filter\\Encrypt [Laminas\\Filter] namespace. @ BlockCipher [Laminas\\Filter\\Encrypt\\BlockCipher] -- implements symmetric block cipher algorithm. @ Openssl [Laminas\\Filter\\Encrypt\\Openssl] -- uses an encryption algorithm from the OpenSSL library. Below, a code example demonstrating the usage of the @ Encrypt [Laminas\\Filter\\Encrypt] filter is provided. <?php // Create Encrypt filter. $filter = new \\Laminas\\Filter\\Encrypt(); // Set encryption adapter. $filter->setAdapter('BlockCipher'); // Encrypt an input data. $filteredValue = $filter->filter('some data to encrypt'); The expected result is a string encrypted with the block cipher. Note The @ Decrypt [Laminas\\Filter\\Decrypt] filter is a \"mirror reflection\" of the @ Encrypt [Laminas\\Filter\\Encrypt] filter and can be used by analogy. By that reason, we do not cover the @ Decrypt [Laminas\\Filter\\Decrypt] filter in this section. Filters Manipulating String Data In this section, we will consider usage examples of the filters from the group of filters related to manipulating string data. StringToLower Filter The @ StringToLower filter class is designed for converting the input string data to lowercase letters. The public methods of the filter are provided in table 8.12 below. Method name Description __construct($options) Constructs the filter. filter($value) Converts the string to lowercase letters. setEncoding($encoding) Sets the input encoding for the given string. getEncoding() Returns the encoding. Table 8.12. Public methods of the StringToLower filter By default, the filter behaves like the strtolower() PHP function. Given a string, it returns the string with all alphabetic characters converted to lowercase. The \"alphabetic characters\" are determined by the system locale. This means that in, for example, the default \"C\" locale, characters such as umlaut-A (\u00c4) will not be converted. Calling the setEncoding() method on the filter and passing it an encoding to use forces this filter to behave like the mb_strtolower() PHP function. By contrast to strtolower() , \"alphabetic\" is determined by the Unicode character properties. Thus, the behavior of this function is not affected by locale settings, and it can convert any characters that have 'alphabetic' property, such as A-umlaut (\u00c4). Note If the value provided is non-scalar, the value will remain unfiltered, and an E_USER_WARNING will be raised indicating it cannot be filtered. Below, a code example showing how to use the @ StringToLower filter is provided: <?php // Create StringToLower filter. $filter = new \\Laminas\\Filter\\StringToLower(); // (Optionally) set encoding on the filter. $filter->setEncoding('UTF-8'); // Filter a string. $filteredValue = $filter->filter('How to Start a Business in 10 Days'); // The expected filter's output is the 'how to start a business in 10 days'. The @ StringToUpper filter (converting a string to uppercase letters) is a \"mirror reflection\" of the @ StringToLower filter and can be used by analogy. By that reason, we do not cover the @ StringToUpper filter in this section. PregReplace Filter The @ PregReplace filter can be used for performing a regular expression search and replace in a string data. This filter is a wrapper over the preg_replace() PHP function. The public methods of the filter are provided in table 8.13 below. Method name Description __construct($options) Constructs the filter. filter($value) Performs a regular expression search and replace. setPattern($pattern) Sets the pattern to search for. It can be either a string or an array with strings. getPattern() Returns the pattern. setReplacement($replacement) Sets the string or an array with strings to replace. getReplacement() Gets currently set replacement value. Table 8.13. Public methods of the PregReplace filter Below, a code example showing how to use the @ PregReplace filter is provided: <?php // Create PregReplace filter. $filter = new \\Laminas\\Filter\\PregReplace(); // Configure the filter. $filter->setPattern(\"/\\s\\s+/\"); $filter->setReplacement(' '); // Filter a string. $filteredValue = $filter->filter('An example with multiple spaces.'); // The expected filter's output is the 'An example with multiple spaces.' StripTags Filter The @ StripTags filter removes all tags (e.g. <!-- --> , <p> , <h1> or <?php ?> ) from the input string. It allows to explicitly define the tags which should not be stripped out. Additionally, it provides an ability to specify which attributes are allowed across all allowed tags and/or specific tags only. Public methods of the @ StripTags filter are listed in table 8.14. Method name Description __construct($options) Constructs the filter. filter($value) Returns the value with tags stripped off it. getAttributesAllowed() Returns the list of attributes allowed for the tags. setAttributesAllowed($attributesAllowed) Sets the list of attributes allowed for the tags. getTagsAllowed() Returns the list of tags allowed. setTagsAllowed($tagsAllowed) Sets the list of tags allowed. Table 8.14. Public methods of the StripTags filter Below, a code example showing how to use the @ StripTags filter is provided: <?php // Create StripTags filter. $filter = new \\Laminas\\Filter\\StripTags(); // Configure the filter. $filter->setTagsAllowed(['p']); // Filter a string. $filteredValue = $filter->filter( '<p>Please click the following <a href=\"example.com\">link</a>.</p>'); // The expected filter's output is the // '<p>Please click the following link.</p>;' Note The @ StripTags will not process a non-scalar value. If the value passed to the filter is non-scalar, the value will remain unfiltered. StripNewlines Filter The @ StripNewlines filter is a very simple filter which returns the input string without any newline control characters (\"\\r\", \"\\n\"). Below, a code example showing how to use the @ StripNewlines filter is provided: <?php // Create StripNewlines filter. $filter = new \\Laminas\\Filter\\StripNewlines(); // Filter a string. $filteredValue = $filter->filter(\"A multi line\\r\\n string\"); // The expected filter's output is the 'A multi line string'. Note The @ StripNewlines will not process a non-scalar value. If the value passed to the filter is non-scalar, the value will remain unfiltered. UriNormalize Filter The @ UriNormalize filter can be used for normalizing a URL string and (optionally) applying a scheme part to it. The public methods of the filter are provided in table 8.15 below. Method name Description filter($value) Filter the URL by normalizing it and applying a default scheme if set. setDefaultScheme($defaultScheme) Set the default scheme to use when parsing schemeless URIs. setEnforcedScheme($enforcedScheme) Set a URI scheme to enforce on schemeless URIs. Table 8.15. Public methods of the UriNormalize filter The URL normalization procedure typically consists of the following steps: The URL string is decomposed into its schema, host, port number, path, and query parts. If the scheme part is missing from the original URL, the default scheme is used. The scheme and host parts are converted to lowercase letters. The port number is checked against the list of allowed port numbers, and if it doesn't belong to the list, the port number is cleared. The path part of the URL is filtered, removing redundant dot segments, URL-decoding any over-encoded characters, and URL-encoding everything that needs to be encoded and is not. The query part is sanitized, URL-decoding everything that doesn't need to be encoded and URL-encoding everything else. The URL normalization procedure rules may be different for different protocols (schemes). If the URL doesn't contain the scheme part, the http scheme is assumed by default. You may use the @ UriNormalize filter's setDefaultScheme() method to set the default scheme for URL normalization. It accepts any of the following schemes: http , https , file , mailto , urn , and tag . Additionally, the @ UriNormalize filter's setEnforcedScheme() allows to override the default scheme part by the so-called \"enforced scheme\", if the original URL doesn't contain scheme part. Below, a code example showing how to use the @ UriNormalize filter is provided: <?php // Create UriNormalize filter. $filter = new \\Laminas\\Filter\\UriNormalize(); // Configure the filter. $filter->setDefaultScheme('http'); $filter->setEnforcedScheme('https'); // Filter an URL string. $filteredValue = $filter->filter('www.example.com'); // The expected filter's output is the 'https://www.example.com/'. Organizing Filters in a Chain Filters can be organized in a sequence. This is accomplished by the @ FilterChain [Laminas\\Filter\\FilterChain] class. When such a compound filter is run, the value filtered by the first filter is passed as an input for the second one, and then the value filtered by the second filter will be passed to the third one, and so on. Note The @ FilterChain [Laminas\\Filter\\FilterChain] class is internally used by the @ InputFilter [Laminas\\InputFilter\\InputFilter] container class for storing the sequence of filters attached to the form model's field. Public methods provided by the @ FilterChain [Laminas\\Filter\\FilterChain] class are presented in table 8.16: Method name Description filter($value) Returns value filtered through each filter in the chain. Filters are run in the order in which they were added to the chain (FIFO). setOptions($options) Sets options. attach($callback, $priority) Attaches an existing filter instance (or a callback function) to the chain. attachByName($name, $options, $priority) Instantiates the filter by class name or alias and inserts it into the chain. merge($filterChain) Merges the filter chain with another filter chain. getFilters() Returns all the attached filters. count() Returns the count of attached filters. Table 8.16. Public methods of the FilterChain filter An example filter chain is shown in figure 8.4. It consists of the @ StringTrim filter followed by the @ StripTags filter, which is then followed by the @ StripNewlines filter. To construct the filter chain like in figure 8.4, we can use the following code: <?php use Laminas\\Filter\\FilterChain; // Instantiate the filter chain. $filter = new FilterChain(); // Insert filters into filter chain. $filter->setOptions([ 'filters'=>[ [ 'name'=>'StringTrim', 'options'=>['charlist'=>\"\\r\\n\\t \"], 'priority'=>FilterChain::DEFAULT_PRIORITY ], [ 'name'=>'StripTags', 'options'=>['tagsallowed'=>['p']], 'priority'=>FilterChain::DEFAULT_PRIORITY ], [ 'name'=>'StripNewlines', 'priority'=>FilterChain::DEFAULT_PRIORITY ] ] ]); // Execute all filters in the chain. $filteredValue = $filter->filter(\" name@example.com<html>\\n \"); // The expected output is 'name@example.com'. In the code above, we instantiate the @ FilterChain [Laminas\\Filter\\FilterChain] filter with the new operator (line 5). In line 8, we set construct the chain of filters with the setOptions() method. The method takes an array configuration which looks the same way as in @ InputFilter [Laminas\\InputFilter\\InputFilter]'s add() method. The array has \"filters\" key where you register the filters you want to insert into the chain. For each attached filter, you provide the following subkeys: \"name\" is the fully qualified class name of the filter (e.g., StringTrim::class ) or its short alias (e.g., \"StringTrim\"); \"options\" is an array of options passed to the filter; and \"priority\" is the optional key which defines the priority of the filter in the chain. Filters with higher priority are visited first. The default value for the priority is DEFAULT_PRIORITY . Finally, in line 28, we call the filter() method, which walks through the chain and passes the filtered value to each filter in turn. Custom Filtering with the Callback Filter Standard filters are designed to be used in frequently appearing situations. For example, you may often need to trim a string or convert it to lowercase. However, sometimes there are cases where you cannot use a standard filter. Here, the @ Callback [Laminas\\Filter\\Callback] filter will be handy. The @ Callback [Laminas\\Filter\\Callback] filter is designed as a wrapper for your custom filtering algorithm. For example, this may be useful when a standard filter is not suitable, and you need to apply your own filtering algorithm to the data. You implement your custom filtering algorithm as a callback function or a callback class method. A callback is a function or a public method of a class which is called by the @ Callback [Laminas\\Filter\\Callback] filter and is passed the value to be filtered and, optionally, user-defined argument(s). The public methods provided by the @ Callback [Laminas\\Filter\\Callback] filter are listed in table 8.17. Method name Description filter($value) Executes a callback function as a filter. setCallback($callback) Sets a new callback for this filter. getCallback() Returns callback set for the filter. setCallbackParams($params) Sets parameters for the callback. getCallbackParams() Gets parameters for the callback. Table 8.17. Public methods of the Callback filter As you can see from the table, the @ Callback [Laminas\\Filter\\Callback] filter provides the setCallback() and setCallbackParams() methods that can be used to set the callback function (or the callback class method) and, optionally, pass it one or several parameters. Example To demonstrate the usage of the @ Callback [Laminas\\Filter\\Callback] filter, let's add the phone number field to our ContactForm form model class and attach a custom filter to it. An international phone number typically looks like \"1 (808) 456-7890\". It consists of the country code followed by the three-digit area code enclosed into braces. The rest of the phone consists of the seven-digit subscriber code divided in two groups separated by a dash. The country code, the area code, and the subscriber code are separated by the space character. We will refer to this phone format as the \"international\" format. The international phone format is required for making telephone calls between different countries (or areas). If the calls are made within the same area, the telephone number may simply look like \"456-7890\" (we just omit the country code and area code). We will refer to this phone format as the \"local\" phone format. To make our filter as generic as possible, we assume that the user is required to enter the phone in international format for some forms and in local format for other forms. Because some site visitors may enter their phone number in a format different from what is required, we want to apply the filter that will \"normalize\" the phone number for us. To do the phone \"normalization\", the filter will: Strip out any non-numeric characters of the input value. Pad the digits to the required length if there are too few digits. Add the braces, the spaces, and the dash (when using the international format); or simply add the dash (when using the local format). Because Laminas does not provide a standard filter for accomplishing such phone filtering operation, we will use the @ Callback [Laminas\\Filter\\Callback] wrapper filter. To do that, we will make the following changes to the code of our ContactForm class: <?php // ... class ContactForm extends Form { // ... protected function addElements() { // ... // Add \"phone\" field $this->add([ 'type' => 'text', 'name' => 'phone', 'attributes' => [ 'id' => 'phone' ], 'options' => [ 'label' => 'Your Phone', ], ]); } private function addInputFilter() { // ... $inputFilter->add([ 'name' => 'phone', 'required' => true, 'filters' => [ [ 'name' => 'Callback', 'options' => [ 'callback' => [$this, 'filterPhone'], 'callbackParams' => [ 'format' => 'intl' ] ] ], ], ]); } // Custom filter for a phone number. public function filterPhone($value, $format) { if(!is_scalar($value)) { // Return non-scalar value unfiltered. return $value; } $value = (string)$value; if(strlen($value)==0) { // Return empty value unfiltered. return $value; } // First, remove any non-digit character. $digits = preg_replace('#[^0-9]#', '', $value); if($format == 'intl') { // Pad with zeros if the number of digits is incorrect. $digits = str_pad($digits, 11, \"0\", STR_PAD_LEFT); // Add the braces, the spaces, and the dash. $phoneNumber = substr($digits, 0, 1) . ' ('. substr($digits, 1, 3) . ') ' . substr($digits, 4, 3) . '-'. substr($digits, 7, 4); } else { // 'local' // Pad with zeros if the number of digits is incorrect. $digits = str_pad($digits, 7, \"0\", STR_PAD_LEFT); // Add the dash. $phoneNumber = substr($digits, 0, 3) . '-'. substr($digits, 3, 4); } return $phoneNumber; } } In lines 11-20 of the code above, we add the \"phone\" field to the ContactForm form model. The field is a usual text input field, and we already had some experience of working with such fields earlier. Then, in lines 26-40, we add a validation rule for the \"phone\" field of our form. Under the \"filters\" key (line 29), we register the @ Callback [Laminas\\Filter\\Callback] filter (here, we use the short alias @ Callback [Laminas\\Filter\\Callback], but you can alternatively use the fully qualified class name Callback::class ). The filter takes two options (line 32): the \"callback\" option and the \"callback_params\" option. The \"callback\" option is an array consisting of two elements, which represent the class and the method to call, respectively. In this example, the callback is the filterPhone() method of the ContactForm class. We pass the \"format\" parameter to the callback method with the help of \"callbackParams\" option (line 34). In lines 44-79, we define the filterPhone() callback method, which takes two arguments: the $value is the phone number to filter, and the $format is the desired phone number format. The $format parameter may either be 'local' (for local format) or 'intl' (for international format). In the filterPhone() callback method, we do the following: First, in line 46, we check if the $value parameter is a scalar and not an array. If the value is not a scalar, we return it without change. In line 53, we check the input value's length. We do nothing if the user entered an empty phone number; we just return it as is. Then, we remove any non-digit characters (line 59). If phone length is too short, we pad it with zeroes. We add the braces, the dash, and the spaces for international phone numbers; or just the dash for local phone numbers. Finally, we return the resulting phone number. To see how this filter works, you can open the \"http://localhost/contactus\" URL in your web browser. If you enter some phone number in an incorrect format, the filter will fix the phone number and transform it to the desired format. Writing Your Own Filter An alternative to using the @ Callback [Laminas\\Filter\\Callback] filter is writing your own filter class implementing the @ FilterInterface [Laminas\\Filter\\FilterInterface] interface. Then, this filter may be used in forms of your web application (or, if you wish, outside a form). To demonstrate how to create your own filter, we will write the PhoneFilter class encapsulating the phone filtering algorithm we used with the @ Callback [Laminas\\Filter\\Callback] filter example. As you may remember, the base concrete class for all standard filters is the @ AbstractFilter class. By analogy, we will also derive our custom PhoneFilter filter from that base class. We plan to have the following methods in our PhoneFilter filter class (see table 8.18): Method name Description __construct($options) Constructor - accepts an optional argument $options , which is needed to set filter options at once. setFormat($format) Sets the phone format option. getFormat() Returns the phone format option. filter($value) Runs the phone filter. Table 8.18. Public methods of the PhoneFilter filter To start, create the PhoneFilter.php file in the Filter directory under the module's source directory 3 . Put the following code into that file: <?php namespace Application\\Filter; use Laminas\\Filter\\AbstractFilter; // This filter class is designed for transforming an arbitrary phone number to // the local or the international format. class PhoneFilter extends AbstractFilter { // Phone format constants. const PHONE_FORMAT_LOCAL = 'local'; // Local phone format const PHONE_FORMAT_INTL = 'intl'; // International phone format // Available filter options. protected $options = [ 'format' => self::PHONE_FORMAT_INTL ]; // Constructor. public function __construct($options = null) { // Set filter options (if provided). if(is_array($options)) { if(isset($options['format'])) $this->setFormat($options['format']); } } // Sets phone format. public function setFormat($format) { // Check input argument. if( $format!=self::PHONE_FORMAT_LOCAL && $format!=self::PHONE_FORMAT_INTL ) { throw new \\Exception('Invalid format argument passed.'); } $this->options['format'] = $format; } // Returns phone format. public function getFormat() { return $this->format; } // Filters a phone number. public function filter($value) { if(!is_scalar($value)) { // Return non-scalar value unfiltered. return $value; } $value = (string)$value; if(strlen($value)==0) { // Return empty value unfiltered. return $value; } // First, remove any non-digit character. $digits = preg_replace('#[^0-9]#', '', $value); $format = $this->options['format']; if($format == self::PHONE_FORMAT_INTL) { // Pad with zeros if the number of digits is incorrect. $digits = str_pad($digits, 11, \"0\", STR_PAD_LEFT); // Add the braces, the spaces, and the dash. $phoneNumber = substr($digits, 0, 1) . ' (' . substr($digits, 1, 3) . ') ' . substr($digits, 4, 3) . '-' . substr($digits, 7, 4); } else { // self::PHONE_FORMAT_LOCAL // Pad with zeros if the number of digits is incorrect. $digits = str_pad($digits, 7, \"0\", STR_PAD_LEFT); // Add the dash. $phoneNumber = substr($digits, 0, 3) . '-'. substr($digits, 3, 4); } return $phoneNumber; } } From line 2, you can see that the filter class lives in the Application\\Filter namespace. In line 8, we define the PhoneFilter class. We derive our filter class from the @ AbstractFilter base class to reuse the functionality it provides. Line 4 contains the short alias for the @ AbstractFilter class. In lines 11-12, for convenience, we define the phone format constants ( PHONE_FORMAT_INTL for international format and PHONE_FORMAT_LOCAL for local format). These are the equivalents of the \"intl\" and \"local\" strings, respectively. In lines 15-17, we define the $options private variable, which is an array having the single key named \"format\". This key will contain the phone format option for our filter. In lines 20-28, we have the constructor method, which takes the single argument $options . When constructing the filter manually, you may omit this parameter. However, when the filter is constructed by the factory class, the factory will pass filter options to the filter's constructor through this argument. In lines 31-40 and 43-46, we have the setFormat() and getFormat() methods that allow to set and retrieve the current phone format, respectively. In lines 49-86, we have the filter() method. This method encapsulates the phone number filtering algorithm. It takes the $value parameter, transforms it by taking the selected phone format in account, and returns the formatted phone number. Using the PhoneFilter Class When the PhoneFilter filter class is ready, you can easily start using it in the feedback form (or in another form) as follows. It is assumed that you call the following code inside of the ContactForm::addInputFilter() method: $inputFilter->add([ 'name' => 'phone', 'required' => true, 'filters' => [ [ 'name' => PhoneFilter::class, 'options' => [ 'format' => PhoneFilter::PHONE_FORMAT_INTL ] ], // ... ], // ... ]); You can see how the PhoneFilter filter works in the Form Demo sample application bundled with this book. Open the \"http://localhost/contactus\" page in your web browser. If you enter some phone number in an incorrect format, the filter will fix the phone number. If you wish, you can use the PhoneFilter outside of forms, as shown in the code example below: <?php use Application\\Filter\\PhoneFilter; // Create PhoneFilter filter. $filter = new PhoneFilter(); // Configure the filter. $filter->setFormat(PhoneFilter::PHONE_FORMAT_INTL); // Filter a string. $filteredValue = $filter->filter('12345678901'); // The expected filter's output is the '1 (234) 567-8901'. Summary Filters are designed to take some input data, process it, and produce some output data. Laminas Framework provides a lot of standard filters that can be used for creating filtering rules of your forms (or, if you wish, to filter an arbitrary data outside of forms). The standard filters can be roughly divided into several groups: filters casting input data to a specified type; filters performing manipulations on a file path; filters performing compression and encryption of input data; filters manipulating string data; and proxy filters wrapping other filters. If a standard filter is not suitable, it is possible to create a custom filter class. In this chapter, we have provided an example of how to write your own PhoneFilter class capable of filtering phone numbers. In this section, we only consider the standard filters belonging to the @ Laminas\\Filter namespace, although there are other filters that can also be considered standard. For example, the @ Laminas\\Filter\\File [Laminas\\Filter] namespace contains several filters applicable to processing file uploads (those filters will be covered in the next chapters). Additionally, the @ Laminas\\I18n component defines several filter classes that are aware of the user's locale. \u21a9 From figure 8.1, you may also notice that there are several more base filters: @ AbstractUnicode filter is the base class for the @ StringToUpper and @ StringToLower filters, because it provides the string conversion functionality common to both of them. And, the @ Decompress filter inherits from the @ Compress filter, because these filters are in fact very similar. By analogy, the @ Decrypt [Laminas\\Filter\\Decrypt] filter inherits from the @ Encrypt [Laminas\\Filter\\Encrypt] filter, because they are the \"mirror reflection\" of each other as well. \u21a9 The PhoneFilter class may be considered as a service model because its goal is to process data, not to store it. By convention, we store all custom filters under the Filter directory. \u21a9","title":"Transforming Input Data with Filters"},{"location":"filters/#transforming-input-data-with-filters","text":"In this chapter, we will provide an overview of standard filters that can be used with your web forms. A filter is a class which takes some input data, processes it, and produces some output data. We will also show how to write a custom filter. Note In general, you can even use filters outside forms to process an arbitrary data. For example, filters may be used in a controller action to transform the data passed as GET and/or POST variables to certain format. Laminas components covered in this chapter: Component Description @ Laminas\\Filter Contains various filters classes. @ Laminas\\InputFilter Implements a container for filters/validators.","title":"Transforming Input Data with Filters"},{"location":"filters/#about-filters","text":"Filters are designed to take some input data, process it, and produce some output data. Laminas Framework provides a lot of standard filters that can be used for creating filtering rules of your forms (or, if you wish, to filter an arbitrary data outside of forms).","title":"About Filters"},{"location":"filters/#filterinterface","text":"Technically, a filter is a PHP class implementing the @ FilterInterface [Laminas\\Filter\\FilterInterface] interface (it belongs to @ Laminas\\Filter namespace). The interface definition is presented below: <?php namespace Laminas\\Filter; interface FilterInterface { // Returns the result of filtering $value. public function filter($value); } As you can see, the @ FilterInterface [Laminas\\Filter\\FilterInterface] interface has the single method filter() (line 7), which takes the single parameter $value . The method transforms the input data and finally returns the resulting (filtered) value. A concrete filter class implementing the @ FilterInterface [Laminas\\Filter\\FilterInterface] interface may have additional methods. For example, many filter classes have methods allowing configuration of the filter (set filtering options).","title":"FilterInterface"},{"location":"filters/#standard-filters-overview","text":"Standard filters implementing the @ FilterInterface [Laminas\\Filter\\FilterInterface] interface belong to @ Laminas\\Filter namespace 1 . A filter class inheritance diagram is shown in figure 8.1. From that figure, you can see that base concrete class for most standard filters is the @ AbstractFilter class, which implements the @ FilterInterface [Laminas\\Filter\\FilterInterface] interface 2 . Note You may notice that there is a strange filter called @ StaticFilter which does not inherit from @ AbstractFilter base class. This is because the @ StaticFilter class is actually a \"wrapper\" (it is designed to be a proxy to another filter without explicit instantiation of that filter). Standard filters provided by the @ Laminas\\Filter component, along with a brief description of each, are listed in table 8.1. As you can see from the table, the standard filters can be roughly divided into the following groups: filters casting input data to a specified type (integer, boolean, date-time, etc.); filters performing manipulations on a file path (getting the base name, parent directory name, etc.); filters performing compression and encryption of input data; filters manipulating string data (case conversion, trimming, character replacement and removal, URL normalizing, etc.); and proxy filters wrapping other filters (@ Callback [Laminas\\Filter\\Callback], @ FilterChain [Laminas\\Filter\\FilterChain] and @ StaticFilter ). Class name Description @ Boolean [Laminas\\Filter\\Boolean] Returns a boolean representation of $value . @ ToInt Casts the input $value to int . @ Digits [Laminas\\Filter\\Digits] Returns the string $value , removing all but digit characters. @ ToNull Returns null if the input value can be treated as null; otherwise returns the $value itself. @ DateTimeFormatter Takes a date & time string in an arbitrary format and produces a date & time string in a given format. @ BaseName Given a string containing the path to a file or directory, this filter will return the trailing name component. @ Dir Given a string containing the path of a file or directory, this filter will return the parent directory's path. @ RealPath Returns canonicalized absolute pathname. @ Compress Compresses the input data with the specified algorithm (GZ by default). @ Decompress Decompresses the input data with the specified algorithm (the effect is inverse to the Compress filter). @ Encrypt [Laminas\\Filter\\Encrypt] Encrypts the input data with the specified cryptographic algorithm. @ Decrypt [Laminas\\Filter\\Decrypt] Decrypts the input data previously encrypted with the specified cryptographic algorithm. @ Inflector Performs the modification of a word to express different grammatical categories such as tense, mood, voice, aspect, person, number, gender, and case. @ PregReplace Performs a regular expression search and replace. @ StringToLower Converts the string to lowercase letters. @ StringToUpper Converts the string to uppercase letters. @ StringTrim Removes white spaces (space, tabs, etc.) from the beginning and the end of the string. @ StripNewlines Removes new line characters from string (ASCII codes #13, #10). @ HtmlEntities Returns the string, converting characters to their corresponding HTML entity equivalents where they exist. @ StripTags Removes tags (e.g., <a></a> ) and comments (e.g., <!-- --> ). @ UriNormalize Converts a URL string to the \"normalized\" form and prepends the schema part (e.g., converts www.example.com to http://www.example.com ). @ Callback [Laminas\\Filter\\Callback] Allows to use a callback function as a filter. @ FilterChain [Laminas\\Filter\\FilterChain] Allows to organize several filters in a chain. @ StaticFilter Returns a value filtered through a specified filter class without requiring separate instantiation of the filter object. Table 8.1. Standard filters","title":"Standard Filters Overview"},{"location":"filters/#instantiating-a-filter","text":"In Laminas Framework, you can use several methods of creating a filter: instantiating it manually (with the new operator); creating it with a factory class (by passing an array configuration), a method most frequently used when adding filtering and validation rules in a form; and instantiating it implicitly with the @ StaticFilter wrapper class. Next, we will cover these three methods in more details.","title":"Instantiating a Filter"},{"location":"filters/#method-1-instantiating-a-filter-manually","text":"As we previously said, a filter in general can be used not only with forms but also for filtering an arbitrary data. To do that, you simply create an instance of the filter class, configure the filter by using the methods it provides, and call the filter() method on the filter. For example, let's consider the usage of the @ StringTrim filter which removes the white space characters from the beginning and the end of a string. The @ StringTrim filter is useful for filtering user-entered string data (E-mail addresses, user names, etc.) because site visitors tend to make typos in those data. For example, a user may unintentionally enter a trailing space in an E-mail field, thus making an E-mail invalid. With the @ StringTrim filter, you will easily cope with such input errors and improve user experience. The methods provided by the filter are listed in table 8.2: Method name Description __construct($charlistOrOptions) Constructs the filter. Accepts the list of options. filter($value) Removes the predefined characters from the beginning and the end of the string. setCharList($charList) Defines the list of characters to strip off. getCharList() Returns the list of characters to strip off. Table 8.2. Public methods of the StringTrim filter As you can see from the table, the @ StringTrim filter, in addition to the filter() method, provides the constructor method which you can (optionally) pass with the complete list of options to initialize the filter, and the setCharList() and getCharList() methods which can be used for setting specific filter options. Note All standard filters have the constructor method (optionally) accepting an array of options for configuring the filter when instantiating it manually. Below, we provide two code examples showing equivalent methods of manually creating an instance of the @ StringTrim filter, setting its options, and filtering a value. Example 1. Passing options to the constructor method. <?php // Optionally, define a short alias for the filter class name. use Laminas\\Filter\\StringTrim; // Create an instance of the filter, passing options to the constructor. $filter = new StringTrim(['charlist'=>\"\\r\\n\\t \"]); // Perform the trimming operation on the string. $filteredValue = $filter->filter(' name@example.com '); // The expected output of the filter is the 'name@example.com' string. In the code above, we create the @ StringTrim filter object with the help of the new operator (line 6). We pass the array of options to the constructor to set the list of characters the filter will remove (here, we tell the filter to remove the new line characters, the tabulation character, and the space character). Actually, passing the array of options to this filter can be omitted because the filter already has some default character list to strip off. In line 9, we call the filter() method and pass it the string value \" name@example.com \" to be trimmed. The expected output of this call is the \"name@example.com\" string. Example 2. Without passing options to the constructor. <?php // Optionally, define a short alias for the filter class name. use Laminas\\Filter\\StringTrim; // Create an instance of the filter. $filter = new StringTrim(); // Specify which characters to remove. $filter->setCharList(\"\\r\\n\\t \"); // Perform the trimming operation on the string $filteredValue = $filter->filter(' name@example.com '); // The expected output of the filter is the 'name@example.com' string In the code above, we create the @ StringTrim filter object with the help of the new operator (line 6). In line 9, we (optionally) call the @ StringTrim filter's setCharList() method to set the list of characters the filter will remove (here, we tell the filter to remove the new line characters, the tabulation character, and the space character). This call is optional because the filter already has some default character list for stripping off. And, in line 12, we call the filter() method and pass it the string value \" name@example.com \" to be trimmed. The expected output of this call is the \"name@example.com\" string.","title":"Method 1: Instantiating a Filter Manually"},{"location":"filters/#method-2-constructing-a-filter-with-staticfilter","text":"An alternative way of manual filter instantiation is by using the @ StaticFilter class. The @ StaticFilter class is some kind of a \"proxy\" designed for automatic filter instantiation, configuration, and execution. For example, let's consider how to create the same @ StringTrim filter, configure it, and call its filter() method: <?php // Create and execute the StringTrim filter through the StaticFilter proxy. $filteredValue = \\Laminas\\Filter\\StaticFilter::execute(' name@example.com ', 'StringTrim', ['charlist' => \"\\r\\n\\t \"]); // The expected output of the filter is the 'name@example.com' string. The @ StaticFilter class provides the execute() static method, which takes three arguments: the input value, the name of the filter to apply, and the array of filter-specific options. In line 3, we call the execute() method to automatically create the @ StringTrim filter, call its setCharList() method, and pass the input value to its filter() method. This is very useful because it can be accomplished in a single line of code.","title":"Method 2: Constructing a Filter with StaticFilter"},{"location":"filters/#method-3-constructing-a-filter-from-array","text":"When using filters with form's validation rules, you typically do not construct a filter object explicitly as we did in the previous section; instead, you pass an array configuration to the factory class, which automatically constructs the filter for you and (optionally) configures it. We already saw how this works when adding validation rules for the feedback form in Collecting User Input with Forms . For example, let's show how to construct the same @ StringTrim filter with the help of the factory: <?php // It is assumed that you call the following code inside of the form model's // addInputFilter() method. $inputFilter->add([ // ... 'filters' => [ [ 'name' => 'StringTrim', 'options' => [ 'charlist' => \"\\r\\n\\t \" ] ], ], // ... ]; In the code above, we call the add() method provided by the @ InputFilter [Laminas\\InputFilter\\InputFilter] container class (line 5). The add() method takes an array which has the filters key. You typically register the filters under that key (line 7). Filters registered under that key are inserted in a filter chain in the order they appear in the list. A filter configuration typically consists of the name (line 9) and options (line 10). The name is a fully qualified filter class name (e.g., @ Laminas\\Filter\\StringTrim ) or its short alias (@ StringTrim ). The options is an array consisting of filter-specific options. When the factory class instantiates the filter, it passes the list of options to the filter's constructor method, and the constructor initializes the filter as needed.","title":"Method 3: Constructing a Filter From Array"},{"location":"filters/#about-filter-plugin-manager","text":"In the previous example, you saw that you can use either the fully qualified filter class name or its short alias when instantiating the filter from the array. The short aliases for the standard filters are defined by the @ FilterPluginManager [Laminas\\Filter\\FilterPluginManager] class. A standard filter's alias is typically the same as the class name. For example, the class @ Laminas\\Filter\\StringTrim has the short alias @ StringTrim . The filter plugin manager is internally used by the @ InputFilter [Laminas\\InputFilter\\InputFilter] container class for instantiating the standard filters.","title":"About Filter Plugin Manager"},{"location":"filters/#filters-behavior-in-case-of-incorrect-input-data","text":"Different filters behave differently if you pass it input data that the filter cannot process correctly. Some filters (such as the @ ToInt filter) will process only scalar data. If you pass an array to such filter, it will return the array as is. Some filters can work with data in certain format only (e.g., with dates only). If filtering of input data is impossible (for example, when you pass the filter some wrong data that it is unable to process), the filter() method may throw a @ Laminas\\Filter\\Exception\\RuntimeException exception. This behavior can be seen in @ DateTimeFormatter filter. Some filters (e.g., @ ToInt or @ StringToLower ) may rise a PHP warning if the value provided is in incorrect format and cannot be filtered. Note It is recommended to read filter's documentation carefully to know what to expect of the filter you plan to use in your form.","title":"Filter's Behavior in Case of Incorrect Input Data"},{"location":"filters/#filter-usage-examples","text":"Next, we will consider the usage of the most important standard filters. These describe the methods (and options) a filter has and provide code examples showing how to instantiate the filter and apply it to input data. If you need to use a filter not covered in this section, please refer to Standard Filters section of the Laminas Framework Reference Manual .","title":"Filter Usage Examples"},{"location":"filters/#filters-casting-input-data-to-a-specified-type","text":"In this section, we will consider several filters from the group of filters related to casting input data to the specified type and provide their usage examples.","title":"Filters Casting Input Data to a Specified Type"},{"location":"filters/#toint-filter","text":"The @ ToInt filter is a very simple filter that is designed to cast an arbitrary scalar data to an integer. This filter may be useful when adding validation rules for form fields that must contain an integer numeric values (e.g., a drop-down list or a text field containing an amount of something). The @ ToInt class has the single filter() method. Note The @ ToInt filter will not cast a non-scalar value. If you pass it an array, it will return it as is. Below, you can find a code example illustrating the usage of the @ ToInt filter. <?php // Create ToInt filter. $filter = new \\Laminas\\Filter\\ToInt(); // Filter a value casting it to an integer number. $filteredValue = $filter->filter('10'); // Returns (int) 10. $filteredValue2 = $filter->filter(['10', '20']); // Returns array as is. In the code above, we pass the string \"10\" to the filter (line 6). The expected return value is the integer 10. In line 7, we pass an array to the filter. Because the @ ToInt filter works with scalar values only, it returns the array as is (without changes) and raises a PHP warning.","title":"ToInt Filter"},{"location":"filters/#boolean-filter","text":"The @ Boolean [Laminas\\Filter\\Boolean] class is a filter that is designed to cast an arbitrary data to a boolean value ( true or false ). This filter can be used for filtering check box form fields. Its public methods are listed in table 8.3. Method name Description filter($value) Returns a boolean representation of $value . setCasting($flag) Sets casting flag. getCasting() Returns the casting flag. setType($type) Sets types from which to cast. getType() Returns types. setTranslations($translations) Sets translations. getTranslations() Returns the translations. Table 8.3. Public methods of the Boolean filter The filter provides several methods allowing to set filtering options ( setCasting() , setType() , and setTranslations() ). The setCasting() method allows to choose one of two modes in which the filter may operate. If the flag is true , the filter will behave like the PHP (boolean) cast operator. Otherwise (if the flag is set to false ), it will cast only from types defined by the setType() method, and all other values will be returned as is. The setType() filter's method allows to define from which types to cast. This method accepts the single argument $type , which can be either an OR combination of TYPE_ -prefixed constants or an array containing the literal equivalents of the constants. Possible constants accepted by the setType() method and their literal equivalents are listed in table 8.4: Constant Numeric Value Literal Equivalent Description TYPE_BOOLEAN 1 \"boolean\" Returns a boolean value as is. TYPE_INTEGER 2 \"integer\" Converts an integer 0 value to false . TYPE_FLOAT 4 \"float\" Converts a float 0.0 value to false . TYPE_STRING 8 \"string\" Converts an empty string '' to false . TYPE_ZERO_STRING 16 \"zero\" Converts a string containing the single character zero ('0') to false . TYPE_EMPTY_ARRAY 32 \"array\" Converts an empty array to false . TYPE_NULL 64 \"null\" Converts a null value to false . TYPE_PHP 127 \"php\" Converts values according to PHP when casting them to boolean. (This is the default behavior.) TYPE_FALSE_STRING 128 \"false\" Converts a string containing the word \"false\" to a boolean false . TYPE_LOCALIZED 256 \"localized\" Converts a localized string which contains certain word to boolean. TYPE_ALL 511 \"all\" Converts all above types to boolean. Table 8.4. Type constants The following code example shows two equivalent ways you can call the setType() method: <?php use Laminas\\Filter\\Boolean; // Call the setType() and pass it a combination of constants. $filter->setType(Boolean::TYPE_BOOLEAN| Boolean::TYPE_INTEGER| Boolean::TYPE_STRING); // Call the setType() and pass it an array with literal equivalents. $filter->setType(['boolean', 'integer', 'string']); The setTranslations() method allows to define localized equivalents of boolean true and false values. This method accepts a single parameter, which must be an array in the form of key=>value pairs, where the key is a localized string and the value is its boolean representation. The following code example shows how to use the setTranlsations() method: <?php $filter->setTranslations([ 'yes' => true, // English 'yes' 'no' => false, // English 'no' 'ja' => true, // German 'yes' 'nicht' => false, // German 'no' '\u0434\u0430' => true, // Russian 'yes' '\u043d\u0435\u0442' => false // Russian 'no' ]); Below, we provide a code example illustrating the usage of the @ Boolean [Laminas\\Filter\\Boolean] filter. <?php // Create ToBoolean filter. $filter = new \\Laminas\\Filter\\Boolean(); // Optionally configure the filter. $filter->setCasting(true); $filter->setType(\\Laminas\\Filter\\Boolean::TYPE_ALL); $filter->setTranslations(['yes'=>true, 'no'=>false]); // Filter a value casting it to a boolean number. $filteredValue = $filter->filter('false'); // Returns boolean false. $filteredValue2 = $filter->filter('1'); // Returns boolean true. $filteredValue3 = $filter->filter('false'); // Returns boolean false. $filteredValue4 = $filter->filter('yes'); // Returns boolean true.","title":"Boolean Filter"},{"location":"filters/#tonull-filter","text":"The @ ToNull filter is designed to cast an arbitrary data to a null value if it meets specific criteria. This may be useful when you work with a database and want to have a null value instead of any other type. If the value cannot be treated as null , the filter will return the value as is. The @ ToNull filter's public methods are listed in table 8.5. Method name Description filter($value) Casts the $value to null , if possible; otherwise returns values as is. setType($type) Defines from which types to cast. getType() Returns defined types. Table 8.5. Public methods of the ToNull filter By default, the ToNull filter behaves like PHP's empty() function: if the empty() function returns a boolean true on the input data, then the filter will return the null value on that data, as well. The setType() method can be used to set the type from which the filter will cast to null . This method takes a single parameter, which can either be a combination of TYPE_ -prefixed constants listed in table 8.6 or an array of their literal equivalents. Constant Numeric Value Literal Equivalent Description TYPE_BOOLEAN 1 \"boolean\" Converts a boolean false value to null . TYPE_INTEGER 2 \"integer\" Converts an integer 0 value to null . TYPE_EMPTY_ARRAY 4 \"array\" Converts an empty array to null . TYPE_STRING 8 \"string\" Converts an empty string '' to null . TYPE_ZERO_STRING 16 \"zero\" Converts a string containing the single character zero ('0') to null . TYPE_FLOAT 32 \"float\" Converts a float 0.0 value to null . TYPE_ALL 63 \"all\" Converts all above types to null . This is the default behavior. Table 8.6. Type constants The following code example illustrates two equivalent ways you can call the setType() method: <?php use Laminas\\Filter\\ToNull; // Call the setType() and pass it a combination of constants. $filter->setType(ToNull::TYPE_ZERO_STRING|ToNull::TYPE_STRING); // Call the setType() and pass it an array with literal equivalents. $filter->setType(['zero', 'string']); Below, a code example showing how to use the @ ToNull filter is provided: <?php // Create ToNull filter. $filter = new \\Laminas\\Filter\\ToNull(); // Optionally configure the filter. $filter->setType(\\Laminas\\Filter\\ToNull::TYPE_ALL); $filteredValue = $filter->filter('0'); // Returns null. $filteredValue2 = $filter->filter('1'); // Returns string '1'. $filteredValue3 = $filter->filter(false); // Returns null.","title":"ToNull Filter"},{"location":"filters/#datetimeformatter-filter","text":"The @ DateTimeFormatter filter accepts a date in an arbitrary format and converts it into the desired format. This filter can accept a string (e.g., '2014-03-22 15:36'), an integer timestamp (like the time() PHP function returns) or an instance of the DateTime PHP class. The @ DateTimeFormatter filter may throw a @ Laminas\\Filter\\Exception\\InvalidArgumentException exception if you pass it a date in an incorrect format. Filter's public methods are listed in table 8.7. Method name Description __construct($options) Constructs the filter. filter($value) Transforms the date into the desired format. setFormat($format) Sets the date format. Table 8.7. Public methods of the DateTimeFormatter filter In the code example below, we show how to create the filter, pass it a string date, and convert it to the desired format: <?php // Create DateTimeFormatter filter. $filter = new \\Laminas\\Filter\\DateTimeFormatter(); // Set filter's format (optional). $filter->setFormat('F j, Y g:i A'); // Transform the date to the specified format. $filteredValue = $filter->filter('2014-03-22 15:36'); // The expected output is 'March 22, 2014 3:36 PM'. Note Internally, the @ DateTimeFormatter filter uses the DateTime class from the PHP standard library for converting and formatting dates. For available date formats, please refer to the PHP documentation for the DateTime class.","title":"DateTimeFormatter Filter"},{"location":"filters/#filters-performing-manipulations-on-a-file-path","text":"In this section, we will consider usage examples of the filters from the group of filters related to manipulating file paths.","title":"Filters Performing Manipulations on a File Path"},{"location":"filters/#basename-filter","text":"The @ BaseName filter class is just a wrapper on the basename() PHP function. It takes a string containing the path to a file or directory and returns the trailing name component. Below, you can find an example of the @ BaseName filter usage: <?php // Create BaseName filter. $filter = new \\Laminas\\Filter\\BaseName(); // Filter a file path and return its last part. $filteredValue = $filter->filter('/var/log/httpd/error.log'); // The expected filter's output is the 'error.log'. Note The @ BaseName filter will not process a non-scalar value. If you pass it an array, it will return the array as is and raise a PHP warning.","title":"BaseName Filter"},{"location":"filters/#dir-filter","text":"The @ Dir filter class is just a wrapper on the dirname() PHP function. It takes a string containing the path to a file or directory and returns the parent directory's path. Note The @ Dir filter will not process a non-scalar value. If you pass it an array, it will return the array as is. Below, a code example demonstrating the usage of the @ Dir filter is provided. <?php // Create Dir filter. $filter = new \\Laminas\\Filter\\Dir(); // Filter a file path and return its directory name part. $filteredValue = $filter->filter('/var/log/httpd/error.log'); // The expected filter's output is the '/var/log/httpd'.","title":"Dir Filter"},{"location":"filters/#realpath-filter","text":"The @ RealPath filter takes an absolute or a relative file path as a string input argument. It expands all symbolic links and resolves references to '/./', '/../' and extra '/' characters in the input path and returns the canonicalized absolute pathname. Note The @ RealPath filter is a wrapper over the realpath() PHP function. Filter's public methods are listed in table 8.8. Method name Description __construct($options) Constructs the filter. filter($value) Returns canonicalized absolute pathname. setExists($flag) Specifies if the path must exist for this filter to succeed. The value true means the path must exist; the value false means a nonexisting path can be given. getExists() Returns true if the filtered path must exist. Table 8.8. Public methods of the RealPath filter The @ RealPath filter returns a boolean false on failure, e.g., if the file does not exist. If a nonexisting path is allowed, you can call the setExists() method with the false parameter. Below, a code example demonstrating the usage of the @ RealPath filter is provided. <?php // Create RealPath filter. $filter = new \\Laminas\\Filter\\RealPath(); // Filter a file path (it is assumed that the current // working directory is /var/log/httpd and that it contains // the error.log file). $filteredValue = $filter->filter('./error.log'); // The expected filter's output is the '/var/log/httpd/error.log'. Note The @ RealPath filter will not process a non-scalar value. If you pass it an array, it will return the array as is.","title":"RealPath Filter"},{"location":"filters/#filters-performing-compression-and-encryption-of-input-data","text":"In this section, we will consider several filters from the group of filters related to compressing and encrypting the input data. These filters are not very usable for filtering form data but can be used outside of forms with a great success.","title":"Filters Performing Compression and Encryption of Input Data"},{"location":"filters/#compress-filter","text":"The @ Compress filter is designed to compress input data with some compression algorithm. For example, you can use this filter to compress the data and save it as an archive file. Filter's public methods are listed in table 8.9. Method name Description __construct($options) Constructs the filter. filter($value) Performs data compression using the specified algorithm. getAdapter() Returns the current adapter, instantiating it if necessary. getAdapterName() Retrieves adapter name. setAdapter($adapter) Sets compression adapter. getAdapterOptions() Retrieves adapter options. setAdapterOptions($options) Sets adapter options. getOptions($option) Gets individual or all options from underlying adapter. Table 8.9. Public methods of the Compress filter The @ Compress filter itself cannot compress data. Instead, it uses a so-called adapter class. The adapter class must implement the @ CompressionAlgorithmInterface interface. You attach an adapter to the @ Compress filter, and the adapter implements the concrete compression algorithm. There are several standard adapter classes available (see figure 8.2 and table 8.10 below). Those classes live in the @ Laminas\\Filter\\Compress [Laminas\\Filter] namespace. Class name Description @ Bz2 Bzip2 (Burrows\u2013Wheeler) compression algorithm. @ Gz Gzip compression algorithm is based on the Deflate algorithm, which is a combination of LZ77 and Huffman coding. @ Zip ZIP is a compression algorithm widely used in Windows operating system. @ Tar Tarball file format is now commonly used to collect many files into one larger file for archiving while preserving file system information such as user and group permissions, dates, and directory structures. Widely used in Linux operating system. @ Lzf LZF is a very fast compression algorithm, ideal for saving space with only slight speed cost. @ Snappy Snappy is a fast data compression and decompression library developed by Google based on ideas from LZ77. @ Rar RAR is an archive file format that supports data compression, error recovery, and file spanning. Table 8.10. Compression adapters Below, a code example demonstrating the usage of the @ Compress filter is provided. <?php // Create Compress filter. $filter = new \\Laminas\\Filter\\Compress(); // Configure the adapter. $filter->setAdapter('Zip'); $filter->setAdapterOptions([ 'archive' => 'example.zip', ]); // Compress an input data (it is assumed that you have the testfile.txt // file in the current working directory. $filter->filter('testfile.txt'); In the code above, we create the instance of the @ Compress filter (line 3), set its adapter (line 6), set adapter's options (line 7), and finally, compress the input file (line 13). The expected result, the example.zip archive file, will be created in the current directory. The archive will contain the testfile.txt file. Note The @ Decompress filter is a \"mirror reflection\" of the @ Compress filter and can be used by analogy. By that reason, we do not cover the @ Decompress filter in this section.","title":"Compress Filter"},{"location":"filters/#encrypt-filter","text":"The @ Encrypt [Laminas\\Filter\\Decrypt] filter's purpose is encrypting the input data with the specified algorithm. Filter's public methods are listed in table 8.11. Method name Description __construct($options) Constructs the filter. filter($value) Performs data encrypting using the specified algorithm. getAdapter() Returns the current adapter, instantiating it if necessary. setAdapter($adapter) Sets encrypting adapter. Table 8.11. Public methods of the Encrypt filter The @ Encrypt [Laminas\\Filter\\Encrypt] filter uses adapter classes to perform actual data encryption. You attach an adapter to the @ Encrypt [Laminas\\Filter\\Encrypt] filter with the setAdapter() method, and the adapter performs the concrete encryption. An adapter class must implement the @ EncryptionAlgorithmInterface interface. There are several standard adapter classes available (see figure 8.3 below). Those classes live in the @ Laminas\\Filter\\Encrypt [Laminas\\Filter] namespace. @ BlockCipher [Laminas\\Filter\\Encrypt\\BlockCipher] -- implements symmetric block cipher algorithm. @ Openssl [Laminas\\Filter\\Encrypt\\Openssl] -- uses an encryption algorithm from the OpenSSL library. Below, a code example demonstrating the usage of the @ Encrypt [Laminas\\Filter\\Encrypt] filter is provided. <?php // Create Encrypt filter. $filter = new \\Laminas\\Filter\\Encrypt(); // Set encryption adapter. $filter->setAdapter('BlockCipher'); // Encrypt an input data. $filteredValue = $filter->filter('some data to encrypt'); The expected result is a string encrypted with the block cipher. Note The @ Decrypt [Laminas\\Filter\\Decrypt] filter is a \"mirror reflection\" of the @ Encrypt [Laminas\\Filter\\Encrypt] filter and can be used by analogy. By that reason, we do not cover the @ Decrypt [Laminas\\Filter\\Decrypt] filter in this section.","title":"Encrypt Filter"},{"location":"filters/#filters-manipulating-string-data","text":"In this section, we will consider usage examples of the filters from the group of filters related to manipulating string data.","title":"Filters Manipulating String Data"},{"location":"filters/#stringtolower-filter","text":"The @ StringToLower filter class is designed for converting the input string data to lowercase letters. The public methods of the filter are provided in table 8.12 below. Method name Description __construct($options) Constructs the filter. filter($value) Converts the string to lowercase letters. setEncoding($encoding) Sets the input encoding for the given string. getEncoding() Returns the encoding. Table 8.12. Public methods of the StringToLower filter By default, the filter behaves like the strtolower() PHP function. Given a string, it returns the string with all alphabetic characters converted to lowercase. The \"alphabetic characters\" are determined by the system locale. This means that in, for example, the default \"C\" locale, characters such as umlaut-A (\u00c4) will not be converted. Calling the setEncoding() method on the filter and passing it an encoding to use forces this filter to behave like the mb_strtolower() PHP function. By contrast to strtolower() , \"alphabetic\" is determined by the Unicode character properties. Thus, the behavior of this function is not affected by locale settings, and it can convert any characters that have 'alphabetic' property, such as A-umlaut (\u00c4). Note If the value provided is non-scalar, the value will remain unfiltered, and an E_USER_WARNING will be raised indicating it cannot be filtered. Below, a code example showing how to use the @ StringToLower filter is provided: <?php // Create StringToLower filter. $filter = new \\Laminas\\Filter\\StringToLower(); // (Optionally) set encoding on the filter. $filter->setEncoding('UTF-8'); // Filter a string. $filteredValue = $filter->filter('How to Start a Business in 10 Days'); // The expected filter's output is the 'how to start a business in 10 days'. The @ StringToUpper filter (converting a string to uppercase letters) is a \"mirror reflection\" of the @ StringToLower filter and can be used by analogy. By that reason, we do not cover the @ StringToUpper filter in this section.","title":"StringToLower Filter"},{"location":"filters/#pregreplace-filter","text":"The @ PregReplace filter can be used for performing a regular expression search and replace in a string data. This filter is a wrapper over the preg_replace() PHP function. The public methods of the filter are provided in table 8.13 below. Method name Description __construct($options) Constructs the filter. filter($value) Performs a regular expression search and replace. setPattern($pattern) Sets the pattern to search for. It can be either a string or an array with strings. getPattern() Returns the pattern. setReplacement($replacement) Sets the string or an array with strings to replace. getReplacement() Gets currently set replacement value. Table 8.13. Public methods of the PregReplace filter Below, a code example showing how to use the @ PregReplace filter is provided: <?php // Create PregReplace filter. $filter = new \\Laminas\\Filter\\PregReplace(); // Configure the filter. $filter->setPattern(\"/\\s\\s+/\"); $filter->setReplacement(' '); // Filter a string. $filteredValue = $filter->filter('An example with multiple spaces.'); // The expected filter's output is the 'An example with multiple spaces.'","title":"PregReplace Filter"},{"location":"filters/#striptags-filter","text":"The @ StripTags filter removes all tags (e.g. <!-- --> , <p> , <h1> or <?php ?> ) from the input string. It allows to explicitly define the tags which should not be stripped out. Additionally, it provides an ability to specify which attributes are allowed across all allowed tags and/or specific tags only. Public methods of the @ StripTags filter are listed in table 8.14. Method name Description __construct($options) Constructs the filter. filter($value) Returns the value with tags stripped off it. getAttributesAllowed() Returns the list of attributes allowed for the tags. setAttributesAllowed($attributesAllowed) Sets the list of attributes allowed for the tags. getTagsAllowed() Returns the list of tags allowed. setTagsAllowed($tagsAllowed) Sets the list of tags allowed. Table 8.14. Public methods of the StripTags filter Below, a code example showing how to use the @ StripTags filter is provided: <?php // Create StripTags filter. $filter = new \\Laminas\\Filter\\StripTags(); // Configure the filter. $filter->setTagsAllowed(['p']); // Filter a string. $filteredValue = $filter->filter( '<p>Please click the following <a href=\"example.com\">link</a>.</p>'); // The expected filter's output is the // '<p>Please click the following link.</p>;' Note The @ StripTags will not process a non-scalar value. If the value passed to the filter is non-scalar, the value will remain unfiltered.","title":"StripTags Filter"},{"location":"filters/#stripnewlines-filter","text":"The @ StripNewlines filter is a very simple filter which returns the input string without any newline control characters (\"\\r\", \"\\n\"). Below, a code example showing how to use the @ StripNewlines filter is provided: <?php // Create StripNewlines filter. $filter = new \\Laminas\\Filter\\StripNewlines(); // Filter a string. $filteredValue = $filter->filter(\"A multi line\\r\\n string\"); // The expected filter's output is the 'A multi line string'. Note The @ StripNewlines will not process a non-scalar value. If the value passed to the filter is non-scalar, the value will remain unfiltered.","title":"StripNewlines Filter"},{"location":"filters/#urinormalize-filter","text":"The @ UriNormalize filter can be used for normalizing a URL string and (optionally) applying a scheme part to it. The public methods of the filter are provided in table 8.15 below. Method name Description filter($value) Filter the URL by normalizing it and applying a default scheme if set. setDefaultScheme($defaultScheme) Set the default scheme to use when parsing schemeless URIs. setEnforcedScheme($enforcedScheme) Set a URI scheme to enforce on schemeless URIs. Table 8.15. Public methods of the UriNormalize filter The URL normalization procedure typically consists of the following steps: The URL string is decomposed into its schema, host, port number, path, and query parts. If the scheme part is missing from the original URL, the default scheme is used. The scheme and host parts are converted to lowercase letters. The port number is checked against the list of allowed port numbers, and if it doesn't belong to the list, the port number is cleared. The path part of the URL is filtered, removing redundant dot segments, URL-decoding any over-encoded characters, and URL-encoding everything that needs to be encoded and is not. The query part is sanitized, URL-decoding everything that doesn't need to be encoded and URL-encoding everything else. The URL normalization procedure rules may be different for different protocols (schemes). If the URL doesn't contain the scheme part, the http scheme is assumed by default. You may use the @ UriNormalize filter's setDefaultScheme() method to set the default scheme for URL normalization. It accepts any of the following schemes: http , https , file , mailto , urn , and tag . Additionally, the @ UriNormalize filter's setEnforcedScheme() allows to override the default scheme part by the so-called \"enforced scheme\", if the original URL doesn't contain scheme part. Below, a code example showing how to use the @ UriNormalize filter is provided: <?php // Create UriNormalize filter. $filter = new \\Laminas\\Filter\\UriNormalize(); // Configure the filter. $filter->setDefaultScheme('http'); $filter->setEnforcedScheme('https'); // Filter an URL string. $filteredValue = $filter->filter('www.example.com'); // The expected filter's output is the 'https://www.example.com/'.","title":"UriNormalize Filter"},{"location":"filters/#organizing-filters-in-a-chain","text":"Filters can be organized in a sequence. This is accomplished by the @ FilterChain [Laminas\\Filter\\FilterChain] class. When such a compound filter is run, the value filtered by the first filter is passed as an input for the second one, and then the value filtered by the second filter will be passed to the third one, and so on. Note The @ FilterChain [Laminas\\Filter\\FilterChain] class is internally used by the @ InputFilter [Laminas\\InputFilter\\InputFilter] container class for storing the sequence of filters attached to the form model's field. Public methods provided by the @ FilterChain [Laminas\\Filter\\FilterChain] class are presented in table 8.16: Method name Description filter($value) Returns value filtered through each filter in the chain. Filters are run in the order in which they were added to the chain (FIFO). setOptions($options) Sets options. attach($callback, $priority) Attaches an existing filter instance (or a callback function) to the chain. attachByName($name, $options, $priority) Instantiates the filter by class name or alias and inserts it into the chain. merge($filterChain) Merges the filter chain with another filter chain. getFilters() Returns all the attached filters. count() Returns the count of attached filters. Table 8.16. Public methods of the FilterChain filter An example filter chain is shown in figure 8.4. It consists of the @ StringTrim filter followed by the @ StripTags filter, which is then followed by the @ StripNewlines filter. To construct the filter chain like in figure 8.4, we can use the following code: <?php use Laminas\\Filter\\FilterChain; // Instantiate the filter chain. $filter = new FilterChain(); // Insert filters into filter chain. $filter->setOptions([ 'filters'=>[ [ 'name'=>'StringTrim', 'options'=>['charlist'=>\"\\r\\n\\t \"], 'priority'=>FilterChain::DEFAULT_PRIORITY ], [ 'name'=>'StripTags', 'options'=>['tagsallowed'=>['p']], 'priority'=>FilterChain::DEFAULT_PRIORITY ], [ 'name'=>'StripNewlines', 'priority'=>FilterChain::DEFAULT_PRIORITY ] ] ]); // Execute all filters in the chain. $filteredValue = $filter->filter(\" name@example.com<html>\\n \"); // The expected output is 'name@example.com'. In the code above, we instantiate the @ FilterChain [Laminas\\Filter\\FilterChain] filter with the new operator (line 5). In line 8, we set construct the chain of filters with the setOptions() method. The method takes an array configuration which looks the same way as in @ InputFilter [Laminas\\InputFilter\\InputFilter]'s add() method. The array has \"filters\" key where you register the filters you want to insert into the chain. For each attached filter, you provide the following subkeys: \"name\" is the fully qualified class name of the filter (e.g., StringTrim::class ) or its short alias (e.g., \"StringTrim\"); \"options\" is an array of options passed to the filter; and \"priority\" is the optional key which defines the priority of the filter in the chain. Filters with higher priority are visited first. The default value for the priority is DEFAULT_PRIORITY . Finally, in line 28, we call the filter() method, which walks through the chain and passes the filtered value to each filter in turn.","title":"Organizing Filters in a Chain"},{"location":"filters/#custom-filtering-with-the-callback-filter","text":"Standard filters are designed to be used in frequently appearing situations. For example, you may often need to trim a string or convert it to lowercase. However, sometimes there are cases where you cannot use a standard filter. Here, the @ Callback [Laminas\\Filter\\Callback] filter will be handy. The @ Callback [Laminas\\Filter\\Callback] filter is designed as a wrapper for your custom filtering algorithm. For example, this may be useful when a standard filter is not suitable, and you need to apply your own filtering algorithm to the data. You implement your custom filtering algorithm as a callback function or a callback class method. A callback is a function or a public method of a class which is called by the @ Callback [Laminas\\Filter\\Callback] filter and is passed the value to be filtered and, optionally, user-defined argument(s). The public methods provided by the @ Callback [Laminas\\Filter\\Callback] filter are listed in table 8.17. Method name Description filter($value) Executes a callback function as a filter. setCallback($callback) Sets a new callback for this filter. getCallback() Returns callback set for the filter. setCallbackParams($params) Sets parameters for the callback. getCallbackParams() Gets parameters for the callback. Table 8.17. Public methods of the Callback filter As you can see from the table, the @ Callback [Laminas\\Filter\\Callback] filter provides the setCallback() and setCallbackParams() methods that can be used to set the callback function (or the callback class method) and, optionally, pass it one or several parameters.","title":"Custom Filtering with the Callback Filter"},{"location":"filters/#example","text":"To demonstrate the usage of the @ Callback [Laminas\\Filter\\Callback] filter, let's add the phone number field to our ContactForm form model class and attach a custom filter to it. An international phone number typically looks like \"1 (808) 456-7890\". It consists of the country code followed by the three-digit area code enclosed into braces. The rest of the phone consists of the seven-digit subscriber code divided in two groups separated by a dash. The country code, the area code, and the subscriber code are separated by the space character. We will refer to this phone format as the \"international\" format. The international phone format is required for making telephone calls between different countries (or areas). If the calls are made within the same area, the telephone number may simply look like \"456-7890\" (we just omit the country code and area code). We will refer to this phone format as the \"local\" phone format. To make our filter as generic as possible, we assume that the user is required to enter the phone in international format for some forms and in local format for other forms. Because some site visitors may enter their phone number in a format different from what is required, we want to apply the filter that will \"normalize\" the phone number for us. To do the phone \"normalization\", the filter will: Strip out any non-numeric characters of the input value. Pad the digits to the required length if there are too few digits. Add the braces, the spaces, and the dash (when using the international format); or simply add the dash (when using the local format). Because Laminas does not provide a standard filter for accomplishing such phone filtering operation, we will use the @ Callback [Laminas\\Filter\\Callback] wrapper filter. To do that, we will make the following changes to the code of our ContactForm class: <?php // ... class ContactForm extends Form { // ... protected function addElements() { // ... // Add \"phone\" field $this->add([ 'type' => 'text', 'name' => 'phone', 'attributes' => [ 'id' => 'phone' ], 'options' => [ 'label' => 'Your Phone', ], ]); } private function addInputFilter() { // ... $inputFilter->add([ 'name' => 'phone', 'required' => true, 'filters' => [ [ 'name' => 'Callback', 'options' => [ 'callback' => [$this, 'filterPhone'], 'callbackParams' => [ 'format' => 'intl' ] ] ], ], ]); } // Custom filter for a phone number. public function filterPhone($value, $format) { if(!is_scalar($value)) { // Return non-scalar value unfiltered. return $value; } $value = (string)$value; if(strlen($value)==0) { // Return empty value unfiltered. return $value; } // First, remove any non-digit character. $digits = preg_replace('#[^0-9]#', '', $value); if($format == 'intl') { // Pad with zeros if the number of digits is incorrect. $digits = str_pad($digits, 11, \"0\", STR_PAD_LEFT); // Add the braces, the spaces, and the dash. $phoneNumber = substr($digits, 0, 1) . ' ('. substr($digits, 1, 3) . ') ' . substr($digits, 4, 3) . '-'. substr($digits, 7, 4); } else { // 'local' // Pad with zeros if the number of digits is incorrect. $digits = str_pad($digits, 7, \"0\", STR_PAD_LEFT); // Add the dash. $phoneNumber = substr($digits, 0, 3) . '-'. substr($digits, 3, 4); } return $phoneNumber; } } In lines 11-20 of the code above, we add the \"phone\" field to the ContactForm form model. The field is a usual text input field, and we already had some experience of working with such fields earlier. Then, in lines 26-40, we add a validation rule for the \"phone\" field of our form. Under the \"filters\" key (line 29), we register the @ Callback [Laminas\\Filter\\Callback] filter (here, we use the short alias @ Callback [Laminas\\Filter\\Callback], but you can alternatively use the fully qualified class name Callback::class ). The filter takes two options (line 32): the \"callback\" option and the \"callback_params\" option. The \"callback\" option is an array consisting of two elements, which represent the class and the method to call, respectively. In this example, the callback is the filterPhone() method of the ContactForm class. We pass the \"format\" parameter to the callback method with the help of \"callbackParams\" option (line 34). In lines 44-79, we define the filterPhone() callback method, which takes two arguments: the $value is the phone number to filter, and the $format is the desired phone number format. The $format parameter may either be 'local' (for local format) or 'intl' (for international format). In the filterPhone() callback method, we do the following: First, in line 46, we check if the $value parameter is a scalar and not an array. If the value is not a scalar, we return it without change. In line 53, we check the input value's length. We do nothing if the user entered an empty phone number; we just return it as is. Then, we remove any non-digit characters (line 59). If phone length is too short, we pad it with zeroes. We add the braces, the dash, and the spaces for international phone numbers; or just the dash for local phone numbers. Finally, we return the resulting phone number. To see how this filter works, you can open the \"http://localhost/contactus\" URL in your web browser. If you enter some phone number in an incorrect format, the filter will fix the phone number and transform it to the desired format.","title":"Example"},{"location":"filters/#writing-your-own-filter","text":"An alternative to using the @ Callback [Laminas\\Filter\\Callback] filter is writing your own filter class implementing the @ FilterInterface [Laminas\\Filter\\FilterInterface] interface. Then, this filter may be used in forms of your web application (or, if you wish, outside a form). To demonstrate how to create your own filter, we will write the PhoneFilter class encapsulating the phone filtering algorithm we used with the @ Callback [Laminas\\Filter\\Callback] filter example. As you may remember, the base concrete class for all standard filters is the @ AbstractFilter class. By analogy, we will also derive our custom PhoneFilter filter from that base class. We plan to have the following methods in our PhoneFilter filter class (see table 8.18): Method name Description __construct($options) Constructor - accepts an optional argument $options , which is needed to set filter options at once. setFormat($format) Sets the phone format option. getFormat() Returns the phone format option. filter($value) Runs the phone filter. Table 8.18. Public methods of the PhoneFilter filter To start, create the PhoneFilter.php file in the Filter directory under the module's source directory 3 . Put the following code into that file: <?php namespace Application\\Filter; use Laminas\\Filter\\AbstractFilter; // This filter class is designed for transforming an arbitrary phone number to // the local or the international format. class PhoneFilter extends AbstractFilter { // Phone format constants. const PHONE_FORMAT_LOCAL = 'local'; // Local phone format const PHONE_FORMAT_INTL = 'intl'; // International phone format // Available filter options. protected $options = [ 'format' => self::PHONE_FORMAT_INTL ]; // Constructor. public function __construct($options = null) { // Set filter options (if provided). if(is_array($options)) { if(isset($options['format'])) $this->setFormat($options['format']); } } // Sets phone format. public function setFormat($format) { // Check input argument. if( $format!=self::PHONE_FORMAT_LOCAL && $format!=self::PHONE_FORMAT_INTL ) { throw new \\Exception('Invalid format argument passed.'); } $this->options['format'] = $format; } // Returns phone format. public function getFormat() { return $this->format; } // Filters a phone number. public function filter($value) { if(!is_scalar($value)) { // Return non-scalar value unfiltered. return $value; } $value = (string)$value; if(strlen($value)==0) { // Return empty value unfiltered. return $value; } // First, remove any non-digit character. $digits = preg_replace('#[^0-9]#', '', $value); $format = $this->options['format']; if($format == self::PHONE_FORMAT_INTL) { // Pad with zeros if the number of digits is incorrect. $digits = str_pad($digits, 11, \"0\", STR_PAD_LEFT); // Add the braces, the spaces, and the dash. $phoneNumber = substr($digits, 0, 1) . ' (' . substr($digits, 1, 3) . ') ' . substr($digits, 4, 3) . '-' . substr($digits, 7, 4); } else { // self::PHONE_FORMAT_LOCAL // Pad with zeros if the number of digits is incorrect. $digits = str_pad($digits, 7, \"0\", STR_PAD_LEFT); // Add the dash. $phoneNumber = substr($digits, 0, 3) . '-'. substr($digits, 3, 4); } return $phoneNumber; } } From line 2, you can see that the filter class lives in the Application\\Filter namespace. In line 8, we define the PhoneFilter class. We derive our filter class from the @ AbstractFilter base class to reuse the functionality it provides. Line 4 contains the short alias for the @ AbstractFilter class. In lines 11-12, for convenience, we define the phone format constants ( PHONE_FORMAT_INTL for international format and PHONE_FORMAT_LOCAL for local format). These are the equivalents of the \"intl\" and \"local\" strings, respectively. In lines 15-17, we define the $options private variable, which is an array having the single key named \"format\". This key will contain the phone format option for our filter. In lines 20-28, we have the constructor method, which takes the single argument $options . When constructing the filter manually, you may omit this parameter. However, when the filter is constructed by the factory class, the factory will pass filter options to the filter's constructor through this argument. In lines 31-40 and 43-46, we have the setFormat() and getFormat() methods that allow to set and retrieve the current phone format, respectively. In lines 49-86, we have the filter() method. This method encapsulates the phone number filtering algorithm. It takes the $value parameter, transforms it by taking the selected phone format in account, and returns the formatted phone number.","title":"Writing Your Own Filter"},{"location":"filters/#using-the-phonefilter-class","text":"When the PhoneFilter filter class is ready, you can easily start using it in the feedback form (or in another form) as follows. It is assumed that you call the following code inside of the ContactForm::addInputFilter() method: $inputFilter->add([ 'name' => 'phone', 'required' => true, 'filters' => [ [ 'name' => PhoneFilter::class, 'options' => [ 'format' => PhoneFilter::PHONE_FORMAT_INTL ] ], // ... ], // ... ]); You can see how the PhoneFilter filter works in the Form Demo sample application bundled with this book. Open the \"http://localhost/contactus\" page in your web browser. If you enter some phone number in an incorrect format, the filter will fix the phone number. If you wish, you can use the PhoneFilter outside of forms, as shown in the code example below: <?php use Application\\Filter\\PhoneFilter; // Create PhoneFilter filter. $filter = new PhoneFilter(); // Configure the filter. $filter->setFormat(PhoneFilter::PHONE_FORMAT_INTL); // Filter a string. $filteredValue = $filter->filter('12345678901'); // The expected filter's output is the '1 (234) 567-8901'.","title":"Using the PhoneFilter Class"},{"location":"filters/#summary","text":"Filters are designed to take some input data, process it, and produce some output data. Laminas Framework provides a lot of standard filters that can be used for creating filtering rules of your forms (or, if you wish, to filter an arbitrary data outside of forms). The standard filters can be roughly divided into several groups: filters casting input data to a specified type; filters performing manipulations on a file path; filters performing compression and encryption of input data; filters manipulating string data; and proxy filters wrapping other filters. If a standard filter is not suitable, it is possible to create a custom filter class. In this chapter, we have provided an example of how to write your own PhoneFilter class capable of filtering phone numbers. In this section, we only consider the standard filters belonging to the @ Laminas\\Filter namespace, although there are other filters that can also be considered standard. For example, the @ Laminas\\Filter\\File [Laminas\\Filter] namespace contains several filters applicable to processing file uploads (those filters will be covered in the next chapters). Additionally, the @ Laminas\\I18n component defines several filter classes that are aware of the user's locale. \u21a9 From figure 8.1, you may also notice that there are several more base filters: @ AbstractUnicode filter is the base class for the @ StringToUpper and @ StringToLower filters, because it provides the string conversion functionality common to both of them. And, the @ Decompress filter inherits from the @ Compress filter, because these filters are in fact very similar. By analogy, the @ Decrypt [Laminas\\Filter\\Decrypt] filter inherits from the @ Encrypt [Laminas\\Filter\\Encrypt] filter, because they are the \"mirror reflection\" of each other as well. \u21a9 The PhoneFilter class may be considered as a service model because its goal is to process data, not to store it. By convention, we store all custom filters under the Filter directory. \u21a9","title":"Summary"},{"location":"forms/","text":"Collecting User Input with Forms In this chapter, you will become familiar with using web forms for gathering data entered by website users. In Laminas Framework, functionality for working with forms is mainly spread across four components: the @ Laminas\\Form component, which allows you to build forms and contains the view helpers for rendering form elements; the @ Laminas\\Filter , @ Laminas\\Validator and @ Laminas\\InputFilter components which allow you to filter and validate user input. Component Description @ Laminas\\Form Contains base form model classes. @ Laminas\\Filter Contains various filters classes. @ Laminas\\Validator Implements various validator classes. @ Laminas\\InputFilter Implements a container for filters/validators. @ Laminas\\Mail Contains E-mail sending functionality. Get the Form Demo Sample from GitHub We will demonstrate form usage on the Form Demo sample web application bundled with the book. This sample is a complete web site you can install and see the working forms in action. To download the Form Demo application, visit this page and click the Clone or Download button to download the code as a ZIP archive. When the download is complete, unpack the archive to a directory of your choosing. Then navigate to the formdemo directory which contains the complete source code of the Form Demo web application: /using-laminas-book-samples /formdemo ... To install the example, you can either edit your default virtual host file or create a new one. After editing the file, restart the Apache HTTP Server and open the web site in your web browser. For additional information on Apache virtual hosts, you can refer to Appendix A. Configuring Web Development Environment . About HTML Forms Form functionality provided by Laminas Framework internally uses HTML forms. Because of that, we start with a brief introduction to HTML forms topic. In HTML, forms are enclosed with <form> and </form> tags. A form typically consists of fields: text input fields, check boxes, radio buttons, submit buttons, hidden fields and so on. HTML provides several tags intended for defining form fields: <input> - specifies an input field where the user can enter some data (field appearance and behavior depends on the field type); <textarea> - multi-line text area which can contain an unlimited number of characters; <button> - a clickable button 1 ; <select> - a dropdown list; <option> - used inside the <select> element for defining the available options in a dropdown list. In table 7.1, you can find examples of HTML form field definitions. Figure 7.1 contains corresponding field visualizations (except the \"hidden\" field type, which has no visual representation). Field Definition Text input field <input type=\"text\"> Text area <textarea rows=4></textarea> Password <input type=\"password\"> Button <input type=\"button\" value=\"Apply\"> or <button type=\"button\">Apply</button> Submit button <input type=\"submit\" value=\"Submit\"> Image (graphical submit button) <input type=\"image\" src=\"button.jpg\"> Reset button <input type=\"reset\" value=\"Reset\"> Checkbox <input type=\"checkbox\">Remember me</input> Radio <input type=\"radio\" value=\"Radio\">Allow</input> Select <select><option>Enable</option><option>Disable</option></select> File <input type=\"file\"> Hidden field <input type=\"hidden\"> Table 7.1. Standard HTML form fields HTML5 introduced several new form field types (listed in table 7.2); figure 7.2 contains corresponding field visualizations. HTML5 fields provide more convenient ways for entering the most frequently used data types: numbers, dates, E-mails, URLs, etc. Additionally, on form submit, the web browser validates that the user entered data is in a correct format, and if not the browser will prevent form submission and ask the user to correct the input error. Field Definition Color picker <input type=\"color\"> Date <input type=\"date\"> Date-time (with time zone) <input type=\"datetime\"> Date-time (without time zone) <input type=\"datetime-local\"> E-mail address <input type=\"email\"> Number <input type=\"number\"> Time <input type=\"time\"> Month <input type=\"month\"> Week <input type=\"week\"> URL <input type=\"url\"> Range (slider) <input type=\"range\"> Search field <input type=\"search\" name=\"googlesearch\"> Telephone number <input type=\"tel\"> Table 7.2. HTML5 form fields Fieldsets You can group related form fields with the help of the <fieldset> tag, as shown in the example below. The optional <legend> tag allows you to define the caption for the group. <fieldset> <legend>Choose a payment method:</legend> <input type=\"radio\" name=\"payment\" value=\"paypal\">PayPal</input> <input type=\"radio\" name=\"payment\" value=\"card\">Credit Card</input> </fieldset> The HTML markup presented above will generate the group as in figure 7.3: Example: \"Contact Us\" Form An example of a typical HTML form is presented below: <form name=\"contact-form\" action=\"/contactus\" method=\"post\"> <label for=\"email\">E-mail</label> <input name=\"email\" type=\"text\"> <br> <label for=\"subject\">Subject</label> <input name=\"subject\" type=\"text\"> <br> <label for=\"body\">Message</label> <textarea name=\"body\" class=\"form-control\" rows=\"6\"></textarea> <br> <input name=\"submit\" type=\"submit\" value=\"Submit\"> </form> In the example above, we have the feedback form which allows the user to enter his E-mail address, message subject, and text, and then submit them to the server. The form definition begins with the <form> tag (line 1). The <form> tag contains several important attributes: the name attribute specifies the name of the form (\"contact-form\"). the action attribute defines the URL of the server-side script which is responsible for processing the submitted form (\"/contactus\"). the method attribute defines the method (either GET or POST) to use for delivering form data. In this example, we use the POST method (recommended). In line 3, we define a text input field with the help of the <input> element. The name attribute specifies the name of the field (\"email\"). The type attribute specifies the purpose of the element (the type \"text\" means the input field is intended for entering text). In line 2, we have the <label> element which represents the label for the E-mail text input field (the corresponding input field's name is determined by the for attribute of the <label> element). In lines 5-6, by analogy, we have the \"Subject\" input field and its label. In line 9, we have the text area field which is suited well for entering multi-line text. The height of the text area (6 rows) is defined by the rows attribute. In line 11, we have the submit button (input element with \"submit\" type). The value attribute allows you to set the title text for the button (\"Submit\"). By clicking this button, the user will send the form data to the server. Line break <br> elements are used in lines 4, 7 and 10 to position form controls one below another (otherwise they would be positioned in one line). To see what this form looks like, you can put its HTML markup code in a .html file and open the file in your browser. You will see the form visualization as in figure 7.4. If you enter some data in the feedback form and click the Submit button, the web browser will send an HTTP request to the URL you specified in the action attribute of the form. The HTTP request will contain the data you entered. GET and POST Methods HTML forms support GET and POST methods for submitting the data to server. These methods have important technical differences. When using POST method for submitting the form, the data is sent in HTTP request body. For example, when you press the Submit button on the feedback form, an HTTP request will look like the example below: POST http://localhost/contactus HTTP/1.1 Host: localhost Connection: keep-alive Content-Length: 76 Accept: text/html,application/xhtml+xml,application/xml Origin: null User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) Content-Type: application/x-www-form-urlencoded email=name%40example.com&subject=Example+Subject&body=Hello%21&submit=Submit Above, you can see that the form data is transmitted in request body (line 10). Form fields are concatenated in a single string and then URL-encoded to replace unsafe characters with allowed characters from the ASCII table. In comparison, when you set the GET method for the form, an HTTP request will look like the example below: GET http://localhost/contactus?email=name%40example.com&subject=Example+Subject&body=Hello%21&submit=Submit HTTP/1.1 Host: localhost Connection: keep-alive Accept: text/html,application/xhtml+xml,application/xml User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) Accept-Encoding: gzip,deflate,sdch In the example above, you can see that the form data is concatenated, URL-encoded and sent as part of the HTTP request's URL (line 1), which makes the URL long and harder to read. Since the form data is sent inside the URL, this makes it easily visible to site visitors. In most cases, you will use the POST method for delivering form data in the request body, because the user doesn't need to see the data in the browser's navigation bar (especially when submitting passwords or other sensitive data). W> Please note that submitting form data using the POST method does not protect your W> sensitive data (like passwords, credit card numbers, etc.) from being stolen. To W> protect such data, you'll have to direct your HTTP traffic to an SSL tunnel W> (SSL stands for Secure Sockets Layer). Protected SSL connections are distinguished by W> using the https:// schema in web page URLs. To enable SSL for your Apache HTTP W> server, you will need to obtain an SSL certificate from a trusted provider W> (like VeriSign ) and install it on your server. Styling HTML Forms with Twitter Bootstrap In laminas-based web sites, we use the Twitter Bootstrap CSS Framework that provides default CSS rules for styling forms and form fields. To apply the CSS rules to a form field (like <input> , <textarea> , etc.), you should assign it the .form-control CSS class. Additionally, when using labels together with input fields, put the label-input pairs inside of <div> elements with the .form-group CSS class. For submit buttons, you can use the .btn CSS class plus a theme class like .btn-default , .btn-primary , etc. Below, we provide the modified example of the feedback form which uses the Bootstrap styling: <h1>Contact Us</h1> <p> Please fill out the following form to contact us. We appreciate your feedback. </p> <form name=\"contact-form\" action=\"/contactus\" method=\"post\"> <div class=\"form-group\"> <label for=\"email\">Your E-mail</label> <input name=\"email\" type=\"text\" class=\"form-control\" placeholder=\"name@example.com\"> </div> <div class=\"form-group\"> <label for=\"subject\">Subject</label> <input name=\"subject\" type=\"text\" class=\"form-control\" placeholder=\"Type subject here\"> </div> <div class=\"form-group\"> <label for=\"body\">Message Body</label> <textarea name=\"body\" class=\"form-control\" rows=\"6\" placeholder=\"Type message text here\"></textarea> </div> <input name=\"submit\" type=\"submit\" class=\"btn btn-primary\" value=\"Submit\"> </form> The visualization of the form is presented in figure 7.5. Because Twitter Bootstrap is designed to support mobile phones, tablets, and desktops, it makes the form fields as wide as the size of the screen. This may make your form too wide and hard to understand. To limit form width, you can use the Bootstrap-provided grid, like in the example below: <div class=\"row\"> <div class=\"col-md-6\"> <form> ... </form> </div> </div> In the HTML markup above, we put a form inside of the 6-column-width grid cell, which makes the form half the width of the screen. Installing Laminas form components To use forms in an MVC web application, you need to install at least the laminas/laminas-mvc-form Composer metapackage: php composer.phar require laminas/laminas-mvc-form When you install this metapackage, there will be installed all necessary components implementing forms in Laminas: @ Laminas\\Form , @ Laminas\\InputFilter , @ Laminas\\Filter , @ Laminas\\Validator , and probably others. Retrieving Form Data in a Controller's Action The website user typically works with the form in the following order: First, a controller's action is executed rendering the web page containing the form prompting the site user for input. Once the user fills the form fields, they click the Submit button, and this generates an HTTP request and sends the data to the server. Second, in your controller's action method, you can extract the submitted data from POST (and/or GET) variables, and display the page with the results of the form processing. Typically these two web pages are handled by the same controller action. In the following example, we will show how you can create a controller action for displaying the feedback form and retrieving the data submitted by the user. To start, add the contact-us.phtml view template in the application/index/ directory under the module's view/ directory (see figure 7.6 for example). Put the HTML markup code of the feedback form from the previous section into the view template file. Then, add the contactUsAction() action method to the IndexController class. In the action method, we want to extract raw data from the feedback form submitted by the site user: <?php namespace Application\\Controller; // ... class IndexController extends AbstractActionController { // This action displays the feedback form public function contactUsAction() { // Check if user has submitted the form if($this->getRequest()->isPost()) { // Retrieve form data from POST variables $data = $this->params()->fromPost(); // ... Do something with the data ... var_dump($data); } // Pass form variable to view return new ViewModel([ 'form' => $form ]); } } In the code above, we define the contactUsAction() action method in the IndexController class (line 9). Then, in line 12, we check whether the request is a POST request (checking the starting line of the HTTP request). Typically, the form uses the POST method for submitting the data. For this reason, we can detect if the form is submitted or not by checking the starting line of the HTTP request. In line 15 we retrieve the raw data submitted by the user. We extract all the POST variables with the help of the @ Params controller plugin. The data is returned in the form of an array and saved into the $data variable. Finally, we have to add a literal route to make a short and memorable URL for the Contact Us page. Add the following contactus key to the routing configuration in the module.config.php file: <?php return [ // ... 'router' => [ 'routes' => [ // Add the following routing rule for the \"Contact Us\" page 'contactus' => [ 'type' => Literal::class, 'options' => [ 'route' => '/contactus', 'defaults' => [ 'controller' => Controller\\IndexController::class, 'action' => 'contactUs', ], ], ], ], ], ], // ... ]; Now, if you type the \"http://localhost/contactus\" URL in your web browser's navigation bar, you should see the page as in figure 7.7. Enter an E-mail, subject, and body text and click the Submit button on the form. The data will be sent to the server, and finally extracted in the IndexController::contactUsAction() method. Below, an example of the $data array (produced with the var_dump() PHP function) is shown. As you can see, the array contains a key for each form field, including the \"submit\" field. array (size=4) 'email' => string 'name@example.com' (length=16) 'subject' => string 'Happy New Year!' (length=15) 'body' => string 'Dear Support, I'd like to thank you for the excellent quality of your support service and wish you a Happy New Year!' (length=118) 'submit' => string 'Submit' (length=6) Forms and Model-View-Controller In the previous section, we've considered a very simple form usage case: we prepared the view template with form HTML markup and a controller action responsible for displaying the form and dumping raw user input to the screen. However, using raw user input in real-life applications has a disadvantage in that we do not check user-submitted data for possible errors and/or malicious code. Here we will discuss how to perform such validation. In a laminas-based web site that uses the Model-View-Controller pattern, form functionality is usually separated into form models responsible for field definition, filtering and validation; and form presentation (view) which is typically implemented with the help of special view helpers. The functionality allowing to create form models, add filtering and validation rules and use view helpers, is schematically shown in figure 7.8. As you can see from the figure, the standard HTML forms functionality is used as a base. The MVC approach to working with forms has the following advantages: You are able to reuse your form model in different controller's actions. By using the view helpers, you can (partly) avoid the boring work of preparing HTML markup for rendering the form and its possible validation errors. You are able to create one or several visual representations for the same form model. By encapsulating the form validation logic in a single form model class you have fewer places in your code where you need to check user input, thus you improve your site security. A Typical Form Usage Workflow Generally speaking, you instantiate a form model inside of your controller's action method, then you retrieve the user-submitted data from PHP variables, and pass it to the form model for validation. Form view helpers are used in a view template for generating HTML markup of the form. This typical workflow is illustrated by figure 7.9. Arrows in figure 7.9 denote the direction of the actions: First, inside of the controller's action method, you retrieve the data submitted by the site user from GET, POST (and possibly other) PHP variables. Then you create an instance of the form model and pass it the user-submitted data. The form model's work is to check (validate) the data for correctness, and if something is wrong, produce error message(s) for any invalid form field. Secondly, you pass the form model to the .phtml view template for rendering (with the help of the @ ViewModel [Laminas\\View\\Model\\ViewModel] variable container). The view template then will be able to access the form model and call its methods. And finally, the view template uses the form model and the view helpers provided by Laminas Framework to render the form fields (and to display possible validation error messages produced at the validation stage). As a result, the HTML markup of the form is produced. In the following sections, we will discuss these in more detail. A Form Model A form model is usually a PHP class which creates a number of fields . The base class for all form models is the @ Form [Laminas\\Form\\Form] class defined in the @ Laminas\\Form component. Fields in a form model can optionally be grouped into fieldsets . Moreover, the form model itself can be considered as a fieldset. This fact is reflected in form class inheritance (figure 7.10). As you can see from the figure, the @ Form [Laminas\\Form\\Form] class extends the @ Fieldset class. The @ Fieldset class, in turn, is derived from the @ Element class which represents a single form field and its attributes. This class inheritance may look strange at first sight, but everything becomes logical if you remember that the @ Form [Laminas\\Form\\Form] class inherits methods for adding form fields from the @ Fieldset class, and that it inherits methods for setting form attributes from the @ Element class. Below, we provide a stub model class for the feedback form from our previous examples: <?php namespace Application\\Form; use Laminas\\Form\\Form; // A feedback form model class ContactForm extends Form { // init() method public function init() : void { // Set POST method for this form // The default is alread POST so it is not needed; // but it is here as a reference in case you want to set it to GET $this->setAttribute('method', 'post'); // Create the form fields here ... } } As you can see, form models of the web site's Application module (by convention) belong to Application\\Form namespace (line 2). In line 7, we define the ContactForm form model class which extends the @ Form [Laminas\\Form\\Form] base class. In line 10, we define the constructor method for the class. Because we derive our form model from the base @ Form [Laminas\\Form\\Form] class, we have to call the parent class' constructor to initialize it (line 13). The parent class' constructor accepts an optional argument allowing it to set the form's name ('contact-form'). We can also set form data delivery method (POST) by using the setAttribute() method provided by the base class (line 16). The setAttribute() takes two parameters: the first one is the name of the attribute to set, and the second one is the value of the attribute. Note Setting the \"action\" attribute for the form is optional, because empty form action forces the browser to submit form data to the URL of the current page. This is sufficient in most scenarios, because usually you use the single controller action for both displaying the form and processing its data. Form fields are typically created inside of the form model's init-method. In the next section, we will learn which form fields are available and how to add them to the form model. Form Elements In a form model, an input field is typically paired with the text label ( <label> and <input> tags are used together). Such a pair is also called a form model's element . Analogous to an HTML form field, a form model's element may contain the name and other (optional) attributes (e.g. \"id\", \"class\", etc.) Additionally, you may set options to an element; the options mostly allow you to specify the text and attributes for the element's label. All form model's elements are inherited from the base class @ Element which also belongs to the @ Laminas\\Form component. The Element base class implements the @ ElementInterface interface. The class inheritance diagram is shown in figure 7.11. Concrete form element classes extend the @ Element base class. They are listed in tables 7.3 - 7.7. These classes live in the @ Laminas\\Form\\Element [Laminas\\Form] namespace. Class name Description @ Button Button. @ Checkbox [Laminas\\Form\\Element\\Checkbox] Check box. @ File [Laminas\\Form\\Element\\File] File field. @ Hidden Hidden field. @ Image [Laminas\\Form\\Element\\Image] Image field. @ Password [Laminas\\Form\\Element\\Password] Password field. @ Radio Radio button. @ Select [Laminas\\Form\\Element\\Select] Dropdown list. @ Submit Submit button. @ Text [Laminas\\Form\\Element\\Text] General-purpose text input field. @ Textarea Multi-line text area. Table 7.3. Form elements compatible with HTML 4 Class name Description @ Color Color picker. @ Date [Laminas\\Form\\Element\\Date] Date picker. @ DateTime [Laminas\\Form\\Element\\DateTime] Date & time (with time zone). @ DateTimeLocal Date & time (without time zone). @ Email E-mail field. @ Month Month input field. @ Number [Laminas\\Form\\Element\\Number] A text input field accepting numbers. @ Time [Laminas\\Form\\Element\\Time] Text input field for entering time. @ Url [Laminas\\Form\\Element\\Url] Text input field for entering an URL. @ Week Text input field for entering days of week. @ Range [Laminas\\Form\\Element\\Range] Range field (slider). Table 7.4. Form elements compatible with HTML 5 Class name Description @ MultiCheckbox A group of related check boxes. @ DateTimeSelect [Laminas\\Form\\Element\\DateTimeSelect] Date & time select. @ DateSelect [Laminas\\Form\\Element\\DateSelect] Date select. @ MonthSelect [Laminas\\Form\\Element\\MonthSelect] Month select. Table 7.5. Compound fields Class name Description @ Captcha Human check image. @ Csrf [Laminas\\Form\\Element\\Csrf] Cross-site request forgery prevention. Table 7.6. Security Form Elements Class name Description @ Collection [Laminas\\Form\\Element\\Collection] Element collection. Table 7.7. Other Form Elements In the tables above, you can see that the laminas-provided form elements have direct mapping on HTML4 and HTML5 input fields (discussed in the beginning of this chapter). For your convenience, Laminas also provides several \"compound\" fields. The @ MultiCheckbox field is a field which is composed of a group of typical checkboxes related to each other. The @ DateTimeSelect [Laminas\\Form\\Element\\DateTimeSelect], @ DateSelect [Laminas\\Form\\Element\\DateSelect], and @ MonthSelect [Laminas\\Form\\Element\\MonthSelect] elements are analogous to corresponding HTML5 elements, but simulate them with the usual select fields. These input fields have an advantage in that they are supported by all web browsers, unlike the corresponding HTML5 fields. The visual representation of these elements can be seen in figure 7.12. Additionally, Laminas provides \"security\" form fields @ Captcha [Laminas\\Form\\Element\\Captcha] and @ Csrf [Laminas\\Form\\Element\\Csrf] which can be used on a form for enhancing the security. The @ Captcha [Laminas\\Form\\Element\\Captcha] element is a graphical element (image) that is placed on a form for checking if the site user is a human or a robot. The @ Csrf [Laminas\\Form\\Element\\Csrf] element has no visual representation and is used for prevention of hacker attacks related to cross-site request forgery 2 . There is another special form element called @ Collection . This element is analogous to fieldset, because it allows you to group related form elements. But, it is designed for adding form elements dynamically by binding an array of objects to the form. Adding Elements to a Form Model The methods inherited by the @ Form [Laminas\\Form\\Form] base class from the @ Fieldset class are used to add elements (and fieldsets) to the form model. These methods are summarized in the table 7.8. Method name Description add($elementOrFieldset, $flags) Attaches an element (or fieldset). has($elementOrFieldset) Checks whether certain element is attached. get($elementOrFieldset) Retrieves the given element (or fieldset) by name. getElements() Retrieves all attached elements. getFieldsets() Retrieves all attached fieldsets. count() Return the count of attached elements/fieldsets. remove($elementOrFieldset) Removes the element (or fieldset). Table 7.8. Methods provided by the Fieldset class Particularly, we are interested in the add() method which is used to attach an element to a form. The add() method takes two arguments: the first one (named $elementOrFieldset ) is an element to insert, and the second one (named $flags ) is the optional flags. The $elementOrFieldset parameter may either be an instance of an @ Element -derived class (or the @ Fieldset class), or an array describing the element that should be created. The optional $flags argument is an array which may contain a combination of the following keys: name (allows you to set the element's name) and priority (allows to specify the zero-based index in the list of elements to insert the element to). If the priority flag is not specified, the element will be inserted at the end of the list of the form model's elements. Below, we provide two code examples illustrating the possible ways of adding elements to a form. Method 1: Passing an Instance of an Element The following code fragment creates an instance of the @ Laminas\\Form\\Element\\Text class and adds the element to the form model: <?php namespace Application\\Form; // Define an alias for the class name use Laminas\\Form\\Form; use Laminas\\Form\\Element\\Text; // A feedback form model class ContactForm extends Form { // init() method public function init() : void { // Create the form fields here ... $element = new Text( 'subject', // Name of the element [ // Array of options 'label'=> 'Subject' // Text label ]); $element->setAttribute('id', 'subject'); // Add the \"subject\" field to the form $this->add($element); } } In the code above, we've created an instance of the @ Laminas\\Form\\Element\\Text class (line 15). The class constructor takes two parameters: the element's name (\"subject\") and an array of options (here we specify the text label \"Subject\"). Additionally, you may configure the element using the methods provided by the @ Element base class. For example, in line 20, we set the \"id\" attribute with the setAttribute() method. For your reference, the (most important) methods of the @ Element base class which can be used for configuring a form element are presented in table 7.9. Method name Description setName($name) Sets element's name. getName() Retrieves element's name. setOptions($options) Sets options. getOptions($options) Retrieves options. getOption($option) Retrieves the given option. setAttribute($key, $value) Sets a single element attribute. getAttribute($key) Retrieves a single element attribute. removeAttribute($key) Removes an attribute. hasAttribute($key) Checks whether such an attribute presents. setAttributes($arrayOrTraversable) Sets a group of attributes. getAttributes() Retrieves all attributes at once. clearAttributes() Removes all attributes at once. setValue() Sets the element value. getValue() Retrieves the element value. setLabel() Sets the label used for this element. getLabel() Retrieves the label string used for this element. setLabelAttributes() Sets the attributes to use with the label. getLabelAttributes() Gets the attributes to use with the label. setLabelOptions() Sets label specific options. getLabelOptions() Retrieves label specific options. Table 7.9. Methods provided by the Element class Method 2: Using Array Specification The second example below (equivalent to the first one) shows how to use an array specification to add an element to form. This method is preferable, because it requires less code to write. When using array specification for adding an element to a form, the element will be instantiated and configured automatically. Internally, this is accomplished with the help of the @ Laminas\\Form\\Factory factory class (illustrated by figure 7.13). <?php namespace Application\\Form; // Define an alias for the class name use Laminas\\Form\\Form; // A feedback form model class ContactForm extends Form { // init() method public function init() : void { // Add \"subject\" field $this->add([ 'type' => 'text', // Element type 'name' => 'subject', // Field name 'attributes' => [ // Array of attributes 'id' => 'subject', ], 'options' => [ // Array of options 'label' => 'Subject', // Text label ], ]); } } In line 14 above, we call the form model's add() method to add the element to form. We pass the element specification to the add() method in the form of an array. The array has the following typical keys: the type key (line 15) defines the class name to use for instantiation of the element. Here you can use either the fully qualified class name (e.g. Text::class ) or its short alias 3 (e.g. \"text\"). the name key (line 16) defines the name for the field (\"subject\"). the attributes key (line 17) defines the list of HTML attributes to set (here we set the \"id\" attribute). the options array (line 18) allows you to specify the text label for the element. Example: Creating the Contact Form Model Now that we know how to set the form name, action, and method attributes and how to add fields (elements) to the form, let's create the complete model class for the feedback form that we used in our previous examples. As we know, form model classes for the Application module live inside the Application\\Form namespace. So, we have to create the ContactForm.php file inside of the Form directory under the Application module's source directory (figure 7.14). We will have two methods in our form class: __construct() constructor will define the form name and method (POST), and initialize the form by adding its elements; addElements() private method will contain the actual code for adding form elements and will be called by the constructor. We put the field creation logic into the addElements() private method to better structure the form model's code. The code of the ContactForm class is presented below: <?php namespace Application\\Form; use Laminas\\Form\\Form; /** * This form is used to collect user feedback data like user E-mail, * message subject and text. */ class ContactForm extends Form { // init() method public function init() : void { // Define form name parent::__construct('contact-form'); // Set POST method for this form $this->setAttribute('method', 'post'); // Add form elements $this->addElements(); } // This method adds elements to form (input fields and // submit button). private function addElements() { // Add \"email\" field $this->add([ 'type' => 'text', 'name' => 'email', 'attributes' => [ 'id' => 'email' ], 'options' => [ 'label' => 'Your E-mail', ], ]); // Add \"subject\" field $this->add([ 'type' => 'text', 'name' => 'subject', 'attributes' => [ 'id' => 'subject' ], 'options' => [ 'label' => 'Subject', ], ]); // Add \"body\" field $this->add([ 'type' => 'text', 'name' => 'body', 'attributes' => [ 'id' => 'body' ], 'options' => [ 'label' => 'Message Body', ], ]); // Add the submit button $this->add([ 'type' => 'submit', 'name' => 'submit', 'attributes' => [ 'value' => 'Submit', ], ]); } } In line 10 above, we define the ContactForm class which extends the @ Form [Laminas\\Form\\Form] base class. In lines 13-23, we have the constructor method. It calls the base class' constructor (line 16) and passes the form name as its argument (\"contact-form\"). In line 19, the base class' setAttribute() method is called allowing you to set the method name for the form (we set the POST method). In line 22, the addElements() private method is called, which does the actual work of adding elements to the form. The code of the addElements() is located in lines 27-73. To add elements to the form, we call the add() method provided by the base class. This method accepts the single argument -- an array containing configuration for an element. We add four fields: the email , the subject , the body and the submit field. In figure 7.15, you can see a schematic graphical representation of the form model we have created. Adding Form Filtering and Validation Rules Form validation is the procedure of filtering and checking the data passed to the server during the form submission. For example, for our feedback form, we want to perform the following checks: We want to test that the E-mail address, message subject, and body fields are always present (because these fields are required ). We want to ensure that the user entered a valid E-mail address like name@example.com . Users may add white space characters to the beginning and/or the end of the E-mail address, so we would like to filter such characters out (perform the string trimming operation). It would be useful to check for minimum and maximum allowed length of the message subject and body text. For the message subject, we would like to filter out (strip) the new line characters and HTML tags 4 . We also want to strip HTML tags from the message body. The requirements above are called filtering and validation rules . Those rules can be divided into two categories: filters and validators. The filters transform the user-entered data to fix possible errors or to ensure the data conforms to a certain format. Filters are typically applied first, validators are applied in the last turn. Validators check whether the data is acceptable or not. If all data is correct, the form is considered valid and the data can be safely used by the business logic layer. If a certain field is invalid, a validator raises an error flag. In that case, the form is typically shown to the user again, and the user is asked to correct any input errors and resend the form to server. What happens if I don't add a validation rule for a certain form field? If you do not add a validation rule then the user-submitted field value will not be checked, leaving a hole in your site's security. It is recommended to always add a validation rule per each form field entered by user and add as many checks per each field as needed to keep your form secure. Input Filter In Laminas, you store the filtering and validation rules with the help of the @ InputFilter [Laminas\\InputFilter\\InputFilter] class. The @ InputFilter [Laminas\\InputFilter\\InputFilter] class is defined in the @ Laminas\\InputFilter component. The input filter is a container for so called inputs . Typically, you add an input per each form model's field you have. Note An input may consist of filters and/or validators and some additional information. For example, an input may contain the flag telling if the field is required or if its value may be missing from HTTP request. Analogous to adding a form model's fields, there are two possible ways of adding inputs to the input filter container: either via passing an instance of an input class as the argument of its add() method, or via passing the array specification 5 . In the next section, we will describe the latter method (it is preferable, because it requires less code to write). Adding Inputs to Input Filter To add an input to the input filter, you use its add() method, which takes the single argument - an array specification of the input in the following form: [ 'name' => '<name>', 'type' => '<type>', 'required' => <required>, 'filters' => [ // Add filters configuration here ... ], 'validators' => [ // Add validators configuration here ... ] ] In the above array, we have the following keys: The name key (line 2) defines the name of the input. The name should be the same as the name of the form model's field. If the name of the input doesn't match the name of the corresponding form model's field, the validation rule won't be applied to the field. The type key (line 3) defines the class name of the input. This key is optional. By default (when this key is omitted), the @ Laminas\\InputFilter\\Input class is used. Available input classes are shown in figure 7.16. In figure 7.16, the @ Input [Laminas\\InputFilter\\Input] class is designed to be used with regular scalar values, @ ArrayInput is used for filtering/validating array values, and @ FileInput is used for checking uploaded files. The required key (line 4) tells whether the form field is required or optional. If the field is required, the site user will have to fill it in; otherwise he will receive a validation error. the filters (line 5) and validators (line 8) keys may contain the configuration for zero, one, or several filters and/or validators applied to the form model's field. Filter Configuration A typical filter configuration is presented below: [ 'name' => '<filter_name>', 'priority' => <priority>, 'options' => [ // Filter options go here ... ] ], The name key (line 2) is the name for the filter. This may be either a fully qualified filter class name (e.g. StringTrim::class ) or an alias (e.g. @ StringTrim ). The optional priority key (line 3) defines filter priority in the list of filters. The priority must be an integer number. The filters with the highest priority will be applied first. By default, the FilterChain::DEFAULT_PRIORITY constant (value 1000) is assigned. The options array (line 4) is specific to a certain filter and may contain parameters for configuring the filter. Validator Configuration A typical validator configuration is presented below: [ 'name' => '<validator_name>', 'break_chain_on_failure' => <flag>, 'options' => [ // Validator options go here ... ] ], The name key (line 2) is the name for the validator. This may be either a fully qualified validator class name (e.g. EmailAddress::class ) or an alias (e.g. @ EmailAddress ). The break_chain_on_failure optional key (line 3) defines the behavior in case the validator check fails. If this equals to true , subsequent validators in the list will not be executed; otherwise every validator in the list will be executed without depending on the result of other validators. The options array (line 4) is specific to certain validator class and may contain parameters for configuring the validator. Creating Input Filter for the Contact Form Now that you have a general idea on know how to define the input filter container and populate it with filters and validators for each form field, let's complete our ContactForm form model class. Below, we add the addInputFilter() private method, which defines the filtering/validation rules and stores them in input filter container: <?php // ... use Laminas\\InputFilter\\InputFilter; class ContactForm extends Form { // init() method public function init() : void { // ... call this method to add filtering/validation rules $this->addInputFilter(); } // ... // This method creates input filter (used for form filtering/validation). private function addInputFilter() { // Get the default input filter attached to form model. $inputFilter = $this->getInputFilter(); $inputFilter->add([ 'name' => 'email', 'required' => true, 'filters' => [ ['name' => 'StringTrim'], ], 'validators' => [ [ 'name' => 'EmailAddress', 'options' => [ 'allow' => \\Laminas\\Validator\\Hostname::ALLOW_DNS, 'useMxCheck' => false, ], ], ], ] ); $inputFilter->add([ 'name' => 'subject', 'required' => true, 'filters' => [ ['name' => 'StringTrim'], ['name' => 'StripTags'], ['name' => 'StripNewlines'], ], 'validators' => [ [ 'name' => 'StringLength', 'options' => [ 'min' => 1, 'max' => 128 ], ], ], ] ); $inputFilter->add([ 'name' => 'body', 'required' => true, 'filters' => [ ['name' => 'StripTags'], ], 'validators' => [ [ 'name' => 'StringLength', 'options' => [ 'min' => 1, 'max' => 4096 ], ], ], ] ); } } As you can see from the code above, first we declare the alias for the @ Laminas\\InputFilter\\InputFilter class (line 3). In the form model's constructor (line 10), we call the addInputFilter() method which we define in lines 16-76. The addInputFilter() method's goal is to add filtering/ validation rules to the InputFilter container (lines 21-75). For inserting filtering/validation rules into the input filter container, we use the add() method provided by the InputFilter class, which takes the array specification of an input to create. We add three inputs (per each field of our form model, except its submit button): For the email field, we set the required flag to true to make filling this field mandatory. We use the @ StringTrim filter to remove white spaces from the beginning and the end of the E-mail address; and the @ EmailAddress validator for checking the user-entered E-mail address for correctness. We configure the @ EmailAddress validator to allow domain names as E-mail addresses (the \\Laminas\\Validator\\Hostname::ALLOW_DNS flag) and disable MX record checking (set useMxCheck option to false ). For the subject field, by analogy, we make it required, and use the @ StringTrim filter to remove white spaces from the beginning and the end. Additionally, we use the @ StripNewlines and @ StripTags filters to filter out the new line characters and HTML tags, respectively. We constrain subject string length to be between 1 and 128 characters in length by using the @ StringLength validator. For the body field, we require it to be mandatory, and we use the @ StripTags filter to strip HTML tags from E-mail text. We also use the @ StringLength validator to constrain E-mail text to be between 1 and 4096 characters in length. In figure 7.17, you can find the schematic graphical representation of the input filter we've created. Above, we briefly described how to create an input filter for the form model. For detailed information about the above mentioned (and other) filters and validators and their usage examples, please refer to Transforming Input Data with Filters and Checking Input Data with Validators . Using the Form in a Controller's Action When the form model class is ready, you finally can use the form in a controller's action method. As you might already know, the way the site user works with form is typically an iterative process (schematically illustrated by figure 7.18): First, you display the form and its fields on a web page, prompting user for input. Once the user fills the form fields, he clicks the Submit button and sends the data to server. Next, your controller extracts the submitted data and asks the form model to validate it. If there were input errors, you display the form again, asking the user to correct input errors. If the data is correct, you process the data with your business logic layer and (usually) redirect the user to another web page. The @ Form [Laminas\\Form\\Form] base class provides several methods for accomplishing these (see table 7.11). Method name Description setData($data) Sets form data for validation. getData($flag) Retrieves the validated data. isValid() Validates the form. hasValidated() Check if the form has been validated. getMessages($elementName = null) Returns a list of validation failure messages, if any, for a single element or for all form elements. Table 7.11. Methods provided by the Form base class So, a generic form usage workflow is the following: Check whether the form data has been submitted, and if not, display the form on the web page. If the data has been submitted by site user, the raw data is retrieved from POST (and/or GET ) variables in the form of an array. The data is assigned to the form model's fields using the form's setData() method. The filtering and validation is performed using the form's isValid() method (this results in executing the input filter attached to the form). If a certain field(s) is/are invalid, display the form again and ask the user to correct their input. As soon as the data has been filtered/validated you retrieve the data from the form model using the getData() method and can pass the data to other models or use it any other way. The code example below illustrates how to implement this typical workflow in your controller's action method: <?php namespace Application\\Controller; use Application\\Form\\ContactForm; // ... class IndexController extends AbstractActionController { // This action displays the feedback form public function contactUsAction() { // Create Contact Us form $form = new ContactForm(); // Check if user has submitted the form if($this->getRequest()->isPost()) { // Fill in the form with POST data $data = $this->params()->fromPost(); $form->setData($data); // Validate form if($form->isValid()) { // Get filtered and validated data $data = $form->getData(); // ... Do something with the validated data ... // Redirect to \"Thank You\" page return $this->redirect()->toRoute('application', ['action'=>'thankYou']); } } // Pass form variable to view return new ViewModel([ 'form' => $form ]); } } In the code above, we define the contactUsAction() action method in the IndexController class (line 10). In the action method, we create an instance of the ContactForm class (line 13). Then, in line 16, we check whether the request is a POST request (checking the starting line of HTTP request). In line 19 we retrieve the raw data submitted by the user. We extract all the POST variables with the help of the @ Params controller plugin. The data is returned in the form of an array and saved into the $data variable. The data submitted by the user may contain mistakes and should be filtered and validated before further usage. To do that, in line 20 we set the data to the form model with the setData() method provided by the Form base class. We validate form data with the isValid() method (line 23), which returns true upon successful validation. If the validation succeeds, we retrieve the validated data using the getData() method (line 26) and then can pass the data to our business logic layer. Once we have used the validated data, in line 31, we redirect the web user to the Thank You page. The redirect is performed with the @ Redirect controller plugin. The @ Redirect plugin's toRoute() method takes two parameters: the first parameter is the name of the route (\"application\"), and the second one is the array of parameters to pass to the router. These identify the web page where you redirect the user. We will prepare the controller's action and view template for the Thank You page a little bit later. In line 37, we pass the form model through the $form variable to the view template. The view template will access this variable and will use it for rendering the form (and possible validation errors). Passing Form Data to a Model To give you a real-life example of how you can use the validated data of the feedback form, in this section we will create a simple MailSender model 6 class which can be used for sending an E-mail message to an E-mail address. When the user submits the form, we will validate the form data and pass the validated data to the MailSender model and ask it to send the E-mail message to the recipient. Note Reading this section is optional and intended mostly for beginners. You may skip it and refer directly to the next section Form Presentation . The MailSender model will internally use the @ Laminas\\Mail component. The @ Laminas\\Mail component is a component provided by Laminas Framework and designed to give you the convenient functionality for composing mail messages (the @ Laminas\\Mail\\Message class) and several classes implementing available transports for sending mail (in this example, we will use the @ Laminas\\Mail\\Transport\\Sendmail class which uses the sendmail program for delivering E-mails). Install the @ Laminas\\Mail component with Composer by typing the following command: php composer.phar require laminas/laminas-mail What is sendmail? The sendmail program is a free open-source mail transfer agent for Linux/Unix operating systems. It accepts messages that a PHP script passes to it, deciding based upon the message header which delivery method it should use, and then passes the message through the SMTP protocol to the appropriate mail server (like Google Mail) for delivery to the recipient. Start with creating the MailSender.php file under the Service directory under the module's source directory (see figure 7.19 for example). The following is the code that should be put into the MailSender.php file: <?php namespace Application\\Service; use Laminas\\Mail; use Laminas\\Mail\\Message; use Laminas\\Mail\\Transport\\Sendmail; // This class is used to deliver an E-mail message to recipient. class MailSender { // Sends the mail message. public function sendMail($sender, $recipient, $subject, $text) { $result = false; try { // Create E-mail message $mail = new Message(); $mail->setFrom($sender); $mail->addTo($recipient); $mail->setSubject($subject); $mail->setBody($text); // Send E-mail message $transport = new Sendmail('-f'.$sender); $transport->send($mail); $result = true; } catch(\\Exception $e) { $result = false; } // Return status return $result; } } In the code above, we define the Application\\Service namespace (line 2), because the MailSender class can be related to service models (its goal is to manipulate data, not to store it). In lines 4-6, we declare the aliases for the @ Mail , @ Message [Laminas\\Mail\\Message] and @ Laminas\\Mail\\Transport\\Sendmail classes provided by the @ Laminas\\Mail component. In lines 9-35, we define the MailSender class. The class has the single method sendMail() (line 12), which takes four arguments: sender's E-mail address, recipient's E-mail address, message subject and, finally, message body text. In line 18, we create an instance of the @ Message [Laminas\\Mail\\Message] class. We use the methods provided by this class for composing the message (set its subject, body etc.) in lines 19-22. In line 25, we create an instance of the @ Sendmail class, which uses the sendmail program to pass the message to the appropriate mail server (see lines 25-26). Since the classes provided by the @ Laminas\\Mail component may throw an exception on failure, we enclose the block of code with the try - catch exception handler. The sendMail() method will return true if the E-mail message sent successfully; otherwise it will return false (line 33). Note Configuring mail system for your web server is a rather complex task. It typically requires installing sendmail and configuring the server's MX DNS record to use certain mail server (either local mail server, e.g. Postfix , or remote server, like Google Mail). Because of the complexity of the topic, it is not discussed in this book. You can find additional information on configuring mail for your particular system online. Now, register the MailSender service in your module.config.php file as follows: return [ //... 'service_manager' => [ 'factories' => [ Service\\MailSender::class => InvokableFactory::class, ], ], //... ]; Later, you can instantiate the MailSender model in your IndexController::contactUsAction() method and pass it the validated form data. Because we use the MailSender service in our controller, this service is a dependency for the controller. So, we will need to create a factory for the controller and inject the dependency into controller's constructor. Looks complex at the first sight, but as you improve your skills, you will find this is rather simple and greatly improves the structure of your code. Let's create the factory for the IndexController (put it into the Factory subdirectory under the Controller subdirectory). You can see that the only work of the factory class is creating the controller and passing it the dependency. <?php namespace Application\\Controller\\Factory; use Interop\\Container\\ContainerInterface; use Laminas\\ServiceManager\\Factory\\FactoryInterface; use Application\\Service\\MailSender; use Application\\Controller\\IndexController; class IndexControllerFactory { public function __invoke(ContainerInterface $container, $requestedName, array $options = null) { $mailSender = $container->get(MailSender::class); // Instantiate the controller and inject dependencies return new IndexController($mailSender); } } Modify the module.config.php file to use the custom factory we have just created: return [ //... 'controllers' => [ 'factories' => [ Controller\\IndexController::class => Controller\\Factory\\IndexControllerFactory::class, ], ], //... ]; Next, add the constructor, the contactUsAction() , thankYouAction() and sendErrorAction() methods to the controller. Below, the complete code is presented: <?php // ... use Application\\Service\\MailSender; class IndexController extends AbstractActionController { private $mailSender; public function __construct($mailSender) { $this->mailSender = $mailSender; } public function contactUsAction() { // Create Contact Us form $form = new ContactForm(); // Check if user has submitted the form if($this->getRequest()->isPost()) { // Fill in the form with POST data $data = $this->params()->fromPost(); $form->setData($data); // Validate form if($form->isValid()) { // Get filtered and validated data $data = $form->getData(); $email = $data['email']; $subject = $data['subject']; $body = $data['body']; // Send E-mail if(!$this->mailSender->sendMail('no-reply@example.com', $email, $subject, $body)) { // In case of error, redirect to \"Error Sending Email\" page return $this->redirect()->toRoute('application', ['action'=>'sendError']); } // Redirect to \"Thank You\" page return $this->redirect()->toRoute('application', ['action'=>'thankYou']); } } // Pass form variable to view return new ViewModel([ 'form' => $form ]); } // This action displays the Thank You page. The user is redirected to this // page on successful mail delivery. public function thankYouAction() { return new ViewModel(); } // This action displays the Send Error page. The user is redirected to this // page on mail delivery error. public function sendErrorAction() { return new ViewModel(); } } As you can see from the code above, we do the following: In line 3, we declare an alias for Application\\Service\\MailSender class. This will allow you to refer to the model class by its short name. In lines 32-34, after we've validated the form, we extract the validated field values into the $email , $subject and $body PHP variables. In line 37, we call the sendMail() method of the MailSender service and pass it four parameters: the sender's address (here we use \"no-reply@example.com\", but you can replace this with the address of your sendmail ); the recipient's E-mail address, the E-mail subject and body. If mail has been sent successfully (if the sendMail() method returned true ), we redirect the user to the Thank You page (line 45). On failure (if sendMail() method returned false ), we redirect the user to the Send Error page (line 40). In lines 58-61, we have the thankYouAction() method which displays the Thank You page. This page is shown if the E-mail message is sent successfully. In line 65-68, we have the sendErrorAction() method which shows the Error Sending Email page. This page is shown on E-mail delivery failure. Form Presentation When your controller's action is ready, all you have to do is prepare the .phtml view template file to display your form on a web page. In the view template, you need to define the markup using <form> , <label> , <input> , and possibly other HTML tags. Additionally, you will have to display error messages if the form validation failed. Because this work is rather boring, Laminas Framework provides you with special view helpers intended for rendering the form. Note For simple forms (which do not show error messages), you can use raw HTML tags for rendering the form and ignore laminas-provided form view helpers. But, form view helpers are really unavoidable when rendering complex forms that may display validation errors and/or add fields dynamically. Preparing the Form Model for Rendering Before rendering, it is required that you call the prepare() method on the form model's instance (see table 7.12). If you forget to call this method, there may be undesired effects. Method name Description prepare() Ensures the form state is ready for use. Table 7.12. Methods provided by the Form base class The prepare() method does the following form model preparations: It calls the input filter container attached to the form model, to ensure validation error messages are available; It prepares any elements and/or fieldsets that require preparation 7 . Standard Form View Helpers Standard form view helpers provided by Laminas are shown in tables 7.13 - 7.16 below. These classes live in the @ Laminas\\Form\\View\\Helper [Laminas\\Form] namespace. As you can see from the table, the view helpers can be divided into the following categories: Generic form view helpers. These classes are designed to render the whole form (@ Form [Laminas\\Form\\View\\Helper\\Form] helper) or its single element (@ FormElement helper) and possible validation errors (@ FormElementErrors helper). View helpers for rendering HTML fields of certain types. These allow you to generate HTML markup for concrete form fields (e.g. @ FormButton , @ FormRadio , etc.) and a text label (@ FormLabel ). View helpers for rendering form fields introduced in HTML5. These are analogous to the view helpers from the previous category, but intended for rendering HTML5 fields (e.g. @ FormDate , @ FormUrl , etc.) Other view helpers. In this category, we can put the view helper classes designed for rendering laminas-specific fields, like @ FormMultiCheckbox , @ FormCaptcha , etc. Method name Description Generic helpers @ Form [Laminas\\Form\\View\\Helper\\Form] Renders the entire form and all its elements. @ FormElement Renders a generic form element. @ FormElementErrors Renders validation errors for a form element. @ FormRow Renders the label, the field and validation errors. Table 7.13. View helpers designed for using with forms Method name Description @ FormButton Renders the <button> form field. @ FormCheckbox Renders the <input type=\"checkbox\"> field. @ FormFile Renders the <input type=\"file\"> form field. @ FormHidden Renders the <input type=\"hidden\"> form field. @ FormInput Renders an <input> form field. @ FormImage Renders the <input type=\"image\"> form field. @ FormLabel Renders the <label> tag. @ FormPassword Renders the <input type=\"password\"> form field. @ FormRadio Renders the <input type=\"radio\"> form field. @ FormReset Renders the <input type=\"reset\"> form field. @ FormSelect Renders the <select> dropdown field. @ FormSubmit Renders the <input type=\"submit\"> form field. @ FormText Renders the <input type=\"text\"> form field. @ FormTextarea Renders the <textarea> multi-line text field. Table 7.14. HTML 4 field helpers Method name Description @ FormColor Renders the <input type=\"color\"> HTML5 form field. @ FormDate Renders the <input type=\"date\"> HTML5 form field. @ FormDateTime Renders the <input type=\"date\"> HTML5 form field. @ FormDateTimeLocal Renders the <input type=\"datetime-local\"> HTML5 form field. @ FormEmail Renders the <input type=\"email\"> HTML5 form field. @ FormMonth Renders the <input type=\"month\"> HTML5 form field. @ FormNumber Renders the <input type=\"number\"> HTML5 form field. @ FormRange Renders the <input type=\"range\"> HTML5 form field. @ FormTel Renders the <input type=\"tel\"> HTML5 form field. @ FormTime Renders the <input type=\"time\"> HTML5 form field. @ FormUrl Renders the <input type=\"url\"> HTML5 form field. @ FormWeek Renders the <input type=\"week\"> HTML5 form field. Table 7.15. HTML 5 field helpers Method name Description @ FormCaptcha Renders the CAPTCHA security field. @ FormDateSelect Renders the date select field. @ FormDateTimeSelect Renders the datetime select field. @ FormMonthSelect Renders the month select field. @ FormMultiCheckbox Renders the multi checkbox field. @ FormCollection Renders the collection of elements. Table 7.16. Other helpers In the next sections, we will provide an overview of several frequently used form view helpers and their usage examples. Rendering a Form Element You can render a form field with the @ FormElement view helper. It is designed to be as flexible as possible and recognize as many field types as possible. So, with this view helper you are able to produce HTML markup for text fields, buttons, dropdown lists and so on. The methods provided by this view helper are listed in table 7.17. Method name Description render($element) PHP magic method which renders the given form field. __invoke($element) PHP magic method which renders the given form field (the effect is the same as render() ). Table 7.17. Methods provided by the FormElement view helper As you can see, there are two methods doing the same thing: The render() method produces the HTML markup for the form field. It accepts the single argument -- the instance of the element to render. You can retrieve the form element with the form model's get() method (see example below). The __invoke() method is a convenience wrapper which results in less code to write. <?php // We assume that the form model is stored in $form variable. // Render the E-mail field with the render() method. echo $this->formElement()->render($form->get('email')); ?> // The same, but with __invoke echo $this->formElement($form->get('email')); When executed, the code above will generate the HTML code as follows: <input type=\"text\" name=\"email\" id=\"email\" value=\"\"> Note Typically, there is no need to call view helpers for concrete HTML (or HTML5) fields (e.g. @ FormText , @ FormSubmit , etc.) Instead, you can use the generic @ FormElement view helper which determines the field type automatically and produces the needed HTML code. Rendering an Element's Validation Errors The @ FormElementErrors view helper class allows you to produce HTML markup for field validation errors (if present). If there are no validation errors for certain element, this view helper does not produce any output. An example of using the @ FormElementErrors view helper is presented below: <?php // We assume that the form model is stored in $form variable. // Render validation errors for the E-mail field. echo $this->formElementErrors($form->get('email')); If there were any validation errors, this code will generate the unordered list of errors using the <ul> HTML tag, and the list will contain as many items as there are errors for certain field. An example of such list for the E-mail field of our feedback form is presented below: <ul> <li>&#039;hostname&#039; is not a valid hostname for the email address</li> <li>The input does not match the expected structure for a DNS hostname</li> <li>The input appears to be a local network name but local network names are not allowed</li> </ul> Rendering an Element's Label The @ FormLabel helper allows you to render the text label for an element: <?php // We assume that the form model is stored in $form variable. // Render text label for the E-mail field. echo $this->formLabel($form->get('email')); When executed, the code above will generate the HTML code as follows: <label for=\"email\">Your E-mail</label> Rendering a Form Row The @ FormRow view helper is designed to simplify the rendering of a form field, it's label, and validation errors. With this class, you are able to render these in a single step. This helper is flexibly configurable, so you can apply a different decoration to the form row. The methods of this view helper class are listed in table 7.18. Method name Description render($element) Renders the form row. __invoke($element, $labelPosition, $renderErrors, $partial) Renders the form row (convenience wrapper). setInputErrorClass($inputErrorClass) Sets input error CSS class. setLabelAttributes($labelAttributes) Sets label attributes. setLabelPosition($labelPosition) Sets label position (before or after the field). setRenderErrors($renderErrors) Set if the errors are rendered by this helper. setPartial($partial) Set a partial view script to use for rendering the row. Table 7.18. Methods provided by the FormRow view helper An example of using the @ FormRow view helper is presented below: <?php // We assume that the form model is stored in $form variable. // Render the E-mail field, its label and (possible) validation errors. echo $this->formRow($form->get('email')); When executed, the code above will generate the HTML code as follows: <label for=\"email\">Your E-mail</label> <input type=\"text\" name=\"email\" id=\"email\"> <ul> <li>&#039;hostname&#039; is not a valid hostname for the email address</li> <li>The input does not match the expected structure for a DNS hostname</li> <li>The input appears to be a local network name but local network names are not allowed</li> </ul> Rendering the Entire Form The @ Form [Laminas\\Form\\View\\Helper\\Form] view helper allows you to render the opening <form> tag and its attributes; and the closing </form> tag. But its major purpose is to render the entire form and all of its fields with a single line of code. Public methods of the Form [Laminas\\Form\\View\\Helper\\Form] view helper class are summarized in table 7.19. Method name Description render($form) Renders the entire form and all its elements. __invoke($form) PHP magic method which renders the entire form and all its elements (the effect is the same as render() ). openTag($form) Renders the opening <form> tag. closeTag() Renders the closing </form> tag. Table 7.19. Methods provided by the Form view helper You can render the whole form with the help of the @ Form [Laminas\\Form\\Form]'s render() method as follows: // We assume that the form model is stored in $form variable // Render the whole form echo $this->form()->render($form); The same effect can be achieved with the __invoke magic method (see example below): // The same, but with `__invoke` echo $this->form($form); Example: Creating the View Template for the Contact Form Now we are ready to define the presentation for our feedback form. If you remember, earlier we added the contact-us.phtml view template in application/index/ directory under the module's view/ directory. Replace the code in that file with the following: <?php $form = $this->form; $form->prepare(); ?> <?= $this->form()->openTag($form); ?> <?= $this->formLabel($form->get('email')); ?> <?= $this->formElement($form->get('email')); ?> <?= $this->formElementErrors($form->get('email')); ?> <?= $this->formLabel($form->get('subject')); ?> <?= $this->formElement($form->get('subject')); ?> <?= $this->formElementErrors($form->get('subject')); ?> <?= $this->formLabel($form->get('body')); ?> <?= $this->formElement($form->get('body')); ?> <?= $this->formElementErrors($form->get('body')); ?> <?= $this->formElement($form->get('submit')); ?> <?= $this->form()->closeTag(); ?> As you can see from the code above, we do the following things to render the form: In line 2, we access the $form variable passed from the controller's action. In line 3, we call the @ Form [Laminas\\Form\\Form]'s prepare() method to prepare the form for rendering. Please note that calling this method is very important. If you forget to do that, there may be some undesired rendering problems. In line 6, we call the openTag() method of the @ Form [Laminas\\Form\\View\\Helper\\Form] view helper. Its purpose is to render the opening <form> tag and its attributes. The method takes a single argument -- an instance of the form model. Paired closing </form> tag is rendered in line 22 with the help of the closeTag() method of the @ Form [Laminas\\Form\\View\\Helper\\Form] view helper. In lines 8-10, we render the E-mail field's label, the text field itself and (possible) validation errors with the help of the @ FormLabel , @ FormElement and @ FormElementErrors view helpers. Those helpers take the instance of the form model's element as a single argument. We get an instance of the element with the get() method provided by the @ Form [Laminas\\Form\\Form] base class. In lines 12-14, by analogy, we render the Subject field, its label and validation errors. And in lines 16-18, we render the label, the field and the validation errors for the body text area field. In line 20, we render the Submit button. When the view template renderer evaluates this code, it will produce the HTML output like below: <form action=\"/contact\" method=\"post\" name=\"contact-form\"> <label for=\"email\">Your E-mail</label> <input type=\"text\" name=\"email\" id=\"email\" value=\"\"> <label for=\"subject\">Subject</label> <input name=\"subject\" type=\"text\" id=\"subject\" value=\"\"> <label for=\"body\">Message Body</label> <textarea name=\"body\" id=\"body\"></textarea> <input name=\"submit\" type=\"submit\" value=\"Submit\"> </form> In the code above, we mostly used the @ FormElement , @ FormElementErrors and @ FormLabel view helpers. You may use the generic @ FormRow or @ Form [Laminas\\Form\\View\\Helper\\Form] view helpers if you want to reduce the amount of code to write, but this may result in less control of form decoration. If certain fields have validation errors, those errors will be outputted below the field in the form of the <ul> unordered HTML list. For example, if you enter the \"123@hostname\" into E-mail form field, you would receive the following validation errors: <label for=\"email\">Your E-mail</label> <input type=\"text\" name=\"email\" value=\"123@hostname\"> <ul> <li>&#039;hostname&#039; is not a valid hostname for the email address</li> <li>The input does not match the expected structure for a DNS hostname</li> <li>The input appears to be a local network name but local network names are not allowed</li> </ul> Applying the Bootstrap CSS Styles to Form The HTML markup above is missing CSS styling. What we want to achieve is to use Twitter Bootstrap CSS classes to give the form a nice, professional-looking appearance. To add Bootstrap styling to the form, you have to modify the code in the .phtml file to make it look like below: <?php $form = $this->form; $form->prepare(); $form->get('email')->setAttributes([ 'class'=>'form-control', 'placeholder'=>'name@example.com' ]); $form->get('subject')->setAttributes([ 'class'=>'form-control', 'placeholder'=>'Type subject here' ]); $form->get('body')->setAttributes([ 'class'=>'form-control', 'rows'=>6, 'placeholder'=>'Type message text here' ]); $form->get('submit')->setAttributes(['class'=>'btn btn-primary']); ?> <h1>Contact Us</h1> <p> Please fill out the following form to contact us. We appreciate your feedback. </p> <div class=\"row\"> <div class=\"col-md-6\"> <?= $this->form()->openTag($form); ?> <div class=\"form-group\"> <?= $this->formLabel($form->get('email')); ?> <?= $this->formElement($form->get('email')); ?> <?= $this->formElementErrors($form->get('email')); ?> </div> <div class=\"form-group\"> <?= $this->formLabel($form->get('subject')); ?> <?= $this->formElement($form->get('subject')); ?> <?= $this->formElementErrors($form->get('subject')); ?> </div> <div class=\"form-group\"> <?= $this->formLabel($form->get('body')); ?> <?= $this->formElement($form->get('body')); ?> <?= $this->formElementErrors($form->get('body')); ?> </div> <?= $this->formElement($form->get('submit')); ?> <?= $this->form()->closeTag(); ?> </div> </div> In the code above, we added the .form-control CSS class to every input field in the form. We did that with the setAttribute() method (see lines 5, 10 and 15). With that method, we also added the \"placeholder\" attribute to define the nice-looking placeholder text when a field is empty. For the \"body\" field, we added the \"rows\" attribute defining the height of the field (6 rows). For the form's Submit button, we use the .btn and .btn-primary CSS classes (see line 21). We also put label-input pairs inside of <div> elements with .form-group CSS class (lines 35, 41, 47). We put a form inside of the 6-column-width grid cell, which makes the form half the width of the screen (look at lines 31-32). Note Sometimes it is impossible to use Twitter Bootstrap styling with standard Laminas form view helpers. For example, standard view helpers @ FormCheckbox and @ FormRadio can't be tweaked to support Bootstrap styles. Fortunately, there is a third-party module neilime/twbs-helper-module that you can install with Composer. This module provides convenient view helpers for rendering Laminas forms and applying Bootstrap styling to them. It works transparently, so once you installed the module, standard Laminas form view helpers become replaced with module-provided form view helpers, so you don't need to change your view template code. Styling the Validation Errors List The error messages on your form, by default, look like a typical unordered list ( <ul> ). To give them a nice visual appearance, we add a couple of CSS rules to the style.css file in APP_DIR/public directory: form ul { list-style-type: none; padding: 0px; margin: 0px 5px; } form ul li { color: red; } The CSS rules above will remove bullets from the list and make validation error messages appear in red. Adding the \"Thank You\" & \"Error Sending Email\" Pages The last small thing we will do is preparing the view templates for the \"Thank You\" and \"Error Sending Email\" pages. Add the thank-you.phtml view template in application/index/ directory under the module's view/ directory. Put the following HTML markup into the view template file: <h1>Thank You!</h1> <p> <div class=\"alert alert-success\"> We will respond to the E-mail address you have provided. </div> </p> Next, add the send-error.phtml view template file. The HTML markup for the Error Sending Email page is presented below: <h1>Error Sending Email!</h1> <p> <div class=\"alert alert-warning\"> Sorry, but we had an unexpected problem when trying to deliver your message. Please try again later. </div> </p> Results Congratulations! Now, if you open the \"http://localhost/contactus\" URL in your web browser, you should see a page like that shown in figure 7.20. {width=80%} If you enter some invalid data in the form and click the Submit button, you should see the validation errors (figure 7.21). Entering the correct E-mail, subject and message text and submitting the form results in sending the message and displaying the Thank You page (see figure 7.22). On a sending failure, you will see the Error Sending Email page (see figure 7.23 for example): You can see the Contact Us form in action in the Form Demo sample application bundled with this book. Summary Forms are the way of collecting user-entered data on web pages. A form usually consists of elements (input field + label pairs). Elements can optionally be grouped into fieldsets. In an MVC-based web site, form functionality is separated into form models responsible for element definition and validation, and form presentation implemented with the help of special view helpers. To create a form model, you write a class deriving from the @ Form [Laminas\\Form\\Form] base class. The form model is initialized by adding its elements with the help of the base class-provided methods. To submit form data to the server, the user clicks the Submit button, then the data is sent as part of a HTTP request. Once the user submits the form, you can extract the form data in your controller and ask the form model to validate it. For checking and filtering the user-entered data, filters and validators are utilized. You use the @ InputFilter [Laminas\\InputFilter\\InputFilter] class which is the container for validation rules. If there are input errors, you display the form again, asking the user to correct the input errors. If the data is correct, you process the data with your business logic layer. The <button> field is analogous to <input type=\"button\"> , however it provides additional capabilities, like specifying a graphical icon on the button. \u21a9 Cross-site request forgery (CSRF) is a type of malicious exploit of a website whereby unauthorized commands are transmitted from a user that the website trusts. \u21a9 If you are confused where we take element aliases from, than you should know that they are defined inside of the @ Laminas\\Form\\FormElementManager\\FormElementManagerTrait class. \u21a9 There may be malicious users inserting HTML code in the message. If you open such code in your browser, you may see some undesired content. To avoid this, we need to replace HTML tags in message subject and text. \u21a9 In the latter (array specification) case, the input will be automatically created with the help of the @ Laminas\\InputFilter\\Factory class. \u21a9 In DDD terms, the MailSender can be related to service models, because its goal is to manipulate data, not to store data. \u21a9 Typically, this results in wrapping field names with the form/fieldset name (for example, the \"email\" field's name will become \"contact-form[email]\") which technically results in a more convenient field grouping in a HTTP request body. \u21a9","title":"Collecting User Input with Forms"},{"location":"forms/#collecting-user-input-with-forms","text":"In this chapter, you will become familiar with using web forms for gathering data entered by website users. In Laminas Framework, functionality for working with forms is mainly spread across four components: the @ Laminas\\Form component, which allows you to build forms and contains the view helpers for rendering form elements; the @ Laminas\\Filter , @ Laminas\\Validator and @ Laminas\\InputFilter components which allow you to filter and validate user input. Component Description @ Laminas\\Form Contains base form model classes. @ Laminas\\Filter Contains various filters classes. @ Laminas\\Validator Implements various validator classes. @ Laminas\\InputFilter Implements a container for filters/validators. @ Laminas\\Mail Contains E-mail sending functionality.","title":"Collecting User Input with Forms"},{"location":"forms/#get-the-form-demo-sample-from-github","text":"We will demonstrate form usage on the Form Demo sample web application bundled with the book. This sample is a complete web site you can install and see the working forms in action. To download the Form Demo application, visit this page and click the Clone or Download button to download the code as a ZIP archive. When the download is complete, unpack the archive to a directory of your choosing. Then navigate to the formdemo directory which contains the complete source code of the Form Demo web application: /using-laminas-book-samples /formdemo ... To install the example, you can either edit your default virtual host file or create a new one. After editing the file, restart the Apache HTTP Server and open the web site in your web browser. For additional information on Apache virtual hosts, you can refer to Appendix A. Configuring Web Development Environment .","title":"Get the Form Demo Sample from GitHub"},{"location":"forms/#about-html-forms","text":"Form functionality provided by Laminas Framework internally uses HTML forms. Because of that, we start with a brief introduction to HTML forms topic. In HTML, forms are enclosed with <form> and </form> tags. A form typically consists of fields: text input fields, check boxes, radio buttons, submit buttons, hidden fields and so on. HTML provides several tags intended for defining form fields: <input> - specifies an input field where the user can enter some data (field appearance and behavior depends on the field type); <textarea> - multi-line text area which can contain an unlimited number of characters; <button> - a clickable button 1 ; <select> - a dropdown list; <option> - used inside the <select> element for defining the available options in a dropdown list. In table 7.1, you can find examples of HTML form field definitions. Figure 7.1 contains corresponding field visualizations (except the \"hidden\" field type, which has no visual representation). Field Definition Text input field <input type=\"text\"> Text area <textarea rows=4></textarea> Password <input type=\"password\"> Button <input type=\"button\" value=\"Apply\"> or <button type=\"button\">Apply</button> Submit button <input type=\"submit\" value=\"Submit\"> Image (graphical submit button) <input type=\"image\" src=\"button.jpg\"> Reset button <input type=\"reset\" value=\"Reset\"> Checkbox <input type=\"checkbox\">Remember me</input> Radio <input type=\"radio\" value=\"Radio\">Allow</input> Select <select><option>Enable</option><option>Disable</option></select> File <input type=\"file\"> Hidden field <input type=\"hidden\"> Table 7.1. Standard HTML form fields HTML5 introduced several new form field types (listed in table 7.2); figure 7.2 contains corresponding field visualizations. HTML5 fields provide more convenient ways for entering the most frequently used data types: numbers, dates, E-mails, URLs, etc. Additionally, on form submit, the web browser validates that the user entered data is in a correct format, and if not the browser will prevent form submission and ask the user to correct the input error. Field Definition Color picker <input type=\"color\"> Date <input type=\"date\"> Date-time (with time zone) <input type=\"datetime\"> Date-time (without time zone) <input type=\"datetime-local\"> E-mail address <input type=\"email\"> Number <input type=\"number\"> Time <input type=\"time\"> Month <input type=\"month\"> Week <input type=\"week\"> URL <input type=\"url\"> Range (slider) <input type=\"range\"> Search field <input type=\"search\" name=\"googlesearch\"> Telephone number <input type=\"tel\"> Table 7.2. HTML5 form fields","title":"About HTML Forms"},{"location":"forms/#fieldsets","text":"You can group related form fields with the help of the <fieldset> tag, as shown in the example below. The optional <legend> tag allows you to define the caption for the group. <fieldset> <legend>Choose a payment method:</legend> <input type=\"radio\" name=\"payment\" value=\"paypal\">PayPal</input> <input type=\"radio\" name=\"payment\" value=\"card\">Credit Card</input> </fieldset> The HTML markup presented above will generate the group as in figure 7.3:","title":"Fieldsets"},{"location":"forms/#example-contact-us-form","text":"An example of a typical HTML form is presented below: <form name=\"contact-form\" action=\"/contactus\" method=\"post\"> <label for=\"email\">E-mail</label> <input name=\"email\" type=\"text\"> <br> <label for=\"subject\">Subject</label> <input name=\"subject\" type=\"text\"> <br> <label for=\"body\">Message</label> <textarea name=\"body\" class=\"form-control\" rows=\"6\"></textarea> <br> <input name=\"submit\" type=\"submit\" value=\"Submit\"> </form> In the example above, we have the feedback form which allows the user to enter his E-mail address, message subject, and text, and then submit them to the server. The form definition begins with the <form> tag (line 1). The <form> tag contains several important attributes: the name attribute specifies the name of the form (\"contact-form\"). the action attribute defines the URL of the server-side script which is responsible for processing the submitted form (\"/contactus\"). the method attribute defines the method (either GET or POST) to use for delivering form data. In this example, we use the POST method (recommended). In line 3, we define a text input field with the help of the <input> element. The name attribute specifies the name of the field (\"email\"). The type attribute specifies the purpose of the element (the type \"text\" means the input field is intended for entering text). In line 2, we have the <label> element which represents the label for the E-mail text input field (the corresponding input field's name is determined by the for attribute of the <label> element). In lines 5-6, by analogy, we have the \"Subject\" input field and its label. In line 9, we have the text area field which is suited well for entering multi-line text. The height of the text area (6 rows) is defined by the rows attribute. In line 11, we have the submit button (input element with \"submit\" type). The value attribute allows you to set the title text for the button (\"Submit\"). By clicking this button, the user will send the form data to the server. Line break <br> elements are used in lines 4, 7 and 10 to position form controls one below another (otherwise they would be positioned in one line). To see what this form looks like, you can put its HTML markup code in a .html file and open the file in your browser. You will see the form visualization as in figure 7.4. If you enter some data in the feedback form and click the Submit button, the web browser will send an HTTP request to the URL you specified in the action attribute of the form. The HTTP request will contain the data you entered.","title":"Example: \"Contact Us\" Form"},{"location":"forms/#get-and-post-methods","text":"HTML forms support GET and POST methods for submitting the data to server. These methods have important technical differences. When using POST method for submitting the form, the data is sent in HTTP request body. For example, when you press the Submit button on the feedback form, an HTTP request will look like the example below: POST http://localhost/contactus HTTP/1.1 Host: localhost Connection: keep-alive Content-Length: 76 Accept: text/html,application/xhtml+xml,application/xml Origin: null User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) Content-Type: application/x-www-form-urlencoded email=name%40example.com&subject=Example+Subject&body=Hello%21&submit=Submit Above, you can see that the form data is transmitted in request body (line 10). Form fields are concatenated in a single string and then URL-encoded to replace unsafe characters with allowed characters from the ASCII table. In comparison, when you set the GET method for the form, an HTTP request will look like the example below: GET http://localhost/contactus?email=name%40example.com&subject=Example+Subject&body=Hello%21&submit=Submit HTTP/1.1 Host: localhost Connection: keep-alive Accept: text/html,application/xhtml+xml,application/xml User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) Accept-Encoding: gzip,deflate,sdch In the example above, you can see that the form data is concatenated, URL-encoded and sent as part of the HTTP request's URL (line 1), which makes the URL long and harder to read. Since the form data is sent inside the URL, this makes it easily visible to site visitors. In most cases, you will use the POST method for delivering form data in the request body, because the user doesn't need to see the data in the browser's navigation bar (especially when submitting passwords or other sensitive data). W> Please note that submitting form data using the POST method does not protect your W> sensitive data (like passwords, credit card numbers, etc.) from being stolen. To W> protect such data, you'll have to direct your HTTP traffic to an SSL tunnel W> (SSL stands for Secure Sockets Layer). Protected SSL connections are distinguished by W> using the https:// schema in web page URLs. To enable SSL for your Apache HTTP W> server, you will need to obtain an SSL certificate from a trusted provider W> (like VeriSign ) and install it on your server.","title":"GET and POST Methods"},{"location":"forms/#styling-html-forms-with-twitter-bootstrap","text":"In laminas-based web sites, we use the Twitter Bootstrap CSS Framework that provides default CSS rules for styling forms and form fields. To apply the CSS rules to a form field (like <input> , <textarea> , etc.), you should assign it the .form-control CSS class. Additionally, when using labels together with input fields, put the label-input pairs inside of <div> elements with the .form-group CSS class. For submit buttons, you can use the .btn CSS class plus a theme class like .btn-default , .btn-primary , etc. Below, we provide the modified example of the feedback form which uses the Bootstrap styling: <h1>Contact Us</h1> <p> Please fill out the following form to contact us. We appreciate your feedback. </p> <form name=\"contact-form\" action=\"/contactus\" method=\"post\"> <div class=\"form-group\"> <label for=\"email\">Your E-mail</label> <input name=\"email\" type=\"text\" class=\"form-control\" placeholder=\"name@example.com\"> </div> <div class=\"form-group\"> <label for=\"subject\">Subject</label> <input name=\"subject\" type=\"text\" class=\"form-control\" placeholder=\"Type subject here\"> </div> <div class=\"form-group\"> <label for=\"body\">Message Body</label> <textarea name=\"body\" class=\"form-control\" rows=\"6\" placeholder=\"Type message text here\"></textarea> </div> <input name=\"submit\" type=\"submit\" class=\"btn btn-primary\" value=\"Submit\"> </form> The visualization of the form is presented in figure 7.5. Because Twitter Bootstrap is designed to support mobile phones, tablets, and desktops, it makes the form fields as wide as the size of the screen. This may make your form too wide and hard to understand. To limit form width, you can use the Bootstrap-provided grid, like in the example below: <div class=\"row\"> <div class=\"col-md-6\"> <form> ... </form> </div> </div> In the HTML markup above, we put a form inside of the 6-column-width grid cell, which makes the form half the width of the screen.","title":"Styling HTML Forms with Twitter Bootstrap"},{"location":"forms/#installing-laminas-form-components","text":"To use forms in an MVC web application, you need to install at least the laminas/laminas-mvc-form Composer metapackage: php composer.phar require laminas/laminas-mvc-form When you install this metapackage, there will be installed all necessary components implementing forms in Laminas: @ Laminas\\Form , @ Laminas\\InputFilter , @ Laminas\\Filter , @ Laminas\\Validator , and probably others.","title":"Installing Laminas form components"},{"location":"forms/#retrieving-form-data-in-a-controllers-action","text":"The website user typically works with the form in the following order: First, a controller's action is executed rendering the web page containing the form prompting the site user for input. Once the user fills the form fields, they click the Submit button, and this generates an HTTP request and sends the data to the server. Second, in your controller's action method, you can extract the submitted data from POST (and/or GET) variables, and display the page with the results of the form processing. Typically these two web pages are handled by the same controller action. In the following example, we will show how you can create a controller action for displaying the feedback form and retrieving the data submitted by the user. To start, add the contact-us.phtml view template in the application/index/ directory under the module's view/ directory (see figure 7.6 for example). Put the HTML markup code of the feedback form from the previous section into the view template file. Then, add the contactUsAction() action method to the IndexController class. In the action method, we want to extract raw data from the feedback form submitted by the site user: <?php namespace Application\\Controller; // ... class IndexController extends AbstractActionController { // This action displays the feedback form public function contactUsAction() { // Check if user has submitted the form if($this->getRequest()->isPost()) { // Retrieve form data from POST variables $data = $this->params()->fromPost(); // ... Do something with the data ... var_dump($data); } // Pass form variable to view return new ViewModel([ 'form' => $form ]); } } In the code above, we define the contactUsAction() action method in the IndexController class (line 9). Then, in line 12, we check whether the request is a POST request (checking the starting line of the HTTP request). Typically, the form uses the POST method for submitting the data. For this reason, we can detect if the form is submitted or not by checking the starting line of the HTTP request. In line 15 we retrieve the raw data submitted by the user. We extract all the POST variables with the help of the @ Params controller plugin. The data is returned in the form of an array and saved into the $data variable. Finally, we have to add a literal route to make a short and memorable URL for the Contact Us page. Add the following contactus key to the routing configuration in the module.config.php file: <?php return [ // ... 'router' => [ 'routes' => [ // Add the following routing rule for the \"Contact Us\" page 'contactus' => [ 'type' => Literal::class, 'options' => [ 'route' => '/contactus', 'defaults' => [ 'controller' => Controller\\IndexController::class, 'action' => 'contactUs', ], ], ], ], ], ], // ... ]; Now, if you type the \"http://localhost/contactus\" URL in your web browser's navigation bar, you should see the page as in figure 7.7. Enter an E-mail, subject, and body text and click the Submit button on the form. The data will be sent to the server, and finally extracted in the IndexController::contactUsAction() method. Below, an example of the $data array (produced with the var_dump() PHP function) is shown. As you can see, the array contains a key for each form field, including the \"submit\" field. array (size=4) 'email' => string 'name@example.com' (length=16) 'subject' => string 'Happy New Year!' (length=15) 'body' => string 'Dear Support, I'd like to thank you for the excellent quality of your support service and wish you a Happy New Year!' (length=118) 'submit' => string 'Submit' (length=6)","title":"Retrieving Form Data in a Controller's Action"},{"location":"forms/#forms-and-model-view-controller","text":"In the previous section, we've considered a very simple form usage case: we prepared the view template with form HTML markup and a controller action responsible for displaying the form and dumping raw user input to the screen. However, using raw user input in real-life applications has a disadvantage in that we do not check user-submitted data for possible errors and/or malicious code. Here we will discuss how to perform such validation. In a laminas-based web site that uses the Model-View-Controller pattern, form functionality is usually separated into form models responsible for field definition, filtering and validation; and form presentation (view) which is typically implemented with the help of special view helpers. The functionality allowing to create form models, add filtering and validation rules and use view helpers, is schematically shown in figure 7.8. As you can see from the figure, the standard HTML forms functionality is used as a base. The MVC approach to working with forms has the following advantages: You are able to reuse your form model in different controller's actions. By using the view helpers, you can (partly) avoid the boring work of preparing HTML markup for rendering the form and its possible validation errors. You are able to create one or several visual representations for the same form model. By encapsulating the form validation logic in a single form model class you have fewer places in your code where you need to check user input, thus you improve your site security.","title":"Forms and Model-View-Controller"},{"location":"forms/#a-typical-form-usage-workflow","text":"Generally speaking, you instantiate a form model inside of your controller's action method, then you retrieve the user-submitted data from PHP variables, and pass it to the form model for validation. Form view helpers are used in a view template for generating HTML markup of the form. This typical workflow is illustrated by figure 7.9. Arrows in figure 7.9 denote the direction of the actions: First, inside of the controller's action method, you retrieve the data submitted by the site user from GET, POST (and possibly other) PHP variables. Then you create an instance of the form model and pass it the user-submitted data. The form model's work is to check (validate) the data for correctness, and if something is wrong, produce error message(s) for any invalid form field. Secondly, you pass the form model to the .phtml view template for rendering (with the help of the @ ViewModel [Laminas\\View\\Model\\ViewModel] variable container). The view template then will be able to access the form model and call its methods. And finally, the view template uses the form model and the view helpers provided by Laminas Framework to render the form fields (and to display possible validation error messages produced at the validation stage). As a result, the HTML markup of the form is produced. In the following sections, we will discuss these in more detail.","title":"A Typical Form Usage Workflow"},{"location":"forms/#a-form-model","text":"A form model is usually a PHP class which creates a number of fields . The base class for all form models is the @ Form [Laminas\\Form\\Form] class defined in the @ Laminas\\Form component. Fields in a form model can optionally be grouped into fieldsets . Moreover, the form model itself can be considered as a fieldset. This fact is reflected in form class inheritance (figure 7.10). As you can see from the figure, the @ Form [Laminas\\Form\\Form] class extends the @ Fieldset class. The @ Fieldset class, in turn, is derived from the @ Element class which represents a single form field and its attributes. This class inheritance may look strange at first sight, but everything becomes logical if you remember that the @ Form [Laminas\\Form\\Form] class inherits methods for adding form fields from the @ Fieldset class, and that it inherits methods for setting form attributes from the @ Element class. Below, we provide a stub model class for the feedback form from our previous examples: <?php namespace Application\\Form; use Laminas\\Form\\Form; // A feedback form model class ContactForm extends Form { // init() method public function init() : void { // Set POST method for this form // The default is alread POST so it is not needed; // but it is here as a reference in case you want to set it to GET $this->setAttribute('method', 'post'); // Create the form fields here ... } } As you can see, form models of the web site's Application module (by convention) belong to Application\\Form namespace (line 2). In line 7, we define the ContactForm form model class which extends the @ Form [Laminas\\Form\\Form] base class. In line 10, we define the constructor method for the class. Because we derive our form model from the base @ Form [Laminas\\Form\\Form] class, we have to call the parent class' constructor to initialize it (line 13). The parent class' constructor accepts an optional argument allowing it to set the form's name ('contact-form'). We can also set form data delivery method (POST) by using the setAttribute() method provided by the base class (line 16). The setAttribute() takes two parameters: the first one is the name of the attribute to set, and the second one is the value of the attribute. Note Setting the \"action\" attribute for the form is optional, because empty form action forces the browser to submit form data to the URL of the current page. This is sufficient in most scenarios, because usually you use the single controller action for both displaying the form and processing its data. Form fields are typically created inside of the form model's init-method. In the next section, we will learn which form fields are available and how to add them to the form model.","title":"A Form Model"},{"location":"forms/#form-elements","text":"In a form model, an input field is typically paired with the text label ( <label> and <input> tags are used together). Such a pair is also called a form model's element . Analogous to an HTML form field, a form model's element may contain the name and other (optional) attributes (e.g. \"id\", \"class\", etc.) Additionally, you may set options to an element; the options mostly allow you to specify the text and attributes for the element's label. All form model's elements are inherited from the base class @ Element which also belongs to the @ Laminas\\Form component. The Element base class implements the @ ElementInterface interface. The class inheritance diagram is shown in figure 7.11. Concrete form element classes extend the @ Element base class. They are listed in tables 7.3 - 7.7. These classes live in the @ Laminas\\Form\\Element [Laminas\\Form] namespace. Class name Description @ Button Button. @ Checkbox [Laminas\\Form\\Element\\Checkbox] Check box. @ File [Laminas\\Form\\Element\\File] File field. @ Hidden Hidden field. @ Image [Laminas\\Form\\Element\\Image] Image field. @ Password [Laminas\\Form\\Element\\Password] Password field. @ Radio Radio button. @ Select [Laminas\\Form\\Element\\Select] Dropdown list. @ Submit Submit button. @ Text [Laminas\\Form\\Element\\Text] General-purpose text input field. @ Textarea Multi-line text area. Table 7.3. Form elements compatible with HTML 4 Class name Description @ Color Color picker. @ Date [Laminas\\Form\\Element\\Date] Date picker. @ DateTime [Laminas\\Form\\Element\\DateTime] Date & time (with time zone). @ DateTimeLocal Date & time (without time zone). @ Email E-mail field. @ Month Month input field. @ Number [Laminas\\Form\\Element\\Number] A text input field accepting numbers. @ Time [Laminas\\Form\\Element\\Time] Text input field for entering time. @ Url [Laminas\\Form\\Element\\Url] Text input field for entering an URL. @ Week Text input field for entering days of week. @ Range [Laminas\\Form\\Element\\Range] Range field (slider). Table 7.4. Form elements compatible with HTML 5 Class name Description @ MultiCheckbox A group of related check boxes. @ DateTimeSelect [Laminas\\Form\\Element\\DateTimeSelect] Date & time select. @ DateSelect [Laminas\\Form\\Element\\DateSelect] Date select. @ MonthSelect [Laminas\\Form\\Element\\MonthSelect] Month select. Table 7.5. Compound fields Class name Description @ Captcha Human check image. @ Csrf [Laminas\\Form\\Element\\Csrf] Cross-site request forgery prevention. Table 7.6. Security Form Elements Class name Description @ Collection [Laminas\\Form\\Element\\Collection] Element collection. Table 7.7. Other Form Elements In the tables above, you can see that the laminas-provided form elements have direct mapping on HTML4 and HTML5 input fields (discussed in the beginning of this chapter). For your convenience, Laminas also provides several \"compound\" fields. The @ MultiCheckbox field is a field which is composed of a group of typical checkboxes related to each other. The @ DateTimeSelect [Laminas\\Form\\Element\\DateTimeSelect], @ DateSelect [Laminas\\Form\\Element\\DateSelect], and @ MonthSelect [Laminas\\Form\\Element\\MonthSelect] elements are analogous to corresponding HTML5 elements, but simulate them with the usual select fields. These input fields have an advantage in that they are supported by all web browsers, unlike the corresponding HTML5 fields. The visual representation of these elements can be seen in figure 7.12. Additionally, Laminas provides \"security\" form fields @ Captcha [Laminas\\Form\\Element\\Captcha] and @ Csrf [Laminas\\Form\\Element\\Csrf] which can be used on a form for enhancing the security. The @ Captcha [Laminas\\Form\\Element\\Captcha] element is a graphical element (image) that is placed on a form for checking if the site user is a human or a robot. The @ Csrf [Laminas\\Form\\Element\\Csrf] element has no visual representation and is used for prevention of hacker attacks related to cross-site request forgery 2 . There is another special form element called @ Collection . This element is analogous to fieldset, because it allows you to group related form elements. But, it is designed for adding form elements dynamically by binding an array of objects to the form.","title":"Form Elements"},{"location":"forms/#adding-elements-to-a-form-model","text":"The methods inherited by the @ Form [Laminas\\Form\\Form] base class from the @ Fieldset class are used to add elements (and fieldsets) to the form model. These methods are summarized in the table 7.8. Method name Description add($elementOrFieldset, $flags) Attaches an element (or fieldset). has($elementOrFieldset) Checks whether certain element is attached. get($elementOrFieldset) Retrieves the given element (or fieldset) by name. getElements() Retrieves all attached elements. getFieldsets() Retrieves all attached fieldsets. count() Return the count of attached elements/fieldsets. remove($elementOrFieldset) Removes the element (or fieldset). Table 7.8. Methods provided by the Fieldset class Particularly, we are interested in the add() method which is used to attach an element to a form. The add() method takes two arguments: the first one (named $elementOrFieldset ) is an element to insert, and the second one (named $flags ) is the optional flags. The $elementOrFieldset parameter may either be an instance of an @ Element -derived class (or the @ Fieldset class), or an array describing the element that should be created. The optional $flags argument is an array which may contain a combination of the following keys: name (allows you to set the element's name) and priority (allows to specify the zero-based index in the list of elements to insert the element to). If the priority flag is not specified, the element will be inserted at the end of the list of the form model's elements. Below, we provide two code examples illustrating the possible ways of adding elements to a form.","title":"Adding Elements to a Form Model"},{"location":"forms/#method-1-passing-an-instance-of-an-element","text":"The following code fragment creates an instance of the @ Laminas\\Form\\Element\\Text class and adds the element to the form model: <?php namespace Application\\Form; // Define an alias for the class name use Laminas\\Form\\Form; use Laminas\\Form\\Element\\Text; // A feedback form model class ContactForm extends Form { // init() method public function init() : void { // Create the form fields here ... $element = new Text( 'subject', // Name of the element [ // Array of options 'label'=> 'Subject' // Text label ]); $element->setAttribute('id', 'subject'); // Add the \"subject\" field to the form $this->add($element); } } In the code above, we've created an instance of the @ Laminas\\Form\\Element\\Text class (line 15). The class constructor takes two parameters: the element's name (\"subject\") and an array of options (here we specify the text label \"Subject\"). Additionally, you may configure the element using the methods provided by the @ Element base class. For example, in line 20, we set the \"id\" attribute with the setAttribute() method. For your reference, the (most important) methods of the @ Element base class which can be used for configuring a form element are presented in table 7.9. Method name Description setName($name) Sets element's name. getName() Retrieves element's name. setOptions($options) Sets options. getOptions($options) Retrieves options. getOption($option) Retrieves the given option. setAttribute($key, $value) Sets a single element attribute. getAttribute($key) Retrieves a single element attribute. removeAttribute($key) Removes an attribute. hasAttribute($key) Checks whether such an attribute presents. setAttributes($arrayOrTraversable) Sets a group of attributes. getAttributes() Retrieves all attributes at once. clearAttributes() Removes all attributes at once. setValue() Sets the element value. getValue() Retrieves the element value. setLabel() Sets the label used for this element. getLabel() Retrieves the label string used for this element. setLabelAttributes() Sets the attributes to use with the label. getLabelAttributes() Gets the attributes to use with the label. setLabelOptions() Sets label specific options. getLabelOptions() Retrieves label specific options. Table 7.9. Methods provided by the Element class","title":"Method 1: Passing an Instance of an Element"},{"location":"forms/#method-2-using-array-specification","text":"The second example below (equivalent to the first one) shows how to use an array specification to add an element to form. This method is preferable, because it requires less code to write. When using array specification for adding an element to a form, the element will be instantiated and configured automatically. Internally, this is accomplished with the help of the @ Laminas\\Form\\Factory factory class (illustrated by figure 7.13). <?php namespace Application\\Form; // Define an alias for the class name use Laminas\\Form\\Form; // A feedback form model class ContactForm extends Form { // init() method public function init() : void { // Add \"subject\" field $this->add([ 'type' => 'text', // Element type 'name' => 'subject', // Field name 'attributes' => [ // Array of attributes 'id' => 'subject', ], 'options' => [ // Array of options 'label' => 'Subject', // Text label ], ]); } } In line 14 above, we call the form model's add() method to add the element to form. We pass the element specification to the add() method in the form of an array. The array has the following typical keys: the type key (line 15) defines the class name to use for instantiation of the element. Here you can use either the fully qualified class name (e.g. Text::class ) or its short alias 3 (e.g. \"text\"). the name key (line 16) defines the name for the field (\"subject\"). the attributes key (line 17) defines the list of HTML attributes to set (here we set the \"id\" attribute). the options array (line 18) allows you to specify the text label for the element.","title":"Method 2: Using Array Specification"},{"location":"forms/#example-creating-the-contact-form-model","text":"Now that we know how to set the form name, action, and method attributes and how to add fields (elements) to the form, let's create the complete model class for the feedback form that we used in our previous examples. As we know, form model classes for the Application module live inside the Application\\Form namespace. So, we have to create the ContactForm.php file inside of the Form directory under the Application module's source directory (figure 7.14). We will have two methods in our form class: __construct() constructor will define the form name and method (POST), and initialize the form by adding its elements; addElements() private method will contain the actual code for adding form elements and will be called by the constructor. We put the field creation logic into the addElements() private method to better structure the form model's code. The code of the ContactForm class is presented below: <?php namespace Application\\Form; use Laminas\\Form\\Form; /** * This form is used to collect user feedback data like user E-mail, * message subject and text. */ class ContactForm extends Form { // init() method public function init() : void { // Define form name parent::__construct('contact-form'); // Set POST method for this form $this->setAttribute('method', 'post'); // Add form elements $this->addElements(); } // This method adds elements to form (input fields and // submit button). private function addElements() { // Add \"email\" field $this->add([ 'type' => 'text', 'name' => 'email', 'attributes' => [ 'id' => 'email' ], 'options' => [ 'label' => 'Your E-mail', ], ]); // Add \"subject\" field $this->add([ 'type' => 'text', 'name' => 'subject', 'attributes' => [ 'id' => 'subject' ], 'options' => [ 'label' => 'Subject', ], ]); // Add \"body\" field $this->add([ 'type' => 'text', 'name' => 'body', 'attributes' => [ 'id' => 'body' ], 'options' => [ 'label' => 'Message Body', ], ]); // Add the submit button $this->add([ 'type' => 'submit', 'name' => 'submit', 'attributes' => [ 'value' => 'Submit', ], ]); } } In line 10 above, we define the ContactForm class which extends the @ Form [Laminas\\Form\\Form] base class. In lines 13-23, we have the constructor method. It calls the base class' constructor (line 16) and passes the form name as its argument (\"contact-form\"). In line 19, the base class' setAttribute() method is called allowing you to set the method name for the form (we set the POST method). In line 22, the addElements() private method is called, which does the actual work of adding elements to the form. The code of the addElements() is located in lines 27-73. To add elements to the form, we call the add() method provided by the base class. This method accepts the single argument -- an array containing configuration for an element. We add four fields: the email , the subject , the body and the submit field. In figure 7.15, you can see a schematic graphical representation of the form model we have created.","title":"Example: Creating the Contact Form Model"},{"location":"forms/#adding-form-filtering-and-validation-rules","text":"Form validation is the procedure of filtering and checking the data passed to the server during the form submission. For example, for our feedback form, we want to perform the following checks: We want to test that the E-mail address, message subject, and body fields are always present (because these fields are required ). We want to ensure that the user entered a valid E-mail address like name@example.com . Users may add white space characters to the beginning and/or the end of the E-mail address, so we would like to filter such characters out (perform the string trimming operation). It would be useful to check for minimum and maximum allowed length of the message subject and body text. For the message subject, we would like to filter out (strip) the new line characters and HTML tags 4 . We also want to strip HTML tags from the message body. The requirements above are called filtering and validation rules . Those rules can be divided into two categories: filters and validators. The filters transform the user-entered data to fix possible errors or to ensure the data conforms to a certain format. Filters are typically applied first, validators are applied in the last turn. Validators check whether the data is acceptable or not. If all data is correct, the form is considered valid and the data can be safely used by the business logic layer. If a certain field is invalid, a validator raises an error flag. In that case, the form is typically shown to the user again, and the user is asked to correct any input errors and resend the form to server. What happens if I don't add a validation rule for a certain form field? If you do not add a validation rule then the user-submitted field value will not be checked, leaving a hole in your site's security. It is recommended to always add a validation rule per each form field entered by user and add as many checks per each field as needed to keep your form secure.","title":"Adding Form Filtering and Validation Rules"},{"location":"forms/#input-filter","text":"In Laminas, you store the filtering and validation rules with the help of the @ InputFilter [Laminas\\InputFilter\\InputFilter] class. The @ InputFilter [Laminas\\InputFilter\\InputFilter] class is defined in the @ Laminas\\InputFilter component. The input filter is a container for so called inputs . Typically, you add an input per each form model's field you have. Note An input may consist of filters and/or validators and some additional information. For example, an input may contain the flag telling if the field is required or if its value may be missing from HTTP request. Analogous to adding a form model's fields, there are two possible ways of adding inputs to the input filter container: either via passing an instance of an input class as the argument of its add() method, or via passing the array specification 5 . In the next section, we will describe the latter method (it is preferable, because it requires less code to write).","title":"Input Filter"},{"location":"forms/#adding-inputs-to-input-filter","text":"To add an input to the input filter, you use its add() method, which takes the single argument - an array specification of the input in the following form: [ 'name' => '<name>', 'type' => '<type>', 'required' => <required>, 'filters' => [ // Add filters configuration here ... ], 'validators' => [ // Add validators configuration here ... ] ] In the above array, we have the following keys: The name key (line 2) defines the name of the input. The name should be the same as the name of the form model's field. If the name of the input doesn't match the name of the corresponding form model's field, the validation rule won't be applied to the field. The type key (line 3) defines the class name of the input. This key is optional. By default (when this key is omitted), the @ Laminas\\InputFilter\\Input class is used. Available input classes are shown in figure 7.16. In figure 7.16, the @ Input [Laminas\\InputFilter\\Input] class is designed to be used with regular scalar values, @ ArrayInput is used for filtering/validating array values, and @ FileInput is used for checking uploaded files. The required key (line 4) tells whether the form field is required or optional. If the field is required, the site user will have to fill it in; otherwise he will receive a validation error. the filters (line 5) and validators (line 8) keys may contain the configuration for zero, one, or several filters and/or validators applied to the form model's field.","title":"Adding Inputs to Input Filter"},{"location":"forms/#filter-configuration","text":"A typical filter configuration is presented below: [ 'name' => '<filter_name>', 'priority' => <priority>, 'options' => [ // Filter options go here ... ] ], The name key (line 2) is the name for the filter. This may be either a fully qualified filter class name (e.g. StringTrim::class ) or an alias (e.g. @ StringTrim ). The optional priority key (line 3) defines filter priority in the list of filters. The priority must be an integer number. The filters with the highest priority will be applied first. By default, the FilterChain::DEFAULT_PRIORITY constant (value 1000) is assigned. The options array (line 4) is specific to a certain filter and may contain parameters for configuring the filter.","title":"Filter Configuration"},{"location":"forms/#validator-configuration","text":"A typical validator configuration is presented below: [ 'name' => '<validator_name>', 'break_chain_on_failure' => <flag>, 'options' => [ // Validator options go here ... ] ], The name key (line 2) is the name for the validator. This may be either a fully qualified validator class name (e.g. EmailAddress::class ) or an alias (e.g. @ EmailAddress ). The break_chain_on_failure optional key (line 3) defines the behavior in case the validator check fails. If this equals to true , subsequent validators in the list will not be executed; otherwise every validator in the list will be executed without depending on the result of other validators. The options array (line 4) is specific to certain validator class and may contain parameters for configuring the validator.","title":"Validator Configuration"},{"location":"forms/#creating-input-filter-for-the-contact-form","text":"Now that you have a general idea on know how to define the input filter container and populate it with filters and validators for each form field, let's complete our ContactForm form model class. Below, we add the addInputFilter() private method, which defines the filtering/validation rules and stores them in input filter container: <?php // ... use Laminas\\InputFilter\\InputFilter; class ContactForm extends Form { // init() method public function init() : void { // ... call this method to add filtering/validation rules $this->addInputFilter(); } // ... // This method creates input filter (used for form filtering/validation). private function addInputFilter() { // Get the default input filter attached to form model. $inputFilter = $this->getInputFilter(); $inputFilter->add([ 'name' => 'email', 'required' => true, 'filters' => [ ['name' => 'StringTrim'], ], 'validators' => [ [ 'name' => 'EmailAddress', 'options' => [ 'allow' => \\Laminas\\Validator\\Hostname::ALLOW_DNS, 'useMxCheck' => false, ], ], ], ] ); $inputFilter->add([ 'name' => 'subject', 'required' => true, 'filters' => [ ['name' => 'StringTrim'], ['name' => 'StripTags'], ['name' => 'StripNewlines'], ], 'validators' => [ [ 'name' => 'StringLength', 'options' => [ 'min' => 1, 'max' => 128 ], ], ], ] ); $inputFilter->add([ 'name' => 'body', 'required' => true, 'filters' => [ ['name' => 'StripTags'], ], 'validators' => [ [ 'name' => 'StringLength', 'options' => [ 'min' => 1, 'max' => 4096 ], ], ], ] ); } } As you can see from the code above, first we declare the alias for the @ Laminas\\InputFilter\\InputFilter class (line 3). In the form model's constructor (line 10), we call the addInputFilter() method which we define in lines 16-76. The addInputFilter() method's goal is to add filtering/ validation rules to the InputFilter container (lines 21-75). For inserting filtering/validation rules into the input filter container, we use the add() method provided by the InputFilter class, which takes the array specification of an input to create. We add three inputs (per each field of our form model, except its submit button): For the email field, we set the required flag to true to make filling this field mandatory. We use the @ StringTrim filter to remove white spaces from the beginning and the end of the E-mail address; and the @ EmailAddress validator for checking the user-entered E-mail address for correctness. We configure the @ EmailAddress validator to allow domain names as E-mail addresses (the \\Laminas\\Validator\\Hostname::ALLOW_DNS flag) and disable MX record checking (set useMxCheck option to false ). For the subject field, by analogy, we make it required, and use the @ StringTrim filter to remove white spaces from the beginning and the end. Additionally, we use the @ StripNewlines and @ StripTags filters to filter out the new line characters and HTML tags, respectively. We constrain subject string length to be between 1 and 128 characters in length by using the @ StringLength validator. For the body field, we require it to be mandatory, and we use the @ StripTags filter to strip HTML tags from E-mail text. We also use the @ StringLength validator to constrain E-mail text to be between 1 and 4096 characters in length. In figure 7.17, you can find the schematic graphical representation of the input filter we've created. Above, we briefly described how to create an input filter for the form model. For detailed information about the above mentioned (and other) filters and validators and their usage examples, please refer to Transforming Input Data with Filters and Checking Input Data with Validators .","title":"Creating Input Filter for the Contact Form"},{"location":"forms/#using-the-form-in-a-controllers-action","text":"When the form model class is ready, you finally can use the form in a controller's action method. As you might already know, the way the site user works with form is typically an iterative process (schematically illustrated by figure 7.18): First, you display the form and its fields on a web page, prompting user for input. Once the user fills the form fields, he clicks the Submit button and sends the data to server. Next, your controller extracts the submitted data and asks the form model to validate it. If there were input errors, you display the form again, asking the user to correct input errors. If the data is correct, you process the data with your business logic layer and (usually) redirect the user to another web page. The @ Form [Laminas\\Form\\Form] base class provides several methods for accomplishing these (see table 7.11). Method name Description setData($data) Sets form data for validation. getData($flag) Retrieves the validated data. isValid() Validates the form. hasValidated() Check if the form has been validated. getMessages($elementName = null) Returns a list of validation failure messages, if any, for a single element or for all form elements. Table 7.11. Methods provided by the Form base class So, a generic form usage workflow is the following: Check whether the form data has been submitted, and if not, display the form on the web page. If the data has been submitted by site user, the raw data is retrieved from POST (and/or GET ) variables in the form of an array. The data is assigned to the form model's fields using the form's setData() method. The filtering and validation is performed using the form's isValid() method (this results in executing the input filter attached to the form). If a certain field(s) is/are invalid, display the form again and ask the user to correct their input. As soon as the data has been filtered/validated you retrieve the data from the form model using the getData() method and can pass the data to other models or use it any other way. The code example below illustrates how to implement this typical workflow in your controller's action method: <?php namespace Application\\Controller; use Application\\Form\\ContactForm; // ... class IndexController extends AbstractActionController { // This action displays the feedback form public function contactUsAction() { // Create Contact Us form $form = new ContactForm(); // Check if user has submitted the form if($this->getRequest()->isPost()) { // Fill in the form with POST data $data = $this->params()->fromPost(); $form->setData($data); // Validate form if($form->isValid()) { // Get filtered and validated data $data = $form->getData(); // ... Do something with the validated data ... // Redirect to \"Thank You\" page return $this->redirect()->toRoute('application', ['action'=>'thankYou']); } } // Pass form variable to view return new ViewModel([ 'form' => $form ]); } } In the code above, we define the contactUsAction() action method in the IndexController class (line 10). In the action method, we create an instance of the ContactForm class (line 13). Then, in line 16, we check whether the request is a POST request (checking the starting line of HTTP request). In line 19 we retrieve the raw data submitted by the user. We extract all the POST variables with the help of the @ Params controller plugin. The data is returned in the form of an array and saved into the $data variable. The data submitted by the user may contain mistakes and should be filtered and validated before further usage. To do that, in line 20 we set the data to the form model with the setData() method provided by the Form base class. We validate form data with the isValid() method (line 23), which returns true upon successful validation. If the validation succeeds, we retrieve the validated data using the getData() method (line 26) and then can pass the data to our business logic layer. Once we have used the validated data, in line 31, we redirect the web user to the Thank You page. The redirect is performed with the @ Redirect controller plugin. The @ Redirect plugin's toRoute() method takes two parameters: the first parameter is the name of the route (\"application\"), and the second one is the array of parameters to pass to the router. These identify the web page where you redirect the user. We will prepare the controller's action and view template for the Thank You page a little bit later. In line 37, we pass the form model through the $form variable to the view template. The view template will access this variable and will use it for rendering the form (and possible validation errors).","title":"Using the Form in a Controller's Action"},{"location":"forms/#passing-form-data-to-a-model","text":"To give you a real-life example of how you can use the validated data of the feedback form, in this section we will create a simple MailSender model 6 class which can be used for sending an E-mail message to an E-mail address. When the user submits the form, we will validate the form data and pass the validated data to the MailSender model and ask it to send the E-mail message to the recipient. Note Reading this section is optional and intended mostly for beginners. You may skip it and refer directly to the next section Form Presentation . The MailSender model will internally use the @ Laminas\\Mail component. The @ Laminas\\Mail component is a component provided by Laminas Framework and designed to give you the convenient functionality for composing mail messages (the @ Laminas\\Mail\\Message class) and several classes implementing available transports for sending mail (in this example, we will use the @ Laminas\\Mail\\Transport\\Sendmail class which uses the sendmail program for delivering E-mails). Install the @ Laminas\\Mail component with Composer by typing the following command: php composer.phar require laminas/laminas-mail What is sendmail? The sendmail program is a free open-source mail transfer agent for Linux/Unix operating systems. It accepts messages that a PHP script passes to it, deciding based upon the message header which delivery method it should use, and then passes the message through the SMTP protocol to the appropriate mail server (like Google Mail) for delivery to the recipient. Start with creating the MailSender.php file under the Service directory under the module's source directory (see figure 7.19 for example). The following is the code that should be put into the MailSender.php file: <?php namespace Application\\Service; use Laminas\\Mail; use Laminas\\Mail\\Message; use Laminas\\Mail\\Transport\\Sendmail; // This class is used to deliver an E-mail message to recipient. class MailSender { // Sends the mail message. public function sendMail($sender, $recipient, $subject, $text) { $result = false; try { // Create E-mail message $mail = new Message(); $mail->setFrom($sender); $mail->addTo($recipient); $mail->setSubject($subject); $mail->setBody($text); // Send E-mail message $transport = new Sendmail('-f'.$sender); $transport->send($mail); $result = true; } catch(\\Exception $e) { $result = false; } // Return status return $result; } } In the code above, we define the Application\\Service namespace (line 2), because the MailSender class can be related to service models (its goal is to manipulate data, not to store it). In lines 4-6, we declare the aliases for the @ Mail , @ Message [Laminas\\Mail\\Message] and @ Laminas\\Mail\\Transport\\Sendmail classes provided by the @ Laminas\\Mail component. In lines 9-35, we define the MailSender class. The class has the single method sendMail() (line 12), which takes four arguments: sender's E-mail address, recipient's E-mail address, message subject and, finally, message body text. In line 18, we create an instance of the @ Message [Laminas\\Mail\\Message] class. We use the methods provided by this class for composing the message (set its subject, body etc.) in lines 19-22. In line 25, we create an instance of the @ Sendmail class, which uses the sendmail program to pass the message to the appropriate mail server (see lines 25-26). Since the classes provided by the @ Laminas\\Mail component may throw an exception on failure, we enclose the block of code with the try - catch exception handler. The sendMail() method will return true if the E-mail message sent successfully; otherwise it will return false (line 33). Note Configuring mail system for your web server is a rather complex task. It typically requires installing sendmail and configuring the server's MX DNS record to use certain mail server (either local mail server, e.g. Postfix , or remote server, like Google Mail). Because of the complexity of the topic, it is not discussed in this book. You can find additional information on configuring mail for your particular system online. Now, register the MailSender service in your module.config.php file as follows: return [ //... 'service_manager' => [ 'factories' => [ Service\\MailSender::class => InvokableFactory::class, ], ], //... ]; Later, you can instantiate the MailSender model in your IndexController::contactUsAction() method and pass it the validated form data. Because we use the MailSender service in our controller, this service is a dependency for the controller. So, we will need to create a factory for the controller and inject the dependency into controller's constructor. Looks complex at the first sight, but as you improve your skills, you will find this is rather simple and greatly improves the structure of your code. Let's create the factory for the IndexController (put it into the Factory subdirectory under the Controller subdirectory). You can see that the only work of the factory class is creating the controller and passing it the dependency. <?php namespace Application\\Controller\\Factory; use Interop\\Container\\ContainerInterface; use Laminas\\ServiceManager\\Factory\\FactoryInterface; use Application\\Service\\MailSender; use Application\\Controller\\IndexController; class IndexControllerFactory { public function __invoke(ContainerInterface $container, $requestedName, array $options = null) { $mailSender = $container->get(MailSender::class); // Instantiate the controller and inject dependencies return new IndexController($mailSender); } } Modify the module.config.php file to use the custom factory we have just created: return [ //... 'controllers' => [ 'factories' => [ Controller\\IndexController::class => Controller\\Factory\\IndexControllerFactory::class, ], ], //... ]; Next, add the constructor, the contactUsAction() , thankYouAction() and sendErrorAction() methods to the controller. Below, the complete code is presented: <?php // ... use Application\\Service\\MailSender; class IndexController extends AbstractActionController { private $mailSender; public function __construct($mailSender) { $this->mailSender = $mailSender; } public function contactUsAction() { // Create Contact Us form $form = new ContactForm(); // Check if user has submitted the form if($this->getRequest()->isPost()) { // Fill in the form with POST data $data = $this->params()->fromPost(); $form->setData($data); // Validate form if($form->isValid()) { // Get filtered and validated data $data = $form->getData(); $email = $data['email']; $subject = $data['subject']; $body = $data['body']; // Send E-mail if(!$this->mailSender->sendMail('no-reply@example.com', $email, $subject, $body)) { // In case of error, redirect to \"Error Sending Email\" page return $this->redirect()->toRoute('application', ['action'=>'sendError']); } // Redirect to \"Thank You\" page return $this->redirect()->toRoute('application', ['action'=>'thankYou']); } } // Pass form variable to view return new ViewModel([ 'form' => $form ]); } // This action displays the Thank You page. The user is redirected to this // page on successful mail delivery. public function thankYouAction() { return new ViewModel(); } // This action displays the Send Error page. The user is redirected to this // page on mail delivery error. public function sendErrorAction() { return new ViewModel(); } } As you can see from the code above, we do the following: In line 3, we declare an alias for Application\\Service\\MailSender class. This will allow you to refer to the model class by its short name. In lines 32-34, after we've validated the form, we extract the validated field values into the $email , $subject and $body PHP variables. In line 37, we call the sendMail() method of the MailSender service and pass it four parameters: the sender's address (here we use \"no-reply@example.com\", but you can replace this with the address of your sendmail ); the recipient's E-mail address, the E-mail subject and body. If mail has been sent successfully (if the sendMail() method returned true ), we redirect the user to the Thank You page (line 45). On failure (if sendMail() method returned false ), we redirect the user to the Send Error page (line 40). In lines 58-61, we have the thankYouAction() method which displays the Thank You page. This page is shown if the E-mail message is sent successfully. In line 65-68, we have the sendErrorAction() method which shows the Error Sending Email page. This page is shown on E-mail delivery failure.","title":"Passing Form Data to a Model"},{"location":"forms/#form-presentation","text":"When your controller's action is ready, all you have to do is prepare the .phtml view template file to display your form on a web page. In the view template, you need to define the markup using <form> , <label> , <input> , and possibly other HTML tags. Additionally, you will have to display error messages if the form validation failed. Because this work is rather boring, Laminas Framework provides you with special view helpers intended for rendering the form. Note For simple forms (which do not show error messages), you can use raw HTML tags for rendering the form and ignore laminas-provided form view helpers. But, form view helpers are really unavoidable when rendering complex forms that may display validation errors and/or add fields dynamically.","title":"Form Presentation"},{"location":"forms/#preparing-the-form-model-for-rendering","text":"Before rendering, it is required that you call the prepare() method on the form model's instance (see table 7.12). If you forget to call this method, there may be undesired effects. Method name Description prepare() Ensures the form state is ready for use. Table 7.12. Methods provided by the Form base class The prepare() method does the following form model preparations: It calls the input filter container attached to the form model, to ensure validation error messages are available; It prepares any elements and/or fieldsets that require preparation 7 .","title":"Preparing the Form Model for Rendering"},{"location":"forms/#standard-form-view-helpers","text":"Standard form view helpers provided by Laminas are shown in tables 7.13 - 7.16 below. These classes live in the @ Laminas\\Form\\View\\Helper [Laminas\\Form] namespace. As you can see from the table, the view helpers can be divided into the following categories: Generic form view helpers. These classes are designed to render the whole form (@ Form [Laminas\\Form\\View\\Helper\\Form] helper) or its single element (@ FormElement helper) and possible validation errors (@ FormElementErrors helper). View helpers for rendering HTML fields of certain types. These allow you to generate HTML markup for concrete form fields (e.g. @ FormButton , @ FormRadio , etc.) and a text label (@ FormLabel ). View helpers for rendering form fields introduced in HTML5. These are analogous to the view helpers from the previous category, but intended for rendering HTML5 fields (e.g. @ FormDate , @ FormUrl , etc.) Other view helpers. In this category, we can put the view helper classes designed for rendering laminas-specific fields, like @ FormMultiCheckbox , @ FormCaptcha , etc. Method name Description Generic helpers @ Form [Laminas\\Form\\View\\Helper\\Form] Renders the entire form and all its elements. @ FormElement Renders a generic form element. @ FormElementErrors Renders validation errors for a form element. @ FormRow Renders the label, the field and validation errors. Table 7.13. View helpers designed for using with forms Method name Description @ FormButton Renders the <button> form field. @ FormCheckbox Renders the <input type=\"checkbox\"> field. @ FormFile Renders the <input type=\"file\"> form field. @ FormHidden Renders the <input type=\"hidden\"> form field. @ FormInput Renders an <input> form field. @ FormImage Renders the <input type=\"image\"> form field. @ FormLabel Renders the <label> tag. @ FormPassword Renders the <input type=\"password\"> form field. @ FormRadio Renders the <input type=\"radio\"> form field. @ FormReset Renders the <input type=\"reset\"> form field. @ FormSelect Renders the <select> dropdown field. @ FormSubmit Renders the <input type=\"submit\"> form field. @ FormText Renders the <input type=\"text\"> form field. @ FormTextarea Renders the <textarea> multi-line text field. Table 7.14. HTML 4 field helpers Method name Description @ FormColor Renders the <input type=\"color\"> HTML5 form field. @ FormDate Renders the <input type=\"date\"> HTML5 form field. @ FormDateTime Renders the <input type=\"date\"> HTML5 form field. @ FormDateTimeLocal Renders the <input type=\"datetime-local\"> HTML5 form field. @ FormEmail Renders the <input type=\"email\"> HTML5 form field. @ FormMonth Renders the <input type=\"month\"> HTML5 form field. @ FormNumber Renders the <input type=\"number\"> HTML5 form field. @ FormRange Renders the <input type=\"range\"> HTML5 form field. @ FormTel Renders the <input type=\"tel\"> HTML5 form field. @ FormTime Renders the <input type=\"time\"> HTML5 form field. @ FormUrl Renders the <input type=\"url\"> HTML5 form field. @ FormWeek Renders the <input type=\"week\"> HTML5 form field. Table 7.15. HTML 5 field helpers Method name Description @ FormCaptcha Renders the CAPTCHA security field. @ FormDateSelect Renders the date select field. @ FormDateTimeSelect Renders the datetime select field. @ FormMonthSelect Renders the month select field. @ FormMultiCheckbox Renders the multi checkbox field. @ FormCollection Renders the collection of elements. Table 7.16. Other helpers In the next sections, we will provide an overview of several frequently used form view helpers and their usage examples.","title":"Standard Form View Helpers"},{"location":"forms/#rendering-a-form-element","text":"You can render a form field with the @ FormElement view helper. It is designed to be as flexible as possible and recognize as many field types as possible. So, with this view helper you are able to produce HTML markup for text fields, buttons, dropdown lists and so on. The methods provided by this view helper are listed in table 7.17. Method name Description render($element) PHP magic method which renders the given form field. __invoke($element) PHP magic method which renders the given form field (the effect is the same as render() ). Table 7.17. Methods provided by the FormElement view helper As you can see, there are two methods doing the same thing: The render() method produces the HTML markup for the form field. It accepts the single argument -- the instance of the element to render. You can retrieve the form element with the form model's get() method (see example below). The __invoke() method is a convenience wrapper which results in less code to write. <?php // We assume that the form model is stored in $form variable. // Render the E-mail field with the render() method. echo $this->formElement()->render($form->get('email')); ?> // The same, but with __invoke echo $this->formElement($form->get('email')); When executed, the code above will generate the HTML code as follows: <input type=\"text\" name=\"email\" id=\"email\" value=\"\"> Note Typically, there is no need to call view helpers for concrete HTML (or HTML5) fields (e.g. @ FormText , @ FormSubmit , etc.) Instead, you can use the generic @ FormElement view helper which determines the field type automatically and produces the needed HTML code.","title":"Rendering a Form Element"},{"location":"forms/#rendering-an-elements-validation-errors","text":"The @ FormElementErrors view helper class allows you to produce HTML markup for field validation errors (if present). If there are no validation errors for certain element, this view helper does not produce any output. An example of using the @ FormElementErrors view helper is presented below: <?php // We assume that the form model is stored in $form variable. // Render validation errors for the E-mail field. echo $this->formElementErrors($form->get('email')); If there were any validation errors, this code will generate the unordered list of errors using the <ul> HTML tag, and the list will contain as many items as there are errors for certain field. An example of such list for the E-mail field of our feedback form is presented below: <ul> <li>&#039;hostname&#039; is not a valid hostname for the email address</li> <li>The input does not match the expected structure for a DNS hostname</li> <li>The input appears to be a local network name but local network names are not allowed</li> </ul>","title":"Rendering an Element's Validation Errors"},{"location":"forms/#rendering-an-elements-label","text":"The @ FormLabel helper allows you to render the text label for an element: <?php // We assume that the form model is stored in $form variable. // Render text label for the E-mail field. echo $this->formLabel($form->get('email')); When executed, the code above will generate the HTML code as follows: <label for=\"email\">Your E-mail</label>","title":"Rendering an Element's Label"},{"location":"forms/#rendering-a-form-row","text":"The @ FormRow view helper is designed to simplify the rendering of a form field, it's label, and validation errors. With this class, you are able to render these in a single step. This helper is flexibly configurable, so you can apply a different decoration to the form row. The methods of this view helper class are listed in table 7.18. Method name Description render($element) Renders the form row. __invoke($element, $labelPosition, $renderErrors, $partial) Renders the form row (convenience wrapper). setInputErrorClass($inputErrorClass) Sets input error CSS class. setLabelAttributes($labelAttributes) Sets label attributes. setLabelPosition($labelPosition) Sets label position (before or after the field). setRenderErrors($renderErrors) Set if the errors are rendered by this helper. setPartial($partial) Set a partial view script to use for rendering the row. Table 7.18. Methods provided by the FormRow view helper An example of using the @ FormRow view helper is presented below: <?php // We assume that the form model is stored in $form variable. // Render the E-mail field, its label and (possible) validation errors. echo $this->formRow($form->get('email')); When executed, the code above will generate the HTML code as follows: <label for=\"email\">Your E-mail</label> <input type=\"text\" name=\"email\" id=\"email\"> <ul> <li>&#039;hostname&#039; is not a valid hostname for the email address</li> <li>The input does not match the expected structure for a DNS hostname</li> <li>The input appears to be a local network name but local network names are not allowed</li> </ul>","title":"Rendering a Form Row"},{"location":"forms/#rendering-the-entire-form","text":"The @ Form [Laminas\\Form\\View\\Helper\\Form] view helper allows you to render the opening <form> tag and its attributes; and the closing </form> tag. But its major purpose is to render the entire form and all of its fields with a single line of code. Public methods of the Form [Laminas\\Form\\View\\Helper\\Form] view helper class are summarized in table 7.19. Method name Description render($form) Renders the entire form and all its elements. __invoke($form) PHP magic method which renders the entire form and all its elements (the effect is the same as render() ). openTag($form) Renders the opening <form> tag. closeTag() Renders the closing </form> tag. Table 7.19. Methods provided by the Form view helper You can render the whole form with the help of the @ Form [Laminas\\Form\\Form]'s render() method as follows: // We assume that the form model is stored in $form variable // Render the whole form echo $this->form()->render($form); The same effect can be achieved with the __invoke magic method (see example below): // The same, but with `__invoke` echo $this->form($form);","title":"Rendering the Entire Form"},{"location":"forms/#example-creating-the-view-template-for-the-contact-form","text":"Now we are ready to define the presentation for our feedback form. If you remember, earlier we added the contact-us.phtml view template in application/index/ directory under the module's view/ directory. Replace the code in that file with the following: <?php $form = $this->form; $form->prepare(); ?> <?= $this->form()->openTag($form); ?> <?= $this->formLabel($form->get('email')); ?> <?= $this->formElement($form->get('email')); ?> <?= $this->formElementErrors($form->get('email')); ?> <?= $this->formLabel($form->get('subject')); ?> <?= $this->formElement($form->get('subject')); ?> <?= $this->formElementErrors($form->get('subject')); ?> <?= $this->formLabel($form->get('body')); ?> <?= $this->formElement($form->get('body')); ?> <?= $this->formElementErrors($form->get('body')); ?> <?= $this->formElement($form->get('submit')); ?> <?= $this->form()->closeTag(); ?> As you can see from the code above, we do the following things to render the form: In line 2, we access the $form variable passed from the controller's action. In line 3, we call the @ Form [Laminas\\Form\\Form]'s prepare() method to prepare the form for rendering. Please note that calling this method is very important. If you forget to do that, there may be some undesired rendering problems. In line 6, we call the openTag() method of the @ Form [Laminas\\Form\\View\\Helper\\Form] view helper. Its purpose is to render the opening <form> tag and its attributes. The method takes a single argument -- an instance of the form model. Paired closing </form> tag is rendered in line 22 with the help of the closeTag() method of the @ Form [Laminas\\Form\\View\\Helper\\Form] view helper. In lines 8-10, we render the E-mail field's label, the text field itself and (possible) validation errors with the help of the @ FormLabel , @ FormElement and @ FormElementErrors view helpers. Those helpers take the instance of the form model's element as a single argument. We get an instance of the element with the get() method provided by the @ Form [Laminas\\Form\\Form] base class. In lines 12-14, by analogy, we render the Subject field, its label and validation errors. And in lines 16-18, we render the label, the field and the validation errors for the body text area field. In line 20, we render the Submit button. When the view template renderer evaluates this code, it will produce the HTML output like below: <form action=\"/contact\" method=\"post\" name=\"contact-form\"> <label for=\"email\">Your E-mail</label> <input type=\"text\" name=\"email\" id=\"email\" value=\"\"> <label for=\"subject\">Subject</label> <input name=\"subject\" type=\"text\" id=\"subject\" value=\"\"> <label for=\"body\">Message Body</label> <textarea name=\"body\" id=\"body\"></textarea> <input name=\"submit\" type=\"submit\" value=\"Submit\"> </form> In the code above, we mostly used the @ FormElement , @ FormElementErrors and @ FormLabel view helpers. You may use the generic @ FormRow or @ Form [Laminas\\Form\\View\\Helper\\Form] view helpers if you want to reduce the amount of code to write, but this may result in less control of form decoration. If certain fields have validation errors, those errors will be outputted below the field in the form of the <ul> unordered HTML list. For example, if you enter the \"123@hostname\" into E-mail form field, you would receive the following validation errors: <label for=\"email\">Your E-mail</label> <input type=\"text\" name=\"email\" value=\"123@hostname\"> <ul> <li>&#039;hostname&#039; is not a valid hostname for the email address</li> <li>The input does not match the expected structure for a DNS hostname</li> <li>The input appears to be a local network name but local network names are not allowed</li> </ul>","title":"Example: Creating the View Template for the Contact Form"},{"location":"forms/#applying-the-bootstrap-css-styles-to-form","text":"The HTML markup above is missing CSS styling. What we want to achieve is to use Twitter Bootstrap CSS classes to give the form a nice, professional-looking appearance. To add Bootstrap styling to the form, you have to modify the code in the .phtml file to make it look like below: <?php $form = $this->form; $form->prepare(); $form->get('email')->setAttributes([ 'class'=>'form-control', 'placeholder'=>'name@example.com' ]); $form->get('subject')->setAttributes([ 'class'=>'form-control', 'placeholder'=>'Type subject here' ]); $form->get('body')->setAttributes([ 'class'=>'form-control', 'rows'=>6, 'placeholder'=>'Type message text here' ]); $form->get('submit')->setAttributes(['class'=>'btn btn-primary']); ?> <h1>Contact Us</h1> <p> Please fill out the following form to contact us. We appreciate your feedback. </p> <div class=\"row\"> <div class=\"col-md-6\"> <?= $this->form()->openTag($form); ?> <div class=\"form-group\"> <?= $this->formLabel($form->get('email')); ?> <?= $this->formElement($form->get('email')); ?> <?= $this->formElementErrors($form->get('email')); ?> </div> <div class=\"form-group\"> <?= $this->formLabel($form->get('subject')); ?> <?= $this->formElement($form->get('subject')); ?> <?= $this->formElementErrors($form->get('subject')); ?> </div> <div class=\"form-group\"> <?= $this->formLabel($form->get('body')); ?> <?= $this->formElement($form->get('body')); ?> <?= $this->formElementErrors($form->get('body')); ?> </div> <?= $this->formElement($form->get('submit')); ?> <?= $this->form()->closeTag(); ?> </div> </div> In the code above, we added the .form-control CSS class to every input field in the form. We did that with the setAttribute() method (see lines 5, 10 and 15). With that method, we also added the \"placeholder\" attribute to define the nice-looking placeholder text when a field is empty. For the \"body\" field, we added the \"rows\" attribute defining the height of the field (6 rows). For the form's Submit button, we use the .btn and .btn-primary CSS classes (see line 21). We also put label-input pairs inside of <div> elements with .form-group CSS class (lines 35, 41, 47). We put a form inside of the 6-column-width grid cell, which makes the form half the width of the screen (look at lines 31-32). Note Sometimes it is impossible to use Twitter Bootstrap styling with standard Laminas form view helpers. For example, standard view helpers @ FormCheckbox and @ FormRadio can't be tweaked to support Bootstrap styles. Fortunately, there is a third-party module neilime/twbs-helper-module that you can install with Composer. This module provides convenient view helpers for rendering Laminas forms and applying Bootstrap styling to them. It works transparently, so once you installed the module, standard Laminas form view helpers become replaced with module-provided form view helpers, so you don't need to change your view template code.","title":"Applying the Bootstrap CSS Styles to Form"},{"location":"forms/#styling-the-validation-errors-list","text":"The error messages on your form, by default, look like a typical unordered list ( <ul> ). To give them a nice visual appearance, we add a couple of CSS rules to the style.css file in APP_DIR/public directory: form ul { list-style-type: none; padding: 0px; margin: 0px 5px; } form ul li { color: red; } The CSS rules above will remove bullets from the list and make validation error messages appear in red.","title":"Styling the Validation Errors List"},{"location":"forms/#adding-the-thank-you-error-sending-email-pages","text":"The last small thing we will do is preparing the view templates for the \"Thank You\" and \"Error Sending Email\" pages. Add the thank-you.phtml view template in application/index/ directory under the module's view/ directory. Put the following HTML markup into the view template file: <h1>Thank You!</h1> <p> <div class=\"alert alert-success\"> We will respond to the E-mail address you have provided. </div> </p> Next, add the send-error.phtml view template file. The HTML markup for the Error Sending Email page is presented below: <h1>Error Sending Email!</h1> <p> <div class=\"alert alert-warning\"> Sorry, but we had an unexpected problem when trying to deliver your message. Please try again later. </div> </p>","title":"Adding the \"Thank You\" &amp; \"Error Sending Email\" Pages"},{"location":"forms/#results","text":"Congratulations! Now, if you open the \"http://localhost/contactus\" URL in your web browser, you should see a page like that shown in figure 7.20. {width=80%} If you enter some invalid data in the form and click the Submit button, you should see the validation errors (figure 7.21). Entering the correct E-mail, subject and message text and submitting the form results in sending the message and displaying the Thank You page (see figure 7.22). On a sending failure, you will see the Error Sending Email page (see figure 7.23 for example): You can see the Contact Us form in action in the Form Demo sample application bundled with this book.","title":"Results"},{"location":"forms/#summary","text":"Forms are the way of collecting user-entered data on web pages. A form usually consists of elements (input field + label pairs). Elements can optionally be grouped into fieldsets. In an MVC-based web site, form functionality is separated into form models responsible for element definition and validation, and form presentation implemented with the help of special view helpers. To create a form model, you write a class deriving from the @ Form [Laminas\\Form\\Form] base class. The form model is initialized by adding its elements with the help of the base class-provided methods. To submit form data to the server, the user clicks the Submit button, then the data is sent as part of a HTTP request. Once the user submits the form, you can extract the form data in your controller and ask the form model to validate it. For checking and filtering the user-entered data, filters and validators are utilized. You use the @ InputFilter [Laminas\\InputFilter\\InputFilter] class which is the container for validation rules. If there are input errors, you display the form again, asking the user to correct the input errors. If the data is correct, you process the data with your business logic layer. The <button> field is analogous to <input type=\"button\"> , however it provides additional capabilities, like specifying a graphical icon on the button. \u21a9 Cross-site request forgery (CSRF) is a type of malicious exploit of a website whereby unauthorized commands are transmitted from a user that the website trusts. \u21a9 If you are confused where we take element aliases from, than you should know that they are defined inside of the @ Laminas\\Form\\FormElementManager\\FormElementManagerTrait class. \u21a9 There may be malicious users inserting HTML code in the message. If you open such code in your browser, you may see some undesired content. To avoid this, we need to replace HTML tags in message subject and text. \u21a9 In the latter (array specification) case, the input will be automatically created with the help of the @ Laminas\\InputFilter\\Factory class. \u21a9 In DDD terms, the MailSender can be related to service models, because its goal is to manipulate data, not to store data. \u21a9 Typically, this results in wrapping field names with the form/fieldset name (for example, the \"email\" field's name will become \"contact-form[email]\") which technically results in a more convenient field grouping in a HTTP request body. \u21a9","title":"Summary"},{"location":"forms_advanced/","text":"Advanced Usage of Forms In previous chapters, you've learned about form usage basics: what HTML forms are and how you define form models and form presentation in Laminas Framework. In this chapter, you will learn some advanced form usage topics such as security form elements (CAPTCHA and CSRF), and so on. Laminas components covered in this chapter: Component Description @ Laminas\\Captcha Implements various CAPTCHA algorithms. @ Laminas\\Form Contains base form model classes. @ Laminas\\Filter Contains various filters classes. @ Laminas\\Validator Implements various validator classes. @ Laminas\\InputFilter Implements a container for filters/validators. Form Security Elements We will consider the usage of two form security elements provided by Laminas Framework: @ Captcha [Laminas\\Form\\Element\\Captcha] and @ Csrf [Laminas\\Form\\Element\\Csrf] (both classes belong to @ Laminas\\Form\\Element [Laminas\\Form] namespace). By adding those elements to your form model (and rendering them in a view template), you will make your form resistant to hacker attacks. CAPTCHA A CAPTCHA (stands for \"Completely Automated Public Turing test to tell Computers and Humans Apart\") is a challenge-response test used in web sites for determining whether the user is a human or a robot. There are several types of CAPTCHA. The most widely used one requires that the user type the letters of a distorted image that is shown on the web page (see figure 11.1 for some examples). A typical CAPTCHA test works using the following algorithm: Some secret sequence of characters (word) is generated server-side. The secret word is saved in a PHP session variable. The distorted image is generated based on the secret word. The image is then displayed on the web page to site user. The site user is asked to type characters shown on the image. If the characters typed by user are the same as the secret word saved in the session, the test is considered passed. The goal of the CAPTCHA test is to protect your form from filling and submission by an automated process (so called robot). Usually, such robots send spam messages to forums, hack passwords on site login forms, or perform some other malicious actions. What is a CAPTCHA Test? The CAPTCHA test allows to reliably distinguish humans from robots, because humans are easily able to recognise and reproduce characters from the distorted image, while robots are not (at the current stage of evolution of computer vision algorithms). CAPTCHA Types In Laminas Framework, there are several CAPTCHA types available (they all belong to the @ Laminas\\Captcha component): Dumb. This is a very simple CAPTCHA algorithm which requires that site user enter the word letters in reverse order. We will not consider this type in details here, because it provides too low protection level. Image. A CAPTCHA algorithm distorting an image with addition of some noise in form of dots and line curves (figure 11.1, a). Figlet. An unusual CAPTCHA type using FIGlet program instead of an image distortion algorithm. The FIGlet is an open-source program which generates the CAPTCHA image of many small ASCII letters (figure 11.1, b). The @ Laminas\\Captcha component provides a unified interface for all CAPTCHA types (the @ AdapterInterface [Laminas\\Captcha\\AdapterInterface] interface). The @ AbstractAdapter [Laminas\\Captcha\\AdapterInterface] base class implements that interface, and all other CAPTCHA algorithms are derived from the abstract adapter class 1 . The class inheritance diagram is shown in figure 11.2 below. As you can see from the figure 11.2, there is another base class for all CAPTCHA types that utilize some secret word of characters: the @ AbstractWord [Laminas\\Captcha\\AbstractWord] class. This base class provides methods for generating random sequence of characters and for adjusting word generation options. CAPTCHA Form Element & View Helper Laminas provides the dedicated form element class and view helper class for letting you use CAPTCHA fields on your forms. To add a CAPTCHA field to a form model, you use the @ Captcha [Laminas\\Form\\Element\\Captcha] class that belongs to @ Laminas\\Form component and lives in @ Laminas\\Form\\Element [Laminas\\Form] namespace. The @ Captcha [Laminas\\Form\\Element\\Captcha] element class can be used with any CAPTCHA algorithm (listed in the previous section) from @ Laminas\\Captcha component. For this purpose, the element class has the setCaptcha() method which takes either an instance of a class implementing @ Laminas\\Captcha\\AdapterInterface interface, or an array containing CAPTCHA configuration 2 . By the setCaptcha() method, you can attach the desired CAPTCHA type to the element. You add the @ Captcha element to a form model as usual, with the add() method provided by the @ Laminas\\Form\\Form base class. As usual, you can pass it either an instance of the @ Laminas\\Form\\Element\\Captcha class or provide an array of configuration options specific to certain CAPTCHA algorithm (in that case, the element and its associated CAPTCHA algorithm will automatically be instantiated and configured by the factory class). The code example below shows how to use the latter method (passing a configuration array). We prefer this method because it requires less code to write. It is assumed that you call this code inside of form model's addElements() protected method: <?php // Add the CAPTCHA field to the form model $this->add([ 'type' => 'captcha', 'name' => 'captcha', 'options' => [ 'label' => 'Human check', 'captcha' => [ 'class' => '<captcha_class_name>', // // Certain-class-specific options follow here ... ], ], ]); In the example above, we call the add() method provided by the @ Form [Laminas\\Form\\Form] base class and pass it an array describing the element to insert (line 3): The type key of the array (line 4), as usual, may either be a fully qualified class name of the element (@ Laminas\\Form\\Element\\Captcha ) or its short alias (\"captcha\"). The name key (line 5) is the value for the \"name\" attribute of the HTML form field. The options key contains the options for the attached CAPTCHA algorithm. The class key (line 9) may either contain the full CAPTCHA class name (e.g. @ Laminas\\Captcha\\Image ) or its short alias (e.g. \"Image\"). Other, adapter-specific, options may be added to the key as well. We will show how to do that a little bit later. For generating the HTML markup for the element, you may use the @ FormCaptcha view helper class (belonging to @ Laminas\\Form\\View\\Helper [Laminas\\Form] namespace). But, as you might learn from the previous chapter, typically you use the generic @ FormElement view helper instead, like shown in the code below: <?= $this->formElement($form->get('captcha')); ?> It is assumed that you call the view helper inside of your view template. Next, we provide two examples illustrating how to use different CAPTCHA types provided by Laminas: the @ Image [Laminas\\Captcha\\Image] and @ Figlet [Laminas\\Captcha\\Figlet]. We will show how to add a CAPTCHA field to the feedback form that we used in examples of the previous chapters. Example 1: Adding Image CAPTCHA to the ContactForm W> Image CAPTCHA requires that you have PHP GD extension installed with PNG W> support and FT fonts. To add the @ Image [Laminas\\Captcha\\Image] CAPTCHA to your form model, call the form's add() method as follows: <?php namespace Application\\Form; // ... class ContactForm extends Form { // ... protected function addElements() { // ... // Add the CAPTCHA field $this->add([ 'type' => 'captcha', 'name' => 'captcha', 'attributes' => [ ], 'options' => [ 'label' => 'Human check', 'captcha' => [ 'class' => 'Image', 'imgDir' => 'public/img/captcha', 'suffix' => '.png', 'imgUrl' => '/img/captcha/', 'imgAlt' => 'CAPTCHA Image', 'font' => './data/font/thorne_shaded.ttf', 'fsize' => 24, 'width' => 350, 'height' => 100, 'expiration' => 600, 'dotNoiseLevel' => 40, 'lineNoiseLevel' => 3 ], ], ]); } } Above, the captcha key of the configuration array (see line 20) contains the following parameters for configuring the @ Image [Laminas\\Captcha\\Image] CAPTCHA algorithm attached to the form element: the class parameter (line 21) should be either the fully qualified CAPTCHA adapter class name (@ \\Laminas\\Captcha\\Image ) or its short alias (@ Image [Laminas\\Captcha\\Image]). the imgDir parameter (line 22) should be the path to the directory where to save the generated distorted images (in this example, we will save the images to the APP_DIR/public/img/captcha directory). the suffix parameter (line 23) defines the extension for a generated image file (\".png\" in this example). the imgUrl parameter (line 24) defines the base part of the URL for opening generated CAPTCHA images in a web browser. In this example, site visitors will be able to access CAPTCHA images using URLs like \"http://localhost/img/captcha/<ID>\", where ID is a unique ID of certain image. the imgAlt parameter (line 25) is an (optional) alternative text to show if CAPTCHA image can't be loaded by the web browser (the \"alt\" attribute of <img> tag). the font parameter (line 26) is the path to the font file. You can download a free TTF font, for example, from here . In this example, we use Thorne Shaded font, which we downloaded and put into the APP_DIR/data/font/thorne_shaded.ttf file. the fsize parameter (line 27) is a positive integer number defining the font size. the width (line 28) and height parameters (line 29) define the width and height (in pixels) of the generated image, respectively. the expiration parameter (line 30) defines the expiration period (in seconds) of the CAPTCHA images. Once an image expires, it is removed from disk. the dotNoiseLevel parameter (line 31) and lineNoiseLevel parameter (line 32) define the image generation options (dot noise level and line noise level, respectively). To render the CAPTCHA field, add the following lines to your contact-us.phtml view template file: <div class=\"form-group\"> <?= $this->formLabel($form->get('captcha')); ?> <?= $this->formElement($form->get('captcha')); ?> <?= $this->formElementErrors($form->get('captcha')); ?> <p class=\"help-block\">Enter the letters above as you see them.</p> </div> Finally, create the APP_DIR/public/img/captcha directory that will store generated CAPTCHA images. Adjust directory permissions to make the directory writeable by the Apache Web Server. In Linux Ubuntu, this is typically accomplished by the following shell commands (replace the APP_DIR placeholder with the actual directory name of your web application): mkdir APP_DIR/public/img/captcha chown -R www-data:www-data APP_DIR chmod -R 775 APP_DIR Above, the mkdir command creates the directory, and chown and chmod commands set the Apache user to be the owner of the directory and allow the web server to write to the directory, respectively. Now, if you open the \"http://localhost/contactus\" page in your web browser, the CAPTCHA image will be generated based on a random sequence of letters and digits saved in session. You should see something like in the figure 11.3 below. When you fill the form fields in and press the Submit button, the letters entered into the Human check field will be transferred to server as part of HTTP request. Then, on form validation, the @ Laminas\\Form\\Element\\Captcha class will compare the submitted letters to those stored in PHP session. If the letters are identical, the form is considered valid; otherwise form validation fails. Once the PHP renderer processes the view template, it generates HTML markup for the CAPTCHA element as shown below: <div class=\"form-group\"> <label for=\"captcha\">Human check</label> <img width=\"350\" height=\"100\" alt=\"CAPTCHA Image\" src=\"/img/captcha/df344b37500dcbb0c4d32f7351a65574.png\"> <input name=\"captcha[id]\" type=\"hidden\" value=\"df344b37500dcbb0c4d32f7351a65574\"> <input name=\"captcha[input]\" type=\"text\"> <p class=\"help-block\">Enter the letters above as you see them.</p> </div> Example 2: Adding a FIGlet CAPTCHA to the ContactForm To use the FIGlet CAPTCHA element with your form, replace the form element definition from the previous example with the following code: <?php // Add the CAPTCHA field $this->add([ 'type' => 'captcha', 'name' => 'captcha', 'attributes' => [ ], 'options' => [ 'label' => 'Human check', 'captcha' => [ 'class' => 'Figlet', 'wordLen' => 6, 'expiration' => 600, ], ], ]); Above, the captcha key of the configuration array (see line 10) contains the following parameters for configuring the @ Figlet [Laminas\\Captcha\\Figlet] CAPTCHA algorithm attached to the form element: the class parameter (line 11) should be either the full CAPTCHA adapter class name (@ \\Laminas\\Captcha\\Figlet ) or its short alias (@ Figlet [Laminas\\Captcha\\Figlet]). the wordLen parameter (line 12) defines the length of the secret word to be generated. the expiration parameter (line 13) defines the CAPTCHA expiration period (in seconds). Now, open the \"http://localhost/contactus\" page in your web browser. Once that is done, you should see a page like in the figure 11.4 below. Once the PHP renderer processes the view template, it generates HTML markup for the CAPTCHA element like shown below: <div class=\"form-group\"> <label for=\"captcha\">Human check</label> <pre> __ _ __ __ _ _ ___ _ _ __ __ | || | || \\ \\\\/ // | \\ / || / _ \\\\ | || | || \\ \\\\/ // | '--' || \\ ` // | \\/ || | / \\ || | || | || \\ ` // | .--. || | || | . . || | \\_/ || | \\\\_/ || | || |_|| |_|| |_|| |_|\\/|_|| \\___// \\____// |_|| `-` `-` `-`' `-` `-` `---` `---` `-`' </pre> <input name=\"captcha[id]\" type=\"hidden\" value=\"b68b010eccc22e78969764461be62714\"> <input name=\"captcha[input]\" type=\"text\"> <p class=\"help-block\">Enter the letters above as you see them.</p> </div> CSRF Prevention Cross-site request forgery (CSRF) is a kind of hacker attack which forces the user's browser to transmit an HTTP request to an arbitrary site. Through the CSRF attack, the malicious script is able to send unauthorized commands from a user that the website trusts. This attack is typically performed on pages containing forms for submission of some sensitive data (e.g. money transfer forms, shopping carts etc.) To better understand how this attack works, take a look at figure 11.5. Figure 11.5 illustrates an example CSRF attack on a payment gateway website: You log into your account at payment gateway web site https://payment.com . Please note that the SSL-protected connection (HTTPS) is used here, but it doesn't protect from such kind of attacks. Typically, you set check on the \"Remember Me\" check box of the login form to avoid entering user name and password too often. Once you logged in to your account, your web browser saves your session information to a cookie variable on your machine. On the payment gateway site, you use the payment form https://payment.com/moneytransfer.php to buy some goods. Please note that this payment form will later be used as a vulnerability allowing to perform the CSRF attack. Next you use the same web browser to visit some website you like. Assume the website contains cool pictures http://coolpictures.com . Unfortunately, this web site is infected by a malicious script, masqueraded by an <img src=\"image.php\"> HTML tag. Once you open the HTML page in your web browser, it loads all its images, thus executing the malicious image.php script. The malicious script checks the cookie variable, and if it presents, it performs the \"session riding\" and can act on behalf of the logged in user. It is now able to submit the payment form to the payment gateway site. Note The above described CSRF attack is possible it the web form on the payment gateway site does not check the source of the HTTP request. The people who maintain the payment gateway site must put more attention in making its forms more secure. To prevent CSRF attacks to a form, one has to require a special token with the form, as follows: For certain form, generate a random sequence of bytes (token) and save it server-side in PHP session data. Add a hidden field to form and set its value with the token. Once the form is submitted by the user, compare the hidden value passed in the form with the token saved server-side. If they match, consider the form data secure. If a malicious user will try to attack the site by submitting the form, he will not be able to put right token in the form submissions, because the token is not stored in cookies. Example: Adding a CSRF Element to Form In Laminas Framework, to add a CSRF protection to your form model, you use the @ Laminas\\Form\\Element\\Csrf form element class. The @ Csrf [Laminas\\Form\\Element\\Csrf] element has no visual representation (you will not see it on the screen). To insert a CSRF element to your form model, add the following lines in its addElements() method: // Add the CSRF field $this->add([ 'type' => 'csrf', 'name' => 'csrf', 'options' => [ 'csrf_options' => [ 'timeout' => 600 ] ], ]); Above, we use the @ Form [Laminas\\Form\\Form]'s add() method (line 2), to which we pass a configuration array describing the CSRF element. The element will be automatically instantiated and initialized by the factory. In line 3, we specify the class name for the CSRF element. This either may be the fully qualified class name (@ Laminas\\Form\\Element\\Csrf ) or a short alias (\"csrf\"). In line 4, we set the \"name\" attribute for the element. In this example, we use \"csrf\" name, but you may use any other name, on your choice. In line 6, inside of csrf_options array, we specify the options specific to @ Laminas\\Form\\Element\\Csrf class. We set the timeout option to 600 (look at line 7), which means the CSRF check expires in 600 seconds (10 minutes) after form creation. To render the CSRF field, in your view template .phtml file, add the following line: <?= $this->formElement($form->get('csrf')); ?> When the PHP renderer evaluates the view template, it generates the HTML markup for the CSRF field like shown below: <input type=\"hidden\" name=\"csrf\" value=\"1bc42bd0da4800fb55d16e81136fe177\"> As you can see from the HTML markup code above, the form now contains a hidden field with a randomly generated token. Since the attacker script doesn't know this token, it won't be able to submit its correct value, thus the CSRF attack becomes prevented. What happens if CSRF element validation fails? If during the form validation the CSRF check fails, the form is considered invalid and the user will see it again to fix input errors, but he won't see the error message for the CSRF element (we don't want hackers to know for sure what's wrong with the form). Using Validation Groups Sometimes it may be useful to temporarily disable validation of some form elements. You can do that with a feature called validation groups . By default, all form elements are validated. A validation group allows to disable validation of certain fields. For example, assume you implement a form named PaymentForm , which allows you to select a payment method of several alternatives (credit card, bank transfer and cash). If the user selects credit card , you also want him to enter the credit card number; else if user selects bank transfer , you want him to enter bank account number; and finally, if the cash is selected, user does not need to enter additional information. For this form, you will have to dynamically hide and display dependent fields in client's browser with JavaScript. How would you validate such form in your controller's action? The problem is that some fields depend on others. The card_number field is required only when payment_method is the \"credit card\", otherwise it is optional. The same is for the bank_account field - it is required only when payment_method is the \"bank transfer\". We can handle this case elegantly with the validation group. The @ Form [Laminas\\Form\\Form] class provides the setValidationGroup() method, which accepts the list of fields that you want to validate; all other fields will be suppressed and not validated. // First, we will validate the \"payment_method\" field. $form->setValidationGroup(['payment_method']); if ($form->isValid()) { $data = $form->getData(); $paymentMethod = $data['payment_method']; // Next, validate the dependent fields if ($paymentMethod=='credit_card') { $form->setValidationGroup(['payment_method', 'card_number']); } else if ($paymentMethod=='bank_account') { $form->setValidationGroup(['payment_method', 'bank_account']); } if ($form->isValid()) { $data = $form->getData(); // Do something with the data // ... } } You can see this example in action in the Form Demo sample web application bundled with this book. Just type \"http://localhost/payment\" URL in your browser. Implementing Multi-Step Forms In this section, we will provide instructions on how to implement a multi-step form with Laminas. A multi-step form is a form having a lot of fields, and which is displayed in several steps. To store the current step and user-entered data between page requests, PHP sessions are utilized. For example, user registration can be performed in several steps: on the first step you display the page allowing to enter login and password, on the second step you display the page where the site visitor can enter his personal information, and on the third step, the visitor can enter billing information. Another example of a multi-step form is a Survey form. This form would display a question and possible variants of the answer. This form would have as many steps as many questions are in the survey. In this section we will implement the User Registration form allowing to collect information about the user being registered. You can see this complete working example in action as part of Form Demo sample web application bundled with this book. Enabling Sessions Note If you are new to the PHP sessions feature, please refer to Working with Sessions before reading this section. Session support is implemented in @ Laminas\\Session component, so you have to install it if you hadn't done that before. Next, modify your APP_DIR/config/global.php config file as follows: <?php use Laminas\\Session\\Storage\\SessionArrayStorage; use Laminas\\Session\\Validator\\RemoteAddr; use Laminas\\Session\\Validator\\HttpUserAgent; return [ // Session configuration. 'session_config' => [ // Session cookie will expire in 1 hour. 'cookie_lifetime' => 60*60*1, // Store session data on server maximum for 30 days. 'gc_maxlifetime' => 60*60*24*30, ], // Session manager configuration. 'session_manager' => [ // Session validators (used for security). 'validators' => [ RemoteAddr::class, HttpUserAgent::class, ] ], // Session storage configuration. 'session_storage' => [ 'type' => SessionArrayStorage::class ], // ... ]; Then add the following lines to your module.config.php to register the UserRegistration session container: <?php return [ // ... 'session_containers' => [ 'UserRegistration' ], ]; Done! Now we can use session container in our code. Next, we will implement the RegistrationForm form model. Adding RegistrationForm The RegistrationForm form model will be used for collecting data about the user (email, full name, password, personal information and billing information). We will add elements to this form in three portions, thus allowing to use it as a multi-step form. To add the form model, create the RegistrationForm.php file in the Form directory under the Application module's source directory: <?php namespace Application\\Form; use Laminas\\Form\\Form; use Laminas\\InputFilter\\InputFilter; use Application\\Validator\\PhoneValidator; /** * This form is used to collect user registration data. This form is multi-step. * It determines which fields to create based on the $step argument you pass to * its constructor. */ class RegistrationForm extends Form { /** * Constructor. */ public function __construct($step) { // Check input. if (!is_int($step) || $step<1 || $step>3) throw new \\Exception('Step is invalid'); // Define form name parent::__construct('registration-form'); // Set POST method for this form $this->setAttribute('method', 'post'); $this->addElements($step); $this->addInputFilter($step); } /** * This method adds elements to form (input fields and submit button). */ protected function addElements($step) { if ($step==1) { // Add \"email\" field $this->add([ 'type' => 'text', 'name' => 'email', 'attributes' => [ 'id' => 'email' ], 'options' => [ 'label' => 'Your E-mail', ], ]); // Add \"full_name\" field $this->add([ 'type' => 'text', 'name' => 'full_name', 'attributes' => [ 'id' => 'full_name' ], 'options' => [ 'label' => 'Full Name', ], ]); // Add \"password\" field $this->add([ 'type' => 'password', 'name' => 'password', 'attributes' => [ 'id' => 'password' ], 'options' => [ 'label' => 'Choose Password', ], ]); // Add \"confirm_password\" field $this->add([ 'type' => 'password', 'name' => 'confirm_password', 'attributes' => [ 'id' => 'confirm_password' ], 'options' => [ 'label' => 'Type Password Again', ], ]); } else if ($step==2) { // Add \"phone\" field $this->add([ 'type' => 'text', 'name' => 'phone', 'attributes' => [ 'id' => 'phone' ], 'options' => [ 'label' => 'Mobile Phone', ], ]); // Add \"street_address\" field $this->add([ 'type' => 'text', 'name' => 'street_address', 'attributes' => [ 'id' => 'street_address' ], 'options' => [ 'label' => 'Street address', ], ]); // Add \"city\" field $this->add([ 'type' => 'text', 'name' => 'city', 'attributes' => [ 'id' => 'city' ], 'options' => [ 'label' => 'City', ], ]); // Add \"state\" field $this->add([ 'type' => 'text', 'name' => 'state', 'attributes' => [ 'id' => 'state' ], 'options' => [ 'label' => 'State', ], ]); // Add \"post_code\" field $this->add([ 'type' => 'text', 'name' => 'post_code', 'attributes' => [ 'id' => 'post_code' ], 'options' => [ 'label' => 'Post Code', ], ]); // Add \"country\" field $this->add([ 'type' => 'select', 'name' => 'country', 'attributes' => [ 'id' => 'country', ], 'options' => [ 'label' => 'Country', 'empty_option' => '-- Please select --', 'value_options' => [ 'US' => 'United States', 'CA' => 'Canada', 'BR' => 'Brazil', 'GB' => 'Great Britain', 'FR' => 'France', 'IT' => 'Italy', 'DE' => 'Germany', 'RU' => 'Russia', 'IN' => 'India', 'CN' => 'China', 'AU' => 'Australia', 'JP' => 'Japan' ], ], ]); } else if ($step==3) { // Add \"billing_plan\" field $this->add([ 'type' => 'select', 'name' => 'billing_plan', 'attributes' => [ 'id' => 'billing_plan', ], 'options' => [ 'label' => 'Billing Plan', 'empty_option' => '-- Please select --', 'value_options' => [ 'Free' => 'Free', 'Bronze' => 'Bronze', 'Silver' => 'Silver', 'Gold' => 'Gold', 'Platinum' => 'Platinum' ], ], ]); // Add \"payment_method\" field $this->add([ 'type' => 'select', 'name' => 'payment_method', 'attributes' => [ 'id' => 'payment_method', ], 'options' => [ 'label' => 'Payment Method', 'empty_option' => '-- Please select --', 'value_options' => [ 'Visa' => 'Visa', 'MasterCard' => 'Master Card', 'PayPal' => 'PayPal' ], ], ]); } // Add the CSRF field $this->add([ 'type' => 'csrf', 'name' => 'csrf', 'attributes' => [], 'options' => [ 'csrf_options' => [ 'timeout' => 600 ] ], ]); // Add the submit button $this->add([ 'type' => 'submit', 'name' => 'submit', 'attributes' => [ 'value' => 'Next Step', 'id' => 'submitbutton', ], ]); } /** * This method creates input filter (used for form filtering/validation). */ private function addInputFilter($step) { $inputFilter = new InputFilter(); $this->setInputFilter($inputFilter); if ($step==1) { $inputFilter->add([ 'name' => 'email', 'required' => true, 'filters' => [ ['name' => 'StringTrim'], ], 'validators' => [ [ 'name' => 'EmailAddress', 'options' => [ 'allow' => \\Laminas\\Validator\\Hostname::ALLOW_DNS, 'useMxCheck' => false, ], ], ], ]); $inputFilter->add([ 'name' => 'full_name', 'required' => true, 'filters' => [ ['name' => 'StringTrim'], ['name' => 'StripTags'], ['name' => 'StripNewlines'], ], 'validators' => [ [ 'name' => 'StringLength', 'options' => [ 'min' => 1, 'max' => 128 ], ], ], ]); // Add input for \"password\" field $inputFilter->add([ 'name' => 'password', 'required' => true, 'filters' => [ ], 'validators' => [ [ 'name' => 'StringLength', 'options' => [ 'min' => 6, 'max' => 64 ], ], ], ]); // Add input for \"confirm_password\" field $inputFilter->add([ 'name' => 'confirm_password', 'required' => true, 'filters' => [ ], 'validators' => [ [ 'name' => 'Identical', 'options' => [ 'token' => 'password', ], ], ], ]); } else if ($step==2) { $inputFilter->add([ 'name' => 'phone', 'required' => true, 'filters' => [ ], 'validators' => [ [ 'name' => 'StringLength', 'options' => [ 'min' => 3, 'max' => 32 ], ], [ 'name' => PhoneValidator::class, 'options' => [ 'format' => PhoneValidator::PHONE_FORMAT_INTL ] ], ], ]); // Add input for \"street_address\" field $inputFilter->add([ 'name' => 'street_address', 'required' => true, 'filters' => [ ['name' => 'StringTrim'], ], 'validators' => [ ['name'=>'StringLength', 'options'=>['min'=>1, 'max'=>255]] ], ]); // Add input for \"city\" field $inputFilter->add([ 'name' => 'city', 'required' => true, 'filters' => [ ['name' => 'StringTrim'], ], 'validators' => [ ['name'=>'StringLength', 'options'=>['min'=>1, 'max'=>255]] ], ]); // Add input for \"state\" field $inputFilter->add([ 'name' => 'state', 'required' => true, 'filters' => [ ['name' => 'StringTrim'], ], 'validators' => [ ['name'=>'StringLength', 'options'=>['min'=>1, 'max'=>32]] ], ]); // Add input for \"post_code\" field $inputFilter->add([ 'name' => 'post_code', 'required' => true, 'filters' => [ ], 'validators' => [ ['name' => 'IsInt'], ['name'=>'Between', 'options'=>['min'=>0, 'max'=>999999]] ], ]); // Add input for \"country\" field $inputFilter->add([ 'name' => 'country', 'required' => false, 'filters' => [ ['name' => 'Alpha'], ['name' => 'StringTrim'], ['name' => 'StringToUpper'], ], 'validators' => [ ['name'=>'StringLength', 'options'=>['min'=>2, 'max'=>2]] ], ]); } else if ($step==3) { // Add input for \"billing_plan\" field $inputFilter->add([ 'name' => 'billing_plan', 'required' => true, 'filters' => [ ], 'validators' => [ [ 'name' => 'InArray', 'options' => [ 'haystack'=>[ 'Free', 'Bronze', 'Silver', 'Gold', 'Platinum' ] ] ] ], ]); // Add input for \"payment_method\" field $inputFilter->add([ 'name' => 'payment_method', 'required' => true, 'filters' => [ ], 'validators' => [ [ 'name' => 'InArray', 'options' => [ 'haystack'=>[ 'PayPal', 'Visa', 'MasterCard', ] ] ] ], ]); } } } As you can see from the code above, the RegistrationForm is a usual form model, but it accepts the $step argument in its constructor allowing to specify what form elements to use on the current step. Adding RegistrationController Next, we'll add the RegistrationController controller class. To do that, create the RegistrationController.php file under the Controller directory and add the following code into it: <?php namespace Application\\Controller; use Laminas\\Mvc\\Controller\\AbstractActionController; use Laminas\\View\\Model\\ViewModel; use Application\\Form\\RegistrationForm; use Laminas\\Session\\Container; /** * This is the controller class displaying a page with the User Registration form. * User registration has several steps, so we display different form elements on * each step. We use session container to remember user's choices on the previous * steps. */ class RegistrationController extends AbstractActionController { /** * Session container. * @var Laminas\\Session\\Container */ private $sessionContainer; /** * Constructor. Its goal is to inject dependencies into controller. */ public function __construct($sessionContainer) { $this->sessionContainer = $sessionContainer; } /** * This is the default \"index\" action of the controller. It displays the * User Registration page. */ public function indexAction() { // Determine the current step. $step = 1; if (isset($this->sessionContainer->step)) { $step = $this->sessionContainer->step; } // Ensure the step is correct (between 1 and 3). if ($step<1 || $step>3) $step = 1; if ($step==1) { // Init user choices. $this->sessionContainer->userChoices = []; } $form = new RegistrationForm($step); // Check if user has submitted the form if($this->getRequest()->isPost()) { // Fill in the form with POST data $data = $this->params()->fromPost(); $form->setData($data); // Validate form if($form->isValid()) { // Get filtered and validated data $data = $form->getData(); // Save user choices in session. $this->sessionContainer->userChoices[\"step$step\"] = $data; // Increase step $step ++; $this->sessionContainer->step = $step; // If we completed all 3 steps, redirect to Review page. if ($step>3) { return $this->redirect()->toRoute('registration', ['action'=>'review']); } // Go to the next step. return $this->redirect()->toRoute('registration'); } } $viewModel = new ViewModel([ 'form' => $form ]); $viewModel->setTemplate(\"application/registration/step$step\"); return $viewModel; } /** * The \"review\" action shows a page allowing to review data entered on previous * three steps. */ public function reviewAction() { // Validate session data. if(!isset($this->sessionContainer->step) || $this->sessionContainer->step<=3 || !isset($this->sessionContainer->userChoices)) { throw new \\Exception('Sorry, the data is not available for review yet'); } // Retrieve user choices from session. $userChoices = $this->sessionContainer->userChoices; return new ViewModel([ 'userChoices' => $userChoices ]); } } In the class above, we have three methods: The __construct() constructor is used to inject the dependency - the session container - into the controller. The indexAction() action method extracts the current step from session and initializes the form model. If the user has submitted the form, we extract data from form and save it to session, incrementing the step. If the step is greater than 3, we redirect the user to the \"Review\" page. The reviewAction() action method extracts the data entered by the user on all three steps and passes it to the view for rendering. Adding RegistrationControllerFactory Next, we add the factory for the RegistrationController . To do that, add the RegistrationControllerFactory.php file inside the Controller/Form directory under the module's source directory. Put the following code into it: <?php namespace Application\\Controller\\Factory; use Interop\\Container\\ContainerInterface; use Laminas\\ServiceManager\\Factory\\FactoryInterface; use Application\\Controller\\RegistrationController; /** * This is the factory for RegistrationController. Its purpose is to instantiate the * controller and inject dependencies into it. */ class RegistrationControllerFactory implements FactoryInterface { public function __invoke(ContainerInterface $container, $requestedName, array $options = null) { $sessionContainer = $container->get('UserRegistration'); // Instantiate the controller and inject dependencies return new RegistrationController($sessionContainer); } } Do not forget to register the controller in the module.config.php file! Adding View Templates Now, let's add the view templates for the controller actions. We have four view templates: step1.phtml , step2.phtml , step3.phtml and review.phtml . The first three ones are used by the indexAction() and the last is used by the reviewAction() . Add step1.phtml file inside the application/registration directory and put the following code into it: <?php $form->get('email')->setAttributes([ 'class'=>'form-control', 'placeholder'=>'name@yourcompany.com' ]); $form->get('full_name')->setAttributes([ 'class'=>'form-control', 'placeholder'=>'John Doe' ]); $form->get('password')->setAttributes([ 'class'=>'form-control', 'placeholder'=>'Type password here (6 characters at minimum)' ]); $form->get('confirm_password')->setAttributes([ 'class'=>'form-control', 'placeholder'=>'Repeat password' ]); $form->get('submit')->setAttributes(array('class'=>'btn btn-primary')); $form->prepare(); ?> <h1>User Registration - Step 1</h1> <div class=\"row\"> <div class=\"col-md-6\"> <?= $this->form()->openTag($form); ?> <div class=\"form-group\"> <?= $this->formLabel($form->get('email')); ?> <?= $this->formElement($form->get('email')); ?> <?= $this->formElementErrors($form->get('email')); ?> </div> <div class=\"form-group\"> <?= $this->formLabel($form->get('full_name')); ?> <?= $this->formElement($form->get('full_name')); ?> <?= $this->formElementErrors($form->get('full_name')); ?> </div> <div class=\"form-group\"> <?= $this->formLabel($form->get('password')); ?> <?= $this->formElement($form->get('password')); ?> <?= $this->formElementErrors($form->get('password')); ?> </div> <div class=\"form-group\"> <?= $this->formLabel($form->get('confirm_password')); ?> <?= $this->formElement($form->get('confirm_password')); ?> <?= $this->formElementErrors($form->get('confirm_password')); ?> </div> <div class=\"form-group\"> <?= $this->formElement($form->get('submit')); ?> </div> <?= $this->formElement($form->get('csrf')); ?> <?= $this->form()->closeTag(); ?> </div> </div> Next, add step2.phtml file inside the application/registration directory and put the following code into it: <?php $form->get('phone')->setAttributes([ 'class'=>'form-control', 'placeholder'=>'Phone number in international format' ]); $form->get('street_address')->setAttributes([ 'class'=>'form-control', ]); $form->get('city')->setAttributes([ 'class'=>'form-control', ]); $form->get('state')->setAttributes([ 'class'=>'form-control', ]); $form->get('post_code')->setAttributes([ 'class'=>'form-control', ]); $form->get('country')->setAttributes([ 'class'=>'form-control' ]); $form->get('submit')->setAttributes(array('class'=>'btn btn-primary')); $form->prepare(); ?> <h1>User Registration - Step 2 - Personal Information</h1> <div class=\"row\"> <div class=\"col-md-6\"> <?= $this->form()->openTag($form); ?> <div class=\"form-group\"> <?= $this->formLabel($form->get('phone')); ?> <?= $this->formElement($form->get('phone')); ?> <?= $this->formElementErrors($form->get('phone')); ?> </div> <div class=\"form-group\"> <?= $this->formLabel($form->get('street_address')); ?> <?= $this->formElement($form->get('street_address')); ?> <?= $this->formElementErrors($form->get('street_address')); ?> </div> <div class=\"form-group\"> <?= $this->formLabel($form->get('city')); ?> <?= $this->formElement($form->get('city')); ?> <?= $this->formElementErrors($form->get('city')); ?> </div> <div class=\"form-group\"> <?= $this->formLabel($form->get('state')); ?> <?= $this->formElement($form->get('state')); ?> <?= $this->formElementErrors($form->get('state')); ?> </div> <div class=\"form-group\"> <?= $this->formLabel($form->get('post_code')); ?> <?= $this->formElement($form->get('post_code')); ?> <?= $this->formElementErrors($form->get('post_code')); ?> </div> <div class=\"form-group\"> <?= $this->formLabel($form->get('country')); ?> <?= $this->formElement($form->get('country')); ?> <?= $this->formElementErrors($form->get('country')); ?> </div> <div class=\"form-group\"> <?= $this->formElement($form->get('submit')); ?> </div> <?= $this->formElement($form->get('csrf')); ?> <?= $this->form()->closeTag(); ?> </div> </div> Next, add step3.phtml file inside the application/registration directory and put the following code into it: <?php $form->get('billing_plan')->setAttributes([ 'class'=>'form-control', ]); $form->get('payment_method')->setAttributes([ 'class'=>'form-control', ]); $form->get('submit')->setAttributes(array('class'=>'btn btn-primary')); $form->prepare(); ?> <h1>User Registration - Step 3 - Billing Information</h1> <div class=\"row\"> <div class=\"col-md-6\"> <?= $this->form()->openTag($form); ?> <div class=\"form-group\"> <?= $this->formLabel($form->get('billing_plan')); ?> <?= $this->formElement($form->get('billing_plan')); ?> <?= $this->formElementErrors($form->get('billing_plan')); ?> </div> <div class=\"form-group\"> <?= $this->formLabel($form->get('payment_method')); ?> <?= $this->formElement($form->get('payment_method')); ?> <?= $this->formElementErrors($form->get('payment_method')); ?> </div> <div class=\"form-group\"> <?= $this->formElement($form->get('submit')); ?> </div> <?= $this->formElement($form->get('csrf')); ?> <?= $this->form()->closeTag(); ?> </div> </div> And finally, add review.phtml file inside the application/registration directory and put the following code into it: <h1>User Registration - Review</h1> <p>Thank you! Now please review the data you entered in previous three steps.</p> <pre> <?php print_r($userChoices); ?> </pre> Adding Route Add the following route inside your module.config.php config file: 'registration' => [ 'type' => Segment::class, 'options' => [ 'route' => '/registration[/:action]', 'constraints' => [ 'action' => '[a-zA-Z][a-zA-Z0-9_-]*' ], 'defaults' => [ 'controller' => Controller\\RegistrationController::class, 'action' => 'index', ], ], ], Great! Now everything is ready for seeing the results! Results To see our multi-step form in action, enter the \"http://localhost/registration\" URL into your browser's navigation bar. The User Registration - Step 1 page appears (see figure 11.6 below): Once the user enters his E-mail, full name and password and clicks Next , he is redirected to the next step (see figure 11.7): And the final step is shown in figure 11.8 below: Clicking Next results in displaying the Review page allowing to see the data entered on the previous three steps: You can find this complete example in the Form Demo sample application bundled with this book. Summary In this chapter, we have discussed some advanced form usage capabilities. Laminas Framework provides two classes whose purpose is enhancing form security: @ Captcha and @ Csrf [Laminas\\Form\\Element\\Csrf]. A CAPTCHA is a type of challenge-response test used to determine whether or not the user is a human. CAPTCHA elements are used on form to prevent form submission by a malicious automated process (a robot). The latter element, @ Csrf [Laminas\\Form\\Element\\Csrf], is used for Cross-Site Request Forgery (abbreviated as CSRF) hacker attack prevention. We have also learned of how to implement a multi-step forms with the help of sessions. The adapter is a design pattern that translates one interface for a class into a compatible interface, which helps two (or several) incompatible interfaces to work together. Typically, CAPTCHA algorithms have different public methods, but since they all implement @ AbstractAdapter [Laminas\\Captcha\\AdapterInterface] interface, the caller may use any CAPTCHA algorithm in the same common manner (by calling the methods provided by the base interface). \u21a9 In the latter case (configuration array), the CAPTCHA algorithm will be automatically instantiated and initialized by the factory class @ Laminas\\Captcha\\Factory . \u21a9","title":"Advanced Usage of Forms"},{"location":"forms_advanced/#advanced-usage-of-forms","text":"In previous chapters, you've learned about form usage basics: what HTML forms are and how you define form models and form presentation in Laminas Framework. In this chapter, you will learn some advanced form usage topics such as security form elements (CAPTCHA and CSRF), and so on. Laminas components covered in this chapter: Component Description @ Laminas\\Captcha Implements various CAPTCHA algorithms. @ Laminas\\Form Contains base form model classes. @ Laminas\\Filter Contains various filters classes. @ Laminas\\Validator Implements various validator classes. @ Laminas\\InputFilter Implements a container for filters/validators.","title":"Advanced Usage of Forms"},{"location":"forms_advanced/#form-security-elements","text":"We will consider the usage of two form security elements provided by Laminas Framework: @ Captcha [Laminas\\Form\\Element\\Captcha] and @ Csrf [Laminas\\Form\\Element\\Csrf] (both classes belong to @ Laminas\\Form\\Element [Laminas\\Form] namespace). By adding those elements to your form model (and rendering them in a view template), you will make your form resistant to hacker attacks.","title":"Form Security Elements"},{"location":"forms_advanced/#captcha","text":"A CAPTCHA (stands for \"Completely Automated Public Turing test to tell Computers and Humans Apart\") is a challenge-response test used in web sites for determining whether the user is a human or a robot. There are several types of CAPTCHA. The most widely used one requires that the user type the letters of a distorted image that is shown on the web page (see figure 11.1 for some examples). A typical CAPTCHA test works using the following algorithm: Some secret sequence of characters (word) is generated server-side. The secret word is saved in a PHP session variable. The distorted image is generated based on the secret word. The image is then displayed on the web page to site user. The site user is asked to type characters shown on the image. If the characters typed by user are the same as the secret word saved in the session, the test is considered passed. The goal of the CAPTCHA test is to protect your form from filling and submission by an automated process (so called robot). Usually, such robots send spam messages to forums, hack passwords on site login forms, or perform some other malicious actions. What is a CAPTCHA Test? The CAPTCHA test allows to reliably distinguish humans from robots, because humans are easily able to recognise and reproduce characters from the distorted image, while robots are not (at the current stage of evolution of computer vision algorithms).","title":"CAPTCHA"},{"location":"forms_advanced/#captcha-types","text":"In Laminas Framework, there are several CAPTCHA types available (they all belong to the @ Laminas\\Captcha component): Dumb. This is a very simple CAPTCHA algorithm which requires that site user enter the word letters in reverse order. We will not consider this type in details here, because it provides too low protection level. Image. A CAPTCHA algorithm distorting an image with addition of some noise in form of dots and line curves (figure 11.1, a). Figlet. An unusual CAPTCHA type using FIGlet program instead of an image distortion algorithm. The FIGlet is an open-source program which generates the CAPTCHA image of many small ASCII letters (figure 11.1, b). The @ Laminas\\Captcha component provides a unified interface for all CAPTCHA types (the @ AdapterInterface [Laminas\\Captcha\\AdapterInterface] interface). The @ AbstractAdapter [Laminas\\Captcha\\AdapterInterface] base class implements that interface, and all other CAPTCHA algorithms are derived from the abstract adapter class 1 . The class inheritance diagram is shown in figure 11.2 below. As you can see from the figure 11.2, there is another base class for all CAPTCHA types that utilize some secret word of characters: the @ AbstractWord [Laminas\\Captcha\\AbstractWord] class. This base class provides methods for generating random sequence of characters and for adjusting word generation options.","title":"CAPTCHA Types"},{"location":"forms_advanced/#captcha-form-element-view-helper","text":"Laminas provides the dedicated form element class and view helper class for letting you use CAPTCHA fields on your forms. To add a CAPTCHA field to a form model, you use the @ Captcha [Laminas\\Form\\Element\\Captcha] class that belongs to @ Laminas\\Form component and lives in @ Laminas\\Form\\Element [Laminas\\Form] namespace. The @ Captcha [Laminas\\Form\\Element\\Captcha] element class can be used with any CAPTCHA algorithm (listed in the previous section) from @ Laminas\\Captcha component. For this purpose, the element class has the setCaptcha() method which takes either an instance of a class implementing @ Laminas\\Captcha\\AdapterInterface interface, or an array containing CAPTCHA configuration 2 . By the setCaptcha() method, you can attach the desired CAPTCHA type to the element. You add the @ Captcha element to a form model as usual, with the add() method provided by the @ Laminas\\Form\\Form base class. As usual, you can pass it either an instance of the @ Laminas\\Form\\Element\\Captcha class or provide an array of configuration options specific to certain CAPTCHA algorithm (in that case, the element and its associated CAPTCHA algorithm will automatically be instantiated and configured by the factory class). The code example below shows how to use the latter method (passing a configuration array). We prefer this method because it requires less code to write. It is assumed that you call this code inside of form model's addElements() protected method: <?php // Add the CAPTCHA field to the form model $this->add([ 'type' => 'captcha', 'name' => 'captcha', 'options' => [ 'label' => 'Human check', 'captcha' => [ 'class' => '<captcha_class_name>', // // Certain-class-specific options follow here ... ], ], ]); In the example above, we call the add() method provided by the @ Form [Laminas\\Form\\Form] base class and pass it an array describing the element to insert (line 3): The type key of the array (line 4), as usual, may either be a fully qualified class name of the element (@ Laminas\\Form\\Element\\Captcha ) or its short alias (\"captcha\"). The name key (line 5) is the value for the \"name\" attribute of the HTML form field. The options key contains the options for the attached CAPTCHA algorithm. The class key (line 9) may either contain the full CAPTCHA class name (e.g. @ Laminas\\Captcha\\Image ) or its short alias (e.g. \"Image\"). Other, adapter-specific, options may be added to the key as well. We will show how to do that a little bit later. For generating the HTML markup for the element, you may use the @ FormCaptcha view helper class (belonging to @ Laminas\\Form\\View\\Helper [Laminas\\Form] namespace). But, as you might learn from the previous chapter, typically you use the generic @ FormElement view helper instead, like shown in the code below: <?= $this->formElement($form->get('captcha')); ?> It is assumed that you call the view helper inside of your view template. Next, we provide two examples illustrating how to use different CAPTCHA types provided by Laminas: the @ Image [Laminas\\Captcha\\Image] and @ Figlet [Laminas\\Captcha\\Figlet]. We will show how to add a CAPTCHA field to the feedback form that we used in examples of the previous chapters.","title":"CAPTCHA Form Element &amp; View Helper"},{"location":"forms_advanced/#example-1-adding-image-captcha-to-the-contactform","text":"W> Image CAPTCHA requires that you have PHP GD extension installed with PNG W> support and FT fonts. To add the @ Image [Laminas\\Captcha\\Image] CAPTCHA to your form model, call the form's add() method as follows: <?php namespace Application\\Form; // ... class ContactForm extends Form { // ... protected function addElements() { // ... // Add the CAPTCHA field $this->add([ 'type' => 'captcha', 'name' => 'captcha', 'attributes' => [ ], 'options' => [ 'label' => 'Human check', 'captcha' => [ 'class' => 'Image', 'imgDir' => 'public/img/captcha', 'suffix' => '.png', 'imgUrl' => '/img/captcha/', 'imgAlt' => 'CAPTCHA Image', 'font' => './data/font/thorne_shaded.ttf', 'fsize' => 24, 'width' => 350, 'height' => 100, 'expiration' => 600, 'dotNoiseLevel' => 40, 'lineNoiseLevel' => 3 ], ], ]); } } Above, the captcha key of the configuration array (see line 20) contains the following parameters for configuring the @ Image [Laminas\\Captcha\\Image] CAPTCHA algorithm attached to the form element: the class parameter (line 21) should be either the fully qualified CAPTCHA adapter class name (@ \\Laminas\\Captcha\\Image ) or its short alias (@ Image [Laminas\\Captcha\\Image]). the imgDir parameter (line 22) should be the path to the directory where to save the generated distorted images (in this example, we will save the images to the APP_DIR/public/img/captcha directory). the suffix parameter (line 23) defines the extension for a generated image file (\".png\" in this example). the imgUrl parameter (line 24) defines the base part of the URL for opening generated CAPTCHA images in a web browser. In this example, site visitors will be able to access CAPTCHA images using URLs like \"http://localhost/img/captcha/<ID>\", where ID is a unique ID of certain image. the imgAlt parameter (line 25) is an (optional) alternative text to show if CAPTCHA image can't be loaded by the web browser (the \"alt\" attribute of <img> tag). the font parameter (line 26) is the path to the font file. You can download a free TTF font, for example, from here . In this example, we use Thorne Shaded font, which we downloaded and put into the APP_DIR/data/font/thorne_shaded.ttf file. the fsize parameter (line 27) is a positive integer number defining the font size. the width (line 28) and height parameters (line 29) define the width and height (in pixels) of the generated image, respectively. the expiration parameter (line 30) defines the expiration period (in seconds) of the CAPTCHA images. Once an image expires, it is removed from disk. the dotNoiseLevel parameter (line 31) and lineNoiseLevel parameter (line 32) define the image generation options (dot noise level and line noise level, respectively). To render the CAPTCHA field, add the following lines to your contact-us.phtml view template file: <div class=\"form-group\"> <?= $this->formLabel($form->get('captcha')); ?> <?= $this->formElement($form->get('captcha')); ?> <?= $this->formElementErrors($form->get('captcha')); ?> <p class=\"help-block\">Enter the letters above as you see them.</p> </div> Finally, create the APP_DIR/public/img/captcha directory that will store generated CAPTCHA images. Adjust directory permissions to make the directory writeable by the Apache Web Server. In Linux Ubuntu, this is typically accomplished by the following shell commands (replace the APP_DIR placeholder with the actual directory name of your web application): mkdir APP_DIR/public/img/captcha chown -R www-data:www-data APP_DIR chmod -R 775 APP_DIR Above, the mkdir command creates the directory, and chown and chmod commands set the Apache user to be the owner of the directory and allow the web server to write to the directory, respectively. Now, if you open the \"http://localhost/contactus\" page in your web browser, the CAPTCHA image will be generated based on a random sequence of letters and digits saved in session. You should see something like in the figure 11.3 below. When you fill the form fields in and press the Submit button, the letters entered into the Human check field will be transferred to server as part of HTTP request. Then, on form validation, the @ Laminas\\Form\\Element\\Captcha class will compare the submitted letters to those stored in PHP session. If the letters are identical, the form is considered valid; otherwise form validation fails. Once the PHP renderer processes the view template, it generates HTML markup for the CAPTCHA element as shown below: <div class=\"form-group\"> <label for=\"captcha\">Human check</label> <img width=\"350\" height=\"100\" alt=\"CAPTCHA Image\" src=\"/img/captcha/df344b37500dcbb0c4d32f7351a65574.png\"> <input name=\"captcha[id]\" type=\"hidden\" value=\"df344b37500dcbb0c4d32f7351a65574\"> <input name=\"captcha[input]\" type=\"text\"> <p class=\"help-block\">Enter the letters above as you see them.</p> </div>","title":"Example 1: Adding Image CAPTCHA to the ContactForm"},{"location":"forms_advanced/#example-2-adding-a-figlet-captcha-to-the-contactform","text":"To use the FIGlet CAPTCHA element with your form, replace the form element definition from the previous example with the following code: <?php // Add the CAPTCHA field $this->add([ 'type' => 'captcha', 'name' => 'captcha', 'attributes' => [ ], 'options' => [ 'label' => 'Human check', 'captcha' => [ 'class' => 'Figlet', 'wordLen' => 6, 'expiration' => 600, ], ], ]); Above, the captcha key of the configuration array (see line 10) contains the following parameters for configuring the @ Figlet [Laminas\\Captcha\\Figlet] CAPTCHA algorithm attached to the form element: the class parameter (line 11) should be either the full CAPTCHA adapter class name (@ \\Laminas\\Captcha\\Figlet ) or its short alias (@ Figlet [Laminas\\Captcha\\Figlet]). the wordLen parameter (line 12) defines the length of the secret word to be generated. the expiration parameter (line 13) defines the CAPTCHA expiration period (in seconds). Now, open the \"http://localhost/contactus\" page in your web browser. Once that is done, you should see a page like in the figure 11.4 below. Once the PHP renderer processes the view template, it generates HTML markup for the CAPTCHA element like shown below: <div class=\"form-group\"> <label for=\"captcha\">Human check</label> <pre> __ _ __ __ _ _ ___ _ _ __ __ | || | || \\ \\\\/ // | \\ / || / _ \\\\ | || | || \\ \\\\/ // | '--' || \\ ` // | \\/ || | / \\ || | || | || \\ ` // | .--. || | || | . . || | \\_/ || | \\\\_/ || | || |_|| |_|| |_|| |_|\\/|_|| \\___// \\____// |_|| `-` `-` `-`' `-` `-` `---` `---` `-`' </pre> <input name=\"captcha[id]\" type=\"hidden\" value=\"b68b010eccc22e78969764461be62714\"> <input name=\"captcha[input]\" type=\"text\"> <p class=\"help-block\">Enter the letters above as you see them.</p> </div>","title":"Example 2: Adding a FIGlet CAPTCHA to the ContactForm"},{"location":"forms_advanced/#csrf-prevention","text":"Cross-site request forgery (CSRF) is a kind of hacker attack which forces the user's browser to transmit an HTTP request to an arbitrary site. Through the CSRF attack, the malicious script is able to send unauthorized commands from a user that the website trusts. This attack is typically performed on pages containing forms for submission of some sensitive data (e.g. money transfer forms, shopping carts etc.) To better understand how this attack works, take a look at figure 11.5. Figure 11.5 illustrates an example CSRF attack on a payment gateway website: You log into your account at payment gateway web site https://payment.com . Please note that the SSL-protected connection (HTTPS) is used here, but it doesn't protect from such kind of attacks. Typically, you set check on the \"Remember Me\" check box of the login form to avoid entering user name and password too often. Once you logged in to your account, your web browser saves your session information to a cookie variable on your machine. On the payment gateway site, you use the payment form https://payment.com/moneytransfer.php to buy some goods. Please note that this payment form will later be used as a vulnerability allowing to perform the CSRF attack. Next you use the same web browser to visit some website you like. Assume the website contains cool pictures http://coolpictures.com . Unfortunately, this web site is infected by a malicious script, masqueraded by an <img src=\"image.php\"> HTML tag. Once you open the HTML page in your web browser, it loads all its images, thus executing the malicious image.php script. The malicious script checks the cookie variable, and if it presents, it performs the \"session riding\" and can act on behalf of the logged in user. It is now able to submit the payment form to the payment gateway site. Note The above described CSRF attack is possible it the web form on the payment gateway site does not check the source of the HTTP request. The people who maintain the payment gateway site must put more attention in making its forms more secure. To prevent CSRF attacks to a form, one has to require a special token with the form, as follows: For certain form, generate a random sequence of bytes (token) and save it server-side in PHP session data. Add a hidden field to form and set its value with the token. Once the form is submitted by the user, compare the hidden value passed in the form with the token saved server-side. If they match, consider the form data secure. If a malicious user will try to attack the site by submitting the form, he will not be able to put right token in the form submissions, because the token is not stored in cookies.","title":"CSRF Prevention"},{"location":"forms_advanced/#example-adding-a-csrf-element-to-form","text":"In Laminas Framework, to add a CSRF protection to your form model, you use the @ Laminas\\Form\\Element\\Csrf form element class. The @ Csrf [Laminas\\Form\\Element\\Csrf] element has no visual representation (you will not see it on the screen). To insert a CSRF element to your form model, add the following lines in its addElements() method: // Add the CSRF field $this->add([ 'type' => 'csrf', 'name' => 'csrf', 'options' => [ 'csrf_options' => [ 'timeout' => 600 ] ], ]); Above, we use the @ Form [Laminas\\Form\\Form]'s add() method (line 2), to which we pass a configuration array describing the CSRF element. The element will be automatically instantiated and initialized by the factory. In line 3, we specify the class name for the CSRF element. This either may be the fully qualified class name (@ Laminas\\Form\\Element\\Csrf ) or a short alias (\"csrf\"). In line 4, we set the \"name\" attribute for the element. In this example, we use \"csrf\" name, but you may use any other name, on your choice. In line 6, inside of csrf_options array, we specify the options specific to @ Laminas\\Form\\Element\\Csrf class. We set the timeout option to 600 (look at line 7), which means the CSRF check expires in 600 seconds (10 minutes) after form creation. To render the CSRF field, in your view template .phtml file, add the following line: <?= $this->formElement($form->get('csrf')); ?> When the PHP renderer evaluates the view template, it generates the HTML markup for the CSRF field like shown below: <input type=\"hidden\" name=\"csrf\" value=\"1bc42bd0da4800fb55d16e81136fe177\"> As you can see from the HTML markup code above, the form now contains a hidden field with a randomly generated token. Since the attacker script doesn't know this token, it won't be able to submit its correct value, thus the CSRF attack becomes prevented. What happens if CSRF element validation fails? If during the form validation the CSRF check fails, the form is considered invalid and the user will see it again to fix input errors, but he won't see the error message for the CSRF element (we don't want hackers to know for sure what's wrong with the form).","title":"Example: Adding a CSRF Element to Form"},{"location":"forms_advanced/#using-validation-groups","text":"Sometimes it may be useful to temporarily disable validation of some form elements. You can do that with a feature called validation groups . By default, all form elements are validated. A validation group allows to disable validation of certain fields. For example, assume you implement a form named PaymentForm , which allows you to select a payment method of several alternatives (credit card, bank transfer and cash). If the user selects credit card , you also want him to enter the credit card number; else if user selects bank transfer , you want him to enter bank account number; and finally, if the cash is selected, user does not need to enter additional information. For this form, you will have to dynamically hide and display dependent fields in client's browser with JavaScript. How would you validate such form in your controller's action? The problem is that some fields depend on others. The card_number field is required only when payment_method is the \"credit card\", otherwise it is optional. The same is for the bank_account field - it is required only when payment_method is the \"bank transfer\". We can handle this case elegantly with the validation group. The @ Form [Laminas\\Form\\Form] class provides the setValidationGroup() method, which accepts the list of fields that you want to validate; all other fields will be suppressed and not validated. // First, we will validate the \"payment_method\" field. $form->setValidationGroup(['payment_method']); if ($form->isValid()) { $data = $form->getData(); $paymentMethod = $data['payment_method']; // Next, validate the dependent fields if ($paymentMethod=='credit_card') { $form->setValidationGroup(['payment_method', 'card_number']); } else if ($paymentMethod=='bank_account') { $form->setValidationGroup(['payment_method', 'bank_account']); } if ($form->isValid()) { $data = $form->getData(); // Do something with the data // ... } } You can see this example in action in the Form Demo sample web application bundled with this book. Just type \"http://localhost/payment\" URL in your browser.","title":"Using Validation Groups"},{"location":"forms_advanced/#implementing-multi-step-forms","text":"In this section, we will provide instructions on how to implement a multi-step form with Laminas. A multi-step form is a form having a lot of fields, and which is displayed in several steps. To store the current step and user-entered data between page requests, PHP sessions are utilized. For example, user registration can be performed in several steps: on the first step you display the page allowing to enter login and password, on the second step you display the page where the site visitor can enter his personal information, and on the third step, the visitor can enter billing information. Another example of a multi-step form is a Survey form. This form would display a question and possible variants of the answer. This form would have as many steps as many questions are in the survey. In this section we will implement the User Registration form allowing to collect information about the user being registered. You can see this complete working example in action as part of Form Demo sample web application bundled with this book.","title":"Implementing Multi-Step Forms"},{"location":"forms_advanced/#enabling-sessions","text":"Note If you are new to the PHP sessions feature, please refer to Working with Sessions before reading this section. Session support is implemented in @ Laminas\\Session component, so you have to install it if you hadn't done that before. Next, modify your APP_DIR/config/global.php config file as follows: <?php use Laminas\\Session\\Storage\\SessionArrayStorage; use Laminas\\Session\\Validator\\RemoteAddr; use Laminas\\Session\\Validator\\HttpUserAgent; return [ // Session configuration. 'session_config' => [ // Session cookie will expire in 1 hour. 'cookie_lifetime' => 60*60*1, // Store session data on server maximum for 30 days. 'gc_maxlifetime' => 60*60*24*30, ], // Session manager configuration. 'session_manager' => [ // Session validators (used for security). 'validators' => [ RemoteAddr::class, HttpUserAgent::class, ] ], // Session storage configuration. 'session_storage' => [ 'type' => SessionArrayStorage::class ], // ... ]; Then add the following lines to your module.config.php to register the UserRegistration session container: <?php return [ // ... 'session_containers' => [ 'UserRegistration' ], ]; Done! Now we can use session container in our code. Next, we will implement the RegistrationForm form model.","title":"Enabling Sessions"},{"location":"forms_advanced/#adding-registrationform","text":"The RegistrationForm form model will be used for collecting data about the user (email, full name, password, personal information and billing information). We will add elements to this form in three portions, thus allowing to use it as a multi-step form. To add the form model, create the RegistrationForm.php file in the Form directory under the Application module's source directory: <?php namespace Application\\Form; use Laminas\\Form\\Form; use Laminas\\InputFilter\\InputFilter; use Application\\Validator\\PhoneValidator; /** * This form is used to collect user registration data. This form is multi-step. * It determines which fields to create based on the $step argument you pass to * its constructor. */ class RegistrationForm extends Form { /** * Constructor. */ public function __construct($step) { // Check input. if (!is_int($step) || $step<1 || $step>3) throw new \\Exception('Step is invalid'); // Define form name parent::__construct('registration-form'); // Set POST method for this form $this->setAttribute('method', 'post'); $this->addElements($step); $this->addInputFilter($step); } /** * This method adds elements to form (input fields and submit button). */ protected function addElements($step) { if ($step==1) { // Add \"email\" field $this->add([ 'type' => 'text', 'name' => 'email', 'attributes' => [ 'id' => 'email' ], 'options' => [ 'label' => 'Your E-mail', ], ]); // Add \"full_name\" field $this->add([ 'type' => 'text', 'name' => 'full_name', 'attributes' => [ 'id' => 'full_name' ], 'options' => [ 'label' => 'Full Name', ], ]); // Add \"password\" field $this->add([ 'type' => 'password', 'name' => 'password', 'attributes' => [ 'id' => 'password' ], 'options' => [ 'label' => 'Choose Password', ], ]); // Add \"confirm_password\" field $this->add([ 'type' => 'password', 'name' => 'confirm_password', 'attributes' => [ 'id' => 'confirm_password' ], 'options' => [ 'label' => 'Type Password Again', ], ]); } else if ($step==2) { // Add \"phone\" field $this->add([ 'type' => 'text', 'name' => 'phone', 'attributes' => [ 'id' => 'phone' ], 'options' => [ 'label' => 'Mobile Phone', ], ]); // Add \"street_address\" field $this->add([ 'type' => 'text', 'name' => 'street_address', 'attributes' => [ 'id' => 'street_address' ], 'options' => [ 'label' => 'Street address', ], ]); // Add \"city\" field $this->add([ 'type' => 'text', 'name' => 'city', 'attributes' => [ 'id' => 'city' ], 'options' => [ 'label' => 'City', ], ]); // Add \"state\" field $this->add([ 'type' => 'text', 'name' => 'state', 'attributes' => [ 'id' => 'state' ], 'options' => [ 'label' => 'State', ], ]); // Add \"post_code\" field $this->add([ 'type' => 'text', 'name' => 'post_code', 'attributes' => [ 'id' => 'post_code' ], 'options' => [ 'label' => 'Post Code', ], ]); // Add \"country\" field $this->add([ 'type' => 'select', 'name' => 'country', 'attributes' => [ 'id' => 'country', ], 'options' => [ 'label' => 'Country', 'empty_option' => '-- Please select --', 'value_options' => [ 'US' => 'United States', 'CA' => 'Canada', 'BR' => 'Brazil', 'GB' => 'Great Britain', 'FR' => 'France', 'IT' => 'Italy', 'DE' => 'Germany', 'RU' => 'Russia', 'IN' => 'India', 'CN' => 'China', 'AU' => 'Australia', 'JP' => 'Japan' ], ], ]); } else if ($step==3) { // Add \"billing_plan\" field $this->add([ 'type' => 'select', 'name' => 'billing_plan', 'attributes' => [ 'id' => 'billing_plan', ], 'options' => [ 'label' => 'Billing Plan', 'empty_option' => '-- Please select --', 'value_options' => [ 'Free' => 'Free', 'Bronze' => 'Bronze', 'Silver' => 'Silver', 'Gold' => 'Gold', 'Platinum' => 'Platinum' ], ], ]); // Add \"payment_method\" field $this->add([ 'type' => 'select', 'name' => 'payment_method', 'attributes' => [ 'id' => 'payment_method', ], 'options' => [ 'label' => 'Payment Method', 'empty_option' => '-- Please select --', 'value_options' => [ 'Visa' => 'Visa', 'MasterCard' => 'Master Card', 'PayPal' => 'PayPal' ], ], ]); } // Add the CSRF field $this->add([ 'type' => 'csrf', 'name' => 'csrf', 'attributes' => [], 'options' => [ 'csrf_options' => [ 'timeout' => 600 ] ], ]); // Add the submit button $this->add([ 'type' => 'submit', 'name' => 'submit', 'attributes' => [ 'value' => 'Next Step', 'id' => 'submitbutton', ], ]); } /** * This method creates input filter (used for form filtering/validation). */ private function addInputFilter($step) { $inputFilter = new InputFilter(); $this->setInputFilter($inputFilter); if ($step==1) { $inputFilter->add([ 'name' => 'email', 'required' => true, 'filters' => [ ['name' => 'StringTrim'], ], 'validators' => [ [ 'name' => 'EmailAddress', 'options' => [ 'allow' => \\Laminas\\Validator\\Hostname::ALLOW_DNS, 'useMxCheck' => false, ], ], ], ]); $inputFilter->add([ 'name' => 'full_name', 'required' => true, 'filters' => [ ['name' => 'StringTrim'], ['name' => 'StripTags'], ['name' => 'StripNewlines'], ], 'validators' => [ [ 'name' => 'StringLength', 'options' => [ 'min' => 1, 'max' => 128 ], ], ], ]); // Add input for \"password\" field $inputFilter->add([ 'name' => 'password', 'required' => true, 'filters' => [ ], 'validators' => [ [ 'name' => 'StringLength', 'options' => [ 'min' => 6, 'max' => 64 ], ], ], ]); // Add input for \"confirm_password\" field $inputFilter->add([ 'name' => 'confirm_password', 'required' => true, 'filters' => [ ], 'validators' => [ [ 'name' => 'Identical', 'options' => [ 'token' => 'password', ], ], ], ]); } else if ($step==2) { $inputFilter->add([ 'name' => 'phone', 'required' => true, 'filters' => [ ], 'validators' => [ [ 'name' => 'StringLength', 'options' => [ 'min' => 3, 'max' => 32 ], ], [ 'name' => PhoneValidator::class, 'options' => [ 'format' => PhoneValidator::PHONE_FORMAT_INTL ] ], ], ]); // Add input for \"street_address\" field $inputFilter->add([ 'name' => 'street_address', 'required' => true, 'filters' => [ ['name' => 'StringTrim'], ], 'validators' => [ ['name'=>'StringLength', 'options'=>['min'=>1, 'max'=>255]] ], ]); // Add input for \"city\" field $inputFilter->add([ 'name' => 'city', 'required' => true, 'filters' => [ ['name' => 'StringTrim'], ], 'validators' => [ ['name'=>'StringLength', 'options'=>['min'=>1, 'max'=>255]] ], ]); // Add input for \"state\" field $inputFilter->add([ 'name' => 'state', 'required' => true, 'filters' => [ ['name' => 'StringTrim'], ], 'validators' => [ ['name'=>'StringLength', 'options'=>['min'=>1, 'max'=>32]] ], ]); // Add input for \"post_code\" field $inputFilter->add([ 'name' => 'post_code', 'required' => true, 'filters' => [ ], 'validators' => [ ['name' => 'IsInt'], ['name'=>'Between', 'options'=>['min'=>0, 'max'=>999999]] ], ]); // Add input for \"country\" field $inputFilter->add([ 'name' => 'country', 'required' => false, 'filters' => [ ['name' => 'Alpha'], ['name' => 'StringTrim'], ['name' => 'StringToUpper'], ], 'validators' => [ ['name'=>'StringLength', 'options'=>['min'=>2, 'max'=>2]] ], ]); } else if ($step==3) { // Add input for \"billing_plan\" field $inputFilter->add([ 'name' => 'billing_plan', 'required' => true, 'filters' => [ ], 'validators' => [ [ 'name' => 'InArray', 'options' => [ 'haystack'=>[ 'Free', 'Bronze', 'Silver', 'Gold', 'Platinum' ] ] ] ], ]); // Add input for \"payment_method\" field $inputFilter->add([ 'name' => 'payment_method', 'required' => true, 'filters' => [ ], 'validators' => [ [ 'name' => 'InArray', 'options' => [ 'haystack'=>[ 'PayPal', 'Visa', 'MasterCard', ] ] ] ], ]); } } } As you can see from the code above, the RegistrationForm is a usual form model, but it accepts the $step argument in its constructor allowing to specify what form elements to use on the current step.","title":"Adding RegistrationForm"},{"location":"forms_advanced/#adding-registrationcontroller","text":"Next, we'll add the RegistrationController controller class. To do that, create the RegistrationController.php file under the Controller directory and add the following code into it: <?php namespace Application\\Controller; use Laminas\\Mvc\\Controller\\AbstractActionController; use Laminas\\View\\Model\\ViewModel; use Application\\Form\\RegistrationForm; use Laminas\\Session\\Container; /** * This is the controller class displaying a page with the User Registration form. * User registration has several steps, so we display different form elements on * each step. We use session container to remember user's choices on the previous * steps. */ class RegistrationController extends AbstractActionController { /** * Session container. * @var Laminas\\Session\\Container */ private $sessionContainer; /** * Constructor. Its goal is to inject dependencies into controller. */ public function __construct($sessionContainer) { $this->sessionContainer = $sessionContainer; } /** * This is the default \"index\" action of the controller. It displays the * User Registration page. */ public function indexAction() { // Determine the current step. $step = 1; if (isset($this->sessionContainer->step)) { $step = $this->sessionContainer->step; } // Ensure the step is correct (between 1 and 3). if ($step<1 || $step>3) $step = 1; if ($step==1) { // Init user choices. $this->sessionContainer->userChoices = []; } $form = new RegistrationForm($step); // Check if user has submitted the form if($this->getRequest()->isPost()) { // Fill in the form with POST data $data = $this->params()->fromPost(); $form->setData($data); // Validate form if($form->isValid()) { // Get filtered and validated data $data = $form->getData(); // Save user choices in session. $this->sessionContainer->userChoices[\"step$step\"] = $data; // Increase step $step ++; $this->sessionContainer->step = $step; // If we completed all 3 steps, redirect to Review page. if ($step>3) { return $this->redirect()->toRoute('registration', ['action'=>'review']); } // Go to the next step. return $this->redirect()->toRoute('registration'); } } $viewModel = new ViewModel([ 'form' => $form ]); $viewModel->setTemplate(\"application/registration/step$step\"); return $viewModel; } /** * The \"review\" action shows a page allowing to review data entered on previous * three steps. */ public function reviewAction() { // Validate session data. if(!isset($this->sessionContainer->step) || $this->sessionContainer->step<=3 || !isset($this->sessionContainer->userChoices)) { throw new \\Exception('Sorry, the data is not available for review yet'); } // Retrieve user choices from session. $userChoices = $this->sessionContainer->userChoices; return new ViewModel([ 'userChoices' => $userChoices ]); } } In the class above, we have three methods: The __construct() constructor is used to inject the dependency - the session container - into the controller. The indexAction() action method extracts the current step from session and initializes the form model. If the user has submitted the form, we extract data from form and save it to session, incrementing the step. If the step is greater than 3, we redirect the user to the \"Review\" page. The reviewAction() action method extracts the data entered by the user on all three steps and passes it to the view for rendering.","title":"Adding RegistrationController"},{"location":"forms_advanced/#adding-registrationcontrollerfactory","text":"Next, we add the factory for the RegistrationController . To do that, add the RegistrationControllerFactory.php file inside the Controller/Form directory under the module's source directory. Put the following code into it: <?php namespace Application\\Controller\\Factory; use Interop\\Container\\ContainerInterface; use Laminas\\ServiceManager\\Factory\\FactoryInterface; use Application\\Controller\\RegistrationController; /** * This is the factory for RegistrationController. Its purpose is to instantiate the * controller and inject dependencies into it. */ class RegistrationControllerFactory implements FactoryInterface { public function __invoke(ContainerInterface $container, $requestedName, array $options = null) { $sessionContainer = $container->get('UserRegistration'); // Instantiate the controller and inject dependencies return new RegistrationController($sessionContainer); } } Do not forget to register the controller in the module.config.php file!","title":"Adding RegistrationControllerFactory"},{"location":"forms_advanced/#adding-view-templates","text":"Now, let's add the view templates for the controller actions. We have four view templates: step1.phtml , step2.phtml , step3.phtml and review.phtml . The first three ones are used by the indexAction() and the last is used by the reviewAction() . Add step1.phtml file inside the application/registration directory and put the following code into it: <?php $form->get('email')->setAttributes([ 'class'=>'form-control', 'placeholder'=>'name@yourcompany.com' ]); $form->get('full_name')->setAttributes([ 'class'=>'form-control', 'placeholder'=>'John Doe' ]); $form->get('password')->setAttributes([ 'class'=>'form-control', 'placeholder'=>'Type password here (6 characters at minimum)' ]); $form->get('confirm_password')->setAttributes([ 'class'=>'form-control', 'placeholder'=>'Repeat password' ]); $form->get('submit')->setAttributes(array('class'=>'btn btn-primary')); $form->prepare(); ?> <h1>User Registration - Step 1</h1> <div class=\"row\"> <div class=\"col-md-6\"> <?= $this->form()->openTag($form); ?> <div class=\"form-group\"> <?= $this->formLabel($form->get('email')); ?> <?= $this->formElement($form->get('email')); ?> <?= $this->formElementErrors($form->get('email')); ?> </div> <div class=\"form-group\"> <?= $this->formLabel($form->get('full_name')); ?> <?= $this->formElement($form->get('full_name')); ?> <?= $this->formElementErrors($form->get('full_name')); ?> </div> <div class=\"form-group\"> <?= $this->formLabel($form->get('password')); ?> <?= $this->formElement($form->get('password')); ?> <?= $this->formElementErrors($form->get('password')); ?> </div> <div class=\"form-group\"> <?= $this->formLabel($form->get('confirm_password')); ?> <?= $this->formElement($form->get('confirm_password')); ?> <?= $this->formElementErrors($form->get('confirm_password')); ?> </div> <div class=\"form-group\"> <?= $this->formElement($form->get('submit')); ?> </div> <?= $this->formElement($form->get('csrf')); ?> <?= $this->form()->closeTag(); ?> </div> </div> Next, add step2.phtml file inside the application/registration directory and put the following code into it: <?php $form->get('phone')->setAttributes([ 'class'=>'form-control', 'placeholder'=>'Phone number in international format' ]); $form->get('street_address')->setAttributes([ 'class'=>'form-control', ]); $form->get('city')->setAttributes([ 'class'=>'form-control', ]); $form->get('state')->setAttributes([ 'class'=>'form-control', ]); $form->get('post_code')->setAttributes([ 'class'=>'form-control', ]); $form->get('country')->setAttributes([ 'class'=>'form-control' ]); $form->get('submit')->setAttributes(array('class'=>'btn btn-primary')); $form->prepare(); ?> <h1>User Registration - Step 2 - Personal Information</h1> <div class=\"row\"> <div class=\"col-md-6\"> <?= $this->form()->openTag($form); ?> <div class=\"form-group\"> <?= $this->formLabel($form->get('phone')); ?> <?= $this->formElement($form->get('phone')); ?> <?= $this->formElementErrors($form->get('phone')); ?> </div> <div class=\"form-group\"> <?= $this->formLabel($form->get('street_address')); ?> <?= $this->formElement($form->get('street_address')); ?> <?= $this->formElementErrors($form->get('street_address')); ?> </div> <div class=\"form-group\"> <?= $this->formLabel($form->get('city')); ?> <?= $this->formElement($form->get('city')); ?> <?= $this->formElementErrors($form->get('city')); ?> </div> <div class=\"form-group\"> <?= $this->formLabel($form->get('state')); ?> <?= $this->formElement($form->get('state')); ?> <?= $this->formElementErrors($form->get('state')); ?> </div> <div class=\"form-group\"> <?= $this->formLabel($form->get('post_code')); ?> <?= $this->formElement($form->get('post_code')); ?> <?= $this->formElementErrors($form->get('post_code')); ?> </div> <div class=\"form-group\"> <?= $this->formLabel($form->get('country')); ?> <?= $this->formElement($form->get('country')); ?> <?= $this->formElementErrors($form->get('country')); ?> </div> <div class=\"form-group\"> <?= $this->formElement($form->get('submit')); ?> </div> <?= $this->formElement($form->get('csrf')); ?> <?= $this->form()->closeTag(); ?> </div> </div> Next, add step3.phtml file inside the application/registration directory and put the following code into it: <?php $form->get('billing_plan')->setAttributes([ 'class'=>'form-control', ]); $form->get('payment_method')->setAttributes([ 'class'=>'form-control', ]); $form->get('submit')->setAttributes(array('class'=>'btn btn-primary')); $form->prepare(); ?> <h1>User Registration - Step 3 - Billing Information</h1> <div class=\"row\"> <div class=\"col-md-6\"> <?= $this->form()->openTag($form); ?> <div class=\"form-group\"> <?= $this->formLabel($form->get('billing_plan')); ?> <?= $this->formElement($form->get('billing_plan')); ?> <?= $this->formElementErrors($form->get('billing_plan')); ?> </div> <div class=\"form-group\"> <?= $this->formLabel($form->get('payment_method')); ?> <?= $this->formElement($form->get('payment_method')); ?> <?= $this->formElementErrors($form->get('payment_method')); ?> </div> <div class=\"form-group\"> <?= $this->formElement($form->get('submit')); ?> </div> <?= $this->formElement($form->get('csrf')); ?> <?= $this->form()->closeTag(); ?> </div> </div> And finally, add review.phtml file inside the application/registration directory and put the following code into it: <h1>User Registration - Review</h1> <p>Thank you! Now please review the data you entered in previous three steps.</p> <pre> <?php print_r($userChoices); ?> </pre>","title":"Adding View Templates"},{"location":"forms_advanced/#adding-route","text":"Add the following route inside your module.config.php config file: 'registration' => [ 'type' => Segment::class, 'options' => [ 'route' => '/registration[/:action]', 'constraints' => [ 'action' => '[a-zA-Z][a-zA-Z0-9_-]*' ], 'defaults' => [ 'controller' => Controller\\RegistrationController::class, 'action' => 'index', ], ], ], Great! Now everything is ready for seeing the results!","title":"Adding Route"},{"location":"forms_advanced/#results","text":"To see our multi-step form in action, enter the \"http://localhost/registration\" URL into your browser's navigation bar. The User Registration - Step 1 page appears (see figure 11.6 below): Once the user enters his E-mail, full name and password and clicks Next , he is redirected to the next step (see figure 11.7): And the final step is shown in figure 11.8 below: Clicking Next results in displaying the Review page allowing to see the data entered on the previous three steps: You can find this complete example in the Form Demo sample application bundled with this book.","title":"Results"},{"location":"forms_advanced/#summary","text":"In this chapter, we have discussed some advanced form usage capabilities. Laminas Framework provides two classes whose purpose is enhancing form security: @ Captcha and @ Csrf [Laminas\\Form\\Element\\Csrf]. A CAPTCHA is a type of challenge-response test used to determine whether or not the user is a human. CAPTCHA elements are used on form to prevent form submission by a malicious automated process (a robot). The latter element, @ Csrf [Laminas\\Form\\Element\\Csrf], is used for Cross-Site Request Forgery (abbreviated as CSRF) hacker attack prevention. We have also learned of how to implement a multi-step forms with the help of sessions. The adapter is a design pattern that translates one interface for a class into a compatible interface, which helps two (or several) incompatible interfaces to work together. Typically, CAPTCHA algorithms have different public methods, but since they all implement @ AbstractAdapter [Laminas\\Captcha\\AdapterInterface] interface, the caller may use any CAPTCHA algorithm in the same common manner (by calling the methods provided by the base interface). \u21a9 In the latter case (configuration array), the CAPTCHA algorithm will be automatically instantiated and initialized by the factory class @ Laminas\\Captcha\\Factory . \u21a9","title":"Summary"},{"location":"intro/","text":"Introduction to Laminas Framework In this chapter you will learn about Laminas Framework, its main principles and components. What is Laminas Framework? PHP is a popular website development language. However, writing websites in pure PHP is difficult. If you write a web application in pure PHP, you'll have to organize your code in some way, collect and validate user input, implement support of user authentication and access control, manage database, test your code and so on. As your site grows in size, it becomes more and more difficult to develop the code in consistent manner. Each developer in your team applies his/her favourite custom coding styles and patterns. The code becomes overcomplicated, slow and difficult to support. You merge all your code in a single giant script with no separation of concerns. You have to reinvent the wheel many times and that causes security problems. Moreover, when you switch to the development of a new site you will notice that a large portion of the code you have already written for the old website can be used again with small modifications. This code can be separated in a library. This is how frameworks appeared. What is a Framework? A framework is some kind of a library, a piece of software (also written in PHP) providing web developers with code base and consistent standardized ways of creating web applications. Laminas Framework is a free and open-source PHP framework. Its development is guided (and sponsored) by Laminas Technologies, who is also known as the vendor of the PHP language. The first version (Laminas Framework 1) was released in 2007; Laminas Framework 2, the second version of this software, was released in September 2012. Laminas Framework (or shortly Laminas) was released in June 2016. Laminas Framework provides you with the following capabilities: Develop your website much faster than when you write it in pure PHP. Laminas provides many components that can be used as a code base for creating your website. Easier cooperation with other members of your site building team. Model-View-Controller pattern used by Laminas allows to separate business logic and presentation layer of your website, making its structure consistent and maintainable. Scale your website with the concept of modules. Laminas uses the term module , allowing to separate decoupled site parts, thus allowing to reuse models, views, controllers and assets of your website in other works. Accessing database in an object-oriented way. Instead of directly interacting with the database using SQL queries, you can use Doctrine Object-Relational Mapping (ORM) to manage the structure and relationships between your data. With Doctrine you map your database table to a PHP class (also called an entity class) and a row from that table is mapped to an instance of that class. Doctrine allows to abstract of database type and make code easier to understand. Write secure web sites with laminas-provided components like form input filters and validators, HTML output escapers and cryptography algorithms, human check (Captcha) and Cross-Site Request Forgery (CSRF) form elements. An Example PHP Website To demonstrate you how difficult it is to write a website without a PHP framework, here we will write a very simple website consisting of three HTML pages: Home , Login and Logout . For this example, we won't use any framework and will try to use only \"pure\" PHP. Note Don't be confused - writing a website with a PHP framework may also be difficult, but with a framework you will do that in a consistent and secure manner. Home Page First, let's implement the Home page for the website. To do that, create the index.php file in your Apache document root directory and put the following code into it: Note To understand the code below, you need to have some experience with PHP. If you have no experience with PHP, it would be good if you refer to some PHP tutorial, like w3schools.com . When you write a website in PHP, you put your code into a file with the .php extension. Such a file is called a PHP script . <?php // index.php session_start(); // If user is logged in, retrieve identity from session. $identity = null; if (isset($_SESSION['identity'])) { $identity = $_SESSION['identity']; } ?> <!DOCTYPE html> <html> <head> <title>Home page</title> </head> <body> <h1>Home</h1> <?php if ($identity==null): ?> <a href=\"login.php\">Sign in</a> <?php else: ?> <strong>Welcome, <?= $identity ?></strong> <a href=\"logout.php\">Sign out</a> <?php endif; ?> <p> This is a simple website to demonstrate the advantages of a PHP framework and disadvantages of \"pure\" PHP. </p> </body> </html> If you now enter the \"http://localhost/index.php\" in your browser (like Google Chrome or Firefox), you should see the page like below: Login Page Next, let's implement the Login page. Such a page would have a form with the E-mail and Password fields. Once the user submits the form, he passes the authentication and his identity is saved to PHP session. The script would look like below: <?php // login.php session_start(); // If user is logged in, redirect him to index.php if (isset($_SESSION['identity'])) { header('Location: index.php'); exit; } // Check if form is submitted. $submitted = false; if ($_SERVER['REQUEST_METHOD']=='POST') { $submitted = true; // Extract form data. $email = $_POST['email']; $password = $_POST['password']; // Authenticate user. $authenticated = false; if ($email=='admin@example.com' && $password=='Secur1ty') { $authenticated = true; // Save identity to session. $_SESSION['identity'] = $email; // Redirect the user to index.php. header('Location: index.php'); exit; } } ?> <!DOCTYPE html> <html> <head> <title>Login page</title> </head> <body> <h1>Sign in</h1> <?php if ($submitted && !$authenticated): ?> <div class=\"alert\"> Invalid credentials. </div> <?php endif; ?> <form name=\"login-form\" action=\"/login.php\" method=\"POST\"> <label for=\"email\">E-mail</label> <input type=\"text\" name=\"email\"> <br> <label for=\"password\">Password</label> <input type=\"password\" name=\"password\"> <br> <input type=\"submit\" name=\"submit\" value=\"Sign In\"> </form> </body> </html> If you open the \"http://localhost/login.php\" URL in your browser, you should see something like below: To log in, use the admin@example.com and Secur1ty as your E-mail and password, respectively. Logout Page And finally, let's implement the Logout page that will clear user identity from session: <?php // logout.php session_start(); unset($_SESSION['identity']); header('Location: index.php'); exit; The complete code of this simple website can be found in Pure PHP sample bundled with this book. Reviewing the Code The above scripts are not only a typical example of a \"pure\" PHP website. It is also an example of how you should not write your websites (even simple websites). What's bad about it? The index.php and login.php scripts tend to merge all the code into a single file. You do not have any separation of concerns, which makes your code too much complex. Intuitively, you understand that it would be more convenient to split the code responsible for user authentication and the code responsible for presentation (HTML rendering). The URLs of your web pages look ugly (for example, \"http://localhost/index.php\"). We would like to hide that .php extension at all. And what happens when a web user tries to visit a page that doesn't exist? We would like to redirect the user to an error page in such case. What if this website grows in size? How would you organise your code? A PHP script per web-page? And what if you want to reuse some of your PHP scripts in other websites without changes? Intuitively you might understand that it would be useful to organise the code in some kind of reusable modules . Both index.php and login.php scripts contain common HTML markup. Why do we copy & paste this common layout in every PHP script? We would like to reuse the same master layout on all (or almost all) pages. The login.php script has problems with security, because we didn't implement any validation of POST variables. PHP session is also subject to hacking. And the login.php PHP script will be located under the Apache document root directory, which is not very secure (it would be better to place it in a place not accessible for web users). The index.php is also insecure, because we did not filter the PHP output (it is subject to XSS attacks). These scripts don't use any PHP classes. Encapsulating functionality into classes in theory would make the code well structured and easy to support. In these scripts you have to write your own implementation of user authentication (and so on). Why do we reinvent the wheel and not use a well-designed library for that? The above problems are easily solved when you write a website within a framework (like Laminas Framework): In Laminas, you use the Model-View-Controller design pattern, splitting your PHP code into models (the code responsible for authentication would go here), views (the code responsible for HTML rendering would go here) and controllers (the code responsible for retrieving POST variables would go here). The Laminas routing allows to make URLs professionally looking by hiding the .php extensions. How URLs can look like are defined by strict rules. If a user tries to see a non-existing page, he is automatically redirected to a standard error page. In Laminas, you can use the concept of module . This allows to conveniently separate your models, views and controllers in autonomous unit (module) and easily reuse that unit in another project. In Laminas you can define a common layout view template and reuse it on all (or most) web pages. Laminas provides you various security features like form filters and validators, output escapers, session validators, cryptography algorithms and so on. In a Laminas website, only index.php is accessible for web users, all other PHP scripts are located outside of Apache document root directory. In a Laminas website, you put your code into classes, which makes it well-organised. Laminas provides you many components that you can use in your website: a component for authentication, a component for working with forms, and so on. Now you may have some idea of the advantages of Laminas Framework and what it can do for you. In the next sections, we will describe Laminas in more details. License Laminas Framework is licensed under BSD-like license, allowing you to use it in both commercial and free applications. You can even modify the library code and release it under another name. The only thing you cannot do is to remove the copyright notice from the code. If you use Laminas Framework, it is also recommended that you mention about it in your site's documentation or on About page. Below, the Laminas Framework license text is presented. Copyright (c) 2005-2016, Laminas Technologies USA, Inc. All rights reserved. Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. * Neither the name of Laminas Technologies USA, Inc. nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. User Support Support is an important thing to consider when deciding whether to use the framework as the base for your web site or not. Support includes well written documentation, webinars, community forums and (optionally) commercial support services, like trainings and certification programs. Documentation . Documentation for Laminas Framework is located by this address . It includes beginner's tutorials and programmers manual. API Reference can be found by this link . Community Forum . You can ask a question about using Laminas Framework at Laminas Discourse . Your questions will be answered by the large community of Laminas developers like you. Stack Overflow . You can ask as well a question about using Laminas Framework at StackOverflow . Want some more Laminas resources? Check out this awesome list of Laminas Framework resources . Framework Source Code The source code of Laminas Framework is stored in GitHub repositories . There is a separate repository per each Laminas component. In most cases you won't need to get the code of Laminas Framework manually. Instead, you will install it with Composer dependency manager. We will become familiar with Composer later in a chapter called Laminas Skeleton Application . Coding Standards It is a good practice to introduce some common coding standard for all your code. This standard would define class naming rules, code formatting rules, etc. Laminas Framework defines such standard here . All the code in Laminas follows the rules described in that document. If you plan to write a laminas-based website, it is recommended that you follow the same standard for your own code. This will make your code consistent and easier to extend and support by other people. Supported Operating Systems As any PHP web-site, laminas-based web application can work on a Linux server and on any other operating system where PHP can run. For instance, for creating samples for this book, the author used Ubuntu Linux operating system. If you do not know yet what OS to use for your web development, it is recommended for you to use Linux, because most server software operates on Linux servers. You can refer to Appendix A. Configuring Web Development Environment for some instructions on configuring your development environment. Server Requirements Laminas Framework requires that your server have PHP version 5.6 (or later) installed. Note that this is a rather strict requirement. Not all cheap shared hostings and not all private servers have such a modern PHP version. Moreover, the recommended way of installing Laminas (and other components your app depends on) is using Composer . This forces the need of shell access (SSH) to be able to execute Composer command-line tool. Some web hostings provide FTP access only, so you won't be able to install a laminas-based web app on such servers the usual way. Laminas utilizes URL rewriting extension for redirecting web-users to entry script of your site (you have to enable Apache's mod_rewrite module.) You may also need to install some PHP extensions, like memcached . This can be a difficulty when using a shared web hosting and requires that you have admin rights on your server. So, if you are planning to use Laminas on a shared web hosting, think twice. The best server to install Laminas on is a server with the latest version of PHP and with shell access to be able to execute Composer and install PHP extensions. If your company manages its own server infrastructure and can afford upgrading PHP version to the latest one, you can install Laminas on your private server. An acceptable alternative is installing a laminas-based web application to a cloud-based hosting service, like Amazon Web Services . Amazon provides Linux server instances as a part of EC2 service. EC2 is rather cheap, and it provides a free usage tier letting you try it for free for one year. We provide instructions for beginners on how to install a Laminas website to Amazon EC2 cloud in Appendix E. Installing a Laminas Web Application to Amazon EC2 . Security Laminas Framework follows best practices to provide you with a secure code base for your web sites. Laminas creators release security patches once the community of users finds a problem. You can incorporate those fixes with a single command through Composer dependency manager. Note Practice shows that using a framework for writing your website is more secure than using \"pure\" PHP, because you don't need to reinvent the wheel. Most security vulnerabilities in frameworks are already known and fixed by the community of users. Laminas provides the following features allowing to make your web site secure: Entry Script ( index.php ) is the only PHP file accessible to web visitors. All other PHP files are located outside of Apache document root. This is much more secure than allowing everyone to visit any of your PHP scripts. Routing allows to define strict rules on how an acceptable page URL should look like. If a site user enters an invalid URL in a web browser's navigation bar, he/she is automatically redirected to an error page. Access control lists (ACL) and Role-Based Access Control (RBAC) allow to define flexible rules for granting or denying access to certain resources of your web site. For example, an anonymous user would have access to your index page only, authenticated users would have access to their profile page, and the administrator user would have access to site management panel. Form validators and filters ensure that no unwanted data is collected through web forms. Filters, for example, allow to trim strings or strip HTML tags. Validators are used to check that the data that had been submitted through a form conforms to certain rules. For example, E-mail validator checks that an E-mail field contains valid E-mail address, and if not, raises an error forcing the site user to correct the input error. Captcha and CSRF (Cross-Site Request Forgery) form elements are used for human checks and hacker attack prevention, respectively. Laminas\\Escaper component allows to strip unwanted HTML tags from data outputted to site pages. Cryptography support allows you to store your sensitive data (e.g. credentials) encrypted with strong crypt algorithms that are difficult to hack. Performance Laminas provides the following features to ensure its performance is acceptable: Lazy class autoloading. Classes are loaded once needed. You don't have to write require_once for each class you want to load. Instead, the framework automatically discovers your classes using the autoloader feature. Efficient service and plugin loading. In Laminas, classes are instantiated only when they really need to. This is achieved through service manager (the central container for services of your application). Support of caching. PHP has several caching extensions (like Memcached) that can be used to speed-up laminas-based websites. Caching saves frequently used data to memory to speed-up data retrieval. Design Patterns Laminas Framework creators are big fans of various design patterns. Although you don't have to understand patterns to read this book, this section is intended to give you an idea of what design patterns Laminas is based on. Model-View-Controller (MVC) pattern . Model-View-Controller pattern is used in all modern PHP frameworks. In an MVC-application you separate your code into three categories: models (your business logic go here), views (your presentation goes here) and controllers (code responsible for interaction with user goes here). This is also called the separation of concerns . With MVC, you can reuse your components. It is also easy to substitute any part of this triad. For example, you can easily replace a view with another one, without changing your business logic. Domain Driven Design (DDD) pattern . In Laminas Framework, by convention, you will have model layer further divided into entities (classes mapped on database tables), repositories (classes used to retrieve entities from database), value objects (model classes not having identity), services (classes responsible for business logic). Aspect Oriented Design pattern. In Laminas, everything is event-driven. When a site user requests a page, an event is generated (triggered). A listener (or observer) can catch event and do something with it. For example, @ Laminas\\Router component parses the URL and determines what controller class to call. When the event finally reaches the page renderer, an HTTP response is generated and the user sees the web page. Singleton pattern. In Laminas, there is the service manager object which is the centralized container of all services available in the application. Each service exists in a single instance only. Strategy pattern. A strategy is just a class encapsulating some algorithm. And you can use different algorithms based on some condition. For example, the page renderer has several rendering strategies, making it possible to render web pages differently (the renderer can generate an HTML page, a JSON response, an RSS feed etc.) Adapter pattern. Adapters allow to adapt a generic class to concrete use case. For example, @ Laminas\\Db component provides access to database in a generic way. Internally, it uses adapters for each supported database (SQLite, MySQL, PostgreSQL and so on.) Factory pattern. You can create an instance of a class using the new operator. Or you can create it with a factory. A factory is just a class encapsulating creation of other objects. Factories are useful, because they simplify dependency injection. Using factories also simplifies the testing of your model and controller classes. Main Laminas Components Laminas developers believe that the framework should be a set of decoupled components with minimum dependencies on each other. This is how Laminas is organized. The idea was to let you use some selected Laminas components alone, even if you write your site with another framework. This becomes even easier, keeping in mind that each component of Laminas is a Composer-installable package, so you can easily install any laminas-component together with its dependencies through a single command. There are several \"main\" Laminas components that are used (either explicitly or implicitly) in almost any web application: @ Laminas\\EventManager component allows to send events and register listeners to react to them. @ Laminas\\ModuleManager . In Laminas, every application consists of modules and this component contains module loading functionality. @ Laminas\\ServiceManager . This is the centralized registry of all services available in the application, making it possible to access services from any point of the web site. @ Laminas\\Http provides an easy interface for performing Hyper-Text Transfer Protocol (HTTP) requests. @ Laminas\\Mvc . Support of Model-View-Controller pattern and separation of business logic from presentation. @ Laminas\\View . Provides a system of helpers, output filters, and variable escaping. Used in presentation layer. @ Laminas\\Form . Web form data collection, filtering, validation and rendering. @ Laminas\\InputFilter . Provides an ability to define form data validation rules. @ Laminas\\Filter . Provides a set of commonly used data filters, like string trimmer. @ Laminas\\Validator . Provides a set of commonly used validators. Differences with Laminas Framework 2 For readers who have an experience in Laminas Framework 2, in this section we'll give some information on what has changed in Laminas Framework. Below, the main technical differences between ZF2 and Laminas are presented: Backward Compatibility Laminas is an evolutionary release, so backward compatibility is preserved in most cases. However, some migration work still has to be done if you used ServiceLocatorAwareInterface across your code (which you probably did). In Laminas, this interface has been removed, and now all dependencies must be injected through factories. So, you'll have to create factories for the most of your controllers, services, view helpers and controller plugins. Components In ZF2, components were stored in a single GIT repository. In Laminas, components are stored in multiple GIT repositories, one repository per component (for example, laminas/laminas-mvc , laminas/laminas-servicemanager , laminas/laminas-form , etc). This allows to develop and release components independently of each other. Components are even more decoupled than before and have minimum dependencies on each other. @ Laminas\\Mvc component has been divided into several ones. For example, routing functionality has been moved to new @ Laminas\\Router component. You are now recommended to specify individual component names your app depends on in composer.json , although it is still possible to depend on laminas/laminas package, which is a meta package installing all available components. Component Installer In Laminas, a special Composer plugin called component installer was introduced. It allows to install components as ZF modules. It injects information about the component into the application configuration file. ServiceManager and EventManager Performance Laminas developers did a great job improving performance of @ Laminas\\ServiceManager and @ Laminas\\EventManager components. They are now about several times faster than before. The disadvantage is that you now have to do some migration work to use the new functionality. Controller and service names are now recommended to utilize the PHP 5.5 feature called ::class . For example, if previously you registered your controller as Application\\Controller\\Index , now you will register it as IndexController::class . If previously you registered service names as you wished, now you are recommended to do that using ServiceClassName::class . Read the documentation for Mvc component for additional information. PSR-4 In ZF2, the recommended directory structure was PSR-0, while in Laminas it is PSR-4. This requires some (small) migration work. Middleware Laminas believes that the future of PHP is in middleware. \"Middleware is, quite simply, code sitting between an incoming HTTP request, and the outgoing HTTP response.\" Now you can register a middleware listener in an MVC application. Focus on Documentation Now each component repository contains its own documentation. Documentation is now in Markdown format and has become better designed. Summary A PHP framework is a library, giving you the code base and defining consistent ways of creating web applications. Laminas Framework is a modern web development framework created by Laminas Technologies, the vendor of PHP language. It provides the developers with outstanding capabilities for building scalable and secure web sites. Laminas is licensed under BSD-like license and can be used for free in both commercial and open-source applications.","title":"Introduction to Laminas Framework"},{"location":"intro/#introduction-to-laminas-framework","text":"In this chapter you will learn about Laminas Framework, its main principles and components.","title":"Introduction to Laminas Framework"},{"location":"intro/#what-is-laminas-framework","text":"PHP is a popular website development language. However, writing websites in pure PHP is difficult. If you write a web application in pure PHP, you'll have to organize your code in some way, collect and validate user input, implement support of user authentication and access control, manage database, test your code and so on. As your site grows in size, it becomes more and more difficult to develop the code in consistent manner. Each developer in your team applies his/her favourite custom coding styles and patterns. The code becomes overcomplicated, slow and difficult to support. You merge all your code in a single giant script with no separation of concerns. You have to reinvent the wheel many times and that causes security problems. Moreover, when you switch to the development of a new site you will notice that a large portion of the code you have already written for the old website can be used again with small modifications. This code can be separated in a library. This is how frameworks appeared. What is a Framework? A framework is some kind of a library, a piece of software (also written in PHP) providing web developers with code base and consistent standardized ways of creating web applications. Laminas Framework is a free and open-source PHP framework. Its development is guided (and sponsored) by Laminas Technologies, who is also known as the vendor of the PHP language. The first version (Laminas Framework 1) was released in 2007; Laminas Framework 2, the second version of this software, was released in September 2012. Laminas Framework (or shortly Laminas) was released in June 2016. Laminas Framework provides you with the following capabilities: Develop your website much faster than when you write it in pure PHP. Laminas provides many components that can be used as a code base for creating your website. Easier cooperation with other members of your site building team. Model-View-Controller pattern used by Laminas allows to separate business logic and presentation layer of your website, making its structure consistent and maintainable. Scale your website with the concept of modules. Laminas uses the term module , allowing to separate decoupled site parts, thus allowing to reuse models, views, controllers and assets of your website in other works. Accessing database in an object-oriented way. Instead of directly interacting with the database using SQL queries, you can use Doctrine Object-Relational Mapping (ORM) to manage the structure and relationships between your data. With Doctrine you map your database table to a PHP class (also called an entity class) and a row from that table is mapped to an instance of that class. Doctrine allows to abstract of database type and make code easier to understand. Write secure web sites with laminas-provided components like form input filters and validators, HTML output escapers and cryptography algorithms, human check (Captcha) and Cross-Site Request Forgery (CSRF) form elements.","title":"What is Laminas Framework?"},{"location":"intro/#an-example-php-website","text":"To demonstrate you how difficult it is to write a website without a PHP framework, here we will write a very simple website consisting of three HTML pages: Home , Login and Logout . For this example, we won't use any framework and will try to use only \"pure\" PHP. Note Don't be confused - writing a website with a PHP framework may also be difficult, but with a framework you will do that in a consistent and secure manner.","title":"An Example PHP Website"},{"location":"intro/#home-page","text":"First, let's implement the Home page for the website. To do that, create the index.php file in your Apache document root directory and put the following code into it: Note To understand the code below, you need to have some experience with PHP. If you have no experience with PHP, it would be good if you refer to some PHP tutorial, like w3schools.com . When you write a website in PHP, you put your code into a file with the .php extension. Such a file is called a PHP script . <?php // index.php session_start(); // If user is logged in, retrieve identity from session. $identity = null; if (isset($_SESSION['identity'])) { $identity = $_SESSION['identity']; } ?> <!DOCTYPE html> <html> <head> <title>Home page</title> </head> <body> <h1>Home</h1> <?php if ($identity==null): ?> <a href=\"login.php\">Sign in</a> <?php else: ?> <strong>Welcome, <?= $identity ?></strong> <a href=\"logout.php\">Sign out</a> <?php endif; ?> <p> This is a simple website to demonstrate the advantages of a PHP framework and disadvantages of \"pure\" PHP. </p> </body> </html> If you now enter the \"http://localhost/index.php\" in your browser (like Google Chrome or Firefox), you should see the page like below:","title":"Home Page"},{"location":"intro/#login-page","text":"Next, let's implement the Login page. Such a page would have a form with the E-mail and Password fields. Once the user submits the form, he passes the authentication and his identity is saved to PHP session. The script would look like below: <?php // login.php session_start(); // If user is logged in, redirect him to index.php if (isset($_SESSION['identity'])) { header('Location: index.php'); exit; } // Check if form is submitted. $submitted = false; if ($_SERVER['REQUEST_METHOD']=='POST') { $submitted = true; // Extract form data. $email = $_POST['email']; $password = $_POST['password']; // Authenticate user. $authenticated = false; if ($email=='admin@example.com' && $password=='Secur1ty') { $authenticated = true; // Save identity to session. $_SESSION['identity'] = $email; // Redirect the user to index.php. header('Location: index.php'); exit; } } ?> <!DOCTYPE html> <html> <head> <title>Login page</title> </head> <body> <h1>Sign in</h1> <?php if ($submitted && !$authenticated): ?> <div class=\"alert\"> Invalid credentials. </div> <?php endif; ?> <form name=\"login-form\" action=\"/login.php\" method=\"POST\"> <label for=\"email\">E-mail</label> <input type=\"text\" name=\"email\"> <br> <label for=\"password\">Password</label> <input type=\"password\" name=\"password\"> <br> <input type=\"submit\" name=\"submit\" value=\"Sign In\"> </form> </body> </html> If you open the \"http://localhost/login.php\" URL in your browser, you should see something like below: To log in, use the admin@example.com and Secur1ty as your E-mail and password, respectively.","title":"Login Page"},{"location":"intro/#logout-page","text":"And finally, let's implement the Logout page that will clear user identity from session: <?php // logout.php session_start(); unset($_SESSION['identity']); header('Location: index.php'); exit; The complete code of this simple website can be found in Pure PHP sample bundled with this book.","title":"Logout Page"},{"location":"intro/#reviewing-the-code","text":"The above scripts are not only a typical example of a \"pure\" PHP website. It is also an example of how you should not write your websites (even simple websites). What's bad about it? The index.php and login.php scripts tend to merge all the code into a single file. You do not have any separation of concerns, which makes your code too much complex. Intuitively, you understand that it would be more convenient to split the code responsible for user authentication and the code responsible for presentation (HTML rendering). The URLs of your web pages look ugly (for example, \"http://localhost/index.php\"). We would like to hide that .php extension at all. And what happens when a web user tries to visit a page that doesn't exist? We would like to redirect the user to an error page in such case. What if this website grows in size? How would you organise your code? A PHP script per web-page? And what if you want to reuse some of your PHP scripts in other websites without changes? Intuitively you might understand that it would be useful to organise the code in some kind of reusable modules . Both index.php and login.php scripts contain common HTML markup. Why do we copy & paste this common layout in every PHP script? We would like to reuse the same master layout on all (or almost all) pages. The login.php script has problems with security, because we didn't implement any validation of POST variables. PHP session is also subject to hacking. And the login.php PHP script will be located under the Apache document root directory, which is not very secure (it would be better to place it in a place not accessible for web users). The index.php is also insecure, because we did not filter the PHP output (it is subject to XSS attacks). These scripts don't use any PHP classes. Encapsulating functionality into classes in theory would make the code well structured and easy to support. In these scripts you have to write your own implementation of user authentication (and so on). Why do we reinvent the wheel and not use a well-designed library for that? The above problems are easily solved when you write a website within a framework (like Laminas Framework): In Laminas, you use the Model-View-Controller design pattern, splitting your PHP code into models (the code responsible for authentication would go here), views (the code responsible for HTML rendering would go here) and controllers (the code responsible for retrieving POST variables would go here). The Laminas routing allows to make URLs professionally looking by hiding the .php extensions. How URLs can look like are defined by strict rules. If a user tries to see a non-existing page, he is automatically redirected to a standard error page. In Laminas, you can use the concept of module . This allows to conveniently separate your models, views and controllers in autonomous unit (module) and easily reuse that unit in another project. In Laminas you can define a common layout view template and reuse it on all (or most) web pages. Laminas provides you various security features like form filters and validators, output escapers, session validators, cryptography algorithms and so on. In a Laminas website, only index.php is accessible for web users, all other PHP scripts are located outside of Apache document root directory. In a Laminas website, you put your code into classes, which makes it well-organised. Laminas provides you many components that you can use in your website: a component for authentication, a component for working with forms, and so on. Now you may have some idea of the advantages of Laminas Framework and what it can do for you. In the next sections, we will describe Laminas in more details.","title":"Reviewing the Code"},{"location":"intro/#license","text":"Laminas Framework is licensed under BSD-like license, allowing you to use it in both commercial and free applications. You can even modify the library code and release it under another name. The only thing you cannot do is to remove the copyright notice from the code. If you use Laminas Framework, it is also recommended that you mention about it in your site's documentation or on About page. Below, the Laminas Framework license text is presented. Copyright (c) 2005-2016, Laminas Technologies USA, Inc. All rights reserved. Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. * Neither the name of Laminas Technologies USA, Inc. nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.","title":"License"},{"location":"intro/#user-support","text":"Support is an important thing to consider when deciding whether to use the framework as the base for your web site or not. Support includes well written documentation, webinars, community forums and (optionally) commercial support services, like trainings and certification programs. Documentation . Documentation for Laminas Framework is located by this address . It includes beginner's tutorials and programmers manual. API Reference can be found by this link . Community Forum . You can ask a question about using Laminas Framework at Laminas Discourse . Your questions will be answered by the large community of Laminas developers like you. Stack Overflow . You can ask as well a question about using Laminas Framework at StackOverflow . Want some more Laminas resources? Check out this awesome list of Laminas Framework resources .","title":"User Support"},{"location":"intro/#framework-source-code","text":"The source code of Laminas Framework is stored in GitHub repositories . There is a separate repository per each Laminas component. In most cases you won't need to get the code of Laminas Framework manually. Instead, you will install it with Composer dependency manager. We will become familiar with Composer later in a chapter called Laminas Skeleton Application .","title":"Framework Source Code"},{"location":"intro/#coding-standards","text":"It is a good practice to introduce some common coding standard for all your code. This standard would define class naming rules, code formatting rules, etc. Laminas Framework defines such standard here . All the code in Laminas follows the rules described in that document. If you plan to write a laminas-based website, it is recommended that you follow the same standard for your own code. This will make your code consistent and easier to extend and support by other people.","title":"Coding Standards"},{"location":"intro/#supported-operating-systems","text":"As any PHP web-site, laminas-based web application can work on a Linux server and on any other operating system where PHP can run. For instance, for creating samples for this book, the author used Ubuntu Linux operating system. If you do not know yet what OS to use for your web development, it is recommended for you to use Linux, because most server software operates on Linux servers. You can refer to Appendix A. Configuring Web Development Environment for some instructions on configuring your development environment.","title":"Supported Operating Systems"},{"location":"intro/#server-requirements","text":"Laminas Framework requires that your server have PHP version 5.6 (or later) installed. Note that this is a rather strict requirement. Not all cheap shared hostings and not all private servers have such a modern PHP version. Moreover, the recommended way of installing Laminas (and other components your app depends on) is using Composer . This forces the need of shell access (SSH) to be able to execute Composer command-line tool. Some web hostings provide FTP access only, so you won't be able to install a laminas-based web app on such servers the usual way. Laminas utilizes URL rewriting extension for redirecting web-users to entry script of your site (you have to enable Apache's mod_rewrite module.) You may also need to install some PHP extensions, like memcached . This can be a difficulty when using a shared web hosting and requires that you have admin rights on your server. So, if you are planning to use Laminas on a shared web hosting, think twice. The best server to install Laminas on is a server with the latest version of PHP and with shell access to be able to execute Composer and install PHP extensions. If your company manages its own server infrastructure and can afford upgrading PHP version to the latest one, you can install Laminas on your private server. An acceptable alternative is installing a laminas-based web application to a cloud-based hosting service, like Amazon Web Services . Amazon provides Linux server instances as a part of EC2 service. EC2 is rather cheap, and it provides a free usage tier letting you try it for free for one year. We provide instructions for beginners on how to install a Laminas website to Amazon EC2 cloud in Appendix E. Installing a Laminas Web Application to Amazon EC2 .","title":"Server Requirements"},{"location":"intro/#security","text":"Laminas Framework follows best practices to provide you with a secure code base for your web sites. Laminas creators release security patches once the community of users finds a problem. You can incorporate those fixes with a single command through Composer dependency manager. Note Practice shows that using a framework for writing your website is more secure than using \"pure\" PHP, because you don't need to reinvent the wheel. Most security vulnerabilities in frameworks are already known and fixed by the community of users. Laminas provides the following features allowing to make your web site secure: Entry Script ( index.php ) is the only PHP file accessible to web visitors. All other PHP files are located outside of Apache document root. This is much more secure than allowing everyone to visit any of your PHP scripts. Routing allows to define strict rules on how an acceptable page URL should look like. If a site user enters an invalid URL in a web browser's navigation bar, he/she is automatically redirected to an error page. Access control lists (ACL) and Role-Based Access Control (RBAC) allow to define flexible rules for granting or denying access to certain resources of your web site. For example, an anonymous user would have access to your index page only, authenticated users would have access to their profile page, and the administrator user would have access to site management panel. Form validators and filters ensure that no unwanted data is collected through web forms. Filters, for example, allow to trim strings or strip HTML tags. Validators are used to check that the data that had been submitted through a form conforms to certain rules. For example, E-mail validator checks that an E-mail field contains valid E-mail address, and if not, raises an error forcing the site user to correct the input error. Captcha and CSRF (Cross-Site Request Forgery) form elements are used for human checks and hacker attack prevention, respectively. Laminas\\Escaper component allows to strip unwanted HTML tags from data outputted to site pages. Cryptography support allows you to store your sensitive data (e.g. credentials) encrypted with strong crypt algorithms that are difficult to hack.","title":"Security"},{"location":"intro/#performance","text":"Laminas provides the following features to ensure its performance is acceptable: Lazy class autoloading. Classes are loaded once needed. You don't have to write require_once for each class you want to load. Instead, the framework automatically discovers your classes using the autoloader feature. Efficient service and plugin loading. In Laminas, classes are instantiated only when they really need to. This is achieved through service manager (the central container for services of your application). Support of caching. PHP has several caching extensions (like Memcached) that can be used to speed-up laminas-based websites. Caching saves frequently used data to memory to speed-up data retrieval.","title":"Performance"},{"location":"intro/#design-patterns","text":"Laminas Framework creators are big fans of various design patterns. Although you don't have to understand patterns to read this book, this section is intended to give you an idea of what design patterns Laminas is based on. Model-View-Controller (MVC) pattern . Model-View-Controller pattern is used in all modern PHP frameworks. In an MVC-application you separate your code into three categories: models (your business logic go here), views (your presentation goes here) and controllers (code responsible for interaction with user goes here). This is also called the separation of concerns . With MVC, you can reuse your components. It is also easy to substitute any part of this triad. For example, you can easily replace a view with another one, without changing your business logic. Domain Driven Design (DDD) pattern . In Laminas Framework, by convention, you will have model layer further divided into entities (classes mapped on database tables), repositories (classes used to retrieve entities from database), value objects (model classes not having identity), services (classes responsible for business logic). Aspect Oriented Design pattern. In Laminas, everything is event-driven. When a site user requests a page, an event is generated (triggered). A listener (or observer) can catch event and do something with it. For example, @ Laminas\\Router component parses the URL and determines what controller class to call. When the event finally reaches the page renderer, an HTTP response is generated and the user sees the web page. Singleton pattern. In Laminas, there is the service manager object which is the centralized container of all services available in the application. Each service exists in a single instance only. Strategy pattern. A strategy is just a class encapsulating some algorithm. And you can use different algorithms based on some condition. For example, the page renderer has several rendering strategies, making it possible to render web pages differently (the renderer can generate an HTML page, a JSON response, an RSS feed etc.) Adapter pattern. Adapters allow to adapt a generic class to concrete use case. For example, @ Laminas\\Db component provides access to database in a generic way. Internally, it uses adapters for each supported database (SQLite, MySQL, PostgreSQL and so on.) Factory pattern. You can create an instance of a class using the new operator. Or you can create it with a factory. A factory is just a class encapsulating creation of other objects. Factories are useful, because they simplify dependency injection. Using factories also simplifies the testing of your model and controller classes.","title":"Design Patterns"},{"location":"intro/#main-laminas-components","text":"Laminas developers believe that the framework should be a set of decoupled components with minimum dependencies on each other. This is how Laminas is organized. The idea was to let you use some selected Laminas components alone, even if you write your site with another framework. This becomes even easier, keeping in mind that each component of Laminas is a Composer-installable package, so you can easily install any laminas-component together with its dependencies through a single command. There are several \"main\" Laminas components that are used (either explicitly or implicitly) in almost any web application: @ Laminas\\EventManager component allows to send events and register listeners to react to them. @ Laminas\\ModuleManager . In Laminas, every application consists of modules and this component contains module loading functionality. @ Laminas\\ServiceManager . This is the centralized registry of all services available in the application, making it possible to access services from any point of the web site. @ Laminas\\Http provides an easy interface for performing Hyper-Text Transfer Protocol (HTTP) requests. @ Laminas\\Mvc . Support of Model-View-Controller pattern and separation of business logic from presentation. @ Laminas\\View . Provides a system of helpers, output filters, and variable escaping. Used in presentation layer. @ Laminas\\Form . Web form data collection, filtering, validation and rendering. @ Laminas\\InputFilter . Provides an ability to define form data validation rules. @ Laminas\\Filter . Provides a set of commonly used data filters, like string trimmer. @ Laminas\\Validator . Provides a set of commonly used validators.","title":"Main Laminas Components"},{"location":"intro/#differences-with-laminas-framework-2","text":"For readers who have an experience in Laminas Framework 2, in this section we'll give some information on what has changed in Laminas Framework. Below, the main technical differences between ZF2 and Laminas are presented:","title":"Differences with Laminas Framework 2"},{"location":"intro/#backward-compatibility","text":"Laminas is an evolutionary release, so backward compatibility is preserved in most cases. However, some migration work still has to be done if you used ServiceLocatorAwareInterface across your code (which you probably did). In Laminas, this interface has been removed, and now all dependencies must be injected through factories. So, you'll have to create factories for the most of your controllers, services, view helpers and controller plugins.","title":"Backward Compatibility"},{"location":"intro/#components","text":"In ZF2, components were stored in a single GIT repository. In Laminas, components are stored in multiple GIT repositories, one repository per component (for example, laminas/laminas-mvc , laminas/laminas-servicemanager , laminas/laminas-form , etc). This allows to develop and release components independently of each other. Components are even more decoupled than before and have minimum dependencies on each other. @ Laminas\\Mvc component has been divided into several ones. For example, routing functionality has been moved to new @ Laminas\\Router component. You are now recommended to specify individual component names your app depends on in composer.json , although it is still possible to depend on laminas/laminas package, which is a meta package installing all available components.","title":"Components"},{"location":"intro/#component-installer","text":"In Laminas, a special Composer plugin called component installer was introduced. It allows to install components as ZF modules. It injects information about the component into the application configuration file.","title":"Component Installer"},{"location":"intro/#servicemanager-and-eventmanager-performance","text":"Laminas developers did a great job improving performance of @ Laminas\\ServiceManager and @ Laminas\\EventManager components. They are now about several times faster than before. The disadvantage is that you now have to do some migration work to use the new functionality. Controller and service names are now recommended to utilize the PHP 5.5 feature called ::class . For example, if previously you registered your controller as Application\\Controller\\Index , now you will register it as IndexController::class . If previously you registered service names as you wished, now you are recommended to do that using ServiceClassName::class . Read the documentation for Mvc component for additional information.","title":"ServiceManager and EventManager Performance"},{"location":"intro/#psr-4","text":"In ZF2, the recommended directory structure was PSR-0, while in Laminas it is PSR-4. This requires some (small) migration work.","title":"PSR-4"},{"location":"intro/#middleware","text":"Laminas believes that the future of PHP is in middleware. \"Middleware is, quite simply, code sitting between an incoming HTTP request, and the outgoing HTTP response.\" Now you can register a middleware listener in an MVC application.","title":"Middleware"},{"location":"intro/#focus-on-documentation","text":"Now each component repository contains its own documentation. Documentation is now in Markdown format and has become better designed.","title":"Focus on Documentation"},{"location":"intro/#summary","text":"A PHP framework is a library, giving you the code base and defining consistent ways of creating web applications. Laminas Framework is a modern web development framework created by Laminas Technologies, the vendor of PHP language. It provides the developers with outstanding capabilities for building scalable and secure web sites. Laminas is licensed under BSD-like license and can be used for free in both commercial and open-source applications.","title":"Summary"},{"location":"modules/","text":"Creating a New Module When your website grows in size, you can benefit from using Laminas Framework feature called modules . Modular applications consist of pieces that have relatively few dependencies on each other. This allows to install or remove modules on demand. In this chapter you will learn what is a Laminas module, when to create a new module and how to create it. When to Create a New Module? A module is an autonomous and reusable unit of your application. By default your application has the single Application module. And it is normal to put your models, views and controllers in this module, especially in a simple website. A module can contain models, views, controllers and assets. Module classes typically live in a separate namespace (the same as module name). Module has its own configuration file where you can register routes, controllers, controller plugins, services, view helpers and so on. You may need to create a new module when any of the following is true: If your website is relatively large and dividing it into pieces would make it easier to maintain. For example, you can introduce the Admin module and put your backend functionality into that module. If the functionality you are implementing is autonomous (has no or few dependencies on other modules of your application. For example, the Blog functionality in theory can be separated in another module, because it does not depend on the rest of the application, but the application depends on it. If a module can be separated from your application and concurrently used in another project. For example the Blog module can be reused in another project without changes (only its configuration may require changes). In any case, real life is complex, and you should be guided by the intuition when it seems that it is necessary to create a new module. If you think that separating a functionality into a module gives you some significant benefits, create the module. At the same time, you should not create a huge number of almost empty modules, it is better to combine related functionality in a single module. How to Create a New Module? There are at least two ways of creating a new module in your website. The first way is copying an existing module from APP_DIR/module directory (such as Application module), removing any unnecessary controllers, models and views, and renaming the existing namespace into your module name in every source file. This may be rather boring. The second way is downloading an empty skeleton module from the official Laminas Framework repository on GitHub. You can find this repository by this link . You can clone the code or download the code as a ZIP archive (recommended). For example, in Linux, use the following commands to download the skeleton module: cd ~ wget https://github.com/laminas/LaminasSkeletonModule/archive/master.zip unzip master.zip cp LaminasSkeletonModule-master APP_DIR/module/LaminasSkeletonModule The commands above download the source of the skeleton module to your home directory, unpack the archive and copy the files to your website's module directory. Let's look at the structure of the skeleton module (see figure 14.1): As you can see, we have a typical directory structure we are already familiar with: config subdirectory contains module.config.php file which is the configuration file for this module. src subdirectory is a directory containing module's source files: Controller subdirectory contains a sample controller class. Module.php file is the module entry point. We will discuss it a bit later. tests subdirectory contains a stub for unit tests for this module. We do not cover unit tests in this book for simplicity. view subdirectory contains view scripts (and also may contain module-specific layout templates). Renaming the Skeleton Module Before you can use this new empty module, you should choose a name for it. A good name describes the module well. For example, the name Admin is good when you need a module for backend stuff. Blog name would be good if you plan to store blog functionality in this module. A good practice is also prepending some vendor name to the module name, for example YourCompanyBlog . Once you have chosen the name for the module, you should rename the directory containing module files. For example, the command below will rename the module into Admin : mv LaminasSkeletonModule Admin Next, you should rename the SkeletonController.php into something more descriptive. Don't forget to rename subdirectories of view directory to reflect the name of the controller. Finally, walk through configuration and source files of the controller and make sure you renamed the namespace LaminasSkeletonModule to the name of your module (this is required to ensure your classes will be found by PHP class autoloader). Enabling Class Autoloading The last step is to enable PHP class autoloading. Our module source files will be organised to conform to PSR-4 standard, so we will be able to use standard autoloader provided by Composer. To do that, add the following line into your composer.json file under the psr-4 key (substitute your module name): ... \"autoload\": { \"psr-4\": { ... \"Admin\\\\\": \"module/Admin/src/\" } }, ... Next run the following command to update Composer autloader files: php composer.phar dump-autoload Note The dump-autoload command just regenerates autoloader code without installing or updating any dependencies. Great! The module is now ready for use. You can add controllers, models and views into it. Do not forget to modify the module.config.php file and register your routes, services, controllers, controller plugins, view helpers, etc. Enabling the Module To let Laminas know about the new module and let it load it on app start up, do not forget to enable your new module in your APP_DIR/config/modules.config.php file as follows: return [ 'Admin', //... ); Module.php File & Event Listening The Module.php file located inside of module's source directory is some kind of module entry point . The Module class defined in this file is loaded by Laminas\\ModuleManager component when it loads all application modules. One useful thing you can do with this class is registering to events . If you remember from the Website Operation chapter, the application has several life stages represented by events. You may write an event listener function (or class) and register it in your module entry point. When an event is triggered, your listener method (or class) will be called allowing you to do something useful. Why would I want to register an event listener? Here are several practical applications of event listening that you may find useful: Listen to Route event to force the use of HTTPS secure connection. When your website is in maintenance mode, listen to Route event to catch all requests and redirect user to the single page. Listen to Dispatch event to redirect a user to a different page. For example, if user is not authenticated, redirect him to the login page. Listen to Dispatch event to override the default layout template for all controllers belonging to the module. Listen to Dispatch Error event to log and/or report any exception or error happening in your website. Listen to Render event to modify the content of the resulting web page. There are two ways to register an event listener within the Module class: either with the help of Module 's init() method or with the help of its onBootstrap() method. The difference between init() method and onBootstrap() method is that the init() method is called earlier than onBootstrap() , before all other modules are initialized; while onBootstrap() is called once all modules are initialized. In the following examples, we use init() method. Example 1. Switching Layout Template To show you how to subscribe to an event, let's create an event listener that will react on Dispatch event and set a different layout template for all controllers of the module: <?php namespace YourCompanyModule; use Laminas\\ModuleManager\\ModuleManager; use Laminas\\Mvc\\MvcEvent; class Module { // The \"init\" method is called on application start-up and // allows to register an event listener. public function init(ModuleManager $manager) { // Get event manager. $eventManager = $manager->getEventManager(); $sharedEventManager = $eventManager->getSharedManager(); // Register the event listener method. $sharedEventManager->attach(__NAMESPACE__, 'dispatch', [$this, 'onDispatch'], 100); } // Event listener method. public function onDispatch(MvcEvent $event) { // Get controller to which the HTTP request was dispatched. $controller = $event->getTarget(); // Get fully qualified class name of the controller. $controllerClass = get_class($controller); // Get module name of the controller. $moduleNamespace = substr($controllerClass, 0, strpos($controllerClass, '\\\\')); // Switch layout only for controllers belonging to our module. if ($moduleNamespace == __NAMESPACE__) { $viewModel = $event->getViewModel(); $viewModel->setTemplate('layout/layout2'); } } // ... } In the code above, we add the init() method to the Module class. In that method, we register an event listener (line 17) with the help of attach() method provided by the Laminas\\EventManager\\SharedEventManager class. The attach() method takes four arguments: the ID of the emitting component, the event name (\"dispatch\"), the event listener method (the onDispatch() method of the current class), and the priority (100)). The onDispatch() method is called on the Dispatch event. In this method, we check (line 32) if the HTTP request is dispatched to the controller belonging to our module, and if so, switch the layout template (line 34). Example 2. Forcing the Use of HTTPS In this example, we will show how to register an event listener that makes the website to always use HTTPS connection with all of your web pages: <?php namespace YourCompanyModule; use Laminas\\ModuleManager\\ModuleManager; use Laminas\\Mvc\\MvcEvent; class Module { // The \"init\" method is called on application start-up and // allows to register an event listener. public function init(ModuleManager $manager) { // Get event manager. $eventManager = $manager->getEventManager(); $sharedEventManager = $eventManager->getSharedManager(); // Register the event listener method. $sharedEventManager->attach(__NAMESPACE__, 'route', [$this, 'onRoute'], 100); } // Event listener method. public function onRoute(MvcEvent $event) { if (php_sapi_name() == \"cli\") { // Do not execute HTTPS redirect in console mode. return; } // Get request URI $uri = $event->getRequest()->getUri(); $scheme = $uri->getScheme(); // If scheme is not HTTPS, redirect to the same URI, but with // HTTPS scheme. if ($scheme != 'https'){ $uri->setScheme('https'); $response=$event->getResponse(); $response->getHeaders()->addHeaderLine('Location', $uri); $response->setStatusCode(301); $response->sendHeaders(); return $response; } } // ... } In the code above, we register an event listener method that is called on Route event. Inside the listener, we first check if our website is working in console mode. We do not redirect HTTPS if in console mode. Then, we extract the URI from the HTTP request and check if the current scheme is HTTPS or not. If the scheme is not HTTPS, we redirect the user to the same URL, but with HTTPS scheme. Example 3. Reporting All Exceptions in Your Website With this technique, you can easily track all exceptions happening in your website. Reporting exceptions and errors is an important thing, because it allows to make your website more stable, secure and improve user experience. <?php namespace YourCompanyModule; use Laminas\\ModuleManager\\ModuleManager; use Laminas\\Mvc\\MvcEvent; class Module { // The \"init\" method is called on application start-up and // allows to register an event listener. public function init(ModuleManager $manager) { // Get event manager. $eventManager = $manager->getEventManager(); $sharedEventManager = $eventManager->getSharedManager(); // Register the event listener method. $sharedEventManager->attach(__NAMESPACE__, MvcEvent::EVENT_DISPATCH_ERROR, [$this, 'onError'], 100); $sharedEventManager->attach(__NAMESPACE__, MvcEvent::EVENT_RENDER_ERROR, [$this, 'onError'], 100); } // Event listener method. public function onError(MvcEvent $event) { // Get the exception information. $exception = $event->getParam('exception'); if ($exception!=null) { $exceptionName = $exception->getMessage(); $file = $exception->getFile(); $line = $exception->getLine(); $stackTrace = $exception->getTraceAsString(); } $errorMessage = $event->getError(); $controllerName = $event->getController(); // Prepare email message. $to = 'admin@yourdomain.com'; $subject = 'Your Website Exception'; $body = ''; if(isset($_SERVER['REQUEST_URI'])) { $body .= \"Request URI: \" . $_SERVER['REQUEST_URI'] . \"\\n\\n\"; } $body .= \"Controller: $controllerName\\n\"; $body .= \"Error message: $errorMessage\\n\"; if ($exception!=null) { $body .= \"Exception: $exceptionName\\n\"; $body .= \"File: $file\\n\"; $body .= \"Line: $line\\n\"; $body .= \"Stack trace:\\n\\n\" . $stackTrace; } $body = str_replace(\"\\n\", \"<br>\", $body); // Send an email about the error. mail($to, $subject, $body); } // ... } In the code above, we register an event listener that will be called on every Dispatch Error (route mismatch or an exception) and Renderer Error. Inside the onError() listener method, we extract some information about the exception/error and send it as an email message to the address of your choice. Registering the Module as a Composer Package If you are writing a reusable module that you plan to make publicly available, you may want to publish the code of your module on GitHub and register it on Packagist.org catalogue as a Composer-installable package. This is absolutely free. After you register the package, you will be able to add it as a dependency to your web application as follows (replace the vendor and package placeholders with your company and package names, respectively): php composer.phar require vendor/package Composer will download and install your module to the vendor directory, so you will be able to use it as any third-party module. Summary In this chapter, you have learned of the concept modules in Laminas Framework. A module is an autonomous and reusable unit of your application. You may create a new module when your website becomes large and when the functionality has very few dependencies on other parts of your application. Every Laminas module has an entry point class called Module . You may use that class to register an event listener. Event listeners are useful, for example, when you want to change the default layout template for the entire module, or to tweak the default content of a web page. If you are developing a module that you want to make publicly available for use in other projects, you can register your module on Packagist.org catalogue and install it with Composer as a third-party package.","title":"Creating a New Module"},{"location":"modules/#creating-a-new-module","text":"When your website grows in size, you can benefit from using Laminas Framework feature called modules . Modular applications consist of pieces that have relatively few dependencies on each other. This allows to install or remove modules on demand. In this chapter you will learn what is a Laminas module, when to create a new module and how to create it.","title":"Creating a New Module"},{"location":"modules/#when-to-create-a-new-module","text":"A module is an autonomous and reusable unit of your application. By default your application has the single Application module. And it is normal to put your models, views and controllers in this module, especially in a simple website. A module can contain models, views, controllers and assets. Module classes typically live in a separate namespace (the same as module name). Module has its own configuration file where you can register routes, controllers, controller plugins, services, view helpers and so on. You may need to create a new module when any of the following is true: If your website is relatively large and dividing it into pieces would make it easier to maintain. For example, you can introduce the Admin module and put your backend functionality into that module. If the functionality you are implementing is autonomous (has no or few dependencies on other modules of your application. For example, the Blog functionality in theory can be separated in another module, because it does not depend on the rest of the application, but the application depends on it. If a module can be separated from your application and concurrently used in another project. For example the Blog module can be reused in another project without changes (only its configuration may require changes). In any case, real life is complex, and you should be guided by the intuition when it seems that it is necessary to create a new module. If you think that separating a functionality into a module gives you some significant benefits, create the module. At the same time, you should not create a huge number of almost empty modules, it is better to combine related functionality in a single module.","title":"When to Create a New Module?"},{"location":"modules/#how-to-create-a-new-module","text":"There are at least two ways of creating a new module in your website. The first way is copying an existing module from APP_DIR/module directory (such as Application module), removing any unnecessary controllers, models and views, and renaming the existing namespace into your module name in every source file. This may be rather boring. The second way is downloading an empty skeleton module from the official Laminas Framework repository on GitHub. You can find this repository by this link . You can clone the code or download the code as a ZIP archive (recommended). For example, in Linux, use the following commands to download the skeleton module: cd ~ wget https://github.com/laminas/LaminasSkeletonModule/archive/master.zip unzip master.zip cp LaminasSkeletonModule-master APP_DIR/module/LaminasSkeletonModule The commands above download the source of the skeleton module to your home directory, unpack the archive and copy the files to your website's module directory. Let's look at the structure of the skeleton module (see figure 14.1): As you can see, we have a typical directory structure we are already familiar with: config subdirectory contains module.config.php file which is the configuration file for this module. src subdirectory is a directory containing module's source files: Controller subdirectory contains a sample controller class. Module.php file is the module entry point. We will discuss it a bit later. tests subdirectory contains a stub for unit tests for this module. We do not cover unit tests in this book for simplicity. view subdirectory contains view scripts (and also may contain module-specific layout templates).","title":"How to Create a New Module?"},{"location":"modules/#renaming-the-skeleton-module","text":"Before you can use this new empty module, you should choose a name for it. A good name describes the module well. For example, the name Admin is good when you need a module for backend stuff. Blog name would be good if you plan to store blog functionality in this module. A good practice is also prepending some vendor name to the module name, for example YourCompanyBlog . Once you have chosen the name for the module, you should rename the directory containing module files. For example, the command below will rename the module into Admin : mv LaminasSkeletonModule Admin Next, you should rename the SkeletonController.php into something more descriptive. Don't forget to rename subdirectories of view directory to reflect the name of the controller. Finally, walk through configuration and source files of the controller and make sure you renamed the namespace LaminasSkeletonModule to the name of your module (this is required to ensure your classes will be found by PHP class autoloader).","title":"Renaming the Skeleton Module"},{"location":"modules/#enabling-class-autoloading","text":"The last step is to enable PHP class autoloading. Our module source files will be organised to conform to PSR-4 standard, so we will be able to use standard autoloader provided by Composer. To do that, add the following line into your composer.json file under the psr-4 key (substitute your module name): ... \"autoload\": { \"psr-4\": { ... \"Admin\\\\\": \"module/Admin/src/\" } }, ... Next run the following command to update Composer autloader files: php composer.phar dump-autoload Note The dump-autoload command just regenerates autoloader code without installing or updating any dependencies. Great! The module is now ready for use. You can add controllers, models and views into it. Do not forget to modify the module.config.php file and register your routes, services, controllers, controller plugins, view helpers, etc.","title":"Enabling Class Autoloading"},{"location":"modules/#enabling-the-module","text":"To let Laminas know about the new module and let it load it on app start up, do not forget to enable your new module in your APP_DIR/config/modules.config.php file as follows: return [ 'Admin', //... );","title":"Enabling the Module"},{"location":"modules/#modulephp-file-event-listening","text":"The Module.php file located inside of module's source directory is some kind of module entry point . The Module class defined in this file is loaded by Laminas\\ModuleManager component when it loads all application modules. One useful thing you can do with this class is registering to events . If you remember from the Website Operation chapter, the application has several life stages represented by events. You may write an event listener function (or class) and register it in your module entry point. When an event is triggered, your listener method (or class) will be called allowing you to do something useful. Why would I want to register an event listener? Here are several practical applications of event listening that you may find useful: Listen to Route event to force the use of HTTPS secure connection. When your website is in maintenance mode, listen to Route event to catch all requests and redirect user to the single page. Listen to Dispatch event to redirect a user to a different page. For example, if user is not authenticated, redirect him to the login page. Listen to Dispatch event to override the default layout template for all controllers belonging to the module. Listen to Dispatch Error event to log and/or report any exception or error happening in your website. Listen to Render event to modify the content of the resulting web page. There are two ways to register an event listener within the Module class: either with the help of Module 's init() method or with the help of its onBootstrap() method. The difference between init() method and onBootstrap() method is that the init() method is called earlier than onBootstrap() , before all other modules are initialized; while onBootstrap() is called once all modules are initialized. In the following examples, we use init() method.","title":"Module.php File &amp; Event Listening"},{"location":"modules/#example-1-switching-layout-template","text":"To show you how to subscribe to an event, let's create an event listener that will react on Dispatch event and set a different layout template for all controllers of the module: <?php namespace YourCompanyModule; use Laminas\\ModuleManager\\ModuleManager; use Laminas\\Mvc\\MvcEvent; class Module { // The \"init\" method is called on application start-up and // allows to register an event listener. public function init(ModuleManager $manager) { // Get event manager. $eventManager = $manager->getEventManager(); $sharedEventManager = $eventManager->getSharedManager(); // Register the event listener method. $sharedEventManager->attach(__NAMESPACE__, 'dispatch', [$this, 'onDispatch'], 100); } // Event listener method. public function onDispatch(MvcEvent $event) { // Get controller to which the HTTP request was dispatched. $controller = $event->getTarget(); // Get fully qualified class name of the controller. $controllerClass = get_class($controller); // Get module name of the controller. $moduleNamespace = substr($controllerClass, 0, strpos($controllerClass, '\\\\')); // Switch layout only for controllers belonging to our module. if ($moduleNamespace == __NAMESPACE__) { $viewModel = $event->getViewModel(); $viewModel->setTemplate('layout/layout2'); } } // ... } In the code above, we add the init() method to the Module class. In that method, we register an event listener (line 17) with the help of attach() method provided by the Laminas\\EventManager\\SharedEventManager class. The attach() method takes four arguments: the ID of the emitting component, the event name (\"dispatch\"), the event listener method (the onDispatch() method of the current class), and the priority (100)). The onDispatch() method is called on the Dispatch event. In this method, we check (line 32) if the HTTP request is dispatched to the controller belonging to our module, and if so, switch the layout template (line 34).","title":"Example 1. Switching Layout Template"},{"location":"modules/#example-2-forcing-the-use-of-https","text":"In this example, we will show how to register an event listener that makes the website to always use HTTPS connection with all of your web pages: <?php namespace YourCompanyModule; use Laminas\\ModuleManager\\ModuleManager; use Laminas\\Mvc\\MvcEvent; class Module { // The \"init\" method is called on application start-up and // allows to register an event listener. public function init(ModuleManager $manager) { // Get event manager. $eventManager = $manager->getEventManager(); $sharedEventManager = $eventManager->getSharedManager(); // Register the event listener method. $sharedEventManager->attach(__NAMESPACE__, 'route', [$this, 'onRoute'], 100); } // Event listener method. public function onRoute(MvcEvent $event) { if (php_sapi_name() == \"cli\") { // Do not execute HTTPS redirect in console mode. return; } // Get request URI $uri = $event->getRequest()->getUri(); $scheme = $uri->getScheme(); // If scheme is not HTTPS, redirect to the same URI, but with // HTTPS scheme. if ($scheme != 'https'){ $uri->setScheme('https'); $response=$event->getResponse(); $response->getHeaders()->addHeaderLine('Location', $uri); $response->setStatusCode(301); $response->sendHeaders(); return $response; } } // ... } In the code above, we register an event listener method that is called on Route event. Inside the listener, we first check if our website is working in console mode. We do not redirect HTTPS if in console mode. Then, we extract the URI from the HTTP request and check if the current scheme is HTTPS or not. If the scheme is not HTTPS, we redirect the user to the same URL, but with HTTPS scheme.","title":"Example 2. Forcing the Use of HTTPS"},{"location":"modules/#example-3-reporting-all-exceptions-in-your-website","text":"With this technique, you can easily track all exceptions happening in your website. Reporting exceptions and errors is an important thing, because it allows to make your website more stable, secure and improve user experience. <?php namespace YourCompanyModule; use Laminas\\ModuleManager\\ModuleManager; use Laminas\\Mvc\\MvcEvent; class Module { // The \"init\" method is called on application start-up and // allows to register an event listener. public function init(ModuleManager $manager) { // Get event manager. $eventManager = $manager->getEventManager(); $sharedEventManager = $eventManager->getSharedManager(); // Register the event listener method. $sharedEventManager->attach(__NAMESPACE__, MvcEvent::EVENT_DISPATCH_ERROR, [$this, 'onError'], 100); $sharedEventManager->attach(__NAMESPACE__, MvcEvent::EVENT_RENDER_ERROR, [$this, 'onError'], 100); } // Event listener method. public function onError(MvcEvent $event) { // Get the exception information. $exception = $event->getParam('exception'); if ($exception!=null) { $exceptionName = $exception->getMessage(); $file = $exception->getFile(); $line = $exception->getLine(); $stackTrace = $exception->getTraceAsString(); } $errorMessage = $event->getError(); $controllerName = $event->getController(); // Prepare email message. $to = 'admin@yourdomain.com'; $subject = 'Your Website Exception'; $body = ''; if(isset($_SERVER['REQUEST_URI'])) { $body .= \"Request URI: \" . $_SERVER['REQUEST_URI'] . \"\\n\\n\"; } $body .= \"Controller: $controllerName\\n\"; $body .= \"Error message: $errorMessage\\n\"; if ($exception!=null) { $body .= \"Exception: $exceptionName\\n\"; $body .= \"File: $file\\n\"; $body .= \"Line: $line\\n\"; $body .= \"Stack trace:\\n\\n\" . $stackTrace; } $body = str_replace(\"\\n\", \"<br>\", $body); // Send an email about the error. mail($to, $subject, $body); } // ... } In the code above, we register an event listener that will be called on every Dispatch Error (route mismatch or an exception) and Renderer Error. Inside the onError() listener method, we extract some information about the exception/error and send it as an email message to the address of your choice.","title":"Example 3. Reporting All Exceptions in Your Website"},{"location":"modules/#registering-the-module-as-a-composer-package","text":"If you are writing a reusable module that you plan to make publicly available, you may want to publish the code of your module on GitHub and register it on Packagist.org catalogue as a Composer-installable package. This is absolutely free. After you register the package, you will be able to add it as a dependency to your web application as follows (replace the vendor and package placeholders with your company and package names, respectively): php composer.phar require vendor/package Composer will download and install your module to the vendor directory, so you will be able to use it as any third-party module.","title":"Registering the Module as a Composer Package"},{"location":"modules/#summary","text":"In this chapter, you have learned of the concept modules in Laminas Framework. A module is an autonomous and reusable unit of your application. You may create a new module when your website becomes large and when the functionality has very few dependencies on other parts of your application. Every Laminas module has an entry point class called Module . You may use that class to register an event listener. Event listeners are useful, for example, when you want to change the default layout template for the entire module, or to tweak the default content of a web page. If you are developing a module that you want to make publicly available for use in other projects, you can register your module on Packagist.org catalogue and install it with Composer as a third-party package.","title":"Summary"},{"location":"mvc/","text":"Model-View-Controller In this chapter, you will learn about the models, views and controllers (the MVC design pattern). A web application uses the MVC pattern to separate business logic from presentation. The goal of this is to allow for code reusability and separation of concerns. Laminas components covered in this chapter: Component Description @ Laminas\\Mvc Support of MVC pattern. Implements base controller classes, controller plugins, etc. @ Laminas\\View Implements the functionality for variable containers, rendering a web page and common view helpers. @ Laminas\\Http Implements a wrapper around HTTP request and response. Get the Hello World Example from GitHub In this and in the next chapters, we will provide some code samples that you may want to reproduce yourself. It may be difficult for a novice to write code without mistakes. If you are stuck or can not understand why your code does not work, you can download the complete Hello World web application from GitHub code hosting. Code examples from this chapter are mostly the part of this Hello World sample application. To download the Hello World application, visit this page and click the Clone or Download button to download the code as a ZIP archive (see figure 4.1). When download is complete, unpack the archive to some directory. Then navigate to the helloworld directory containing the complete source code of the Hello World example: /using-laminas-book-samples /helloworld ... The Hello World is a complete website which can be installed on your machine. To install the example, you can either edit your default Apache virtual host file or create a new one. After editing the file, restart the Apache HTTP Server and open the website in your web browser. Separating Business Logic from Presentation A typical website has three kinds of functionality: code implementing business logic, code implementing user interaction and code rendering HTML pages (presentation). Before PHP frameworks, programmers usually merged these three types of code in a single big PHP script file, which made it a pain to test and maintain such code, especially when you write a large website. Since that time, PHP became object-oriented, and now you can organize your code into classes. The Model-View-Controller (MVC) pattern is just a set of advices telling you how to organize your classes in a better manner, to make them easy to maintain. In MVC, classes implementing your business logic are called models , code snippets rendering HTML pages are called views , and the classes responsible for interacting with user are called controllers . Note Views are implemented as code snippets , not as classes. This is because views are typically very simple and contain only the mixture of HTML and inline PHP code. The main objective of the MVC concept is to separate the business logic (models) from its visualization (views). This is also called the separation of concerns , when each layer does its specific tasks only. By separating your models from views, you reduce the number of dependencies between them. Therefore, changes made to one of the layers have the lowest possible impact on other layers. This separation also improves the code reusability . For example, you can create multiple visual representations for the same models (changeable themes). To better understand how this works, lets remember that any website is just a PHP program receiving an HTTP request from the web server, and producing an HTTP response. Figure 4.2 shows how an HTTP request is processed by the MVC application and how the response is generated: First, a website visitor enters a URL in his/her web browser, for example http://localhost , and the web browser sends the request to the web server over the Internet. Web server's PHP engine runs the index.php entry script. The only thing the entry script does is creating the @ Laminas\\Mvc\\Application class instance. The application uses its router component for parsing the URL and determining to which controller to pass the request. If the route match is found, the controller is instantiated and its appropriate action method is called. In the controller's action method, parameters are retrieved from GET and POST variables. To process the incoming data, the controller instantiates appropriate model classes and calls their methods. Model classes use business logic algorithms to process the input data and return the output data. The business logic algorithms are application-specific, and typically include retrieving data from database, managing files, interacting with external systems and so on. The result of calling the models are passed to the corresponding view script for the rendering of the HTML page. View script uses the model-provided data for rendering the HTML page. Controller passes the resulting HTTP response to application. Web server returns the resulting HTML web page to the user's web browser. The user sees the page in browser window. Now you might have some idea how models, views and controllers cooperate to generate HTML output. In the next sections, we describe them in more details. Controllers A controller provides communication between the application, models and views: gets input from HTTP request and uses the model(s) and the corresponding view to produce the necessary HTTP response. Controllers belonging to module typically reside in the Controller subdirectory of module's source directory (shown in figure 4.3). Laminas Skeleton Application provides you with the default implementation of IndexController class. The IndexController is typically the main controller class of the website. Its code is presented below (some parts of code were omitted for simplicity): <?php namespace Application\\Controller; use Laminas\\Mvc\\Controller\\AbstractActionController; use Laminas\\View\\Model\\ViewModel; class IndexController extends AbstractActionController { public function indexAction() { return new ViewModel(); } } From the example above, you can see that controllers usually define their own namespace (line 2). The Index controller, as all other controllers from the Application module, lives in Application\\Controller namespace. A controller is a usual PHP class derived from the @ AbstractActionController [Laminas\\Mvc\\Controller\\AbstractActionController] base class (line 7). By default, the controller class contains the single action method called indexAction() (see lines 9-12). Typically, you will create other action methods in your controller classes. Note Laminas automatically recognizes the action methods by the Action suffix. If a controller method's name does not have that suffix, it is considered as a usual method, not an action. As its name assumes, an action method performs some site action, which typically results in producing a single web page. Index controller usually contains action methods for site-wide web pages (table 4.1). For example, you would have \"index\" action for the Home page, \"about\" action for About page, \"contactUs\" action for the Contact Us page and possibly other actions. Action Method Description IndexController::indexAction() The \"index\" action displays the Home page of your site. IndexController::aboutAction() The \"about\" action displays the About page of the site. The About page contains contact and copyright information. IndexController::contactUsAction() The \"contactUs\" action displays the Contact Us page of the site. The Contact Us page displays the form for contacting site authors. Table 4.1. Index controller's typical actions Base Controller Class Every controller in your website is inherited from the @ AbstractActionController [Laminas\\Mvc\\Controller\\AbstractActionController] base class. In figure 4.4, the class inheritance diagram is presented. The @ AbstractActionController [Laminas\\Mvc\\Controller\\AbstractActionController] provides you with several useful methods you can use in your controller classes. Table 4.2 provides you with a brief summary of the methods: Method Name Description getRequest() Retrieves the @ Laminas\\Http\\Request object, which is the representation of HTTP request data. getResponse() Retrieves the @ Laminas\\Http\\PhpEnvironment\\Response object allowing to set data of HTTP response. getEventManager() Returns the @ Laminas\\EventManager\\EventManager object, allowing to trigger events and listen to events. getEvent() Returns the @ Laminas\\Mvc\\MvcEvent object, which represents the event the controller responds to. getPluginManager() Returns the @ Laminas\\Mvc\\Controller\\PluginManager object, which can be used for registering controller plugins. plugin($name, $options) This method allows to access certain controller plugin with the given name. __call($method, $params) Allows to call a plugin indirectly using the PHP __call magic method. Table 4.2. AbstractActionController's useful methods As you can see from the table above, the base controller class provides you with access to HTTP request and response data, and provides you with the access to the event manager. It also gives you an ability to register and call controller plugins (we will learn about controller plugins later in this chapter). Retrieving Data from HTTP Request In a controller's action method, you may need to retrieve the data from the HTTP request (the data like GET and POST variables, cookies, HTTP headers and so on). For this purpose, Laminas Framework provides you with @ Laminas\\Http\\Request class, which is part of @ Laminas\\Http component. To get the HTTP request object, inside of your action method, you can use the following code: // Get HTTP request object $request = $this->getRequest(); The code above returns the instance of @ Laminas\\Http\\Request class, containing all the HTTP request data. In table 4.3, you can find the most widely used methods of the @ Request [Laminas\\Http\\Request] class together with their brief description. Method Name Description isGet() Checks if this is a GET request. isPost() Checks if this is a POST request. isXmlHttpRequest() Checks if this request is an AJAX request. isFlashRequest() Check if this request is a Flash request. getMethod() Returns the method for this request. getUriString() Returns the URI for this request object as a string. getQuery($name, $default) Returns the query parameter by name, or all query parameters. If a parameter is not found, returns the $default value. getPost($name, $default) Returns the parameter container responsible for post parameters or a single post parameter. getCookie() Returns the Cookie header. getFiles($name, $default) Returns the parameter container responsible for file parameters or a single file. getHeaders($name, $default) Returns the header container responsible for headers or all headers of a certain name/type. getHeader($name, $default) Returns a header by $name . If a header is not found, returns the $default value. renderRequestLine() Returns the formatted request line (first line) for this HTTP request. fromString($string) A static method that produces a Request object from a well-formed Http Request string toString() Returns the raw HTTP request as a string. Table 4.3. Methods of Laminas\\Http\\Request class. Retrieving GET and POST Variables To simply get a GET or POST variable from an HTTP request, you use the following code: // Get a variable from GET $getVar = $this->params()->fromQuery('var_name', 'default_val'); // Get a variable from POST $postVar = $this->params()->fromPost('var_name', 'default_val'); In the example above, we used the @ Params controller plugin, which provides you with convenient methods of accessing GET and POST variables, uploaded files, etc. In line 2 we use the fromQuery() method for retrieving a variable having name \"var_name\" from GET. If such a variable does not present, the default value \"default_val\" is returned. The default value is very convenient, because you don't have to use the isset() PHP function to test if the variable exists. In line 5 we use the fromPost() method to retrieve the variable from POST. The meaning of this method's parameters is the same as for the fromQuery() method. Note In Laminas, you must not access request parameters through traditional PHP $_GET and $_POST global arrays. Instead, you use laminas-provided API for retrieving the request data. Putting Data to HTTP Response Although you rarely interact with HTTP response data directly, you can do that with the help of getResponse() method provided by the @ AbstractActionController [Laminas\\Mvc\\Controller\\AbstractActionController] base class. The getResponse() method returns the instance of @ Laminas\\Http\\PhpEnvironment\\Response class. Table 4.4 contains the most important methods of this class: Method Name Description fromString($string) Populate response object from string. toString() Renders entire response as HTTP response string. setStatusCode($code) Sets HTTP status code and (optionally) message. getStatusCode() Retrieves HTTP status code. setReasonPhrase($reasonPhrase) Sets the HTTP status message. getReasonPhrase() Gets HTTP status message. isForbidden() Checks if the response code is 403 Forbidden. isNotFound() Checks if the status code indicates the resource is not found (404 status code). isOk() Checks whether the response is successful. isServerError() Checks if the response is 5xx status code. isRedirect() Checks whether the response is 303 Redirect. isSuccess() Checks whether the response is 200 Successful. setHeaders(Headers $headers) Allows to set response headers. getHeaders() Returns the list of response headers. getCookie() Retrieves Cookie header. setContent($value) Sets raw response content. getContent() Returns raw response content. getBody() Gets and decodes the content of the response. Table 4.4. Methods of Laminas\\Http\\PhpEnvironment\\Response class. For example, use the following code to set 404 status code for the response: $this->getResponse()->setStatusCode(404); Use the following code to add a header to response: $headers = $this->getResponse()->getHeaders(); $headers->addHeaderLine( \"Content-type: application/octet-stream\"); Use the following code to set response content: $this->getResponse()->setContent('Some content'); Variable Containers After you have retrieved the data from the HTTP request, you would do something with that data (typically you will process the data with your model layer) and return the data from the action method. You can see that the indexAction() method of the Index controller returns an instance of the @ ViewModel [Laminas\\View\\Model\\ViewModel] class. The @ ViewModel [Laminas\\View\\Model\\ViewModel] class is some kind of a variable container . All variables passed to its constructor, will be then automatically accessible by the view script. Let's have some real-life example. We will create another action method in our IndexController class, which we will call the aboutAction() . The \"about\" action will display the About page of our site. In the action method, we will create two variables containing information about our website, and return the variables for rendering in a view with the help of @ ViewModel [Laminas\\View\\Model\\ViewModel] object: // The \"about\" action public function aboutAction() { $appName = 'HelloWorld'; $appDescription = 'A sample application for the Using Laminas Framework book'; // Return variables to view script with the help of // ViewModel variable container return new ViewModel([ 'appName' => $appName, 'appDescription' => $appDescription ]); } In lines 4-5, we create the $appName and $appDescription variables. They store our application name and description, respectively. In lines 9-12, we pass the variables we've created to the constructor of the @ ViewModel [Laminas\\View\\Model\\ViewModel] object as an associative array. The array keys define the names of the variables which on return will be accessible to view script. The @ ViewModel [Laminas\\View\\Model\\ViewModel] class provides several methods that you can additionally use to set variables to @ ViewModel [Laminas\\View\\Model\\ViewModel] and retrieve variables from it. The table 4.5 provides the methods summary: Method name Description getVariable($name, $default) Returns a variable by name (or default value if the variable does not exist). setVariable($name, $value) Sets a variable. setVariables($variables, $overwrite) Sets a group of variables, optionally overwriting the existing ones. getVariables() Returns all variables as an array. clearVariables() Removes all variables. Table 4.5. Methods of the ViewModel class Expressing Error Conditions Sometimes things go wrong and some error occurs. For example, you expect to receive a GET variable from HTTP request, but it is missing or has an invalid value. To express this error condition, you typically set 4xx status code in HTTP response and return from controller's action. For example, in a Blog application, assume a user enters the following URL in his browser's navigation bar: http://localhost/posts/view?id=10000 . The intention of such request is to display the blog post with ID=10000. If the post with such ID doesn't exist, we can't display it and use the following code to set 404 status code (Page Not Found) for the response: // The \"view\" action displays a blog post with the given ID public function viewAction() { // Get ID argument from GET $id = (int)$this->params()->fromQuery('id', -1); // Validate the argument if ($id<1) { // Error condition - we can not display such post $this->getResponse()->setStatusCode(404); return; } // Try to find the post (we omit the actual SQL query for simplicity). $post = ... if (!$post) { // Error condition - post not found $this->getResponse()->setStatusCode(404); return; } // Normal execution // ... } When Laminas encounters the 4xx status code in response, it redirects the user to a special error page . We will talk about error pages later in this chapter. Another way to express a (critical) error condition is to throw an Exception , for example, like this: throw new \\Exception(\"Post with ID=$id could not be found\"); When Laminas encounters an unhandled exception, it displays another error page with the information about the exception. Controller Registration All controller classes belonging to a module should be registered in the module.config.php configuration file. If your controller class doesn't need to use some services (doesn't have dependencies), you can register it as follows: <?php use Laminas\\ServiceManager\\Factory\\InvokableFactory; return [ // ... 'controllers' => [ 'factories' => [ Controller\\IndexController::class => InvokableFactory::class // Put other controllers registration here ], ], // ... ]; In line 7, we have the controllers key, which contains the factories subkey. To register a controller class, you add the line in form of key=>value pair. The key should be the fully qualified name of the controller class, like \\Application\\Controller\\IndexController (we can use the PHP ::class keyword for class name resolution), and value should be the name of a factory class that would create the controller class for use. In our case, we use the standard @ InvokableFactory , but you can create your own if you need. By using the @ InvokableFactory , you tell Laminas Framework that it can invoke the controller by instantiating it with the new operator. This is the most simple way of instantiating the controller. As an alternative, you can register your own factory to create the controller instance, and inject dependencies into controller. Registering a Controller Factory If your controller class needs to call some service (this happens very often), you need to request that service from the service manager (we discussed the service manager in the Website Operation chapter) and pass that service to controller's constructor, and the controller saves the service you passed in a private property for internal use (this also called dependency injection). This procedure is typically implemented inside of a factory class. For example, assume our controller class needs to use some CurrencyConverter service which will convert money from USD to EUR. The factory class for our controller will look like below: <?php namespace Application\\Controller\\Factory; use Laminas\\ServiceManager\\Factory\\FactoryInterface; use Application\\Service\\CurrencyConverter; use Application\\Controller\\IndexController; // Factory class class IndexControllerFactory implements FactoryInterface { public function __invoke(ContainerInterface $container, $requestedName, array $options = null) { // Get the instance of CurrencyConverter service from the service manager. $currencyConverter = $container->get(CurrencyConverter::class); // Create an instance of the controller and pass the dependency // to controller's constructor. return new IndexController($currencyConverter); } } Then you register the controller the same way, but specify the factory class we have just written: <?php return [ // ... 'controllers' => [ 'factories' => [ Controller\\IndexController::class => Controller\\Factory\\IndexControllerFactory::class ], ], // ... ]; LazyControllerAbstractFactory Writing a factory for almost every controller may seem boring at first sight. If you are so lazy that you don't want to do that, you can use the standard @ LazyControllerAbstractFactory factory class. The @ LazyControllerAbstractFactory factory uses reflection to determine which services your controller wants to use. You just need to typehint the arguments of controller's constructor, and the factory will itself retrieve the needed services and pass it to the constructor. For example, to inject the CurrencyConverter service in your controller, make sure its constructor looks like below: namespace Application\\Controller; use Application\\Service\\CurrencyConverter; class IndexController extends AbstractActionController { // Here we will save the service for internal use. private $currencyConverter; // Typehint the arguments of constructor to get the dependencies. public function __construct(CurrencyConverter $currencyConverter) { $this->currencyConverter = $currencyConverter; } } Then you register the controller the same way, but specify the @ LazyControllerAbstractFactory factory: <?php use Laminas\\Mvc\\Controller\\LazyControllerAbstractFactory; return [ // ... 'controllers' => [ 'factories' => [ Controller\\IndexController::class => LazyControllerAbstractFactory::class ], ], // ... ]; When to Create a New Controller? When your site grows in size, you should create new controller classes instead of putting all actions to IndexController . The Index controller is used for defining the actions which work for your entire site. Note It is not recommended to create huge controllers with hundreds of actions, because they are difficult to understand and support. It is recommended to create new controller class for each model (or for most important ones) of your business logic domain. For example, you can create UserController to manage users of your site. This controller would have the default \"index\" action for displaying the page with all users, \"add\" action for adding a new user, \"edit\" action for editing user's profile and \"delete\" action for deleting the user. By analogy, you would create PurchaseController and its actions to manage the purchases of your products and implementing the shopping cart, DownloadController and its actions to manage file downloads for the site, etc. Controller Plugins A controller plugin is a class which extends the functionality of all controllers in some way. Without plugins, to extend the functionality of all controllers, you would have to create a custom base class, say BaseController , and derive other controllers from that base class. This way can also be used, but from Laminas creators' point of view, plugins are better solution, because they use class composition 1 , which provides better flexibility comparing to class inheritance. You register your plugin controller and it automatically becomes accessible from all controllers of your app (@ AbstractActionController base class uses PHP's __call() magic method to proxy calls to registered controller plugins). There are several standard controller plugins available out of the box (table 4.6), and we've already used one of them (the @ Params plugin) in one of our previous examples. Standard Plugin Class Description @ Params Allows to retrieve variables from HTTP request, including GET and POST variables. @ Url [Laminas\\Mvc\\Controller\\Plugin\\Url] Allows to generate absolute or relative URLs from inside controllers. @ Layout [Laminas\\Mvc\\Controller\\Plugin\\Layout] Gives access to layout view model for passing data to layout template. @ Identity [Laminas\\Mvc\\Plugin\\Identity\\Identity] Returns the identity of the user who has logged into the website. @ FlashMessenger [Laminas\\Mvc\\Plugin\\FlashMessenger\\FlashMessenger] Allows to define \"flash\" messages which are stored in session and can be displayed on a different web page. @ Redirect [Laminas\\Mvc\\Controller\\Plugin\\Redirect] Allows to redirect the request to another controller's action method. @ PostRedirectGet [Laminas\\Mvc\\Plugin\\Prg\\PostRedirectGet] Redirects the POST request, converting all POST variables to GET ones. @ FilePostRedirectGet [Laminas\\Mvc\\Plugin\\FilePrg\\FilePostRedirectGet] Redirects the POST request, preserving uploaded files. Table 4.6. Standard Controller Plugins Inside of the controller's action method, you access a plugin in the following way: // Access Url plugin $urlPlugin = $this->url(); // Access Layout plugin $layoutPlugin = $this->layout(); // Access Redirect plugin $redirectPlugin = $this->redirect(); As an alternative, you can invoke a plugin by its fully qualified name with the plugin() method provided by the base controller class, as follows: use Laminas\\Mvc\\Controller\\Plugin\\Url; // Inside your controller's action use the plugin() method. $urlPlugin = $this->plugin(Url::class); Writing Own Controller Plugin In your websites, you will likely need to create custom controller plugins. For example, assume you need that all your controller classes to be able to check whether a site user is allowed to access certain controller action. This can be implemented with the AccessPlugin class. The controller plugin should be derived from the @ AbstractPlugin [Laminas\\Mvc\\Controller\\Plugin\\AbstractPlugin] class. Plugins typically live in their own namespace Plugin , which is nested in Controller namespace: <?php namespace Application\\Controller\\Plugin; use Laminas\\Mvc\\Controller\\Plugin\\AbstractPlugin; // Plugin class class AccessPlugin extends AbstractPlugin { // This method checks whether user is allowed // to visit the page public function checkAccess($actionName) { // ... } } To let Laminas Framework know about your plugin, you need to register it in your module.config.php file under the controller_plugins key. See below for example: <?php return [ // ... 'controller_plugins' => [ 'factories' => [ Controller\\Plugin\\AccessPlugin::class => InvokableFactory::class, ], 'aliases' => [ 'access' => Controller\\Plugin\\AccessPlugin::class, ] ], // ... ]; Note Please note that we also register an alias for the plugin to be able to get the plugin by its short name. After that, you'll be able to access your custom plugin from all of your controller's actions in this way: // Check if site user is allowed to visit the \"index\" page $isAllowed = $this->access()->checkAccess('index'); Views Views belong to the presentation layer of the web application, because their goal is to produce HTML output returned by the web server to site visitors. In Laminas Framework, you implement a view as a template file , which is a file having .phtml extension (\"phtml\" stands for PHP+HTML). View templates have such a name because they usually contain HTML code mixed with PHP code snippets used for rendering the web pages. Views typically live inside of the view subdirectory of the module (see figure 4.5): Why are view template files not stored under module's source directory? View templates ( .phtml files) are not stored under module's src/ directory, because they are not usual PHP classes and do not need to be resolved by a PHP class autoloading feature. View templates are resolved by the special Laminas class called view resolver , and for this reason, view templates are stored under the module's view directory. View templates can have different behaviors, based on variables you pass to them from the controller's action method. Data is passed to view templates with the help of a @ ViewModel [Laminas\\View\\Model\\ViewModel] variable container. For example, let's implement the view template for the aboutAction() of our Index controller. The About page will display the title and some information about our Hello World application. To create the view template file, in your NetBeans window, navigate to view/application/index directory (see figure 4.6), and right click on the \"index\" directory name. From the context menu that appears, select the New->PHP File... menu item. In the \"New PHP File\" dialog that appears (figure 4.7), enter the name about.phtml and click the Finish button. The about.phtml view template file will be created and displayed in the right pane of NetBeans window. In that file, enter the following: <h1>About</h1> <p> The Hello World application. </p> <p> Application name: <?= $this->escapeHtml($appName); ?> </p> <p> Application description: <?= $this->escapeHtml($appDescription); ?>. </p> As you can see, the view template is a usual HTML page with several PHP code fragments. A view script just renders the data you pass to it with a @ ViewModel [Laminas\\View\\Model\\ViewModel] variable container. For example, in line 8 we get the value of $appName variable and print it into the standard output stream. Note Inside the view template, you easily can access the variables that were passed from the controller's action. For example, to get the value of the application name variable, use either $appName or $this->appName syntax. These two ways of accessing the variable are equivalent, but the first one requires less writing, so we will use it in the future. Please note that we are using @ EscapeHtml view helper to escape the string printed to the web page to make the website resistant to hacker attacks. Note You should always escape variables that you print to your web page. Escaping allows to be sure that no malicious code is injected on your page. In your view script, you can also use simple flow control operations (like if , foreach or switch ) to make the appearance of the page different depending on variable's value. Now let's look at how the page looks like in the web browser. Type \"http://localhost/application/about\" URL in your browser's navigation bar. The About page should appear (see figure 4.8): In general, the PHP code you use inside of views must be as simple as possible. Views typically do not modify the data you pass from controller. For example, a view can use the model you pass to it to walk through database table rows and render the items to an HTML page, but it should never create database tables or modify them itself. View Helpers View helpers are analogous to controller plugins: the controller plugins allow to \"extend\" the functionality of controllers, and view helpers allow to \"extend\" the functionality of view templates. A view helper is typically a (relatively) simple PHP class whose goal is to render some part of a view. You can invoke view helpers from any view template. With view helpers, you can create reusable widgets (like menus, navigation bars, etc.) for your web pages. Laminas provides many standard view helpers out of the box. In the table 4.7, some of them are presented with a brief description: Standard Plugin Class Description @ BasePath Allows to retrieve the base path to the web application, which is the absolute path to APP_DIR . @ Url [Laminas\\View\\Helper\\Url] Allows to generate absolute or relative URL addresses from inside view templates. @ ServerUrl Retrieves the current request's URL. @ Doctype Helper for setting and retrieving the doctype HTML element of the web page. @ HeadTitle Helper for setting the title HTML element of the web page. @ HtmlList Helper for generating ordered and unordered HTML lists. @ ViewModel [Laminas\\View\\Helper\\ViewModel] Helper for storing and retrieving the view model @ Layout [Laminas\\View\\Helper\\Layout] Retrieves the layout template view. @ Partial Allows to render a \"partial\" view template. @ InlineScript Helper for setting and retrieving script elements for inclusion in HTML body section. @ Identity [Laminas\\View\\Helper\\Identity] View helper to retrieve the authenticated user's identity. @ FlashMessenger [Laminas\\View\\Helper\\FlashMessenger] Allows to retrieve the \"flash\" messages stored in session. @ EscapeHtml Allows to escape a variable outputted to a web page. Table 4.7. Standard View Helpers To demonstrate the usage of a view helper, below we will show how to set a title for a web page. Typically, it is required to give a different title per each web page. You can do this with the @ HeadTitle view helper. For example, you can set the title for the About page by adding the following PHP code in the beginning of the about.phtml view template: <?php $this->headTitle('About'); ?> In the code above, we call the @ HeadTitle view helper and pass it the page title string (\"About\") as the argument. The @ HeadTitle view helper internally sets the text for the <title> HTML element of your web page. Then, if you open the About page in your web browser, the page title will look like \"About - Laminas Skeleton Application\" (see the figure 4.9 below for an example): We will discuss the view helpers in more details and provide more usage examples in the chapter Page Appearance and Layout . View Template Names When you return data with the @ ViewModel [Laminas\\View\\Model\\ViewModel] variable container from your controller's action method, Laminas Framework knows the name of the corresponding view template file. Laminas determines the correct view template name by module name, controller name and action name. For example, IndexController::aboutAction() action belonging to Application module will have the application/index/about.phtml view template by default. Note If your your controller or action name consists of several words in camel-case (like UserRegistrationController and registrationStep1Action ), the corresponding view template will be application/user-registration/registration-step-1.phtml (camel-cased names are converted to lower-case and words are separated by dashes). Overriding Default View Template Name The @ ViewModel [Laminas\\View\\Model\\ViewModel] can also be used to override the default view template resolving. Actually the @ ViewModel [Laminas\\View\\Model\\ViewModel] class is more than just a variable container. Additionally, it allows to specify which view template should be used for page rendering. The summary of methods provided for this purpose is shown in table 4.8. Method name Description setTemplate() Sets the view template name. getTemplate() Returns the view template name. Table 4.8. Methods of the ViewModel class for setting and retrieving the view template name To set the view template name, you use the setTemplate() method. The getTemplate() method returns the view template name currently set for the view model. The following code example shows how you can call the setTemplate() method from your IndexController class' indexAction() method to force Laminas to use the about.phtml view template file for rendering the Home page, instead of the index.phtml file: // Index action renders the Home page of your site. public function indexAction() { // Use a different view template for rendering the page. $viewModel = new ViewModel(); $viewModel->setTemplate('application/index/about'); return $viewModel; } In the code above, we created a new instance of the ViewModel class as usual (line 5). Then we called the setTemplate() method on the view model object (line 6) and passed the name of the view template name as its argument. The view template name is actually a relative path to the about.phtml file, minus file extension. Finally, we returned the view model object from the action method (line 7). Note However, calling the setTemplate() method in every action method is optional. If you don't do that, Laminas will determine the view template name automatically by concatenating the current module name, controller name and action method name. View Resolver When Laminas Framework has the template name, it only remains to determine the absolute path to the corresponding .phtml file. This is also called the view template resolving . View templates are resolved with the special Laminas Framework's class called the view resolver . In Laminas, there are two view resolvers out of the box: @ TemplatePathStack and @ TemplateMapResolver . Both resolvers take a view template name as input, and return path to view template file as output. The template name is usually composed of module name followed by controller name followed by template name, like \"application/index/about\", \"application/index/index\". An exception is \"layout/layout\", which doesn't include module name. The template map resolver uses a PHP nested array to determine path to view template file by its name. This way is fast, but you have to maintain some template map array and update it each time you add a new view script. The template path stack resolver assumes that the view template name can be mapped to directory structure. For example, \"application/index/about\" template name maps to APP_DIR/module/Application/view/application/index/about.phtml . This way is simpler, because you don't have to maintain any maps. View resolver settings are stored inside of your module.config.php file under the view_manager key: <?php return [ //... 'view_manager' => [ //... 'template_map' => [ 'layout/layout' => __DIR__ . '/../view/layout/layout.phtml', 'application/index/index' => __DIR__ . '/../view/application/index/index.phtml', 'error/404' => __DIR__ . '/../view/error/404.phtml', 'error/index' => __DIR__ . '/../view/error/index.phtml', ], 'template_path_stack' => [ __DIR__ . '/../view', ], ], ]; You can see that template map resolver's settings are stored under the template_map key. By default, there are several \"standard\" view templates, which are resolved this way: the index page template, the layout template (we will talk about it in Page Appearance and Layout ) and error templates (we will talk about them a little bit later). These standard pages are served with this type of resolver, because it is fast. The template path stack resolver's settings are stored under the template_path_stack key. You can see that this resolver looks for your view scripts under the \"view\" directory of your module. That's why we could just put about.phtml file under that directory, and ZF will automatically find the template. The template map resolver and template path stack resolver work in pair. First, the fast template map resolver tries to find the template view in its array map, and if the page is not found, the template path stack resolver is executed. Disabling the View Rendering Sometimes, you would need to disable the default view rendering. To do that, just return the @ Response [Laminas\\Http\\PhpEnvironment\\Response] object from the the controller's action. For example, let's create a DownloadController class, and add the \"file\" action, which would allow site users to download files from your website. This action does not need a corresponding file.phtml view template, because it just dumps file contents to PHP standard output stream. Add the DownloadController.php file to Controller directory of Application module, then put the following code into the file: <?php namespace Application\\Controller; use Laminas\\Mvc\\Controller\\AbstractActionController; use Laminas\\View\\Model\\ViewModel; /** * This is the controller class for managing file downloads. */ class DownloadController extends AbstractActionController { /** * This is the 'file' action that is invoked * when a user wants to download the given file. */ public function fileAction() { // Get the file name from GET variable $fileName = $this->params()->fromQuery('name', ''); // Take some precautions to make file name secure $fileName = str_replace(\"/\", \"\", $fileName); // Remove slashes $fileName = str_replace(\"\\\\\", \"\", $fileName); // Remove back-slashes // Try to open file $path = './data/download/' . $fileName; if (!is_readable($path)) { // Set 404 Not Found status code $this->getResponse()->setStatusCode(404); return; } // Get file size in bytes $fileSize = filesize($path); // Write HTTP headers $response = $this->getResponse(); $headers = $response->getHeaders(); $headers->addHeaderLine( \"Content-type: application/octet-stream\"); $headers->addHeaderLine( \"Content-Disposition: attachment; filename=\\\"\" . $fileName . \"\\\"\"); $headers->addHeaderLine(\"Content-length: $fileSize\"); $headers->addHeaderLine(\"Cache-control: private\"); // Write file content $fileContent = file_get_contents($path); if($fileContent!=false) { $response->setContent($fileContent); } else { // Set 500 Server Error status code $this->getResponse()->setStatusCode(500); return; } // Return Response to avoid default view rendering return $this->getResponse(); } } The action method takes the name parameter from URL's query part (line 19), removes slashes from file name (lines 22-23), adds HTTP headers to @ Response [Laminas\\Http\\PhpEnvironment\\Response] object (lines 39-45) and file contents (lines 48-55). Finally, it returns the @ Response [Laminas\\Http\\PhpEnvironment\\Response] object to disable the default view rendering. Register the DownloadController class by adding the following line to your module.config.php file: <?php return [ // ... 'controllers' => [ 'factories' => [ // ... Controller\\DownloadController::class => InvokableFactory::class ], ], // ... ]; You will also need to add a route to your module.config.php (a route tells Laminas to what URL to map the controller action). Modify the routes key of the config file as follows: <?php return [ // ... 'router' => [ 'routes' => [ // Add this route for the DownloadController 'download' => [ 'type' => Segment::class, 'options' => [ 'route' => '/download[/:action]', 'defaults' => [ 'controller' => Controller\\DownloadController::class, 'action' => 'index', ], ], ], ], ], // ... ]; To see how the file download works, create APP_DIR/data/download directory and put some text file named sample.txt in it. Then open your web browser and type the URL \"http://localhost/download/file?name=sample.txt\" in your browser's navigation bar and press the Enter key. The browser will download the sample.txt file and offer you to save it to some location. View Rendering Strategies A rendering strategy determines how the page will be rendered. By default, to produce the HTML page, the .phtml view template is rendered with the help of @ PhpRenderer class living in @ Laminas\\View\\Renderer [Laminas\\View] namespace. This strategy works well in 99% of cases. But sometimes you may need to return something else, for example, a JSON response or a RSS feed response. Note A response in JSON format is typically returned when you implement some kind of API (Application Programming Interface). API is used to retrieve some the data in machine-readable format. A response in RSS feed format is typically used to publish frequently changing information, like blog posts or news. So, Laminas provides three view rendering strategies out of the box: the default one (also known as @ PhpRendererStrategy [Laminas\\View\\Strategy\\PhpRendererStrategy]). the @ JsonStrategy producing an JSON response. and the @ FeedStrategy producing an RSS feed response. Returning JSON Response For example, let's show how to use @ JsonStrategy to return JSON response from a controller action. First, you'll need to register the strategy in module.config.php configuration file: <?php return [ //... 'view_manager' => [ //... 'strategies' => [ 'ViewJsonStrategy', ], ], ]; Then, return @ JsonModel (instead of the usual @ ViewModel [Laminas\\View\\Model\\ViewModel]) from your controller's action method: namespace Application\\Controller; use Laminas\\Mvc\\Controller\\ActionController; use Laminas\\View\\Model\\JsonModel; class IndexController extends ActionController { public function getJsonAction() { return new JsonModel([ 'status' => 'SUCCESS', 'message'=>'Here is your data', 'data' => [ 'full_name' => 'John Doe', 'address' => '51 Middle st.' ] ]); } } If you open the page http://localhost/application/get-json in your browser, you will see JSON response: {'status':'SUCCESS', 'message':'Here is your data', 'data':{'full_name:'John Doe', 'address':'51 Middle st.'}} Error Pages When a page could not be found or some other error happens inside of your web application, a standard error page is displayed. The appearance of the error page is controlled by the error templates. There are two error templates: error/404 which is used for \"404 Page Not Found\" error (shown in figure 4.10), and error/index which is displayed when a generic error occurs (such as an unhandled exception is thrown somewhere inside of the application). The module.config.php file contains several parameters under the view_manager key, which you can use to configure the appearance of your error templates: <?php return [ //... 'view_manager' => [ 'display_not_found_reason' => true, 'display_exceptions' => true, //... 'not_found_template' => 'error/404', 'exception_template' => 'error/index', 'template_map' => [ //... 'error/404' => __DIR__ . '/../view/error/404.phtml', 'error/index'=> __DIR__ . '/../view/error/index.phtml', ], //... ], ]; The display_not_found_reason parameter controls whether to display the detailed information about the \"Page not Found\" error. The display_exceptions parameter defines whether to display information about an unhandled exception and its stack trace. The not_found_template defines the template name for the 404 error. The exception_template specifies the template name for the unhandled exception error. Note You typically set the display_not_found_reason and display_exceptions parameters to false in production systems, because you don't want site visitors see the details about errors in your site. However, you will still be able to retrieve the detailed information from Apache's error.log file. Models A model is a PHP class which contains the business logic of your application. The business logic is the \"core\" of your website. It implements the goal of site operation. For example, if you implement an E-commerce website, you will have models implementing the product catalog and the shopping cart. In general, the term model means a simplified representation of a real-life object or phenomenon. Simplified because the real-life object has infinite amount of properties. For example, a real-life person who visits your site consists of billions of atoms, and you cannot describe them all. Instead, you take several properties of the object, which are the most important for your system and ignore all others. For example, the most important properties of the site visitor (from website architect's point of view) are first name, last name, country, city, post code and street address. Models can have some behavior. For example, a mailer model may send E-mail messages, the currency converter model may be able to convert money and so on. With Laminas, you represent models as usual PHP classes. Properties are implemented as class fields, and the behaviors are implemented as class methods. Model Types In Laminas Framework, there is no single Model directory for storing the model classes, as you could assume. Instead, by convention, models are further subdivided into the following principal types, and each type is stored in its own subdirectory (see table 4.9): Model Type Directory Entities APP_DIR/module/Application/src/Entity Repositories APP_DIR/module/Application/src/Repository Value Objects APP_DIR/module/Application/src/ValueObject Services APP_DIR/module/Application/src/Service Factories In Factory subdirectory under each model type directory. For example, controller factories would be stored in APP_DIR/module/Application/src/Controller/Factory Table 4.9. Model Types and their Location Separation of models into different types make it easier to design your business logic domain. This is also called the \"Domain Driven Design\" (or shortly, DDD). The person who proposed DDD was Eric Evans in his famous book called Domain-Driven Design \u2014 Tackling Complexity in the Heart of Software . Below, we will describe the principal model types further. Entities Entities are intended for storing some data and always have some identifier property, so you can uniquely identify the data. For example, a User entity always has a unique login property, and you can identify the user by that attribute. You can change some other attributes of the entity, like firstName , or address , but its identifier never changes. Entities are usually stored in a database, in a file system or in any other storage. Below, you can find an example a User entity, which represents a site visitor: // The User entity represents a site visitor class User { // Properties private $login; // e.g. \"admin\" private $title; // e.g. \"Mr.\" private $firstName; // e.g. \"John\" private $lastName; // e.g. \"Doe\" private $country; // e.g. \"USA\" private $city; // e.g. \"Paris\" private $postCode; // e.g. \"10543\" private $address; // e.g. \"Jackson rd.\" // Behaviors public function getLogin() { return $this->login; } public setLogin($login) { $this->login = $login; } //... } In lines 5-12, we define User model's properties. The best practice is to define the properties using the private access type, and make them available to the caller through getter and setter public methods (like getLogin() and setLogin() , etc). Note Model's behavior methods are not limited by getters and setters. You can create other methods which manipulate model's data. For example, you can define the getFullName() convenience method, which would return the user's full name, like \"Mr. John Doe\". Repositories Repositories are specific models responsible for storing and retrieving entities. For example, a UserRepository may represent a database table and provide methods for retrieving User entities. You typically use repositories when storing entities in a database. With repositories, you can encapsulate SQL query logic in the single place and easily maintain and test it. We will learn about repositories in more details in Database Management with Doctrine , when talking about Doctrine library. Value Objects Value objects are a kind of model for which the identity is not as important as for entities. A value object is usually a small class identified by all of its attributes. It does not have an identifier attribute. Value objects typically have getter methods, but do not have setters (value objects are immutable). For example, a model wrapping a money amount can be treated as a value object: class MoneyAmount { // Properties private $currency; private $amount; // Constructor public function __construct($amount, $currency='USD') { $this->amount = $amount; $this->currency = $currency; } // Gets the currency code public function getCurrency() { return $this->currency; } // Gets the money amount public function getAmount() { return $this->amount; } } In lines 4-5 we define two properties: currency and amount . The model has no identifier property, instead it is identified by all properties as a whole: if you change either the currency or amount , you would have a different money amount object. In lines 8-12 we define the constructor method, which initializes the properties. In lines 15-24, we define getter methods for model's properties. Note that we do not have setter methods (the model is immutable). Services Service models usually encapsulate some business logic functionality. Services usually have easily recognizable names ending with \"er\" suffix, like FileUploader or UserManager . Below, an example of Mailer service is presented. It has the sendMail() method which takes an EmailMessage value object and sends an E-mail message using standard PHP mail() function: <?php // The Email message value object class EmailMessage { private $recipient; private $subject; private $text; // Constructor public function __construct($recipient, $subject, $text) { $this->recipient = $recipient; $this->subject = $subject; $this->text = $text; } // Getters public function getRecipient() { return $this->recipient; } public function getSubject() { return $this->subject; } public function getText() { return $this->text; } } // The Mailer service, which can send messages by E-mail class Mailer { public function sendMail($message) { // Use PHP mail() function to send an E-mail if(!mail($message->getRecipient(), $message->getSubject(), $message()->getText())) { // Error sending message return false; } return true; } } In Laminas Framework, you typically register your service models in Service Manager. Factories Factories are usually being designed to instantiate other models (particularly, service models). In the simplest cases you can create an instance of a service without any factory, just by using the new operator, but sometimes class creation logic might be rather complex. For example, services often depend on each other, so you might need to inject dependencies to a service. Also, sometimes it may be required to initialize the service right after instantiation by calling one (or several) of its methods. Factory classes typically have names ending with Factory suffix, like CurrencyConverterFactory , MailerFactory , etc. For a real-life example, let's imagine that we have a PurchaseManager service, which can process purchases of some goods, and that the PurchaseManager service uses another service named CurrencyConverter , which can connect to an external system providing money exchange rates. Let's write a factory class for the PurchaseManager , which would instantiate the service and pass it the dependency: <?php namespace Application\\Service\\Factory; use Interop\\Container\\ContainerInterface; use Laminas\\ServiceManager\\Factory\\FactoryInterface; use Application\\Service\\CurrencyConverter; use Application\\Service\\PurchaseManager; /** * This is the factory for PurchaseManager service. Its purpose is to instantiate the * service and inject its dependencies. */ class PurchaseManagerFactory implements FactoryInterface { public function __invoke(ContainerInterface $container, $requestedName, array $options = null) { // Get CurrencyConverter service from the service manager. $currencyConverter = $container->get(CurrencyConverter::class); // Instantiate the service and inject dependencies. return new PurchaseManager($currencyConverter); } } In the code above we have the PurchaseManagerFactory class which implements the Laminas\\ServiceManager\\Factory\\FactoryInterface interface. The factory class has the __invoke() method whose goal is to instantiate the object. This method has the $container argument which is the service manager. You can use $container to retrieve services from service manager and pass them to the constructor method of the service being instantiated. Determining the Correct Model Type Isn't it confusing to have so many model types? Well, yes and no. At first, it may be a little difficult to determine the correct model type, but as soon you improve your skills, you will be able to do that intuitively. Just remember that model types improve the structure of your domain models. When writing your own application, you may be confused when trying to decide to which model type your class belongs (whether it is an entity, value object, repository, service or factory). Below, a simple algorithm is provided to make it easier for you to determine the correct model type when writing your own application: Your model class is definitely a Service if it encapsulates some business logic if you call it from your controller class if you think the best name for it ends with \"er\": suffix, like FileUploader or VersionChecker Your model class is an Entity : if your model is stored in a database if it has an ID attribute if it has both getters and setters methods Your model class is a ValueObject : if changing any attribute would make the model completely different if your model has getters, but not setters (immutable) Your model is a Repository : if it works with a database to retrieve entities Your model is a Factory : if it can create other objects and can do nothing else Hmm... what if I just store all my models in a single Model directory? Of course, you can, if you strongly wish. But, when you use Doctrine ORM library, you will notice that it utilizes DDD principles as well, so using DDD makes your application well-organized. Other Model Types In your website, you will typically divide your principal model types (described above) into subtypes. For example, you will have: Forms . Forms are models whose purpose is to collect data entered by web user. Forms are a subtype of entities . You will typically store forms in APP_DIR/module/Application/src/Form directory. Filters . Filters are designed for transforming input data. Filters are a subtype of services . You will typically store filters in APP_DIR/module/Application/src/Filter directory. Validators . Validators are used for checking input data for correctness. Validators are also a subtype of services . You will typically store validators in APP_DIR/module/Application/src/Validator directory. View Helpers . They encapsulate some page rendering functionality. View helpers are similar to services . You will typically store view helpers in APP_DIR/module/Application/src/View/Helper directory. Routes . Routes are a specific service model used for implementing custom mapping rules between URLs and your controllers. You will typically store custom routes in APP_DIR/module/Application/src/Route directory. So, eventually you will have the following typical directory structure of your website's module: /Application/src /Controller /Factory /Plugin /Factory /Entity /Filter /Form /Repository /Route /Service /Factory /Validator /ValueObject /View /Helper /Factory It is possible to have arbitrarily many model subtypes. The more complex is your application, the more model subtypes you may have. Skinny Controllers, Fat Models, Simple Views When developing a website using Model-View-Controller pattern, there is a risk of misunderstanding the role of controllers, views and models. This results in making the controllers huge and models small, which in turn makes it difficult to test and support your application. This section's goal is to give you a general understanding of what code may be placed in a controller class, what code may be placed in a view template, and what code may be placed in a model class. Skinny Controllers The idea behind the term \"skinny controller\" is that typically, in your controller classes, you put only the code that: accesses user request data ( $_GET , $_POST , $_FILES and other PHP variables); checks the validity of the input data; (optionally) makes some basic preparations to the data; passes the data to model(s) and retrieves the result returned by the model(s); and finally returns the output data as a part of a ViewModel variable container. A controller class should avoid: containing complex business logic, which is better kept in model classes; containing any HTML or any other presentational markup code. This is better be put in view templates. For an example of a \"skinny\" controller, look at the CurrencyConverterController class below. This controller provides the \"convert\" action method whose goal is to convert an amount of money from EUR to USD currency. The user passes the amount of money through the \"amount\" GET variable. class CurrencyConverterController extends AbstractActionController { // Currency converter model private $currencyConverter; // Constructor. It's purpose is to \"inject\" dependencies. public function __construct($currencyConverter) { $this->currencyConverter = $currencyConverter; } // The \"convert\" action displays the converted money amount public function convertAction() { // Get the money amount from GET $amount = (float)$this->params()->fromQuery('amount', -1); // Validate input data if($amount<0) { // Money amount is missing $this->getResponse()->setStatusCode(404); return; } // Pass the data to the CurrencyConverter model $convertedAmount = $this->currencyConverter->convertEURtoUSD($amount); return new ViewModel([ 'amount'=>$amount, 'convertedAmount'=>$convertedAmount ]); } } The controller's action method above does the following: Takes the data passed by site user (line 16). This data is usually part of Request object and can be retrieved using the controller's getRequest() method or @ Params controller plugin. Performs the basic check on the data passed by user (line 19), and if the data is missing (or invalid), sets an HTTP error code (line 21). Passes the money amount to the CurrencyConverter model (line 26) by calling its convertEURtoUSD() method. The method then returns the converted amount. Constructs the @ ViewModel [Laminas\\View\\Model\\ViewModel] variable container and passes the resulting data to it (line 28). This variable container can be further accessed in the corresponding view template responsible for data presentation. Fat Models Because you need to keep your controllers as thin as possible, most of the business logic of your application should be put into model classes. In a properly designed Model-View-Controller application, models look \"huge\". A model class may contain the code which: Performs complex data filtering and validation. Because the data that you retrieved in controller is passed to your application from an outside world, in your model, you have to take a lot of effort to verify the data and ensure the data will not break your system. This results in a secure website resistant to hacker attacks. Performs data manipulation. Your models should manipulate the data: e.g. load the data from database, save it to database and transform the data. Models are the right place for storing database queries, file reading and writing functionality, and so on. In a model class you are not recommended to: Access the data from the HTTP request, $_GET , $_POST and other PHP variables. It is the controller's work to extract that data and pass it to model's input. Produce HTML or other code specific to presentation. The presentational code may vary depending on the user request, and it is better to put it in a view template. If you follow these principles, you will encounter that your models are easy to test, because they have clearly identified input and output. You can write a unit test which passes some test data to input end of the model, retrieves the output data and verifies that the data is correct. If you are confused whether to put certain code in a controller or in a model, ask yourself: is this an important business logic that needs to be carefully tested? If the answer is yes, you should put the code in a model. Simple View Templates Because most of the logic is stored in models, your view templates should be as simple as possible to produce the presentation of the data passed through the variable container. In a view template, you may: Keep static HTML markup code. Retrieve the data from a variable container and echo them to PHP output stream. If a controller passed a certain model through a variable container, poll the model for data (e.g. you can retrieve table rows from a database table and render them). Contain simple PHP flow control operations, like if , foreach , switch and so on. This allows to vary the presentation depending on variables passed by the controller. The view template is not recommended to: Access data from the HTTP request and super global PHP variables. Create models, manipulate them and modify the state of the application. If you follow these principles, you will encounter that your views can easily be substituted without modifying the business logic of your application. For example, you can easily change the design of your web pages, or even introduce changeable themes. Summary A Laminas Framework based website is just a PHP program receiving an HTTP request from the web server, and producing an HTTP response. The web application uses the Model-View-Controller pattern to separate business logic from presentation. The goal of this is to allow for code reusability and separation of concerns. A controller is a mediator between the application, models and views: it gets input from HTTP request and uses the model(s) and the corresponding view to produce the necessary HTTP response. A controller is a usual PHP class containing action methods. Views are simple HTML+PHP code snippets producing HTML output returned by the web server to site visitors. You pass the data to view scripts through the @ ViewModel [Laminas\\View\\Model\\ViewModel] variable container. A model is a PHP class which contains the business logic of your application. The business logic is the \"core\" of your website which implement the goal of site operation. Models can access database, manipulate disk files, connect to external systems, manipulate other models and so on. Composition is a relationship between two classes that is best described as a \"has-a\" and \"whole/part\" relationship. The owner class contains a reference to another class (plugin). The owner is responsible for the lifetime of the object it holds. \u21a9","title":"Model-View-Controller"},{"location":"mvc/#model-view-controller","text":"In this chapter, you will learn about the models, views and controllers (the MVC design pattern). A web application uses the MVC pattern to separate business logic from presentation. The goal of this is to allow for code reusability and separation of concerns. Laminas components covered in this chapter: Component Description @ Laminas\\Mvc Support of MVC pattern. Implements base controller classes, controller plugins, etc. @ Laminas\\View Implements the functionality for variable containers, rendering a web page and common view helpers. @ Laminas\\Http Implements a wrapper around HTTP request and response.","title":"Model-View-Controller"},{"location":"mvc/#get-the-hello-world-example-from-github","text":"In this and in the next chapters, we will provide some code samples that you may want to reproduce yourself. It may be difficult for a novice to write code without mistakes. If you are stuck or can not understand why your code does not work, you can download the complete Hello World web application from GitHub code hosting. Code examples from this chapter are mostly the part of this Hello World sample application. To download the Hello World application, visit this page and click the Clone or Download button to download the code as a ZIP archive (see figure 4.1). When download is complete, unpack the archive to some directory. Then navigate to the helloworld directory containing the complete source code of the Hello World example: /using-laminas-book-samples /helloworld ... The Hello World is a complete website which can be installed on your machine. To install the example, you can either edit your default Apache virtual host file or create a new one. After editing the file, restart the Apache HTTP Server and open the website in your web browser.","title":"Get the Hello World Example from GitHub"},{"location":"mvc/#separating-business-logic-from-presentation","text":"A typical website has three kinds of functionality: code implementing business logic, code implementing user interaction and code rendering HTML pages (presentation). Before PHP frameworks, programmers usually merged these three types of code in a single big PHP script file, which made it a pain to test and maintain such code, especially when you write a large website. Since that time, PHP became object-oriented, and now you can organize your code into classes. The Model-View-Controller (MVC) pattern is just a set of advices telling you how to organize your classes in a better manner, to make them easy to maintain. In MVC, classes implementing your business logic are called models , code snippets rendering HTML pages are called views , and the classes responsible for interacting with user are called controllers . Note Views are implemented as code snippets , not as classes. This is because views are typically very simple and contain only the mixture of HTML and inline PHP code. The main objective of the MVC concept is to separate the business logic (models) from its visualization (views). This is also called the separation of concerns , when each layer does its specific tasks only. By separating your models from views, you reduce the number of dependencies between them. Therefore, changes made to one of the layers have the lowest possible impact on other layers. This separation also improves the code reusability . For example, you can create multiple visual representations for the same models (changeable themes). To better understand how this works, lets remember that any website is just a PHP program receiving an HTTP request from the web server, and producing an HTTP response. Figure 4.2 shows how an HTTP request is processed by the MVC application and how the response is generated: First, a website visitor enters a URL in his/her web browser, for example http://localhost , and the web browser sends the request to the web server over the Internet. Web server's PHP engine runs the index.php entry script. The only thing the entry script does is creating the @ Laminas\\Mvc\\Application class instance. The application uses its router component for parsing the URL and determining to which controller to pass the request. If the route match is found, the controller is instantiated and its appropriate action method is called. In the controller's action method, parameters are retrieved from GET and POST variables. To process the incoming data, the controller instantiates appropriate model classes and calls their methods. Model classes use business logic algorithms to process the input data and return the output data. The business logic algorithms are application-specific, and typically include retrieving data from database, managing files, interacting with external systems and so on. The result of calling the models are passed to the corresponding view script for the rendering of the HTML page. View script uses the model-provided data for rendering the HTML page. Controller passes the resulting HTTP response to application. Web server returns the resulting HTML web page to the user's web browser. The user sees the page in browser window. Now you might have some idea how models, views and controllers cooperate to generate HTML output. In the next sections, we describe them in more details.","title":"Separating Business Logic from Presentation"},{"location":"mvc/#controllers","text":"A controller provides communication between the application, models and views: gets input from HTTP request and uses the model(s) and the corresponding view to produce the necessary HTTP response. Controllers belonging to module typically reside in the Controller subdirectory of module's source directory (shown in figure 4.3). Laminas Skeleton Application provides you with the default implementation of IndexController class. The IndexController is typically the main controller class of the website. Its code is presented below (some parts of code were omitted for simplicity): <?php namespace Application\\Controller; use Laminas\\Mvc\\Controller\\AbstractActionController; use Laminas\\View\\Model\\ViewModel; class IndexController extends AbstractActionController { public function indexAction() { return new ViewModel(); } } From the example above, you can see that controllers usually define their own namespace (line 2). The Index controller, as all other controllers from the Application module, lives in Application\\Controller namespace. A controller is a usual PHP class derived from the @ AbstractActionController [Laminas\\Mvc\\Controller\\AbstractActionController] base class (line 7). By default, the controller class contains the single action method called indexAction() (see lines 9-12). Typically, you will create other action methods in your controller classes. Note Laminas automatically recognizes the action methods by the Action suffix. If a controller method's name does not have that suffix, it is considered as a usual method, not an action. As its name assumes, an action method performs some site action, which typically results in producing a single web page. Index controller usually contains action methods for site-wide web pages (table 4.1). For example, you would have \"index\" action for the Home page, \"about\" action for About page, \"contactUs\" action for the Contact Us page and possibly other actions. Action Method Description IndexController::indexAction() The \"index\" action displays the Home page of your site. IndexController::aboutAction() The \"about\" action displays the About page of the site. The About page contains contact and copyright information. IndexController::contactUsAction() The \"contactUs\" action displays the Contact Us page of the site. The Contact Us page displays the form for contacting site authors. Table 4.1. Index controller's typical actions","title":"Controllers"},{"location":"mvc/#base-controller-class","text":"Every controller in your website is inherited from the @ AbstractActionController [Laminas\\Mvc\\Controller\\AbstractActionController] base class. In figure 4.4, the class inheritance diagram is presented. The @ AbstractActionController [Laminas\\Mvc\\Controller\\AbstractActionController] provides you with several useful methods you can use in your controller classes. Table 4.2 provides you with a brief summary of the methods: Method Name Description getRequest() Retrieves the @ Laminas\\Http\\Request object, which is the representation of HTTP request data. getResponse() Retrieves the @ Laminas\\Http\\PhpEnvironment\\Response object allowing to set data of HTTP response. getEventManager() Returns the @ Laminas\\EventManager\\EventManager object, allowing to trigger events and listen to events. getEvent() Returns the @ Laminas\\Mvc\\MvcEvent object, which represents the event the controller responds to. getPluginManager() Returns the @ Laminas\\Mvc\\Controller\\PluginManager object, which can be used for registering controller plugins. plugin($name, $options) This method allows to access certain controller plugin with the given name. __call($method, $params) Allows to call a plugin indirectly using the PHP __call magic method. Table 4.2. AbstractActionController's useful methods As you can see from the table above, the base controller class provides you with access to HTTP request and response data, and provides you with the access to the event manager. It also gives you an ability to register and call controller plugins (we will learn about controller plugins later in this chapter).","title":"Base Controller Class"},{"location":"mvc/#retrieving-data-from-http-request","text":"In a controller's action method, you may need to retrieve the data from the HTTP request (the data like GET and POST variables, cookies, HTTP headers and so on). For this purpose, Laminas Framework provides you with @ Laminas\\Http\\Request class, which is part of @ Laminas\\Http component. To get the HTTP request object, inside of your action method, you can use the following code: // Get HTTP request object $request = $this->getRequest(); The code above returns the instance of @ Laminas\\Http\\Request class, containing all the HTTP request data. In table 4.3, you can find the most widely used methods of the @ Request [Laminas\\Http\\Request] class together with their brief description. Method Name Description isGet() Checks if this is a GET request. isPost() Checks if this is a POST request. isXmlHttpRequest() Checks if this request is an AJAX request. isFlashRequest() Check if this request is a Flash request. getMethod() Returns the method for this request. getUriString() Returns the URI for this request object as a string. getQuery($name, $default) Returns the query parameter by name, or all query parameters. If a parameter is not found, returns the $default value. getPost($name, $default) Returns the parameter container responsible for post parameters or a single post parameter. getCookie() Returns the Cookie header. getFiles($name, $default) Returns the parameter container responsible for file parameters or a single file. getHeaders($name, $default) Returns the header container responsible for headers or all headers of a certain name/type. getHeader($name, $default) Returns a header by $name . If a header is not found, returns the $default value. renderRequestLine() Returns the formatted request line (first line) for this HTTP request. fromString($string) A static method that produces a Request object from a well-formed Http Request string toString() Returns the raw HTTP request as a string. Table 4.3. Methods of Laminas\\Http\\Request class.","title":"Retrieving Data from HTTP Request"},{"location":"mvc/#retrieving-get-and-post-variables","text":"To simply get a GET or POST variable from an HTTP request, you use the following code: // Get a variable from GET $getVar = $this->params()->fromQuery('var_name', 'default_val'); // Get a variable from POST $postVar = $this->params()->fromPost('var_name', 'default_val'); In the example above, we used the @ Params controller plugin, which provides you with convenient methods of accessing GET and POST variables, uploaded files, etc. In line 2 we use the fromQuery() method for retrieving a variable having name \"var_name\" from GET. If such a variable does not present, the default value \"default_val\" is returned. The default value is very convenient, because you don't have to use the isset() PHP function to test if the variable exists. In line 5 we use the fromPost() method to retrieve the variable from POST. The meaning of this method's parameters is the same as for the fromQuery() method. Note In Laminas, you must not access request parameters through traditional PHP $_GET and $_POST global arrays. Instead, you use laminas-provided API for retrieving the request data.","title":"Retrieving GET and POST Variables"},{"location":"mvc/#putting-data-to-http-response","text":"Although you rarely interact with HTTP response data directly, you can do that with the help of getResponse() method provided by the @ AbstractActionController [Laminas\\Mvc\\Controller\\AbstractActionController] base class. The getResponse() method returns the instance of @ Laminas\\Http\\PhpEnvironment\\Response class. Table 4.4 contains the most important methods of this class: Method Name Description fromString($string) Populate response object from string. toString() Renders entire response as HTTP response string. setStatusCode($code) Sets HTTP status code and (optionally) message. getStatusCode() Retrieves HTTP status code. setReasonPhrase($reasonPhrase) Sets the HTTP status message. getReasonPhrase() Gets HTTP status message. isForbidden() Checks if the response code is 403 Forbidden. isNotFound() Checks if the status code indicates the resource is not found (404 status code). isOk() Checks whether the response is successful. isServerError() Checks if the response is 5xx status code. isRedirect() Checks whether the response is 303 Redirect. isSuccess() Checks whether the response is 200 Successful. setHeaders(Headers $headers) Allows to set response headers. getHeaders() Returns the list of response headers. getCookie() Retrieves Cookie header. setContent($value) Sets raw response content. getContent() Returns raw response content. getBody() Gets and decodes the content of the response. Table 4.4. Methods of Laminas\\Http\\PhpEnvironment\\Response class. For example, use the following code to set 404 status code for the response: $this->getResponse()->setStatusCode(404); Use the following code to add a header to response: $headers = $this->getResponse()->getHeaders(); $headers->addHeaderLine( \"Content-type: application/octet-stream\"); Use the following code to set response content: $this->getResponse()->setContent('Some content');","title":"Putting Data to HTTP Response"},{"location":"mvc/#variable-containers","text":"After you have retrieved the data from the HTTP request, you would do something with that data (typically you will process the data with your model layer) and return the data from the action method. You can see that the indexAction() method of the Index controller returns an instance of the @ ViewModel [Laminas\\View\\Model\\ViewModel] class. The @ ViewModel [Laminas\\View\\Model\\ViewModel] class is some kind of a variable container . All variables passed to its constructor, will be then automatically accessible by the view script. Let's have some real-life example. We will create another action method in our IndexController class, which we will call the aboutAction() . The \"about\" action will display the About page of our site. In the action method, we will create two variables containing information about our website, and return the variables for rendering in a view with the help of @ ViewModel [Laminas\\View\\Model\\ViewModel] object: // The \"about\" action public function aboutAction() { $appName = 'HelloWorld'; $appDescription = 'A sample application for the Using Laminas Framework book'; // Return variables to view script with the help of // ViewModel variable container return new ViewModel([ 'appName' => $appName, 'appDescription' => $appDescription ]); } In lines 4-5, we create the $appName and $appDescription variables. They store our application name and description, respectively. In lines 9-12, we pass the variables we've created to the constructor of the @ ViewModel [Laminas\\View\\Model\\ViewModel] object as an associative array. The array keys define the names of the variables which on return will be accessible to view script. The @ ViewModel [Laminas\\View\\Model\\ViewModel] class provides several methods that you can additionally use to set variables to @ ViewModel [Laminas\\View\\Model\\ViewModel] and retrieve variables from it. The table 4.5 provides the methods summary: Method name Description getVariable($name, $default) Returns a variable by name (or default value if the variable does not exist). setVariable($name, $value) Sets a variable. setVariables($variables, $overwrite) Sets a group of variables, optionally overwriting the existing ones. getVariables() Returns all variables as an array. clearVariables() Removes all variables. Table 4.5. Methods of the ViewModel class","title":"Variable Containers"},{"location":"mvc/#expressing-error-conditions","text":"Sometimes things go wrong and some error occurs. For example, you expect to receive a GET variable from HTTP request, but it is missing or has an invalid value. To express this error condition, you typically set 4xx status code in HTTP response and return from controller's action. For example, in a Blog application, assume a user enters the following URL in his browser's navigation bar: http://localhost/posts/view?id=10000 . The intention of such request is to display the blog post with ID=10000. If the post with such ID doesn't exist, we can't display it and use the following code to set 404 status code (Page Not Found) for the response: // The \"view\" action displays a blog post with the given ID public function viewAction() { // Get ID argument from GET $id = (int)$this->params()->fromQuery('id', -1); // Validate the argument if ($id<1) { // Error condition - we can not display such post $this->getResponse()->setStatusCode(404); return; } // Try to find the post (we omit the actual SQL query for simplicity). $post = ... if (!$post) { // Error condition - post not found $this->getResponse()->setStatusCode(404); return; } // Normal execution // ... } When Laminas encounters the 4xx status code in response, it redirects the user to a special error page . We will talk about error pages later in this chapter. Another way to express a (critical) error condition is to throw an Exception , for example, like this: throw new \\Exception(\"Post with ID=$id could not be found\"); When Laminas encounters an unhandled exception, it displays another error page with the information about the exception.","title":"Expressing Error Conditions"},{"location":"mvc/#controller-registration","text":"All controller classes belonging to a module should be registered in the module.config.php configuration file. If your controller class doesn't need to use some services (doesn't have dependencies), you can register it as follows: <?php use Laminas\\ServiceManager\\Factory\\InvokableFactory; return [ // ... 'controllers' => [ 'factories' => [ Controller\\IndexController::class => InvokableFactory::class // Put other controllers registration here ], ], // ... ]; In line 7, we have the controllers key, which contains the factories subkey. To register a controller class, you add the line in form of key=>value pair. The key should be the fully qualified name of the controller class, like \\Application\\Controller\\IndexController (we can use the PHP ::class keyword for class name resolution), and value should be the name of a factory class that would create the controller class for use. In our case, we use the standard @ InvokableFactory , but you can create your own if you need. By using the @ InvokableFactory , you tell Laminas Framework that it can invoke the controller by instantiating it with the new operator. This is the most simple way of instantiating the controller. As an alternative, you can register your own factory to create the controller instance, and inject dependencies into controller.","title":"Controller Registration"},{"location":"mvc/#registering-a-controller-factory","text":"If your controller class needs to call some service (this happens very often), you need to request that service from the service manager (we discussed the service manager in the Website Operation chapter) and pass that service to controller's constructor, and the controller saves the service you passed in a private property for internal use (this also called dependency injection). This procedure is typically implemented inside of a factory class. For example, assume our controller class needs to use some CurrencyConverter service which will convert money from USD to EUR. The factory class for our controller will look like below: <?php namespace Application\\Controller\\Factory; use Laminas\\ServiceManager\\Factory\\FactoryInterface; use Application\\Service\\CurrencyConverter; use Application\\Controller\\IndexController; // Factory class class IndexControllerFactory implements FactoryInterface { public function __invoke(ContainerInterface $container, $requestedName, array $options = null) { // Get the instance of CurrencyConverter service from the service manager. $currencyConverter = $container->get(CurrencyConverter::class); // Create an instance of the controller and pass the dependency // to controller's constructor. return new IndexController($currencyConverter); } } Then you register the controller the same way, but specify the factory class we have just written: <?php return [ // ... 'controllers' => [ 'factories' => [ Controller\\IndexController::class => Controller\\Factory\\IndexControllerFactory::class ], ], // ... ];","title":"Registering a Controller Factory"},{"location":"mvc/#lazycontrollerabstractfactory","text":"Writing a factory for almost every controller may seem boring at first sight. If you are so lazy that you don't want to do that, you can use the standard @ LazyControllerAbstractFactory factory class. The @ LazyControllerAbstractFactory factory uses reflection to determine which services your controller wants to use. You just need to typehint the arguments of controller's constructor, and the factory will itself retrieve the needed services and pass it to the constructor. For example, to inject the CurrencyConverter service in your controller, make sure its constructor looks like below: namespace Application\\Controller; use Application\\Service\\CurrencyConverter; class IndexController extends AbstractActionController { // Here we will save the service for internal use. private $currencyConverter; // Typehint the arguments of constructor to get the dependencies. public function __construct(CurrencyConverter $currencyConverter) { $this->currencyConverter = $currencyConverter; } } Then you register the controller the same way, but specify the @ LazyControllerAbstractFactory factory: <?php use Laminas\\Mvc\\Controller\\LazyControllerAbstractFactory; return [ // ... 'controllers' => [ 'factories' => [ Controller\\IndexController::class => LazyControllerAbstractFactory::class ], ], // ... ];","title":"LazyControllerAbstractFactory"},{"location":"mvc/#when-to-create-a-new-controller","text":"When your site grows in size, you should create new controller classes instead of putting all actions to IndexController . The Index controller is used for defining the actions which work for your entire site. Note It is not recommended to create huge controllers with hundreds of actions, because they are difficult to understand and support. It is recommended to create new controller class for each model (or for most important ones) of your business logic domain. For example, you can create UserController to manage users of your site. This controller would have the default \"index\" action for displaying the page with all users, \"add\" action for adding a new user, \"edit\" action for editing user's profile and \"delete\" action for deleting the user. By analogy, you would create PurchaseController and its actions to manage the purchases of your products and implementing the shopping cart, DownloadController and its actions to manage file downloads for the site, etc.","title":"When to Create a New Controller?"},{"location":"mvc/#controller-plugins","text":"A controller plugin is a class which extends the functionality of all controllers in some way. Without plugins, to extend the functionality of all controllers, you would have to create a custom base class, say BaseController , and derive other controllers from that base class. This way can also be used, but from Laminas creators' point of view, plugins are better solution, because they use class composition 1 , which provides better flexibility comparing to class inheritance. You register your plugin controller and it automatically becomes accessible from all controllers of your app (@ AbstractActionController base class uses PHP's __call() magic method to proxy calls to registered controller plugins). There are several standard controller plugins available out of the box (table 4.6), and we've already used one of them (the @ Params plugin) in one of our previous examples. Standard Plugin Class Description @ Params Allows to retrieve variables from HTTP request, including GET and POST variables. @ Url [Laminas\\Mvc\\Controller\\Plugin\\Url] Allows to generate absolute or relative URLs from inside controllers. @ Layout [Laminas\\Mvc\\Controller\\Plugin\\Layout] Gives access to layout view model for passing data to layout template. @ Identity [Laminas\\Mvc\\Plugin\\Identity\\Identity] Returns the identity of the user who has logged into the website. @ FlashMessenger [Laminas\\Mvc\\Plugin\\FlashMessenger\\FlashMessenger] Allows to define \"flash\" messages which are stored in session and can be displayed on a different web page. @ Redirect [Laminas\\Mvc\\Controller\\Plugin\\Redirect] Allows to redirect the request to another controller's action method. @ PostRedirectGet [Laminas\\Mvc\\Plugin\\Prg\\PostRedirectGet] Redirects the POST request, converting all POST variables to GET ones. @ FilePostRedirectGet [Laminas\\Mvc\\Plugin\\FilePrg\\FilePostRedirectGet] Redirects the POST request, preserving uploaded files. Table 4.6. Standard Controller Plugins Inside of the controller's action method, you access a plugin in the following way: // Access Url plugin $urlPlugin = $this->url(); // Access Layout plugin $layoutPlugin = $this->layout(); // Access Redirect plugin $redirectPlugin = $this->redirect(); As an alternative, you can invoke a plugin by its fully qualified name with the plugin() method provided by the base controller class, as follows: use Laminas\\Mvc\\Controller\\Plugin\\Url; // Inside your controller's action use the plugin() method. $urlPlugin = $this->plugin(Url::class);","title":"Controller Plugins"},{"location":"mvc/#writing-own-controller-plugin","text":"In your websites, you will likely need to create custom controller plugins. For example, assume you need that all your controller classes to be able to check whether a site user is allowed to access certain controller action. This can be implemented with the AccessPlugin class. The controller plugin should be derived from the @ AbstractPlugin [Laminas\\Mvc\\Controller\\Plugin\\AbstractPlugin] class. Plugins typically live in their own namespace Plugin , which is nested in Controller namespace: <?php namespace Application\\Controller\\Plugin; use Laminas\\Mvc\\Controller\\Plugin\\AbstractPlugin; // Plugin class class AccessPlugin extends AbstractPlugin { // This method checks whether user is allowed // to visit the page public function checkAccess($actionName) { // ... } } To let Laminas Framework know about your plugin, you need to register it in your module.config.php file under the controller_plugins key. See below for example: <?php return [ // ... 'controller_plugins' => [ 'factories' => [ Controller\\Plugin\\AccessPlugin::class => InvokableFactory::class, ], 'aliases' => [ 'access' => Controller\\Plugin\\AccessPlugin::class, ] ], // ... ]; Note Please note that we also register an alias for the plugin to be able to get the plugin by its short name. After that, you'll be able to access your custom plugin from all of your controller's actions in this way: // Check if site user is allowed to visit the \"index\" page $isAllowed = $this->access()->checkAccess('index');","title":"Writing Own Controller Plugin"},{"location":"mvc/#views","text":"Views belong to the presentation layer of the web application, because their goal is to produce HTML output returned by the web server to site visitors. In Laminas Framework, you implement a view as a template file , which is a file having .phtml extension (\"phtml\" stands for PHP+HTML). View templates have such a name because they usually contain HTML code mixed with PHP code snippets used for rendering the web pages. Views typically live inside of the view subdirectory of the module (see figure 4.5): Why are view template files not stored under module's source directory? View templates ( .phtml files) are not stored under module's src/ directory, because they are not usual PHP classes and do not need to be resolved by a PHP class autoloading feature. View templates are resolved by the special Laminas class called view resolver , and for this reason, view templates are stored under the module's view directory. View templates can have different behaviors, based on variables you pass to them from the controller's action method. Data is passed to view templates with the help of a @ ViewModel [Laminas\\View\\Model\\ViewModel] variable container. For example, let's implement the view template for the aboutAction() of our Index controller. The About page will display the title and some information about our Hello World application. To create the view template file, in your NetBeans window, navigate to view/application/index directory (see figure 4.6), and right click on the \"index\" directory name. From the context menu that appears, select the New->PHP File... menu item. In the \"New PHP File\" dialog that appears (figure 4.7), enter the name about.phtml and click the Finish button. The about.phtml view template file will be created and displayed in the right pane of NetBeans window. In that file, enter the following: <h1>About</h1> <p> The Hello World application. </p> <p> Application name: <?= $this->escapeHtml($appName); ?> </p> <p> Application description: <?= $this->escapeHtml($appDescription); ?>. </p> As you can see, the view template is a usual HTML page with several PHP code fragments. A view script just renders the data you pass to it with a @ ViewModel [Laminas\\View\\Model\\ViewModel] variable container. For example, in line 8 we get the value of $appName variable and print it into the standard output stream. Note Inside the view template, you easily can access the variables that were passed from the controller's action. For example, to get the value of the application name variable, use either $appName or $this->appName syntax. These two ways of accessing the variable are equivalent, but the first one requires less writing, so we will use it in the future. Please note that we are using @ EscapeHtml view helper to escape the string printed to the web page to make the website resistant to hacker attacks. Note You should always escape variables that you print to your web page. Escaping allows to be sure that no malicious code is injected on your page. In your view script, you can also use simple flow control operations (like if , foreach or switch ) to make the appearance of the page different depending on variable's value. Now let's look at how the page looks like in the web browser. Type \"http://localhost/application/about\" URL in your browser's navigation bar. The About page should appear (see figure 4.8): In general, the PHP code you use inside of views must be as simple as possible. Views typically do not modify the data you pass from controller. For example, a view can use the model you pass to it to walk through database table rows and render the items to an HTML page, but it should never create database tables or modify them itself.","title":"Views"},{"location":"mvc/#view-helpers","text":"View helpers are analogous to controller plugins: the controller plugins allow to \"extend\" the functionality of controllers, and view helpers allow to \"extend\" the functionality of view templates. A view helper is typically a (relatively) simple PHP class whose goal is to render some part of a view. You can invoke view helpers from any view template. With view helpers, you can create reusable widgets (like menus, navigation bars, etc.) for your web pages. Laminas provides many standard view helpers out of the box. In the table 4.7, some of them are presented with a brief description: Standard Plugin Class Description @ BasePath Allows to retrieve the base path to the web application, which is the absolute path to APP_DIR . @ Url [Laminas\\View\\Helper\\Url] Allows to generate absolute or relative URL addresses from inside view templates. @ ServerUrl Retrieves the current request's URL. @ Doctype Helper for setting and retrieving the doctype HTML element of the web page. @ HeadTitle Helper for setting the title HTML element of the web page. @ HtmlList Helper for generating ordered and unordered HTML lists. @ ViewModel [Laminas\\View\\Helper\\ViewModel] Helper for storing and retrieving the view model @ Layout [Laminas\\View\\Helper\\Layout] Retrieves the layout template view. @ Partial Allows to render a \"partial\" view template. @ InlineScript Helper for setting and retrieving script elements for inclusion in HTML body section. @ Identity [Laminas\\View\\Helper\\Identity] View helper to retrieve the authenticated user's identity. @ FlashMessenger [Laminas\\View\\Helper\\FlashMessenger] Allows to retrieve the \"flash\" messages stored in session. @ EscapeHtml Allows to escape a variable outputted to a web page. Table 4.7. Standard View Helpers To demonstrate the usage of a view helper, below we will show how to set a title for a web page. Typically, it is required to give a different title per each web page. You can do this with the @ HeadTitle view helper. For example, you can set the title for the About page by adding the following PHP code in the beginning of the about.phtml view template: <?php $this->headTitle('About'); ?> In the code above, we call the @ HeadTitle view helper and pass it the page title string (\"About\") as the argument. The @ HeadTitle view helper internally sets the text for the <title> HTML element of your web page. Then, if you open the About page in your web browser, the page title will look like \"About - Laminas Skeleton Application\" (see the figure 4.9 below for an example): We will discuss the view helpers in more details and provide more usage examples in the chapter Page Appearance and Layout .","title":"View Helpers"},{"location":"mvc/#view-template-names","text":"When you return data with the @ ViewModel [Laminas\\View\\Model\\ViewModel] variable container from your controller's action method, Laminas Framework knows the name of the corresponding view template file. Laminas determines the correct view template name by module name, controller name and action name. For example, IndexController::aboutAction() action belonging to Application module will have the application/index/about.phtml view template by default. Note If your your controller or action name consists of several words in camel-case (like UserRegistrationController and registrationStep1Action ), the corresponding view template will be application/user-registration/registration-step-1.phtml (camel-cased names are converted to lower-case and words are separated by dashes).","title":"View Template Names"},{"location":"mvc/#overriding-default-view-template-name","text":"The @ ViewModel [Laminas\\View\\Model\\ViewModel] can also be used to override the default view template resolving. Actually the @ ViewModel [Laminas\\View\\Model\\ViewModel] class is more than just a variable container. Additionally, it allows to specify which view template should be used for page rendering. The summary of methods provided for this purpose is shown in table 4.8. Method name Description setTemplate() Sets the view template name. getTemplate() Returns the view template name. Table 4.8. Methods of the ViewModel class for setting and retrieving the view template name To set the view template name, you use the setTemplate() method. The getTemplate() method returns the view template name currently set for the view model. The following code example shows how you can call the setTemplate() method from your IndexController class' indexAction() method to force Laminas to use the about.phtml view template file for rendering the Home page, instead of the index.phtml file: // Index action renders the Home page of your site. public function indexAction() { // Use a different view template for rendering the page. $viewModel = new ViewModel(); $viewModel->setTemplate('application/index/about'); return $viewModel; } In the code above, we created a new instance of the ViewModel class as usual (line 5). Then we called the setTemplate() method on the view model object (line 6) and passed the name of the view template name as its argument. The view template name is actually a relative path to the about.phtml file, minus file extension. Finally, we returned the view model object from the action method (line 7). Note However, calling the setTemplate() method in every action method is optional. If you don't do that, Laminas will determine the view template name automatically by concatenating the current module name, controller name and action method name.","title":"Overriding Default View Template Name"},{"location":"mvc/#view-resolver","text":"When Laminas Framework has the template name, it only remains to determine the absolute path to the corresponding .phtml file. This is also called the view template resolving . View templates are resolved with the special Laminas Framework's class called the view resolver . In Laminas, there are two view resolvers out of the box: @ TemplatePathStack and @ TemplateMapResolver . Both resolvers take a view template name as input, and return path to view template file as output. The template name is usually composed of module name followed by controller name followed by template name, like \"application/index/about\", \"application/index/index\". An exception is \"layout/layout\", which doesn't include module name. The template map resolver uses a PHP nested array to determine path to view template file by its name. This way is fast, but you have to maintain some template map array and update it each time you add a new view script. The template path stack resolver assumes that the view template name can be mapped to directory structure. For example, \"application/index/about\" template name maps to APP_DIR/module/Application/view/application/index/about.phtml . This way is simpler, because you don't have to maintain any maps. View resolver settings are stored inside of your module.config.php file under the view_manager key: <?php return [ //... 'view_manager' => [ //... 'template_map' => [ 'layout/layout' => __DIR__ . '/../view/layout/layout.phtml', 'application/index/index' => __DIR__ . '/../view/application/index/index.phtml', 'error/404' => __DIR__ . '/../view/error/404.phtml', 'error/index' => __DIR__ . '/../view/error/index.phtml', ], 'template_path_stack' => [ __DIR__ . '/../view', ], ], ]; You can see that template map resolver's settings are stored under the template_map key. By default, there are several \"standard\" view templates, which are resolved this way: the index page template, the layout template (we will talk about it in Page Appearance and Layout ) and error templates (we will talk about them a little bit later). These standard pages are served with this type of resolver, because it is fast. The template path stack resolver's settings are stored under the template_path_stack key. You can see that this resolver looks for your view scripts under the \"view\" directory of your module. That's why we could just put about.phtml file under that directory, and ZF will automatically find the template. The template map resolver and template path stack resolver work in pair. First, the fast template map resolver tries to find the template view in its array map, and if the page is not found, the template path stack resolver is executed.","title":"View Resolver"},{"location":"mvc/#disabling-the-view-rendering","text":"Sometimes, you would need to disable the default view rendering. To do that, just return the @ Response [Laminas\\Http\\PhpEnvironment\\Response] object from the the controller's action. For example, let's create a DownloadController class, and add the \"file\" action, which would allow site users to download files from your website. This action does not need a corresponding file.phtml view template, because it just dumps file contents to PHP standard output stream. Add the DownloadController.php file to Controller directory of Application module, then put the following code into the file: <?php namespace Application\\Controller; use Laminas\\Mvc\\Controller\\AbstractActionController; use Laminas\\View\\Model\\ViewModel; /** * This is the controller class for managing file downloads. */ class DownloadController extends AbstractActionController { /** * This is the 'file' action that is invoked * when a user wants to download the given file. */ public function fileAction() { // Get the file name from GET variable $fileName = $this->params()->fromQuery('name', ''); // Take some precautions to make file name secure $fileName = str_replace(\"/\", \"\", $fileName); // Remove slashes $fileName = str_replace(\"\\\\\", \"\", $fileName); // Remove back-slashes // Try to open file $path = './data/download/' . $fileName; if (!is_readable($path)) { // Set 404 Not Found status code $this->getResponse()->setStatusCode(404); return; } // Get file size in bytes $fileSize = filesize($path); // Write HTTP headers $response = $this->getResponse(); $headers = $response->getHeaders(); $headers->addHeaderLine( \"Content-type: application/octet-stream\"); $headers->addHeaderLine( \"Content-Disposition: attachment; filename=\\\"\" . $fileName . \"\\\"\"); $headers->addHeaderLine(\"Content-length: $fileSize\"); $headers->addHeaderLine(\"Cache-control: private\"); // Write file content $fileContent = file_get_contents($path); if($fileContent!=false) { $response->setContent($fileContent); } else { // Set 500 Server Error status code $this->getResponse()->setStatusCode(500); return; } // Return Response to avoid default view rendering return $this->getResponse(); } } The action method takes the name parameter from URL's query part (line 19), removes slashes from file name (lines 22-23), adds HTTP headers to @ Response [Laminas\\Http\\PhpEnvironment\\Response] object (lines 39-45) and file contents (lines 48-55). Finally, it returns the @ Response [Laminas\\Http\\PhpEnvironment\\Response] object to disable the default view rendering. Register the DownloadController class by adding the following line to your module.config.php file: <?php return [ // ... 'controllers' => [ 'factories' => [ // ... Controller\\DownloadController::class => InvokableFactory::class ], ], // ... ]; You will also need to add a route to your module.config.php (a route tells Laminas to what URL to map the controller action). Modify the routes key of the config file as follows: <?php return [ // ... 'router' => [ 'routes' => [ // Add this route for the DownloadController 'download' => [ 'type' => Segment::class, 'options' => [ 'route' => '/download[/:action]', 'defaults' => [ 'controller' => Controller\\DownloadController::class, 'action' => 'index', ], ], ], ], ], // ... ]; To see how the file download works, create APP_DIR/data/download directory and put some text file named sample.txt in it. Then open your web browser and type the URL \"http://localhost/download/file?name=sample.txt\" in your browser's navigation bar and press the Enter key. The browser will download the sample.txt file and offer you to save it to some location.","title":"Disabling the View Rendering"},{"location":"mvc/#view-rendering-strategies","text":"A rendering strategy determines how the page will be rendered. By default, to produce the HTML page, the .phtml view template is rendered with the help of @ PhpRenderer class living in @ Laminas\\View\\Renderer [Laminas\\View] namespace. This strategy works well in 99% of cases. But sometimes you may need to return something else, for example, a JSON response or a RSS feed response. Note A response in JSON format is typically returned when you implement some kind of API (Application Programming Interface). API is used to retrieve some the data in machine-readable format. A response in RSS feed format is typically used to publish frequently changing information, like blog posts or news. So, Laminas provides three view rendering strategies out of the box: the default one (also known as @ PhpRendererStrategy [Laminas\\View\\Strategy\\PhpRendererStrategy]). the @ JsonStrategy producing an JSON response. and the @ FeedStrategy producing an RSS feed response.","title":"View Rendering Strategies"},{"location":"mvc/#returning-json-response","text":"For example, let's show how to use @ JsonStrategy to return JSON response from a controller action. First, you'll need to register the strategy in module.config.php configuration file: <?php return [ //... 'view_manager' => [ //... 'strategies' => [ 'ViewJsonStrategy', ], ], ]; Then, return @ JsonModel (instead of the usual @ ViewModel [Laminas\\View\\Model\\ViewModel]) from your controller's action method: namespace Application\\Controller; use Laminas\\Mvc\\Controller\\ActionController; use Laminas\\View\\Model\\JsonModel; class IndexController extends ActionController { public function getJsonAction() { return new JsonModel([ 'status' => 'SUCCESS', 'message'=>'Here is your data', 'data' => [ 'full_name' => 'John Doe', 'address' => '51 Middle st.' ] ]); } } If you open the page http://localhost/application/get-json in your browser, you will see JSON response: {'status':'SUCCESS', 'message':'Here is your data', 'data':{'full_name:'John Doe', 'address':'51 Middle st.'}}","title":"Returning JSON Response"},{"location":"mvc/#error-pages","text":"When a page could not be found or some other error happens inside of your web application, a standard error page is displayed. The appearance of the error page is controlled by the error templates. There are two error templates: error/404 which is used for \"404 Page Not Found\" error (shown in figure 4.10), and error/index which is displayed when a generic error occurs (such as an unhandled exception is thrown somewhere inside of the application). The module.config.php file contains several parameters under the view_manager key, which you can use to configure the appearance of your error templates: <?php return [ //... 'view_manager' => [ 'display_not_found_reason' => true, 'display_exceptions' => true, //... 'not_found_template' => 'error/404', 'exception_template' => 'error/index', 'template_map' => [ //... 'error/404' => __DIR__ . '/../view/error/404.phtml', 'error/index'=> __DIR__ . '/../view/error/index.phtml', ], //... ], ]; The display_not_found_reason parameter controls whether to display the detailed information about the \"Page not Found\" error. The display_exceptions parameter defines whether to display information about an unhandled exception and its stack trace. The not_found_template defines the template name for the 404 error. The exception_template specifies the template name for the unhandled exception error. Note You typically set the display_not_found_reason and display_exceptions parameters to false in production systems, because you don't want site visitors see the details about errors in your site. However, you will still be able to retrieve the detailed information from Apache's error.log file.","title":"Error Pages"},{"location":"mvc/#models","text":"A model is a PHP class which contains the business logic of your application. The business logic is the \"core\" of your website. It implements the goal of site operation. For example, if you implement an E-commerce website, you will have models implementing the product catalog and the shopping cart. In general, the term model means a simplified representation of a real-life object or phenomenon. Simplified because the real-life object has infinite amount of properties. For example, a real-life person who visits your site consists of billions of atoms, and you cannot describe them all. Instead, you take several properties of the object, which are the most important for your system and ignore all others. For example, the most important properties of the site visitor (from website architect's point of view) are first name, last name, country, city, post code and street address. Models can have some behavior. For example, a mailer model may send E-mail messages, the currency converter model may be able to convert money and so on. With Laminas, you represent models as usual PHP classes. Properties are implemented as class fields, and the behaviors are implemented as class methods.","title":"Models"},{"location":"mvc/#model-types","text":"In Laminas Framework, there is no single Model directory for storing the model classes, as you could assume. Instead, by convention, models are further subdivided into the following principal types, and each type is stored in its own subdirectory (see table 4.9): Model Type Directory Entities APP_DIR/module/Application/src/Entity Repositories APP_DIR/module/Application/src/Repository Value Objects APP_DIR/module/Application/src/ValueObject Services APP_DIR/module/Application/src/Service Factories In Factory subdirectory under each model type directory. For example, controller factories would be stored in APP_DIR/module/Application/src/Controller/Factory Table 4.9. Model Types and their Location Separation of models into different types make it easier to design your business logic domain. This is also called the \"Domain Driven Design\" (or shortly, DDD). The person who proposed DDD was Eric Evans in his famous book called Domain-Driven Design \u2014 Tackling Complexity in the Heart of Software . Below, we will describe the principal model types further.","title":"Model Types"},{"location":"mvc/#entities","text":"Entities are intended for storing some data and always have some identifier property, so you can uniquely identify the data. For example, a User entity always has a unique login property, and you can identify the user by that attribute. You can change some other attributes of the entity, like firstName , or address , but its identifier never changes. Entities are usually stored in a database, in a file system or in any other storage. Below, you can find an example a User entity, which represents a site visitor: // The User entity represents a site visitor class User { // Properties private $login; // e.g. \"admin\" private $title; // e.g. \"Mr.\" private $firstName; // e.g. \"John\" private $lastName; // e.g. \"Doe\" private $country; // e.g. \"USA\" private $city; // e.g. \"Paris\" private $postCode; // e.g. \"10543\" private $address; // e.g. \"Jackson rd.\" // Behaviors public function getLogin() { return $this->login; } public setLogin($login) { $this->login = $login; } //... } In lines 5-12, we define User model's properties. The best practice is to define the properties using the private access type, and make them available to the caller through getter and setter public methods (like getLogin() and setLogin() , etc). Note Model's behavior methods are not limited by getters and setters. You can create other methods which manipulate model's data. For example, you can define the getFullName() convenience method, which would return the user's full name, like \"Mr. John Doe\".","title":"Entities"},{"location":"mvc/#repositories","text":"Repositories are specific models responsible for storing and retrieving entities. For example, a UserRepository may represent a database table and provide methods for retrieving User entities. You typically use repositories when storing entities in a database. With repositories, you can encapsulate SQL query logic in the single place and easily maintain and test it. We will learn about repositories in more details in Database Management with Doctrine , when talking about Doctrine library.","title":"Repositories"},{"location":"mvc/#value-objects","text":"Value objects are a kind of model for which the identity is not as important as for entities. A value object is usually a small class identified by all of its attributes. It does not have an identifier attribute. Value objects typically have getter methods, but do not have setters (value objects are immutable). For example, a model wrapping a money amount can be treated as a value object: class MoneyAmount { // Properties private $currency; private $amount; // Constructor public function __construct($amount, $currency='USD') { $this->amount = $amount; $this->currency = $currency; } // Gets the currency code public function getCurrency() { return $this->currency; } // Gets the money amount public function getAmount() { return $this->amount; } } In lines 4-5 we define two properties: currency and amount . The model has no identifier property, instead it is identified by all properties as a whole: if you change either the currency or amount , you would have a different money amount object. In lines 8-12 we define the constructor method, which initializes the properties. In lines 15-24, we define getter methods for model's properties. Note that we do not have setter methods (the model is immutable).","title":"Value Objects"},{"location":"mvc/#services","text":"Service models usually encapsulate some business logic functionality. Services usually have easily recognizable names ending with \"er\" suffix, like FileUploader or UserManager . Below, an example of Mailer service is presented. It has the sendMail() method which takes an EmailMessage value object and sends an E-mail message using standard PHP mail() function: <?php // The Email message value object class EmailMessage { private $recipient; private $subject; private $text; // Constructor public function __construct($recipient, $subject, $text) { $this->recipient = $recipient; $this->subject = $subject; $this->text = $text; } // Getters public function getRecipient() { return $this->recipient; } public function getSubject() { return $this->subject; } public function getText() { return $this->text; } } // The Mailer service, which can send messages by E-mail class Mailer { public function sendMail($message) { // Use PHP mail() function to send an E-mail if(!mail($message->getRecipient(), $message->getSubject(), $message()->getText())) { // Error sending message return false; } return true; } } In Laminas Framework, you typically register your service models in Service Manager.","title":"Services"},{"location":"mvc/#factories","text":"Factories are usually being designed to instantiate other models (particularly, service models). In the simplest cases you can create an instance of a service without any factory, just by using the new operator, but sometimes class creation logic might be rather complex. For example, services often depend on each other, so you might need to inject dependencies to a service. Also, sometimes it may be required to initialize the service right after instantiation by calling one (or several) of its methods. Factory classes typically have names ending with Factory suffix, like CurrencyConverterFactory , MailerFactory , etc. For a real-life example, let's imagine that we have a PurchaseManager service, which can process purchases of some goods, and that the PurchaseManager service uses another service named CurrencyConverter , which can connect to an external system providing money exchange rates. Let's write a factory class for the PurchaseManager , which would instantiate the service and pass it the dependency: <?php namespace Application\\Service\\Factory; use Interop\\Container\\ContainerInterface; use Laminas\\ServiceManager\\Factory\\FactoryInterface; use Application\\Service\\CurrencyConverter; use Application\\Service\\PurchaseManager; /** * This is the factory for PurchaseManager service. Its purpose is to instantiate the * service and inject its dependencies. */ class PurchaseManagerFactory implements FactoryInterface { public function __invoke(ContainerInterface $container, $requestedName, array $options = null) { // Get CurrencyConverter service from the service manager. $currencyConverter = $container->get(CurrencyConverter::class); // Instantiate the service and inject dependencies. return new PurchaseManager($currencyConverter); } } In the code above we have the PurchaseManagerFactory class which implements the Laminas\\ServiceManager\\Factory\\FactoryInterface interface. The factory class has the __invoke() method whose goal is to instantiate the object. This method has the $container argument which is the service manager. You can use $container to retrieve services from service manager and pass them to the constructor method of the service being instantiated.","title":"Factories"},{"location":"mvc/#determining-the-correct-model-type","text":"Isn't it confusing to have so many model types? Well, yes and no. At first, it may be a little difficult to determine the correct model type, but as soon you improve your skills, you will be able to do that intuitively. Just remember that model types improve the structure of your domain models. When writing your own application, you may be confused when trying to decide to which model type your class belongs (whether it is an entity, value object, repository, service or factory). Below, a simple algorithm is provided to make it easier for you to determine the correct model type when writing your own application: Your model class is definitely a Service if it encapsulates some business logic if you call it from your controller class if you think the best name for it ends with \"er\": suffix, like FileUploader or VersionChecker Your model class is an Entity : if your model is stored in a database if it has an ID attribute if it has both getters and setters methods Your model class is a ValueObject : if changing any attribute would make the model completely different if your model has getters, but not setters (immutable) Your model is a Repository : if it works with a database to retrieve entities Your model is a Factory : if it can create other objects and can do nothing else Hmm... what if I just store all my models in a single Model directory? Of course, you can, if you strongly wish. But, when you use Doctrine ORM library, you will notice that it utilizes DDD principles as well, so using DDD makes your application well-organized.","title":"Determining the Correct Model Type"},{"location":"mvc/#other-model-types","text":"In your website, you will typically divide your principal model types (described above) into subtypes. For example, you will have: Forms . Forms are models whose purpose is to collect data entered by web user. Forms are a subtype of entities . You will typically store forms in APP_DIR/module/Application/src/Form directory. Filters . Filters are designed for transforming input data. Filters are a subtype of services . You will typically store filters in APP_DIR/module/Application/src/Filter directory. Validators . Validators are used for checking input data for correctness. Validators are also a subtype of services . You will typically store validators in APP_DIR/module/Application/src/Validator directory. View Helpers . They encapsulate some page rendering functionality. View helpers are similar to services . You will typically store view helpers in APP_DIR/module/Application/src/View/Helper directory. Routes . Routes are a specific service model used for implementing custom mapping rules between URLs and your controllers. You will typically store custom routes in APP_DIR/module/Application/src/Route directory. So, eventually you will have the following typical directory structure of your website's module: /Application/src /Controller /Factory /Plugin /Factory /Entity /Filter /Form /Repository /Route /Service /Factory /Validator /ValueObject /View /Helper /Factory It is possible to have arbitrarily many model subtypes. The more complex is your application, the more model subtypes you may have.","title":"Other Model Types"},{"location":"mvc/#skinny-controllers-fat-models-simple-views","text":"When developing a website using Model-View-Controller pattern, there is a risk of misunderstanding the role of controllers, views and models. This results in making the controllers huge and models small, which in turn makes it difficult to test and support your application. This section's goal is to give you a general understanding of what code may be placed in a controller class, what code may be placed in a view template, and what code may be placed in a model class.","title":"Skinny Controllers, Fat Models, Simple Views"},{"location":"mvc/#skinny-controllers","text":"The idea behind the term \"skinny controller\" is that typically, in your controller classes, you put only the code that: accesses user request data ( $_GET , $_POST , $_FILES and other PHP variables); checks the validity of the input data; (optionally) makes some basic preparations to the data; passes the data to model(s) and retrieves the result returned by the model(s); and finally returns the output data as a part of a ViewModel variable container. A controller class should avoid: containing complex business logic, which is better kept in model classes; containing any HTML or any other presentational markup code. This is better be put in view templates. For an example of a \"skinny\" controller, look at the CurrencyConverterController class below. This controller provides the \"convert\" action method whose goal is to convert an amount of money from EUR to USD currency. The user passes the amount of money through the \"amount\" GET variable. class CurrencyConverterController extends AbstractActionController { // Currency converter model private $currencyConverter; // Constructor. It's purpose is to \"inject\" dependencies. public function __construct($currencyConverter) { $this->currencyConverter = $currencyConverter; } // The \"convert\" action displays the converted money amount public function convertAction() { // Get the money amount from GET $amount = (float)$this->params()->fromQuery('amount', -1); // Validate input data if($amount<0) { // Money amount is missing $this->getResponse()->setStatusCode(404); return; } // Pass the data to the CurrencyConverter model $convertedAmount = $this->currencyConverter->convertEURtoUSD($amount); return new ViewModel([ 'amount'=>$amount, 'convertedAmount'=>$convertedAmount ]); } } The controller's action method above does the following: Takes the data passed by site user (line 16). This data is usually part of Request object and can be retrieved using the controller's getRequest() method or @ Params controller plugin. Performs the basic check on the data passed by user (line 19), and if the data is missing (or invalid), sets an HTTP error code (line 21). Passes the money amount to the CurrencyConverter model (line 26) by calling its convertEURtoUSD() method. The method then returns the converted amount. Constructs the @ ViewModel [Laminas\\View\\Model\\ViewModel] variable container and passes the resulting data to it (line 28). This variable container can be further accessed in the corresponding view template responsible for data presentation.","title":"Skinny Controllers"},{"location":"mvc/#fat-models","text":"Because you need to keep your controllers as thin as possible, most of the business logic of your application should be put into model classes. In a properly designed Model-View-Controller application, models look \"huge\". A model class may contain the code which: Performs complex data filtering and validation. Because the data that you retrieved in controller is passed to your application from an outside world, in your model, you have to take a lot of effort to verify the data and ensure the data will not break your system. This results in a secure website resistant to hacker attacks. Performs data manipulation. Your models should manipulate the data: e.g. load the data from database, save it to database and transform the data. Models are the right place for storing database queries, file reading and writing functionality, and so on. In a model class you are not recommended to: Access the data from the HTTP request, $_GET , $_POST and other PHP variables. It is the controller's work to extract that data and pass it to model's input. Produce HTML or other code specific to presentation. The presentational code may vary depending on the user request, and it is better to put it in a view template. If you follow these principles, you will encounter that your models are easy to test, because they have clearly identified input and output. You can write a unit test which passes some test data to input end of the model, retrieves the output data and verifies that the data is correct. If you are confused whether to put certain code in a controller or in a model, ask yourself: is this an important business logic that needs to be carefully tested? If the answer is yes, you should put the code in a model.","title":"Fat Models"},{"location":"mvc/#simple-view-templates","text":"Because most of the logic is stored in models, your view templates should be as simple as possible to produce the presentation of the data passed through the variable container. In a view template, you may: Keep static HTML markup code. Retrieve the data from a variable container and echo them to PHP output stream. If a controller passed a certain model through a variable container, poll the model for data (e.g. you can retrieve table rows from a database table and render them). Contain simple PHP flow control operations, like if , foreach , switch and so on. This allows to vary the presentation depending on variables passed by the controller. The view template is not recommended to: Access data from the HTTP request and super global PHP variables. Create models, manipulate them and modify the state of the application. If you follow these principles, you will encounter that your views can easily be substituted without modifying the business logic of your application. For example, you can easily change the design of your web pages, or even introduce changeable themes.","title":"Simple View Templates"},{"location":"mvc/#summary","text":"A Laminas Framework based website is just a PHP program receiving an HTTP request from the web server, and producing an HTTP response. The web application uses the Model-View-Controller pattern to separate business logic from presentation. The goal of this is to allow for code reusability and separation of concerns. A controller is a mediator between the application, models and views: it gets input from HTTP request and uses the model(s) and the corresponding view to produce the necessary HTTP response. A controller is a usual PHP class containing action methods. Views are simple HTML+PHP code snippets producing HTML output returned by the web server to site visitors. You pass the data to view scripts through the @ ViewModel [Laminas\\View\\Model\\ViewModel] variable container. A model is a PHP class which contains the business logic of your application. The business logic is the \"core\" of your website which implement the goal of site operation. Models can access database, manipulate disk files, connect to external systems, manipulate other models and so on. Composition is a relationship between two classes that is best described as a \"has-a\" and \"whole/part\" relationship. The owner class contains a reference to another class (plugin). The owner is responsible for the lifetime of the object it holds. \u21a9","title":"Summary"},{"location":"netbeans/","text":"Appendix B. Introduction to PHP Development in NetBeans IDE In this book, we use NetBeans IDE for developing Laminas Framework based applications. In Appendix A. Configuring Web Development Environment , we have installed NetBeans IDE. Here we will provide some useful tips on using NetBeans for PHP programming. We will learn how to launch and interactively debug a laminas-based website. What if I want to use another IDE (not NetBeans) for developing my applications? Well, you can use any IDE you want. The problem is that it is impossible to cover all IDEs for PHP development in this book. The author only provides instructions for NetBeans IDE. It would be easier for a beginner to use NetBeans IDE. Advanced developers may use an IDE of their choices. Run Configuration To be able to run and debug a website, you first need to edit the site's properties. To do that, in NetBeans' Projects pane, right-click on the project's name, and from context menu select Properties item. The project's Properties dialog will appear (shown in figure B.1). In the left pane of the dialog that appears, click the Sources node. In the right pane, edit the Web Root field to point to your website's APP_DIR/public directory. You can do this by clicking the Browse button to the right of the field. Then, in the dialog, click on the public directory and then click Select Folder button (shown in figure B.2). Next, click the Run Configuration node in the left pane. The right pane should display the run settings for your site (figure B.3). In the right pane, you can see that the current configuration is \"default\". As an option, you can create several run configurations. Edit the fields as follows: In the Run As field, select \"Local Website (running on local web server)\". In the Project URL field, enter \"http://localhost\". If you configured your virtual host to listen on different port (say, on port 8080), enter the port number like this \"http://localhost:8080\". Keep the Index File field empty, because Apache's mod_rewrite module will mask our actual index.php file. In the Arguments field, you can specify which GET parameters to pass to your site through the URL string. Typically, you keep this field empty. Finally, click the OK button to close the Properties dialog. Running the Website Running the website means opening it in your default web browser. To launch the site, press the Run button on the Run Toolbar (figure B.4). Alternatively, you can press F6 button on your keyboard. If everything is OK with your run configuration, the default web browser will be launched, and in the browser window, you will be able to see the Home page of the website. The same effect would have typing \"http://localhost/\" in your browser, but NetBeans' run toolbar allows you to do that in a single click. Site Debugging in NetBeans The \"conventional\" debugging technique in PHP is putting the var_dump() function in the code block that you want to examine: var_dump($var); exit; The lines above would print the value of the $var variable to the browser's output and then stop program execution. While this can be used for debugging even a complex site, it makes the debugging a pain, because you have to type variable dump commands in your PHP source file, then refresh your web page in the browser to see the output, then edit the source file again, until you determine the reason of the problem. In contrast, when you debug your website in NetBeans IDE, the PHP interpreter pauses program execution flow at every line where you set a breakpoint . This makes it possible to conveniently retrieve information about the current state of the program, like the values of the local variables and the call stack. You see the debugging information in NetBeans window in graphical form. W> To be able to debug the site, you need to have the XDebug extension installed. W> If you haven't installed it yet, please refer to Appendix A. Configuring Web Development Environment for additional W> information on how to install it. To start the debugging session, in NetBeans window, click the Debug button on the Run Toolbar (figure B.4). Alternatively, you can press the CTRL+F5 key combination on your keyboard. If everything is OK, you should be able to see the current program counter on the first code line of the index.php file (shown in figure B.5): While the program is in paused state, your web browser's window is frozen, because the browser is waiting for data from the web server. Once you continue program execution, the browser receives the data, and displays the web page. Debug Toolbar You can resume/suspend program execution with the Debug Toolbar (see figure B.6): The Finish Debugger Session of the toolbar allows to stop the debugger. Press this button when you're done with debugging the program. The same effect would have pressing the SHIFT+F5 key combination. Clicking the Continue button (or pressing F5 key) continues the program execution until the next breakpoint, or until the end of the program, if there are no more breakpoints. The Step Over toolbar button (or pressing F8 key) moves the current program counter to the next line of the program. The Step Into toolbar button (or pressing F7 key) moves the current program counter to the next line of the program, and if it is the function entry point, enters the function body. Use this when you want to investigate your code in-depth. The Step Out toolbar button ( CTRL+F7 ) allows to continue program execution until returning from the current function. And Run to Cursor ( F4 ) allows to continue program execution until the line of code where you place the cursor. This may be convenient if you want to skip some code block and pause at a certain line of your program. Breakpoints Typically, you set one or several breakpoints to the lines which you want to debug in step-by-step mode. To set a breakpoint, put your mouse to the left of the line of code where you want the breakpoint to appear and click on the line number. Alternatively, you can put the cursor caret to the line where you want to set a breakpoint and press CTRL+F8 key combination. When you set the breakpoint, the line is marked with red color and a small red rectangle appears to the left of it (shown in figure B.7): Note Be careful not to set a breakpoint on an empty line or on a comment line. Such a breakpoint will be ignored by XDebug, and it will be marked by the \"broken\" square (see figure B.8 for example): You can travel between breakpoints with the F5 key press. This button continues program execution until it encounters the next breakpoint. Once the program flow comes to the breakpoint, the PHP interpreter becomes paused, and you can review the state of the program. You can see the complete list of breakpoints you have set in the Breakpoints window (see figure B.9). The Breakpoints window is located in the bottom part of NetBeans window. In this window you can add new breakpoints or unset breakpoints that have already been set. Watching Variables When the PHP interpreter is paused, you can conveniently watch the values of PHP variables. A simple way to browse a variable is just positioning the mouse cursor over the variable name inside of the code and waiting for a second. If the variable value can be evaluated, it will be displayed inside of a small pop up window. Another way to watch variables is through the Variables window (shown in figure B.10), which is displayed in the bottom part of NetBeans window. The Variables window has three columns: Name , Type and Value . Mainly, you will be faced with three kinds of variables: super globals , locals and $this : Super global variables are special PHP variables like $_GET , $_POST , $_SERVER , $_COOKIES and so on. They typically contain server information and parameters passed by the web browser as part of HTTP request. Local variables are variables living in the scope of the current function (or class method). For example, in the Hello World application, if you place a breakpoint inside of the IndexController::aboutAction() , the variable $appName will be a local variable. $this variable points to the current class instance, if the current code is being executed in context of a PHP class. Some variables can be \"expanded\" (to expand a variable, you need to click on a triangle icon to the left of variable's name). For example, by clicking and expanding $this variable, you can watch all fields of the class instance. If you expand an array variable, you will be able to watch array items. Using the Variables window it is possible not only to watch variable's value, but also to change the value on the fly. To do that, place your mouse cursor over the value column and click over it. The edit box appears, where you can set the new value of the variable. Call Stack The call stack displays the list of nested functions whose code is being executed at the moment (shown in the figure B.11). Each line of the call stack (also called a stack frame) contains the full name of the class, the name of the method within the class and line number. Moving down the stack, you can better understand the current execution state of the program. For example, in figure B.11, you can see that currently the IndexController::aboutAction() is being executed, and this method was in turn called by the AbstractActionController::onDispatch() method, and so on. We can walk the call stack until we reach the index.php file, which is the top of the stack. You can also click a stack frame to see the place of the code that is currently being executed. Debugging Options NetBeans allows you to configure some aspects of the debugger's behavior. To open the Options dialog, select menu Tools->Options . In the dialog that appears, click the PHP tab, and in that tab, select Debugging subtab (figure B.12). You typically do not change most of these options, you just need to have an idea of what they do. These are the following debugging options: The Debugger Port and Session ID parameters define how NetBeans connects to XDebug. By default, the port number is 9000. The port number should be the same as the debugger port you set in php.ini file when installing XDebug. The session name is by default \"netbeans-xdebug\". You typically do not change this value. The Stop at First Line parameter makes the debugger to stop at the first line of your index.php file, instead of stopping at the first breakpoint. This may be annoying, so you may want to uncheck this option. The Watches and Balloon Evaluation option group is disabled by default, because these may cause XDebug fault. You can enable these options only when you know what you are doing. The Maximum Depth of Structures parameter sets whether nested structures (like nested arrays, objects in objects, etc.) will be visible or not. By default, the depth is set to 3. The Maximum Number of Children option defines how many array items to display in Variables window. If you set this to, say 30, you will see only the first 30 items even when the array has more than 30 items. The Show Requested URLs option, when enabled, displays the URL which is currently being processed. It prints the URL to an Output window. The Debugger Console option allows to see the output of PHP scripts being debugged. The output is shown in the Output window. If you plan to use this feature, it is recommended to add output_buffering = Off parameter in [xdebug] section of your php.ini file, otherwise the output may appear with delays. Profiling When your site is ready and working, you are typically interested in making it as fast and performing as possible. XDebug provides you with an ability to profile your website. Profiling means determining which class methods (or functions) spend what time to execute. This allows you to determine the \"bottle neck\" places in your code and address the performance issues. For each HTTP request, the XDebug extension measures the amount of time a function executes, and writes the profiling information to a file. Typically, the profiling info files are placed into the system temporary directory (in Linux, to /tmp directory) and have names like xdebug.out.<timestamp> , where the <timestamp> placeholder is the timestamp of the HTTP request. All you have to do is to open a profiling file and analyze it. W> To enable XDebug profiler, you should set the following XDebug configuration parameter in your xdebug.ini file: W> W> xdebug.profiler_enable = 1 Unfortunately, NetBeans for PHP does not have an embedded tool for visualizing the profiling results. That's why you need to install a third-party visualizer tool. Below, we will provide instructions on how to install a simple web-based tool named Webgrind . Webgrind can work on any platform, because this tool itself is written in PHP. Webgrind's installation is very straightforward. First, you need to download webgrind from its project page and unpack it to some folder. In Linux, you can do this with the following commands: $ cd ~ $ wget https://github.com/jokkedk/webgrind/archive/master.zip $ unzip master.zip The commands above will change your working directory to your home directory, then will download the Webgrind archive from the Internet, and then unpack the archive. Next, you need to tell the Apache web server where to find Webgrind files. This means you need to configure a separate virtual host. We have already learned about virtual hosts in Appendix A. Configuring Web Development Environment . Do not forget to restart Apache web server after you have configured the virtual host. Finally, open Webgrind in your browser by navigating to the URL of your Webgrind install. For example, if you configured the virtual host to listen on port 8080, enter \"http://localhost:8080\" in your browser's navigation bar and press Enter. The Webgrind web page should appear (see figure B.13): At the top of the Webgrind page, you can select the percentage of the \"heaviest\" function calls to show (figure B.14). By default, it is set to 90%. Setting this to a lower percentage will hide the functions called less often. The drop-down list to the right of percent field allows to select the profiling data file to analyze. By default, it is set to \"Auto (newest)\", which forces Webgrind to use the file with the most recent timestamp. You may need to select another file, for example, if your web pages use asynchronous AJAX requests. The right-most drop-down list allows to set the units which should be used for measuring the data. Possible options are: percent (default), milliseconds and microseconds. When you have selected the percentage, file name and units, click the Update button to let Webgrind to visualize the data for you (the calculation may take a few seconds). As the calculation finishes, you should be able to see the table of function calls, sorted in descending order by function \"weight\". The heaviest functions will be displayed at the top. The table has the following columns: The first column ( Function ), displays the class name followed by method name (in case of a method call) or function name (in case of a regular function). The second column contains the \"paragraph\" icons, which can be clicked to open the corresponding PHP source file that function is defined in the web browser. Invocation Count column displays the number of times the function was called. Total Self Cost column shows the total time it took to execute the built-in PHP code in the function (excluding the time spent on executing other non-standard functions). Total Inclusive Cost column contains the total execution time for the function, including built-in PHP code and any other user functions called. Clicking a column header allows to sort data in ascending or descending order. You can click the triangle icon next to a function name to expand a list of function invocations. This list allows you to see who called this function and what the amount of time spent is, and contains the following columns: Calls is the \"parent\" functions or class methods invoking this (child) function; Total Call Cost is the total time executing this function, when called from the parent function; Count - number of times the parent calls the child function. The coloured bar at the top of the page displays the contribution of different function types: Blue denotes PHP internal (built-in) functions; Lavender is time taken to include (or require) PHP files; Green shows the contribution of your own class methods; Orange denotes time taken on traditional \"procedural\" functions (functions that are not part of a PHP classes). Note Please note that the profiler creates a new data file in your /tmp directory for each HTTP request to your website. This may cause disk space exhaustion, which can be fixed only by rebooting your system. So, when you've finished profiling your application, it is recommended to disable the profiling by editing the php.ini file, commenting the xdebug.profiler_enable parameter as follows, and then restarting the Apache web server. ;xdebug.profiler_enable = 0 Summary In this appendix, we've learned how to use NetBeans IDE to run the website and debug it in interactive step-by-step mode. To be able to run a website, you first need to edit the site's properties (run configuration). To debug the site, you need to have the XDebug PHP extension installed. When you debug your website in NetBeans, the PHP engine pauses program execution at every line where you set a breakpoint. You see the debugging information (like local variables and call stack) in NetBeans window in graphical form. Along with debugging, XDebug extension also provides the ability to profile websites. With profiling, you see how much time was spent for execution of a certain function or class method. This allows you to determine the \"bottle necks\" and performance issues.","title":"Appendix B. Introduction to PHP Development in NetBeans IDE"},{"location":"netbeans/#appendix-b-introduction-to-php-development-in-netbeans-ide","text":"In this book, we use NetBeans IDE for developing Laminas Framework based applications. In Appendix A. Configuring Web Development Environment , we have installed NetBeans IDE. Here we will provide some useful tips on using NetBeans for PHP programming. We will learn how to launch and interactively debug a laminas-based website. What if I want to use another IDE (not NetBeans) for developing my applications? Well, you can use any IDE you want. The problem is that it is impossible to cover all IDEs for PHP development in this book. The author only provides instructions for NetBeans IDE. It would be easier for a beginner to use NetBeans IDE. Advanced developers may use an IDE of their choices.","title":"Appendix B. Introduction to PHP Development in NetBeans IDE"},{"location":"netbeans/#run-configuration","text":"To be able to run and debug a website, you first need to edit the site's properties. To do that, in NetBeans' Projects pane, right-click on the project's name, and from context menu select Properties item. The project's Properties dialog will appear (shown in figure B.1). In the left pane of the dialog that appears, click the Sources node. In the right pane, edit the Web Root field to point to your website's APP_DIR/public directory. You can do this by clicking the Browse button to the right of the field. Then, in the dialog, click on the public directory and then click Select Folder button (shown in figure B.2). Next, click the Run Configuration node in the left pane. The right pane should display the run settings for your site (figure B.3). In the right pane, you can see that the current configuration is \"default\". As an option, you can create several run configurations. Edit the fields as follows: In the Run As field, select \"Local Website (running on local web server)\". In the Project URL field, enter \"http://localhost\". If you configured your virtual host to listen on different port (say, on port 8080), enter the port number like this \"http://localhost:8080\". Keep the Index File field empty, because Apache's mod_rewrite module will mask our actual index.php file. In the Arguments field, you can specify which GET parameters to pass to your site through the URL string. Typically, you keep this field empty. Finally, click the OK button to close the Properties dialog.","title":"Run Configuration"},{"location":"netbeans/#running-the-website","text":"Running the website means opening it in your default web browser. To launch the site, press the Run button on the Run Toolbar (figure B.4). Alternatively, you can press F6 button on your keyboard. If everything is OK with your run configuration, the default web browser will be launched, and in the browser window, you will be able to see the Home page of the website. The same effect would have typing \"http://localhost/\" in your browser, but NetBeans' run toolbar allows you to do that in a single click.","title":"Running the Website"},{"location":"netbeans/#site-debugging-in-netbeans","text":"The \"conventional\" debugging technique in PHP is putting the var_dump() function in the code block that you want to examine: var_dump($var); exit; The lines above would print the value of the $var variable to the browser's output and then stop program execution. While this can be used for debugging even a complex site, it makes the debugging a pain, because you have to type variable dump commands in your PHP source file, then refresh your web page in the browser to see the output, then edit the source file again, until you determine the reason of the problem. In contrast, when you debug your website in NetBeans IDE, the PHP interpreter pauses program execution flow at every line where you set a breakpoint . This makes it possible to conveniently retrieve information about the current state of the program, like the values of the local variables and the call stack. You see the debugging information in NetBeans window in graphical form. W> To be able to debug the site, you need to have the XDebug extension installed. W> If you haven't installed it yet, please refer to Appendix A. Configuring Web Development Environment for additional W> information on how to install it. To start the debugging session, in NetBeans window, click the Debug button on the Run Toolbar (figure B.4). Alternatively, you can press the CTRL+F5 key combination on your keyboard. If everything is OK, you should be able to see the current program counter on the first code line of the index.php file (shown in figure B.5): While the program is in paused state, your web browser's window is frozen, because the browser is waiting for data from the web server. Once you continue program execution, the browser receives the data, and displays the web page.","title":"Site Debugging in NetBeans"},{"location":"netbeans/#debug-toolbar","text":"You can resume/suspend program execution with the Debug Toolbar (see figure B.6): The Finish Debugger Session of the toolbar allows to stop the debugger. Press this button when you're done with debugging the program. The same effect would have pressing the SHIFT+F5 key combination. Clicking the Continue button (or pressing F5 key) continues the program execution until the next breakpoint, or until the end of the program, if there are no more breakpoints. The Step Over toolbar button (or pressing F8 key) moves the current program counter to the next line of the program. The Step Into toolbar button (or pressing F7 key) moves the current program counter to the next line of the program, and if it is the function entry point, enters the function body. Use this when you want to investigate your code in-depth. The Step Out toolbar button ( CTRL+F7 ) allows to continue program execution until returning from the current function. And Run to Cursor ( F4 ) allows to continue program execution until the line of code where you place the cursor. This may be convenient if you want to skip some code block and pause at a certain line of your program.","title":"Debug Toolbar"},{"location":"netbeans/#breakpoints","text":"Typically, you set one or several breakpoints to the lines which you want to debug in step-by-step mode. To set a breakpoint, put your mouse to the left of the line of code where you want the breakpoint to appear and click on the line number. Alternatively, you can put the cursor caret to the line where you want to set a breakpoint and press CTRL+F8 key combination. When you set the breakpoint, the line is marked with red color and a small red rectangle appears to the left of it (shown in figure B.7): Note Be careful not to set a breakpoint on an empty line or on a comment line. Such a breakpoint will be ignored by XDebug, and it will be marked by the \"broken\" square (see figure B.8 for example): You can travel between breakpoints with the F5 key press. This button continues program execution until it encounters the next breakpoint. Once the program flow comes to the breakpoint, the PHP interpreter becomes paused, and you can review the state of the program. You can see the complete list of breakpoints you have set in the Breakpoints window (see figure B.9). The Breakpoints window is located in the bottom part of NetBeans window. In this window you can add new breakpoints or unset breakpoints that have already been set.","title":"Breakpoints"},{"location":"netbeans/#watching-variables","text":"When the PHP interpreter is paused, you can conveniently watch the values of PHP variables. A simple way to browse a variable is just positioning the mouse cursor over the variable name inside of the code and waiting for a second. If the variable value can be evaluated, it will be displayed inside of a small pop up window. Another way to watch variables is through the Variables window (shown in figure B.10), which is displayed in the bottom part of NetBeans window. The Variables window has three columns: Name , Type and Value . Mainly, you will be faced with three kinds of variables: super globals , locals and $this : Super global variables are special PHP variables like $_GET , $_POST , $_SERVER , $_COOKIES and so on. They typically contain server information and parameters passed by the web browser as part of HTTP request. Local variables are variables living in the scope of the current function (or class method). For example, in the Hello World application, if you place a breakpoint inside of the IndexController::aboutAction() , the variable $appName will be a local variable. $this variable points to the current class instance, if the current code is being executed in context of a PHP class. Some variables can be \"expanded\" (to expand a variable, you need to click on a triangle icon to the left of variable's name). For example, by clicking and expanding $this variable, you can watch all fields of the class instance. If you expand an array variable, you will be able to watch array items. Using the Variables window it is possible not only to watch variable's value, but also to change the value on the fly. To do that, place your mouse cursor over the value column and click over it. The edit box appears, where you can set the new value of the variable.","title":"Watching Variables"},{"location":"netbeans/#call-stack","text":"The call stack displays the list of nested functions whose code is being executed at the moment (shown in the figure B.11). Each line of the call stack (also called a stack frame) contains the full name of the class, the name of the method within the class and line number. Moving down the stack, you can better understand the current execution state of the program. For example, in figure B.11, you can see that currently the IndexController::aboutAction() is being executed, and this method was in turn called by the AbstractActionController::onDispatch() method, and so on. We can walk the call stack until we reach the index.php file, which is the top of the stack. You can also click a stack frame to see the place of the code that is currently being executed.","title":"Call Stack"},{"location":"netbeans/#debugging-options","text":"NetBeans allows you to configure some aspects of the debugger's behavior. To open the Options dialog, select menu Tools->Options . In the dialog that appears, click the PHP tab, and in that tab, select Debugging subtab (figure B.12). You typically do not change most of these options, you just need to have an idea of what they do. These are the following debugging options: The Debugger Port and Session ID parameters define how NetBeans connects to XDebug. By default, the port number is 9000. The port number should be the same as the debugger port you set in php.ini file when installing XDebug. The session name is by default \"netbeans-xdebug\". You typically do not change this value. The Stop at First Line parameter makes the debugger to stop at the first line of your index.php file, instead of stopping at the first breakpoint. This may be annoying, so you may want to uncheck this option. The Watches and Balloon Evaluation option group is disabled by default, because these may cause XDebug fault. You can enable these options only when you know what you are doing. The Maximum Depth of Structures parameter sets whether nested structures (like nested arrays, objects in objects, etc.) will be visible or not. By default, the depth is set to 3. The Maximum Number of Children option defines how many array items to display in Variables window. If you set this to, say 30, you will see only the first 30 items even when the array has more than 30 items. The Show Requested URLs option, when enabled, displays the URL which is currently being processed. It prints the URL to an Output window. The Debugger Console option allows to see the output of PHP scripts being debugged. The output is shown in the Output window. If you plan to use this feature, it is recommended to add output_buffering = Off parameter in [xdebug] section of your php.ini file, otherwise the output may appear with delays.","title":"Debugging Options"},{"location":"netbeans/#profiling","text":"When your site is ready and working, you are typically interested in making it as fast and performing as possible. XDebug provides you with an ability to profile your website. Profiling means determining which class methods (or functions) spend what time to execute. This allows you to determine the \"bottle neck\" places in your code and address the performance issues. For each HTTP request, the XDebug extension measures the amount of time a function executes, and writes the profiling information to a file. Typically, the profiling info files are placed into the system temporary directory (in Linux, to /tmp directory) and have names like xdebug.out.<timestamp> , where the <timestamp> placeholder is the timestamp of the HTTP request. All you have to do is to open a profiling file and analyze it. W> To enable XDebug profiler, you should set the following XDebug configuration parameter in your xdebug.ini file: W> W> xdebug.profiler_enable = 1 Unfortunately, NetBeans for PHP does not have an embedded tool for visualizing the profiling results. That's why you need to install a third-party visualizer tool. Below, we will provide instructions on how to install a simple web-based tool named Webgrind . Webgrind can work on any platform, because this tool itself is written in PHP. Webgrind's installation is very straightforward. First, you need to download webgrind from its project page and unpack it to some folder. In Linux, you can do this with the following commands: $ cd ~ $ wget https://github.com/jokkedk/webgrind/archive/master.zip $ unzip master.zip The commands above will change your working directory to your home directory, then will download the Webgrind archive from the Internet, and then unpack the archive. Next, you need to tell the Apache web server where to find Webgrind files. This means you need to configure a separate virtual host. We have already learned about virtual hosts in Appendix A. Configuring Web Development Environment . Do not forget to restart Apache web server after you have configured the virtual host. Finally, open Webgrind in your browser by navigating to the URL of your Webgrind install. For example, if you configured the virtual host to listen on port 8080, enter \"http://localhost:8080\" in your browser's navigation bar and press Enter. The Webgrind web page should appear (see figure B.13): At the top of the Webgrind page, you can select the percentage of the \"heaviest\" function calls to show (figure B.14). By default, it is set to 90%. Setting this to a lower percentage will hide the functions called less often. The drop-down list to the right of percent field allows to select the profiling data file to analyze. By default, it is set to \"Auto (newest)\", which forces Webgrind to use the file with the most recent timestamp. You may need to select another file, for example, if your web pages use asynchronous AJAX requests. The right-most drop-down list allows to set the units which should be used for measuring the data. Possible options are: percent (default), milliseconds and microseconds. When you have selected the percentage, file name and units, click the Update button to let Webgrind to visualize the data for you (the calculation may take a few seconds). As the calculation finishes, you should be able to see the table of function calls, sorted in descending order by function \"weight\". The heaviest functions will be displayed at the top. The table has the following columns: The first column ( Function ), displays the class name followed by method name (in case of a method call) or function name (in case of a regular function). The second column contains the \"paragraph\" icons, which can be clicked to open the corresponding PHP source file that function is defined in the web browser. Invocation Count column displays the number of times the function was called. Total Self Cost column shows the total time it took to execute the built-in PHP code in the function (excluding the time spent on executing other non-standard functions). Total Inclusive Cost column contains the total execution time for the function, including built-in PHP code and any other user functions called. Clicking a column header allows to sort data in ascending or descending order. You can click the triangle icon next to a function name to expand a list of function invocations. This list allows you to see who called this function and what the amount of time spent is, and contains the following columns: Calls is the \"parent\" functions or class methods invoking this (child) function; Total Call Cost is the total time executing this function, when called from the parent function; Count - number of times the parent calls the child function. The coloured bar at the top of the page displays the contribution of different function types: Blue denotes PHP internal (built-in) functions; Lavender is time taken to include (or require) PHP files; Green shows the contribution of your own class methods; Orange denotes time taken on traditional \"procedural\" functions (functions that are not part of a PHP classes). Note Please note that the profiler creates a new data file in your /tmp directory for each HTTP request to your website. This may cause disk space exhaustion, which can be fixed only by rebooting your system. So, when you've finished profiling your application, it is recommended to disable the profiling by editing the php.ini file, commenting the xdebug.profiler_enable parameter as follows, and then restarting the Apache web server. ;xdebug.profiler_enable = 0","title":"Profiling"},{"location":"netbeans/#summary","text":"In this appendix, we've learned how to use NetBeans IDE to run the website and debug it in interactive step-by-step mode. To be able to run a website, you first need to edit the site's properties (run configuration). To debug the site, you need to have the XDebug PHP extension installed. When you debug your website in NetBeans, the PHP engine pauses program execution at every line where you set a breakpoint. You see the debugging information (like local variables and call stack) in NetBeans window in graphical form. Along with debugging, XDebug extension also provides the ability to profile websites. With profiling, you see how much time was spent for execution of a certain function or class method. This allows you to determine the \"bottle necks\" and performance issues.","title":"Summary"},{"location":"operation/","text":"Website Operation In this chapter we will provide some theory on how a typical Laminas Framework based web application works. You'll learn some PHP basics like PHP classes, how PHP namespaces are used for avoiding name collisions, what class autoloading is, how to define application configuration parameters and the stages present in an application's life-cycle. You will also become familiar with such important Laminas components as @ Laminas\\EventManager , @ Laminas\\ModuleManager and @ Laminas\\ServiceManager . If instead of learning the theory, you want to have some practical examples, skip this chapter and refer directly to Model-View-Controller . Laminas components covered in this chapter: Component Description @ Laminas\\Mvc Support of Model-View-Controller pattern. Separation of business logic from presentation. @ Laminas\\ModuleManager This component is responsible for loading and initializing modules of the web application. @ Laminas\\EventManager This component implements functionality for triggering events and event handling. @ Laminas\\ServiceManager Implements the registry of all services available in the web application. PHP Classes PHP supports object oriented style of programming (OOP). In OOP, the main building block of your code is a class . A class can have properties and methods . For example, let's create a PHP script named Person.php and define a simple class named Person in that file: <?php class Person { private $fullName; public function __construct() { // Some initialization code. $this->fullName = 'Unknown person'; } public function getFullName() { return $this->fullName; } public function setFullName($fullName) { $this->fullName = $fullName; } } Important You may notice that in example above we have the opening <?php tag which tells the PHP engine that the text after the tag is a PHP code. In example above, when the file contains only the PHP code (without mixing PHP and HTML tags), you don't need to insert the closing ?> tag after the end of the code. Moreover, this is not recommended and may cause undesired effects, if you inadvertently add some character after the closing ?> tag. The Person class above has a private property $fullName and three methods: __construct() method is a special method called constructor . It is used if you need to somehow initialize properties of the class. getFullName() and setFullName() are public methods used to do something with the class. Once you have defined the class, you can create objects of that class with the new operator, as follows: <?php // Instantiate the Person. $person = new Person(); // Set full name. $person->setFullName('John Doe'); // Print person's full name to screen. echo \"Person's full name is: \" . $person->getFullName() . \"\\n\"; Note Classes allow to split your functionality into smaller blocks and make it well organised. Laminas consists of hundreds of classes. You will also write your own classes in your web applications. PHP Namespaces When you use classes from different libraries (or even classes from different components of a single library) in your program, the class names may conflict. This means you can encounter two classes having the same name, resulting in a PHP interpreter error. If you've ever programmed websites with Laminas Framework 1, you might remember those extra long class names like Laminas_Controller_Abstract . The idea with long names was utilized to avoid name collisions between different components. Each component defined its own name prefix, like Laminas_ or My_ . To achieve the same goal, Laminas Framework uses a PHP language feature called namespaces . The namespaces allow to solve name collisions between code components, and provide you with the ability to make the long names shorter. A namespace is a container for a group of names. You can nest namespaces into each other. If a class does not define a namespace, it lives inside of the global namespace (for example, PHP classes Exception and DateTime belong to global namespace). A real-world example of a namespace definition (taken from @ Laminas\\Mvc component) is presented below: <?php namespace Laminas\\Mvc; /** * Main application class for invoking applications. */ class Application { // ... class members were omitted for simplicity ... } In Laminas Framework, all classes belong to top-level Laminas namespace. The line 2 defines the namespace Mvc , which is nested into Laminas namespace, and all classes of this component (including the @ Application [Laminas\\Mvc\\Application] class shown in this example on lines 7-10) belong to this namespace. You separate nested namespace names with the back-slash character ('\\'). In other parts of code, you reference the @ Application [Laminas\\Mvc\\Application] class using its fully-qualified name: <?php $application = new \\Laminas\\Mvc\\Application(); Note Please note the leading back-slash in @ \\Laminas\\Mvc\\Application name. If you specify a class name with leading back-slash, this means the fully-qualified class name. It is also possible to specify class name relatively to the current namespace, in that case you do not specify the leading back-slash. It is also possible to use the alias (short name for the class) with the help of PHP's use statement: <?php // Define the alias in the beginning of the file. use Laminas\\Mvc\\Application; // Later in your code, use the short class name. $application = new Application(); Note Although the alias allows to use a short class name instead of the full name, its usage is optional. You are not required to always use aliases, and can refer the class by its fully-qualified name. Every PHP file of your application typically defines the namespace (except index.php entry script and config files, which typically do not). For example, the main module of your site, the Application module, defines its own namespace whose name equals to the module name: <?php namespace Application; class Module { // ... class members were omitted for simplicity ... } PHP Interfaces In PHP, interfaces allow you to define which behavior a class should have, but without providing the implementation of such a behavior. This is also called a contract : by implementing an interface, a class agrees to the contract terms. In Laminas Framework, interfaces are widely used. For example, the @ Application class implements the @ ApplicationInterface , which defines the methods every application class must provide: <?php namespace Laminas\\Mvc; interface ApplicationInterface { // Retrieves the service manager. public function getServiceManager(); // Retrieves the HTTP request object. public function getRequest(); // Retrieves the HTTP response object. public function getResponse(); // Runs the application. public function run(); } As you can see from the example above, an interface is defined using the interface keyword, almost the same way you define a standard PHP class. As a usual class, the interface defines methods. However, the interface does not provide any implementation of its methods. In the @ ApplicationInterface interface definition above, you can see that every application implementing this interface will have method getServiceManager() for retrieving the service manager (about the service manager, see later in this chapter), the getRequest() and getResponse() methods for retrieving the HTTP request and response, respectively, and method run() for running the application. Note In Laminas Framework, by convention, interface classes should be named with Interface suffix, like @ ApplicationInterface . This convention is followed by most programmers world wide, not only at Laminas. A class implementing an interface is called a concrete class. The concrete @ Application class implements the @ ApplicationInterface , which means it provides the implementation of the methods defined by the interface: <?php namespace Laminas\\Mvc; class Application implements ApplicationInterface { // Implement the interface's methods here public function getServiceManager() { // Provide some implementation... } public function getRequest() { // Provide some implementation... } public function getResponse() { // Provide some implementation... } public function run() { // Provide some implementation... } } The concrete @ Application class uses the implements keyword to show that it provides an implementation of all methods of ApplicationInterface interface. The @ Application class can also have additional methods, which are not part of the interface. Graphically, the class relations are displayed using inheritance diagrams. In figure 3.1, the diagram for @ Application class is presented. The arrow points from the child class to the parent class. PHP Class Autoloading A web application consists of many PHP classes, and each class typically resides in a separate file. This introduces the need of including the files. For example, let's assume we have the file named Application.php which contains the definition for the @ \\Laminas\\Mvc\\Application class from the previous section. Before you can create an instance of the @ Application class somewhere in your code, you have to include the contents of Application.php file (you can do this with the help of require_once statement, passing it the full path to the file): <?php require_once \"/path/to/laminas/laminas-mvc/src/Application.php\"; use Laminas\\Mvc\\Application; $application = new Application(); As your application grows in size, it may be difficult to include each needed file. Laminas Framework itself consists of hundreds of files, and it can be very difficult to load the entire library and all its dependencies this way. Moreover, when executing the resulting code, PHP interpreter will take CPU time to process each included file, even if you don't create an instance of its class. To fix this problem, in PHP, the class autoloading feature has been introduced. The PHP function spl_autoload_register() allows you to register an autoloader function. For complex websites, you even can create several autoloader functions, which are chained in a stack. During script execution, if PHP interpreter encounters a class name which has not been defined yet, it calls all the registered autoloader functions in turn, until either the autoloader function includes the class or \"not found\" error is raised. This allows for \"lazy\" loading, when PHP interpreter processes the class definition only at the moment of class invocation, when it is really needed. Class Map Autoloader To give you an idea of how an autoloader function looks like, below we provide a simplified implementation of an autoloader function: <?php // Autoloader function. function autoloadFunc($className) { // Class map static array. static $classMap = [ '\\\\Laminas\\\\Mvc\\\\Application' => '/path/to/laminas/laminas-mvc/src/Laminas/Mvc/Application.php', '\\\\Application\\\\Module' => '/path/to/app/dir/module/Application/Module.php', //... ]; // Check if such a class name presents in the class map. if(isset(static::$classMap[$className])) { $fileName = static::$classMap[$className]; // Check if file exists and is readable. if (is_readable($fileName)) { // Include the file. require $fileName; } } } // Register our autoloader function. spl_autoload_register(\"autoloadFunc\"); In the above example, we define the autoloadFunc() autoloader function, which we will further refer to as the class map autoloader. The class map autoloader uses the class map for mapping between class name and absolute path to PHP file containing that class. The class map is just a usual PHP array containing keys and values. To determine the file path by class name, the class map autoloader just needs to fetch the value from the class map array. It is obvious, that the class map autoloader works very fast. However, the disadvantage of it is that you have to maintain the class map and update it each time you add a new class to your program. PSR-4 Standard Because each library's vendor uses its own code naming and file organization conventions, you will have to register a different custom autoloader function per each dependent library, which is rather annoying (and actually this is an unneeded work). To resolve this problem, the PSR-4 standard was introduced. What is PSR? PSR stands for PHP Standards Recommendation. These recommendations are maintained by the PHP FIG PHP Frameworks Interoperability Group. The PSR-4 standard defines the recommended code structure that an application or library must follow to guarantee autoloader interoperability. In short, the standard says that: The class namespaces should be organized in the following way: \\<Vendor Name>\\(<Namespace>)*\\<Class Name> Namespaces can have as many nesting levels as desired, but the Vendor Name should be the top-level namespace. Namespaces should map to directory structure. Each namespace separator ('\\') is converted to a OS-specific DIRECTORY_SEPARATOR constant when loading from the file system. The class name is suffixed with .php extension when loading the file from the file system. For example, for the @ Laminas\\Mvc\\Application class, you will have the following directory structure: /path/to/laminas/laminas-mvc/src /Laminas /Mvc Application.php The disadvantage of this is that you need to put your code in multiple nested directories ( Laminas and Mvc ). To fix this, the PSR-4 allows you to define that a contiguous series of one or more leading namespace and sub-namespace names corresponds to a \"base directory\". For example, if you have the @ \\Laminas\\Mvc\\Application fully qualified class name, and if you define that the series @ \\Laminas\\Mvc corresponds to the \"/path/to/laminas/laminas-mvc/src\" directory, you can organise your files as follows: /path/to/laminas/laminas-mvc/src Application.php For the code conforming to the PSR-4 standard, we can write and register an autoloader, which we will refer to as the \"standard\" autoloader: <?php // \"Standard\" autoloader function. function standardAutoloadFunc($className) { // Replace the namespace prefix with base directory. $prefix = '\\\\Laminas\\\\Mvc'; $baseDir = '/path/to/laminas/laminas-mvc/src/'; if (substr($className, 0, strlen($prefix)) == $prefix) { $className = substr($className, strlen($prefix)+1); $className = $baseDir . $className; } // Replace namespace separators in class name with directory separators. $className = str_replace('\\\\', DIRECTORY_SEPARATOR, $className); // Add the .php extension. $fileName = $className . \".php\"; // Check if file exists and is readable. if (is_readable($fileName)) { // Include the file. require $fileName; } } // Register the autoloader function. spl_autoload_register(\"standardAutoloadFunc\"); The standard autoloader works as follows. Assuming that the class namespace can be mapped to the directory structure one-by-one, the function calculates the path to PHP file by transforming back-slashes (namespace separators) to forward slashes (path separators) and concatenating the resulting path with the absolute path to the directory where the library is located. Then the function checks if such a PHP file really exists, and if so, includes it with the require statement. It is obvious, that the standard autoloader works slower than the class map autoloader. However, its advantage is that you don't need to maintain any class map, which is very convenient when you develop new code and add new classes to your application. Note Laminas Framework conforms to PSR-4 standard, making it possible to use standard autoloading mechanism across all its components. It is also compatible with other PSR-4 conforming libraries like Doctrine or Symfony. Composer-provided Autoloader Composer can generate autoloader functions (both class map autoloaders and PSR-4 standard autoloaders) for the code you install with it. Laminas Framework uses the autoloader implementation provided by Composer. When you install a package with Composer, it automatically creates the file APP_DIR/vendor/autoload.php , which uses the spl_autoload_register() PHP function to register an autoloader. This way all PHP classes located in APP_DIR/vendor directory are correctly autoloaded. To autoload PHP classes located in your own modules (like Application module), you'll have to specify the autoload key in your composer.json file: \"autoload\": { \"psr-4\": { \"Application\\\\\": \"module/Application/src/\" } }, Then the only thing need to be done is to include that file in your website entry script index.php : // Composer autoloading include __DIR__ . '/../vendor/autoload.php'; Note The autoload.php file is generated each time you install a package with Composer. Besides that, to make Composer generate the autoload.php file, you may need to execute the dump-autoload command: php composer.phar dump-autoload PSR-4 and Module's Source Directory Structure In Laminas Skeleton Application, you can see how the PSR-4 standard is applied in practice. For the default module of your website, the Application module, PHP classes which are registered with the standard autoloader are stored under the APP_DIR/module/Application/src directory (\"src\" abbreviation means \"source\"). We will refer to the src directory as module's source directory. For example, lets look at the IndexController.php file of Application module (figure 3.2). As you can see, it contains the IndexController class 1 belonging to Application\\Controller namespace. To be able to follow the PSR-4 standard and use the standard autoloader with this PHP class, we have to put it under the Controller directory under the module's source directory. HTTP Request and Response When a site user opens a web page in a web browser's window, the browser generates a request message and sends it using HTTP protocol to the web server. The web server directs this HTTP request to your web application. What is HTTP? HTTP (stands for Hyper Text Transfer Protocol) - a protocol for transferring data in the form of hyper text documents (web pages). HTTP is based on the client-server technology: the client initiates a connection and sends a request to web server, and the server waits for a connection, performs the necessary actions and returns a response message back. Thus, the main underlying goal of any web application is handling the HTTP request and producing an HTTP response typically containing the HTML code of the requested web page. The response is sent by the web server to the client web browser and the browser displays a web page on the screen. A typical HTTP request is presented below: GET http://www.w3schools.com/ HTTP/1.1 Host: www.w3schools.com Connection: keep-alive Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) Accept-Encoding: gzip,deflate,sdch Accept-Language: en-US;q=0.8,en;q=0.6 Cookie: __gads=ID=42213729da4df8df:T=1368250765:S=ALNI_MaOAFe3U1T9Syh; (empty line) (message body goes here) The HTTP request message above consists of three parts: The starting line (line 1) specifies the method of the request (e.g GET or POST), the URL string and HTTP protocol version. Optional headers (lines 2-8) characterize the message, the transmission parameters and provide other meta information. In the example above, each row represents a single header in the form of name:value . Optional message body contains message data. It is separated from the headers with a blank line. The headers and the message body may be absent, but the starting line is always present in the request, because it indicates its type and URL. The server response for the above request is presented below: HTTP/1.1 200 OK Cache-Control: private Content-Type: text/html Content-Encoding: gzip Vary: Accept-Encoding Server: Microsoft-IIS/7.5 Set-Cookie: ASPSESSIONIDQQRBACTR=FOCCINICEFAMEKODNKIBFOJP; path=/ X-Powered-By: ASP.NET Date: Sun, 04 Aug 2013 13:33:59 GMT Content-Length: 8434 (empty line) (page content follows) As you can see from the dump above, the HTTP response has almost the same format as the request: The starting line (line 1) represents the HTTP protocol version, response status code and message (200 OK). Optional headers (lines 2-10) provide various meta information about the response. Optional message body follows the headers, and must be separated from headers by an empty line. The message body typically contains the HTML code of the requested web page. Site Entry Script When the Apache web server receives an HTTP request from a client browser, it executes the APP_DIR/public/index.php file, also called the entry script . The entry script is the only PHP file accessible to the outside world. Apache web server directs all HTTP requests to this script (remember the .htaccess file?). Having this single entry script makes the website more secure (comparing with the situation when you allow everyone to access all PHP files of your application). Although the index.php file is very important, it is surprisingly small (see below): <?php use Laminas\\Mvc\\Application; use Laminas\\Stdlib\\ArrayUtils; /** * This makes our life easier when dealing with paths. Everything is relative * to the application root now. */ chdir(dirname(__DIR__)); // Decline static file requests back to the PHP built-in webserver if (php_sapi_name() === 'cli-server') { $path = realpath(__DIR__ . parse_url($_SERVER['REQUEST_URI'], PHP_URL_PATH)); if (__FILE__ !== $path && is_file($path)) { return false; } unset($path); } // Composer autoloading include __DIR__ . '/../vendor/autoload.php'; if (! class_exists(Application::class)) { throw new RuntimeException( \"Unable to load application.\\n\" . \"- Type `composer install` if you are developing locally.\\n\" . \"- Type `vagrant ssh -c 'composer install'` if you are using Vagrant.\\n\" . \"- Type `docker-compose run zf composer install` if you are using Docker.\\n\" ); } // Retrieve configuration $appConfig = require __DIR__ . '/../config/application.config.php'; if (file_exists(__DIR__ . '/../config/development.config.php')) { $appConfig = ArrayUtils::merge($appConfig, require __DIR__ . '/../config/development.config.php'); } // Run the application! Application::init($appConfig)->run(); Mainly, there are three things done in it. First, in line 10, current working directory is changed to APP_DIR . This makes it simple to define relative file paths in your application. Next, in line 22, PHP class autoloading is initialized. This allows to easily load any class either located in Laminas Framework library or in your application without the need for require_once statement. And finally, in line 40, an instance of @ Laminas\\Mvc\\Application class is created. The application is initialized with the settings read from application.config.php configuration file, and, the application is run. Events & Application's Life Cycle As you've learned from the previous section, on every HTTP request, the @ Laminas\\Mvc\\Application object is created. Typically, an application \"lives\" for a second or less (this time is enough to generate the HTTP response). The application's \"life\" consists of several stages. Laminas Framework uses the concept of event . One class can trigger an event, and other classes may listen to events. Technically, triggering an event means just calling another class' \"callback\" method. The event management is implemented inside of the @ Laminas\\EventManager component. Each application life stage is initiated by the application by triggering an event (this event is represented by the @ MvcEvent class living in @ Laminas\\Mvc namespace). Other classes (either belonging to Laminas Framework or specific to your application) may listen to events and react accordingly. Below, the five main events (life stages) are presented: Bootstrap . When this event is triggered by the application, a module has a chance to register itself as a listener of further application events in its onBootstrap() callback method. Route . When this event is triggered, the request's URL is analyzed using a router class (typically, with @ Laminas\\Router\\Http\\TreeRouteStack class). If an exact match between the URL and a route is found, the request is passed to the site-specific controller class assigned to the route. Dispatch . The controller class \"dispatches\" the request using the corresponding action method and produces the data that can be displayed on the web page. Render . On this event, the data produced by the controller's action method are passed for rendering to @ Laminas\\View\\Renderer\\PhpRenderer class. The renderer class uses a view template file for producing an HTML page. Finish . On this event, the HTTP response is sent back to client. The event flow is illustrated in figure 3.3: Note Although needed relatively rarely, some practical examples of how to listen and react to an event can be found in Creating a New Module chapter. Application Configuration Most of Laminas Framework components which are used in your website, require configuration (fine-tuning). For example, in the configuration file you define database connection credentials, specify which modules are present in your application, and, optionally, provide some custom parameters specific to your application. You can define the configuration parameters at two levels: either at the application level, or at the module level. At the application level you typically define parameters which control the whole app and are common to all modules of your application. At the module level, you define parameters which affect only this module. Note Some PHP frameworks prefer conventions over configuration concept, where most of your parameters are hard-coded and do not require configuration. This makes it faster to develop the application, but makes it less customizable. In Laminas Framework, the configuration over conventions concept is used, so you can customize any aspect of your application, but have to spend some time for learning how to do that. Application-Level Config Files The APP_DIR/config subdirectory contains application-wide configuration files. Let's look at this subdirectory in more details (figure 3.4). The APP_DIR/config/application.config.php file is the main configuration file. It is used by the application on start up for determining which application modules should be loaded and which services to create by default. Below, the content of application.config.php file is presented. You can see that the configuration file is just a usual PHP nested associative array, and each component may have a specific key in that array. You can provide inline comments for the array keys to make it easier for others to understand what each key means. Note By convention, key names should be in lower case, and if the key name consists of several words, the words should be separated by the underscore symbol ('_'). return [ // Retrieve list of modules used in this application. 'modules' => require __DIR__ . '/modules.config.php', // These are various options for the listeners attached to the ModuleManager 'module_listener_options' => [ // This should be an array of paths in which modules reside. // If a string key is provided, the listener will consider that a module // namespace, the value of that key the specific path to that module's // Module class. 'module_paths' => [ './module', './vendor', ], // An array of paths from which to glob configuration files after // modules are loaded. These effectively override configuration // provided by modules themselves. Paths may use GLOB_BRACE notation. 'config_glob_paths' => [ realpath(__DIR__) . '/autoload/{{,*.}global,{,*.}local}.php', ], // Whether or not to enable a configuration cache. // If enabled, the merged configuration will be cached and used in // subsequent requests. 'config_cache_enabled' => true, // The key used to create the configuration cache file name. 'config_cache_key' => 'application.config.cache', // Whether or not to enable a module class map cache. // If enabled, creates a module class map cache which will be used // by in future requests, to reduce the autoloading process. 'module_map_cache_enabled' => true, // The key used to create the class map cache file name. 'module_map_cache_key' => 'application.module.cache', // The path in which to cache merged configuration. 'cache_dir' => 'data/cache/', // Whether or not to enable modules dependency checking. // Enabled by default, prevents usage of modules that depend on other modules // that weren't loaded. // 'check_dependencies' => true, ], // Used to create an own service manager. May contain one or more child arrays. //'service_listener_options' => [ // [ // 'service_manager' => $stringServiceManagerName, // 'config_key' => $stringConfigKey, // 'interface' => $stringOptionalInterface, // 'method' => $stringRequiredMethodName, // ], // ], // Initial configuration with which to seed the ServiceManager. // Should be compatible with Laminas\\ServiceManager\\Config. // 'service_manager' => [], ]; In line 3 we have the modules key defining which modules will be loaded on start up. You can see that the module names are stored inside of another config file modules.config.php , which lists all modules present in your website. In line 11, there is the module_paths key which tells Laminas about directories where to look for source files belonging to modules. Application modules that you develop are located under APP_DIR/module directory, and third-party modules may be located inside the APP_DIR/vendor directory. And in line 19 we have the config_glob_paths key, which tells Laminas where to look for extra config files. You see that files from APP_DIR/config/autoload which have global.php or local.php suffix, are automatically loaded. Summing up, you typically use the main application.config.php file for storing the information about which modules should be loaded into your app and where they are located and how they are loaded (for example, you can control caching options here). In this file you can also tune the service manager. It is not recommended to add more keys in this file. For that purpose it is better to use autoload/global.php file. And let's also look inside the modules.config.php file. Currently, you have the following modules installed in your website: return [ 'Laminas\\Session', 'Laminas\\Mvc\\Plugin\\Prg', 'Laminas\\Mvc\\Plugin\\Identity', 'Laminas\\Mvc\\Plugin\\FlashMessenger', 'Laminas\\Mvc\\Plugin\\FilePrg', 'Laminas\\Form', 'Laminas\\Router', 'Laminas\\Validator', 'Application', ]; The Application module is a module containing your app's files. All other modules listed are Laminas Framework components. Note In Laminas, a special Composer plugin called component installer was introduced. If you remember, in the chapter Laminas Skeleton Application , we answered several yes/no questions of the installer, determining which components to install. And the installer injected those components' module names here, in modules.config.php Application-Level Extra Config Files \"Extra\" config files, APP_DIR/config/autoload/global.php and APP_DIR/config/autoload/local.php files define application-wide environment-agnostic and environment-dependent parameters, respectively. These config files are automatically loaded and recursively merged with the module-provided config files, that's why their directory is named autoload . Having different config files in APP_DIR/config/autoload directory, you might have been confused about which parameters should be put into each one. Here are some hints: You use the autoload/global.php file for storing parameters which do not depend on the concrete machine environment. For example, here you can store parameters which override the default parameters of some module. Do not store sensitive information (like database credentials) here, for that purpose it's better to use autoload/local.php . You use the autoload/local.php file for storing parameters specific to the concrete environment. For example, here you can store your database credentials. Each developer usually has a local database when developing and testing the website. The developer thus will edit the local.php file and enter his own database credentials here. When you install your site to the production server, you will edit the local.php file and enter the credentials for the \"live\" database here. Important Because the autoload/local.php file contains environment-specific parameters, in version control system you store its \"distribution template\" local.php.dist . Each developer in your team then renames the local.php.dist file into local.php and enters his own parameters. This local.php file should not be stored under version control, because it may contain sensitive information like database credentials (username and password), and you might want that other people do not see these. Application-Level Development Config File The application-level development configuration file ( APP_DIR/config/development.config.php ) presents only when you enable the development mode . If you remember, we enabled the development mode earlier in the Laminas Skeleton Application chapter. Reminder You enable the development mode with the following command: php composer.phar development-enable The development.config.php file is merged with the main application.config.php file. This allows you to override some parameters. For example, you can: disable config caching. When you develop your website, you frequently modify your config files, so config caching may have undesired consequences, like inability to see the result of your changes immediately. load additional modules. For example, you can load LaminasDeveloperTools module only in development mode. If you disable the development mode, the development.config.php file will be removed. So, you should not store this file under the version control. Instead, store its distribution version, development.config.php.dist under version control. Application-Level Extra Development Config Files The application-level extra development configuration file ( APP_DIR/config/autoload/development.local.php ) presents only when you enable the development mode . The development.local.php file is merged with other module-level config files. This allows you to override some module-specific parameters used in development environment only. If you disable the development mode, the development.local.php file will be removed. So, you should not store this file under the version control. Instead, store its distribution version, development.local.php.dist under version control. Module-Level Config Files In figure 3.4, you could see that the Application module shipped with your application has the module.config.php file, in which you put your module-specific parameters. Let's look at module.config.php file of the Application module: <?php namespace Application; use Laminas\\Router\\Http\\Literal; use Laminas\\Router\\Http\\Segment; use Laminas\\ServiceManager\\Factory\\InvokableFactory; return [ 'router' => [ 'routes' => [ 'home' => [ 'type' => Literal::class, 'options' => [ 'route' => '/', 'defaults' => [ 'controller' => Controller\\IndexController::class, 'action' => 'index', ], ], ], 'application' => [ 'type' => Segment::class, 'options' => [ 'route' => '/application[/:action]', 'defaults' => [ 'controller' => Controller\\IndexController::class, 'action' => 'index', ], ], ], ], ], 'controllers' => [ 'factories' => [ Controller\\IndexController::class => InvokableFactory::class, ], ], 'view_manager' => [ 'display_not_found_reason' => true, 'display_exceptions' => true, 'doctype' => 'HTML5', 'not_found_template' => 'error/404', 'exception_template' => 'error/index', 'template_map' => [ 'layout/layout' => __DIR__ . '/../view/layout/layout.phtml', 'application/index/index' => __DIR__ . '/../view/application/index/index.phtml', 'error/404' => __DIR__ . '/../view/error/404.phtml', 'error/index' => __DIR__ . '/../view/error/index.phtml', ], 'template_path_stack' => [ __DIR__ . '/../view', ], ], ]; In this file, you register the module's controllers, put information about routing rules for mapping URLs to your controllers, register controller plugins, and also register view templates and view helpers (we will learn more about these terms in this chapter and in the next chapters). Combining the Configuration Files When an application is being created, module-provided configuration files and extra configuration files from APP_DIR/config/autoload directory are being merged into one big nested array, so every configuration parameter becomes available to any piece of the website. So, potentially, you are able to override some parameters specified by the modules. Note You might also have seen the \"combined\" config file when installing PHP, where there is the main php.ini file and several extra config files, which are included into the main one. Such a separation makes your application configuration fine-grained and flexible, because you don't have to put all your params to a single file and edit it each time you need to change something. The configuration files are loaded in the following order: The main application.config.php file is loaded first. It is used to initialize the service manager and load application modules. The data loaded from this config is stored alone and not merged with other config files. Configuration files for each application module are loaded and merged. Modules are loaded in the same order as they are listed in the application.config.php file. If two modules store (either intentionally, or by mistake) parameters in the similar-named keys, these parameters may be overwritten. Extra config files from the APP_DIR/config/autoload folder are loaded and merged into a single array. Then this array is merged with the module config array produced on the previous stage, when loading the module configuration. Application-wide configuration has higher priority than the module configuration, so you can override module keys here, if you wish. Module Entry Point In Laminas, your web application consists of modules. By default, you have the single Application module, but can create more if needed. Typically, your own modules are stored in APP_DIR/module directory, while third-party modules live in APP_DIR/vendor directory. On start up, when the @ Laminas\\Mvc\\Application object is created, it uses the @ Laminas\\ModuleManager component to find and load all modules registered in application config. Each module of the web application has the Module.php file which is some kind of entry point for the module. This file provides the Module class. Below, the contents of skeleton application's Module class is presented: <?php namespace Application; class Module { public function getConfig() { return include __DIR__ . '/../config/module.config.php'; } } The class Module belongs to the module's namespace (for the main module it belongs to the Application namespace). The getConfig() method is typically used to provide module's configuration to Laminas Framework ( module.config.php file). Note You can also register some event listeners here, we'll see how to do this later in Creating a New Module chapter. Service Manager You can imagine the web application as a set of services . For example, you can have an authentication service responsible for logging in the site users, entity manager service responsible for accessing the database, event manager service responsible for triggering events and delivering them to event listeners, etc. In Laminas Framework, the @ ServiceManager class is a centralized container for all application services. The service manager is implemented in @ Laminas\\ServiceManager component, as the @ ServiceManager class. Class inheritance diagram is shown in figure 3.5 below: The service manager is created on application start up (inside of init() static method of @ Laminas\\Mvc\\Application class). The standard services available through service manager are presented in table 3.1. This table is incomplete, because the actual number of services registered in service manager may be much bigger. Service Name Description Application Allows to retrieve the singleton of @ Laminas\\Mvc\\Application class. ApplicationConfig Configuration array extracted from application.config.php file. Merged configuration array extracted from module.config.php files merged with autoload/global.php and autoload/local.php . EventManager Allows to retrieve a new instance of @ Laminas\\EventManager\\EventManager class. The event manager allows to send (trigger) events and attach event listeners. SharedEventManager Allows to retrieve the singleton instance of @ Laminas\\EventManager\\SharedEventManager class. The shared event manager allows to listen to events defined by other classes and components. ModuleManager Allows to retrieve the singleton of @ Laminas\\ModuleManager\\ModuleManager class. The module manager is responsible for loading application modules. Request The singleton of @ Laminas\\Http\\Request class. Represents HTTP request received from client. Response The singleton of @ Laminas\\Http\\Response class. Represents HTTP response that will be sent to client. Router The singleton of @ Laminas\\Router\\Http\\TreeRouteStack . Performs URL routing. ServiceManager Service manager itself. ViewManager The singleton of @ Laminas\\Mvc\\View\\Http\\ViewManager class. Responsible for preparing the view layer for page rendering. Table 3.1. Standard services A service is typically an arbitrary PHP class, but not always. For example, when Laminas loads the configuration files and merges the data into nested arrays, it saves the arrays in the service manager as a couple of services (!): ApplicationConfig and Config . The first one is the array loaded from application-level configuration file application.config.php , and the later one is the merged array from module-level config files and auto-loaded application-level config files. Thus, in the service manager you can store anything you want: a PHP class, a simple variable or an array. From table 3.1, you can see that in Laminas almost everything can be considered as a service. The service manager is itself registered as a service. Moreover, the @ Application class is also registered as a service. Note An important thing you should note about the services is that they are typically stored in a single instance only (this is also called the singleton pattern). Obviously, you don't need the second instance of the @ Application class (in that case you would have a nightmare). But, there is an important exception from the rule above. It may be confusing at first, but the @ EventManager is not a singleton. Each time you retrieve the event manager service from service manager, you receive a new object. This is done for performance reasons and to avoid possible event conflicts between different components. We will discuss this further in the About Event Manager section later in this chapter. The service manager defines several methods needed for locating and retrieving a service from the service manager (see the table 3.2 below). Method Name Description has($name) Checks if such a service is registered. get($name) Retrieves a registered service's instance. build($name, $options) Always returns a new instance of the requested service. Table 3.2. ServiceManager methods You can test if a service is registered by passing its name to the service manager's has() method. It returns a boolean true if the service is registered, or false if the service with such a name is not registered. You can retrieve a service by its name later with the help of the service manager's get() method. This method takes a single parameter representing the service name. Look at the following example: <?php // Retrieve the application config array. $appConfig = $serviceManager->get('ApplicationConfig'); // Use it (for example, retrieve the module list). $modules = $appConfig['modules']; And the build() method always creates a new instance of the service when you call it (comparing to get() , which typically creates the instance of the service only once and returns it on later requests). Note You will typically retrieve services from service manager not in any place of your code, but inside of a factory . A factory is a code responsible for creation of an object. When creating the object, you can retrieve services it depends on from the service manager and pass those services (dependencies) to the object's constructor. This is also called dependency injection . Registering a Service When writing your website, you will often need to register your own service in the service manager. One of the ways to register a service is using the setService() method of the service manager. For example, let's create and register the currency converter service class, which will be used, for example, on a shopping cart page to convert EUR currency to USD: <?php // Define a namespace where our custom service lives. namespace Application\\Service; // Define a currency converter service class. class CurrencyConverter { // Converts euros to US dollars. public function convertEURtoUSD($amount) { return $amount*1.25; } //... } Above, in lines 6-15 we define an example CurrencyConverter class (for simplicity, we implement only a single method convertEURtoUSD() which is able to convert euros to US dollars). // Create an instance of the class. $service = new CurrencyConverter(); // Save the instance to service manager. $serviceManager->setService(CurrencyConverter::class, $service); In the example above, we instantiate the class with the new operator, and register it with the service manager using the setService() method (we assume that the $serviceManager variable is of type @ Laminas\\ServiceManager\\ServiceManager class, and that it was declared somewhere else). The setService() method takes two parameters: the service name string, and the service instance. The service name should be unique within all other possible services. Once the service is stored in service manager, you can retrieve it by name at any place of your application with the help of the service manager's get() method. Look at the following example: <?php // Retrieve the currency converter service. $service = $serviceManager->get(CurrencyConverter::class); // Use it (convert money amount). $convertedAmount = $service->convertEURtoUSD(50); Service Names Different services can use different naming styles. For example, the same currency converter service may be registered under the different names: CurrencyConverter , currency_converter and so on. To introduce some uniform naming convention, it is recommended to register a service by its fully qualified class name, as follows: $serviceManager->setService(CurrencyConverter::class); In the example above, we used the keyword class . It is available since PHP 5.5 and is used for class name resolution. CurrencyConverter::class is expanded to the fully qualified name of the class, like \\Application\\Service\\CurrencyConverter . Overriding an Existing Service If you are trying to register the service name which is already present, the setService() method will throw an exception. But sometimes you want to override the service with the same name (to replace it by the new one). For this purpose, you can use the setAllowOverride() method of the service manager: <?php // Allow to replace services $serviceManager->setAllowOverride(true); // Save the instance to service manager. There will be no exception // even if there is another service with such a name. $serviceManager->setService(CurrencyConverter::class, $service); Above, the setAllowOverride() method takes the single boolean parameter defining whether to allow you replace the service CurrencyConverter if such a name is already present, or not. Registering Invokable Classes What is bad with the setService() method is that you have to create the service instance before you really need it. If you never use the service, the service instantiation will only waste the time and memory. To resolve this issue, the service manager provides you with the setInvokableClass() method. <?php // Register an invokable class $serviceManager->setInvokableClass(CurrencyConverter::class); In the example above, we pass to the service manager the fully qualified class name of the service instead of passing its instance. With this technique, the service will be instantiated by the service manager only when someone calls the get(CurrencyConverter::class) method. This is also called lazy loading. Note Services often depend on each other. For example, the currency converter service may use entity manager service to read money exchange rates from database. The disadvantage of setInvokableClass() method is that it doesn't allow to pass parameters (dependencies) to the service on object instantiation. To resolve this issue, you can use factories , as described below. Registering a Factory A factory is a class that can do only one thing - to create other objects. You register a factory for a service with the setFactory() method of the service manager: The simplest factory is @ InvokableFactory - it is analogous to the setInvokableClass() method from the previous section. <?php use Laminas\\ServiceManager\\Factory\\InvokableFactory; // This is equivalent to the setInvokableClass() method from previous section. $serviceManager->setFactory(CurrencyConverter::class, InvokableFactory::class); After you have registered the factory you can retrieve the service from service manager as usual with the get() method. The service will be instantiated only when you retrieve it from service manager (lazy loading). Sometimes, service instantiation is more complex than just creating the service instance with new operator (like @ InvokableFactory does). You may need to pass some parameters to the service's constructor or invoke some service methods just after construction. This complex instantiation logic can be encapsulated inside of your own custom factory class. The factory class typically implements the @ FactoryInterface [Laminas\\ServiceManager\\Factory\\FactoryInterface]: <?php namespace Laminas\\ServiceManager\\Factory; use Interop\\Container\\ContainerInterface; interface FactoryInterface { public function __invoke(ContainerInterface $container, $requestedName, array $options = null); } As we see from the definition of the @ FactoryInterface [Laminas\\ServiceManager\\Factory\\FactoryInterface], the factory class must provide the __invoke magic method returning the instance of a single service. The service manager is passed to the __invoke method as the $container parameter; it can be used during the construction of the service for accessing other services (to inject dependencies ). The second argument ( $requestedName ) is the service name. The third argument ( $options ) can be used to pass some parameters to the service, and is used only when you request the service with the build() method of the service manager. As an example, let's write a factory for our currency converter service (see the code below). We don't use complex construction logics for our CurrencyConverter service, but for more complex services, you may need to use one. <?php namespace Application\\Service\\Factory; use Laminas\\ServiceManager\\Factory\\FactoryInterface; use Application\\Service\\CurrencyConverter; // Factory class class CurrencyConverterFactory implements FactoryInterface { public function __invoke(ContainerInterface $container, $requestedName, array $options = null) { // Create an instance of the class. $service = new CurrencyConverter(); return $service; } } Note Technically, in Laminas you can use the same factory class for instantiating several services that have similar instantiation code (for that purpose, you can use the $requestedName argument passed to the __invoke() method of the factory). However, mostly you will create a different factory per each service. Registering an Abstract Factory Even more complex case of a factory is when you need to determine at run time which service names should be registered. For such a situation, you can use an abstract factory . An abstract factory class should implement the @ AbstractFactoryInterface [Laminas\\ServiceManager\\Factory\\AbstractFactoryInterface] interface: <?php namespace Laminas\\ServiceManager\\Factory; use Interop\\Container\\ContainerInterface; interface AbstractFactoryInterface extends FactoryInterface { public function canCreate(ContainerInterface $container, $requestedName); } An abstract factory has two methods: canCreate() and __invoke() . The first one is needed to test if the factory can create the service with the certain name, and the latter one allows to actually create the service. The methods take two parameters: service manager ( $container ) and service name ( $requestedName ). Comparing to usual factory class, the difference is that the usual factory class typically creates only a single type of service, but an abstract factory can dynamically create as many types of services as it wants. You register an abstract factory with the setAbstractFactory() method of the service manager. Note Abstract factories are a powerful feature, but you should use them only when really necessary, because they negatively impact the performance. It is better to use the usual (non-abstract) factories. Registering Service Aliases Sometimes, you may want to define an alias for a service. The alias is like a symbolic link: it references the already registered service. To create an alias, you use the service manager's setAlias() method: <?php // Register an alias for the CurrencyConverter service $serviceManager->setAlias('CurConv', CurrencyConverter::class); Once registered, you can retrieve the service by both its name and alias using the service manager's get() method. Shared and Non-Shared Services By default, services are stored in service manager in single instance only. This is also called the singleton design pattern. For example, when you try to retrieve the CurrencyConverter service twice, you will receive the same object. This is also called a shared service. But, in some (rare) situations, you will need to create a new instance of a service each time someone requests it from service manager. An example is the @ EventManager - you get a new instance of it each time you request it. To mark a service as a non-shared, you can use service manager's setShared() method: $serviceManager->setShared('EventManager', false); Service Manager Configuration In your website, you typically use service manager configuration to register your services (instead of calling service manager's methods as described above). To automatically register a service within the service manager, typically the service_manager key of a configuration file is used. You can put this key either inside of an application-level configuration file or in a module-level configuration file. Important If you are putting this key in a module-level configuration file, be careful about the danger of name overwriting during the configs merge. Do not register the same service name in different modules. This service_manager key should look like below: <?php return [ //... // Register the services under this key 'service_manager' => [ 'services' => [ // Register service class instances here //... ], 'invokables' => [ // Register invokable classes here //... ], 'factories' => [ // Register factories here //... ], 'abstract_factories' => [ // Register abstract factories here //... ], 'aliases' => [ // Register service aliases here //... ], 'shared' => [ // Specify here which services must be non-shared ] ], //... ]; In the example above, you can see that the service_manager key may contain several subkeys for registering services in different ways: the services subkey (line 7) allows to register class instances; the invokables subkey (line 11) allows to register full class name of a service; the service will be instantiated using lazy loading; the factories subkey (line 15) allows for registering a factory, which is able to create instances of a single service; the abstract_factories (line 19) can be used for registering abstract factories, which are able to register several services by name; the aliases subkey (line 23) provides an ability to register an alias for a service. the shared subkey (line 27) allows to specify which services must be non-shared. As an example, let's register our CurrencyConverter service and create an alias for it: <?php use Laminas\\ServiceManager\\Factory\\InvokableFactory; use Application\\Service\\CurrencyConverter; return [ //... // Register the services under this key 'service_manager' => [ 'factories' => [ // Register CurrencyConverter service. CurrencyConverter::class => InvokableFactory::class ], 'aliases' => [ // Register an alias for the CurrencyConverter service. 'CurConv' => CurrencyConverter::class ], ], //... ]; Plugin Managers Now that you understand what service manager is, it shouldn't be very difficult for you to learn the concept of plugin managers . A plugin manager is almost the same as the service manager, but it can instantiate services of the single type only. Which plugin type a plugin manager may be hard-coded instantiated inside the plugin manager class. Why would you need such thing? Actually, in Laminas, plugin managers are widely used, because they allow to instantiate a plugin only when it is needed (this reduces CPU and memory usage). There is a separate plugin manager for: controllers (the @ Laminas\\Mvc\\Controller\\ControllerManager class) controller plugins (the @ Laminas\\Mvc\\Controller\\PluginManager class) view helpers (the @ Laminas\\View\\HelperPluginManager class) form elements (the @ Laminas\\Form\\FormElementManager\\FormElementManagerV3Polyfill class) filters (the @ Laminas\\Filter\\FilterPluginManager class) validators (the @ Laminas\\Validator\\ValidatorPluginManager class) and probably other stuff The fact that each plugin manager inherits from the @ Laminas\\ServiceManager\\ServiceManager base class allows all plugin managers to have similar configuration. For example, controllers are registered under the controllers key in module.config.php file, and this key may have the same subkeys: services , invokables , factories , abstract_factories , and aliases . The same structure has the view_helpers key that is used for registering view helpers, the controller_plugins key that is used for registering controller plugins, and so on. About Event Manager Note In this section, we will give some advanced information about event manager. You can relatively safely skip this section, however refer to it if you plan to implement some advanced event listeners in your website. Previously in this chapter we have mentioned that the application life cycle consists of events . One class can trigger an event, and other classes may listen to events. Technically, triggering an event means just calling another class' \"callback\" method. The event management is implemented inside of the @ Laminas\\EventManager component. Laminas (and particularly its @ Laminas\\Mvc component) hardly depends on events to operate, and because of that its source code is a combination of event listeners which is rather difficult to understand. Fortunately, in most cases you do not need to understand how Laminas triggers and handles events internally, you just need to understand what event is, what events present in application life cycle and what is the difference between usual event manager and shared event manager . Event & MvcEvent An event is technically an instance of the @ Laminas\\EventManager\\Event class. An event can basically have at least the following parts: name - uniquely identifies the event; target - this is typically a pointer to the object which triggered the event; and params - event-specific arguments passed to the event listeners. It is possible to create custom types of events by extending the @ Event [Laminas\\EventManager\\Event] class. For example, the @ Laminas\\Mvc component defines the custom event type named @ Laminas\\Mvc\\MvcEvent , which extends the Event class and adds several properties and methods needed for the @ Laminas\\Mvc component to work. EventManager & SharedEventManager It is important to understand the difference between the usual event manager and the shared event manager. The usual event manager is not stored as a singleton in the service manager. Every time you request the @ EventManager service from the service manager, you receive a new instance of it. This is done for privacy and performance reasons: It is assumed by default that the class triggering events will request and save somewhere its own private event manager, because it doesn't want other classes to automatically listen to those events. Events triggered by the class are assumed to belong to that class privately. If anyone would be able to listen to any event triggered by any class, there would be performance hell - too many event listeners would be invoked, thus increasing page load time. It is better to avoid this by keeping events private. But, in case if someone intentionally needs to listen to other's events, there is a special shared event manager. The @ SharedEventManager service is stored in the service manager as a singleton, so you can be sure everyone will have the same instance of it. With the @ SharedEventManager , you can attach a listener to private events triggered by certain class (or several classes). You specify the unique class identifier(s) to which you would like to listen. That simple! Note Some practical examples of how to listen and react to an event can be found in Creating a New Module chapter and User Management, Authentication & Access Filtering chapter. Summary In this chapter, we've learned some theory about laminas-based website operation basics. Laminas uses PHP namespaces and class autoloading features, simplifying the development of applications which use many third-party components. The namespaces allow to solve the name collisions between code components, and provide you with the ability to make the long names shorter. The class autoloading makes it possible to use any PHP class in any library installed with Composer without the use of require_once statement. Composer also provides a PSR-4 autoloader for the classes located in the modules of your web application. Most of Laminas Framework components require configuration. You can define the configuration parameters either at the application level, or at the module level. The main goal of any web application is handling the HTTP request and producing an HTTP response typically containing the HTML code of the requested web page. When Apache web server receives an HTTP request from a client browser, it executes the index.php file, which is also called the site's entry script. On every HTTP request, the @ Laminas\\Mvc\\Application object is created, whose \"life cycle\" consists of several stages (or events). The web application's business logic can be also considered as a set of services. In Laminas Framework, the service manager is a centralized container for all the application services. A service is typically a PHP class, but in general it can be a variable or an array, if needed. IndexController class is the default controller for the skeleton website. We will talk about controllers later in chapter Model-View-Controller . \u21a9","title":"Website Operation"},{"location":"operation/#website-operation","text":"In this chapter we will provide some theory on how a typical Laminas Framework based web application works. You'll learn some PHP basics like PHP classes, how PHP namespaces are used for avoiding name collisions, what class autoloading is, how to define application configuration parameters and the stages present in an application's life-cycle. You will also become familiar with such important Laminas components as @ Laminas\\EventManager , @ Laminas\\ModuleManager and @ Laminas\\ServiceManager . If instead of learning the theory, you want to have some practical examples, skip this chapter and refer directly to Model-View-Controller . Laminas components covered in this chapter: Component Description @ Laminas\\Mvc Support of Model-View-Controller pattern. Separation of business logic from presentation. @ Laminas\\ModuleManager This component is responsible for loading and initializing modules of the web application. @ Laminas\\EventManager This component implements functionality for triggering events and event handling. @ Laminas\\ServiceManager Implements the registry of all services available in the web application.","title":"Website Operation"},{"location":"operation/#php-classes","text":"PHP supports object oriented style of programming (OOP). In OOP, the main building block of your code is a class . A class can have properties and methods . For example, let's create a PHP script named Person.php and define a simple class named Person in that file: <?php class Person { private $fullName; public function __construct() { // Some initialization code. $this->fullName = 'Unknown person'; } public function getFullName() { return $this->fullName; } public function setFullName($fullName) { $this->fullName = $fullName; } } Important You may notice that in example above we have the opening <?php tag which tells the PHP engine that the text after the tag is a PHP code. In example above, when the file contains only the PHP code (without mixing PHP and HTML tags), you don't need to insert the closing ?> tag after the end of the code. Moreover, this is not recommended and may cause undesired effects, if you inadvertently add some character after the closing ?> tag. The Person class above has a private property $fullName and three methods: __construct() method is a special method called constructor . It is used if you need to somehow initialize properties of the class. getFullName() and setFullName() are public methods used to do something with the class. Once you have defined the class, you can create objects of that class with the new operator, as follows: <?php // Instantiate the Person. $person = new Person(); // Set full name. $person->setFullName('John Doe'); // Print person's full name to screen. echo \"Person's full name is: \" . $person->getFullName() . \"\\n\"; Note Classes allow to split your functionality into smaller blocks and make it well organised. Laminas consists of hundreds of classes. You will also write your own classes in your web applications.","title":"PHP Classes"},{"location":"operation/#php-namespaces","text":"When you use classes from different libraries (or even classes from different components of a single library) in your program, the class names may conflict. This means you can encounter two classes having the same name, resulting in a PHP interpreter error. If you've ever programmed websites with Laminas Framework 1, you might remember those extra long class names like Laminas_Controller_Abstract . The idea with long names was utilized to avoid name collisions between different components. Each component defined its own name prefix, like Laminas_ or My_ . To achieve the same goal, Laminas Framework uses a PHP language feature called namespaces . The namespaces allow to solve name collisions between code components, and provide you with the ability to make the long names shorter. A namespace is a container for a group of names. You can nest namespaces into each other. If a class does not define a namespace, it lives inside of the global namespace (for example, PHP classes Exception and DateTime belong to global namespace). A real-world example of a namespace definition (taken from @ Laminas\\Mvc component) is presented below: <?php namespace Laminas\\Mvc; /** * Main application class for invoking applications. */ class Application { // ... class members were omitted for simplicity ... } In Laminas Framework, all classes belong to top-level Laminas namespace. The line 2 defines the namespace Mvc , which is nested into Laminas namespace, and all classes of this component (including the @ Application [Laminas\\Mvc\\Application] class shown in this example on lines 7-10) belong to this namespace. You separate nested namespace names with the back-slash character ('\\'). In other parts of code, you reference the @ Application [Laminas\\Mvc\\Application] class using its fully-qualified name: <?php $application = new \\Laminas\\Mvc\\Application(); Note Please note the leading back-slash in @ \\Laminas\\Mvc\\Application name. If you specify a class name with leading back-slash, this means the fully-qualified class name. It is also possible to specify class name relatively to the current namespace, in that case you do not specify the leading back-slash. It is also possible to use the alias (short name for the class) with the help of PHP's use statement: <?php // Define the alias in the beginning of the file. use Laminas\\Mvc\\Application; // Later in your code, use the short class name. $application = new Application(); Note Although the alias allows to use a short class name instead of the full name, its usage is optional. You are not required to always use aliases, and can refer the class by its fully-qualified name. Every PHP file of your application typically defines the namespace (except index.php entry script and config files, which typically do not). For example, the main module of your site, the Application module, defines its own namespace whose name equals to the module name: <?php namespace Application; class Module { // ... class members were omitted for simplicity ... }","title":"PHP Namespaces"},{"location":"operation/#php-interfaces","text":"In PHP, interfaces allow you to define which behavior a class should have, but without providing the implementation of such a behavior. This is also called a contract : by implementing an interface, a class agrees to the contract terms. In Laminas Framework, interfaces are widely used. For example, the @ Application class implements the @ ApplicationInterface , which defines the methods every application class must provide: <?php namespace Laminas\\Mvc; interface ApplicationInterface { // Retrieves the service manager. public function getServiceManager(); // Retrieves the HTTP request object. public function getRequest(); // Retrieves the HTTP response object. public function getResponse(); // Runs the application. public function run(); } As you can see from the example above, an interface is defined using the interface keyword, almost the same way you define a standard PHP class. As a usual class, the interface defines methods. However, the interface does not provide any implementation of its methods. In the @ ApplicationInterface interface definition above, you can see that every application implementing this interface will have method getServiceManager() for retrieving the service manager (about the service manager, see later in this chapter), the getRequest() and getResponse() methods for retrieving the HTTP request and response, respectively, and method run() for running the application. Note In Laminas Framework, by convention, interface classes should be named with Interface suffix, like @ ApplicationInterface . This convention is followed by most programmers world wide, not only at Laminas. A class implementing an interface is called a concrete class. The concrete @ Application class implements the @ ApplicationInterface , which means it provides the implementation of the methods defined by the interface: <?php namespace Laminas\\Mvc; class Application implements ApplicationInterface { // Implement the interface's methods here public function getServiceManager() { // Provide some implementation... } public function getRequest() { // Provide some implementation... } public function getResponse() { // Provide some implementation... } public function run() { // Provide some implementation... } } The concrete @ Application class uses the implements keyword to show that it provides an implementation of all methods of ApplicationInterface interface. The @ Application class can also have additional methods, which are not part of the interface. Graphically, the class relations are displayed using inheritance diagrams. In figure 3.1, the diagram for @ Application class is presented. The arrow points from the child class to the parent class.","title":"PHP Interfaces"},{"location":"operation/#php-class-autoloading","text":"A web application consists of many PHP classes, and each class typically resides in a separate file. This introduces the need of including the files. For example, let's assume we have the file named Application.php which contains the definition for the @ \\Laminas\\Mvc\\Application class from the previous section. Before you can create an instance of the @ Application class somewhere in your code, you have to include the contents of Application.php file (you can do this with the help of require_once statement, passing it the full path to the file): <?php require_once \"/path/to/laminas/laminas-mvc/src/Application.php\"; use Laminas\\Mvc\\Application; $application = new Application(); As your application grows in size, it may be difficult to include each needed file. Laminas Framework itself consists of hundreds of files, and it can be very difficult to load the entire library and all its dependencies this way. Moreover, when executing the resulting code, PHP interpreter will take CPU time to process each included file, even if you don't create an instance of its class. To fix this problem, in PHP, the class autoloading feature has been introduced. The PHP function spl_autoload_register() allows you to register an autoloader function. For complex websites, you even can create several autoloader functions, which are chained in a stack. During script execution, if PHP interpreter encounters a class name which has not been defined yet, it calls all the registered autoloader functions in turn, until either the autoloader function includes the class or \"not found\" error is raised. This allows for \"lazy\" loading, when PHP interpreter processes the class definition only at the moment of class invocation, when it is really needed.","title":"PHP Class Autoloading"},{"location":"operation/#class-map-autoloader","text":"To give you an idea of how an autoloader function looks like, below we provide a simplified implementation of an autoloader function: <?php // Autoloader function. function autoloadFunc($className) { // Class map static array. static $classMap = [ '\\\\Laminas\\\\Mvc\\\\Application' => '/path/to/laminas/laminas-mvc/src/Laminas/Mvc/Application.php', '\\\\Application\\\\Module' => '/path/to/app/dir/module/Application/Module.php', //... ]; // Check if such a class name presents in the class map. if(isset(static::$classMap[$className])) { $fileName = static::$classMap[$className]; // Check if file exists and is readable. if (is_readable($fileName)) { // Include the file. require $fileName; } } } // Register our autoloader function. spl_autoload_register(\"autoloadFunc\"); In the above example, we define the autoloadFunc() autoloader function, which we will further refer to as the class map autoloader. The class map autoloader uses the class map for mapping between class name and absolute path to PHP file containing that class. The class map is just a usual PHP array containing keys and values. To determine the file path by class name, the class map autoloader just needs to fetch the value from the class map array. It is obvious, that the class map autoloader works very fast. However, the disadvantage of it is that you have to maintain the class map and update it each time you add a new class to your program.","title":"Class Map Autoloader"},{"location":"operation/#psr-4-standard","text":"Because each library's vendor uses its own code naming and file organization conventions, you will have to register a different custom autoloader function per each dependent library, which is rather annoying (and actually this is an unneeded work). To resolve this problem, the PSR-4 standard was introduced. What is PSR? PSR stands for PHP Standards Recommendation. These recommendations are maintained by the PHP FIG PHP Frameworks Interoperability Group. The PSR-4 standard defines the recommended code structure that an application or library must follow to guarantee autoloader interoperability. In short, the standard says that: The class namespaces should be organized in the following way: \\<Vendor Name>\\(<Namespace>)*\\<Class Name> Namespaces can have as many nesting levels as desired, but the Vendor Name should be the top-level namespace. Namespaces should map to directory structure. Each namespace separator ('\\') is converted to a OS-specific DIRECTORY_SEPARATOR constant when loading from the file system. The class name is suffixed with .php extension when loading the file from the file system. For example, for the @ Laminas\\Mvc\\Application class, you will have the following directory structure: /path/to/laminas/laminas-mvc/src /Laminas /Mvc Application.php The disadvantage of this is that you need to put your code in multiple nested directories ( Laminas and Mvc ). To fix this, the PSR-4 allows you to define that a contiguous series of one or more leading namespace and sub-namespace names corresponds to a \"base directory\". For example, if you have the @ \\Laminas\\Mvc\\Application fully qualified class name, and if you define that the series @ \\Laminas\\Mvc corresponds to the \"/path/to/laminas/laminas-mvc/src\" directory, you can organise your files as follows: /path/to/laminas/laminas-mvc/src Application.php For the code conforming to the PSR-4 standard, we can write and register an autoloader, which we will refer to as the \"standard\" autoloader: <?php // \"Standard\" autoloader function. function standardAutoloadFunc($className) { // Replace the namespace prefix with base directory. $prefix = '\\\\Laminas\\\\Mvc'; $baseDir = '/path/to/laminas/laminas-mvc/src/'; if (substr($className, 0, strlen($prefix)) == $prefix) { $className = substr($className, strlen($prefix)+1); $className = $baseDir . $className; } // Replace namespace separators in class name with directory separators. $className = str_replace('\\\\', DIRECTORY_SEPARATOR, $className); // Add the .php extension. $fileName = $className . \".php\"; // Check if file exists and is readable. if (is_readable($fileName)) { // Include the file. require $fileName; } } // Register the autoloader function. spl_autoload_register(\"standardAutoloadFunc\"); The standard autoloader works as follows. Assuming that the class namespace can be mapped to the directory structure one-by-one, the function calculates the path to PHP file by transforming back-slashes (namespace separators) to forward slashes (path separators) and concatenating the resulting path with the absolute path to the directory where the library is located. Then the function checks if such a PHP file really exists, and if so, includes it with the require statement. It is obvious, that the standard autoloader works slower than the class map autoloader. However, its advantage is that you don't need to maintain any class map, which is very convenient when you develop new code and add new classes to your application. Note Laminas Framework conforms to PSR-4 standard, making it possible to use standard autoloading mechanism across all its components. It is also compatible with other PSR-4 conforming libraries like Doctrine or Symfony.","title":"PSR-4 Standard"},{"location":"operation/#composer-provided-autoloader","text":"Composer can generate autoloader functions (both class map autoloaders and PSR-4 standard autoloaders) for the code you install with it. Laminas Framework uses the autoloader implementation provided by Composer. When you install a package with Composer, it automatically creates the file APP_DIR/vendor/autoload.php , which uses the spl_autoload_register() PHP function to register an autoloader. This way all PHP classes located in APP_DIR/vendor directory are correctly autoloaded. To autoload PHP classes located in your own modules (like Application module), you'll have to specify the autoload key in your composer.json file: \"autoload\": { \"psr-4\": { \"Application\\\\\": \"module/Application/src/\" } }, Then the only thing need to be done is to include that file in your website entry script index.php : // Composer autoloading include __DIR__ . '/../vendor/autoload.php'; Note The autoload.php file is generated each time you install a package with Composer. Besides that, to make Composer generate the autoload.php file, you may need to execute the dump-autoload command: php composer.phar dump-autoload","title":"Composer-provided Autoloader"},{"location":"operation/#psr-4-and-modules-source-directory-structure","text":"In Laminas Skeleton Application, you can see how the PSR-4 standard is applied in practice. For the default module of your website, the Application module, PHP classes which are registered with the standard autoloader are stored under the APP_DIR/module/Application/src directory (\"src\" abbreviation means \"source\"). We will refer to the src directory as module's source directory. For example, lets look at the IndexController.php file of Application module (figure 3.2). As you can see, it contains the IndexController class 1 belonging to Application\\Controller namespace. To be able to follow the PSR-4 standard and use the standard autoloader with this PHP class, we have to put it under the Controller directory under the module's source directory.","title":"PSR-4 and Module's Source Directory Structure"},{"location":"operation/#http-request-and-response","text":"When a site user opens a web page in a web browser's window, the browser generates a request message and sends it using HTTP protocol to the web server. The web server directs this HTTP request to your web application. What is HTTP? HTTP (stands for Hyper Text Transfer Protocol) - a protocol for transferring data in the form of hyper text documents (web pages). HTTP is based on the client-server technology: the client initiates a connection and sends a request to web server, and the server waits for a connection, performs the necessary actions and returns a response message back. Thus, the main underlying goal of any web application is handling the HTTP request and producing an HTTP response typically containing the HTML code of the requested web page. The response is sent by the web server to the client web browser and the browser displays a web page on the screen. A typical HTTP request is presented below: GET http://www.w3schools.com/ HTTP/1.1 Host: www.w3schools.com Connection: keep-alive Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) Accept-Encoding: gzip,deflate,sdch Accept-Language: en-US;q=0.8,en;q=0.6 Cookie: __gads=ID=42213729da4df8df:T=1368250765:S=ALNI_MaOAFe3U1T9Syh; (empty line) (message body goes here) The HTTP request message above consists of three parts: The starting line (line 1) specifies the method of the request (e.g GET or POST), the URL string and HTTP protocol version. Optional headers (lines 2-8) characterize the message, the transmission parameters and provide other meta information. In the example above, each row represents a single header in the form of name:value . Optional message body contains message data. It is separated from the headers with a blank line. The headers and the message body may be absent, but the starting line is always present in the request, because it indicates its type and URL. The server response for the above request is presented below: HTTP/1.1 200 OK Cache-Control: private Content-Type: text/html Content-Encoding: gzip Vary: Accept-Encoding Server: Microsoft-IIS/7.5 Set-Cookie: ASPSESSIONIDQQRBACTR=FOCCINICEFAMEKODNKIBFOJP; path=/ X-Powered-By: ASP.NET Date: Sun, 04 Aug 2013 13:33:59 GMT Content-Length: 8434 (empty line) (page content follows) As you can see from the dump above, the HTTP response has almost the same format as the request: The starting line (line 1) represents the HTTP protocol version, response status code and message (200 OK). Optional headers (lines 2-10) provide various meta information about the response. Optional message body follows the headers, and must be separated from headers by an empty line. The message body typically contains the HTML code of the requested web page.","title":"HTTP Request and Response"},{"location":"operation/#site-entry-script","text":"When the Apache web server receives an HTTP request from a client browser, it executes the APP_DIR/public/index.php file, also called the entry script . The entry script is the only PHP file accessible to the outside world. Apache web server directs all HTTP requests to this script (remember the .htaccess file?). Having this single entry script makes the website more secure (comparing with the situation when you allow everyone to access all PHP files of your application). Although the index.php file is very important, it is surprisingly small (see below): <?php use Laminas\\Mvc\\Application; use Laminas\\Stdlib\\ArrayUtils; /** * This makes our life easier when dealing with paths. Everything is relative * to the application root now. */ chdir(dirname(__DIR__)); // Decline static file requests back to the PHP built-in webserver if (php_sapi_name() === 'cli-server') { $path = realpath(__DIR__ . parse_url($_SERVER['REQUEST_URI'], PHP_URL_PATH)); if (__FILE__ !== $path && is_file($path)) { return false; } unset($path); } // Composer autoloading include __DIR__ . '/../vendor/autoload.php'; if (! class_exists(Application::class)) { throw new RuntimeException( \"Unable to load application.\\n\" . \"- Type `composer install` if you are developing locally.\\n\" . \"- Type `vagrant ssh -c 'composer install'` if you are using Vagrant.\\n\" . \"- Type `docker-compose run zf composer install` if you are using Docker.\\n\" ); } // Retrieve configuration $appConfig = require __DIR__ . '/../config/application.config.php'; if (file_exists(__DIR__ . '/../config/development.config.php')) { $appConfig = ArrayUtils::merge($appConfig, require __DIR__ . '/../config/development.config.php'); } // Run the application! Application::init($appConfig)->run(); Mainly, there are three things done in it. First, in line 10, current working directory is changed to APP_DIR . This makes it simple to define relative file paths in your application. Next, in line 22, PHP class autoloading is initialized. This allows to easily load any class either located in Laminas Framework library or in your application without the need for require_once statement. And finally, in line 40, an instance of @ Laminas\\Mvc\\Application class is created. The application is initialized with the settings read from application.config.php configuration file, and, the application is run.","title":"Site Entry Script"},{"location":"operation/#events-applications-life-cycle","text":"As you've learned from the previous section, on every HTTP request, the @ Laminas\\Mvc\\Application object is created. Typically, an application \"lives\" for a second or less (this time is enough to generate the HTTP response). The application's \"life\" consists of several stages. Laminas Framework uses the concept of event . One class can trigger an event, and other classes may listen to events. Technically, triggering an event means just calling another class' \"callback\" method. The event management is implemented inside of the @ Laminas\\EventManager component. Each application life stage is initiated by the application by triggering an event (this event is represented by the @ MvcEvent class living in @ Laminas\\Mvc namespace). Other classes (either belonging to Laminas Framework or specific to your application) may listen to events and react accordingly. Below, the five main events (life stages) are presented: Bootstrap . When this event is triggered by the application, a module has a chance to register itself as a listener of further application events in its onBootstrap() callback method. Route . When this event is triggered, the request's URL is analyzed using a router class (typically, with @ Laminas\\Router\\Http\\TreeRouteStack class). If an exact match between the URL and a route is found, the request is passed to the site-specific controller class assigned to the route. Dispatch . The controller class \"dispatches\" the request using the corresponding action method and produces the data that can be displayed on the web page. Render . On this event, the data produced by the controller's action method are passed for rendering to @ Laminas\\View\\Renderer\\PhpRenderer class. The renderer class uses a view template file for producing an HTML page. Finish . On this event, the HTTP response is sent back to client. The event flow is illustrated in figure 3.3: Note Although needed relatively rarely, some practical examples of how to listen and react to an event can be found in Creating a New Module chapter.","title":"Events &amp; Application's Life Cycle"},{"location":"operation/#application-configuration","text":"Most of Laminas Framework components which are used in your website, require configuration (fine-tuning). For example, in the configuration file you define database connection credentials, specify which modules are present in your application, and, optionally, provide some custom parameters specific to your application. You can define the configuration parameters at two levels: either at the application level, or at the module level. At the application level you typically define parameters which control the whole app and are common to all modules of your application. At the module level, you define parameters which affect only this module. Note Some PHP frameworks prefer conventions over configuration concept, where most of your parameters are hard-coded and do not require configuration. This makes it faster to develop the application, but makes it less customizable. In Laminas Framework, the configuration over conventions concept is used, so you can customize any aspect of your application, but have to spend some time for learning how to do that.","title":"Application Configuration"},{"location":"operation/#application-level-config-files","text":"The APP_DIR/config subdirectory contains application-wide configuration files. Let's look at this subdirectory in more details (figure 3.4). The APP_DIR/config/application.config.php file is the main configuration file. It is used by the application on start up for determining which application modules should be loaded and which services to create by default. Below, the content of application.config.php file is presented. You can see that the configuration file is just a usual PHP nested associative array, and each component may have a specific key in that array. You can provide inline comments for the array keys to make it easier for others to understand what each key means. Note By convention, key names should be in lower case, and if the key name consists of several words, the words should be separated by the underscore symbol ('_'). return [ // Retrieve list of modules used in this application. 'modules' => require __DIR__ . '/modules.config.php', // These are various options for the listeners attached to the ModuleManager 'module_listener_options' => [ // This should be an array of paths in which modules reside. // If a string key is provided, the listener will consider that a module // namespace, the value of that key the specific path to that module's // Module class. 'module_paths' => [ './module', './vendor', ], // An array of paths from which to glob configuration files after // modules are loaded. These effectively override configuration // provided by modules themselves. Paths may use GLOB_BRACE notation. 'config_glob_paths' => [ realpath(__DIR__) . '/autoload/{{,*.}global,{,*.}local}.php', ], // Whether or not to enable a configuration cache. // If enabled, the merged configuration will be cached and used in // subsequent requests. 'config_cache_enabled' => true, // The key used to create the configuration cache file name. 'config_cache_key' => 'application.config.cache', // Whether or not to enable a module class map cache. // If enabled, creates a module class map cache which will be used // by in future requests, to reduce the autoloading process. 'module_map_cache_enabled' => true, // The key used to create the class map cache file name. 'module_map_cache_key' => 'application.module.cache', // The path in which to cache merged configuration. 'cache_dir' => 'data/cache/', // Whether or not to enable modules dependency checking. // Enabled by default, prevents usage of modules that depend on other modules // that weren't loaded. // 'check_dependencies' => true, ], // Used to create an own service manager. May contain one or more child arrays. //'service_listener_options' => [ // [ // 'service_manager' => $stringServiceManagerName, // 'config_key' => $stringConfigKey, // 'interface' => $stringOptionalInterface, // 'method' => $stringRequiredMethodName, // ], // ], // Initial configuration with which to seed the ServiceManager. // Should be compatible with Laminas\\ServiceManager\\Config. // 'service_manager' => [], ]; In line 3 we have the modules key defining which modules will be loaded on start up. You can see that the module names are stored inside of another config file modules.config.php , which lists all modules present in your website. In line 11, there is the module_paths key which tells Laminas about directories where to look for source files belonging to modules. Application modules that you develop are located under APP_DIR/module directory, and third-party modules may be located inside the APP_DIR/vendor directory. And in line 19 we have the config_glob_paths key, which tells Laminas where to look for extra config files. You see that files from APP_DIR/config/autoload which have global.php or local.php suffix, are automatically loaded. Summing up, you typically use the main application.config.php file for storing the information about which modules should be loaded into your app and where they are located and how they are loaded (for example, you can control caching options here). In this file you can also tune the service manager. It is not recommended to add more keys in this file. For that purpose it is better to use autoload/global.php file. And let's also look inside the modules.config.php file. Currently, you have the following modules installed in your website: return [ 'Laminas\\Session', 'Laminas\\Mvc\\Plugin\\Prg', 'Laminas\\Mvc\\Plugin\\Identity', 'Laminas\\Mvc\\Plugin\\FlashMessenger', 'Laminas\\Mvc\\Plugin\\FilePrg', 'Laminas\\Form', 'Laminas\\Router', 'Laminas\\Validator', 'Application', ]; The Application module is a module containing your app's files. All other modules listed are Laminas Framework components. Note In Laminas, a special Composer plugin called component installer was introduced. If you remember, in the chapter Laminas Skeleton Application , we answered several yes/no questions of the installer, determining which components to install. And the installer injected those components' module names here, in modules.config.php","title":"Application-Level Config Files"},{"location":"operation/#application-level-extra-config-files","text":"\"Extra\" config files, APP_DIR/config/autoload/global.php and APP_DIR/config/autoload/local.php files define application-wide environment-agnostic and environment-dependent parameters, respectively. These config files are automatically loaded and recursively merged with the module-provided config files, that's why their directory is named autoload . Having different config files in APP_DIR/config/autoload directory, you might have been confused about which parameters should be put into each one. Here are some hints: You use the autoload/global.php file for storing parameters which do not depend on the concrete machine environment. For example, here you can store parameters which override the default parameters of some module. Do not store sensitive information (like database credentials) here, for that purpose it's better to use autoload/local.php . You use the autoload/local.php file for storing parameters specific to the concrete environment. For example, here you can store your database credentials. Each developer usually has a local database when developing and testing the website. The developer thus will edit the local.php file and enter his own database credentials here. When you install your site to the production server, you will edit the local.php file and enter the credentials for the \"live\" database here. Important Because the autoload/local.php file contains environment-specific parameters, in version control system you store its \"distribution template\" local.php.dist . Each developer in your team then renames the local.php.dist file into local.php and enters his own parameters. This local.php file should not be stored under version control, because it may contain sensitive information like database credentials (username and password), and you might want that other people do not see these.","title":"Application-Level Extra Config Files"},{"location":"operation/#application-level-development-config-file","text":"The application-level development configuration file ( APP_DIR/config/development.config.php ) presents only when you enable the development mode . If you remember, we enabled the development mode earlier in the Laminas Skeleton Application chapter. Reminder You enable the development mode with the following command: php composer.phar development-enable The development.config.php file is merged with the main application.config.php file. This allows you to override some parameters. For example, you can: disable config caching. When you develop your website, you frequently modify your config files, so config caching may have undesired consequences, like inability to see the result of your changes immediately. load additional modules. For example, you can load LaminasDeveloperTools module only in development mode. If you disable the development mode, the development.config.php file will be removed. So, you should not store this file under the version control. Instead, store its distribution version, development.config.php.dist under version control.","title":"Application-Level Development Config File"},{"location":"operation/#application-level-extra-development-config-files","text":"The application-level extra development configuration file ( APP_DIR/config/autoload/development.local.php ) presents only when you enable the development mode . The development.local.php file is merged with other module-level config files. This allows you to override some module-specific parameters used in development environment only. If you disable the development mode, the development.local.php file will be removed. So, you should not store this file under the version control. Instead, store its distribution version, development.local.php.dist under version control.","title":"Application-Level Extra Development Config Files"},{"location":"operation/#module-level-config-files","text":"In figure 3.4, you could see that the Application module shipped with your application has the module.config.php file, in which you put your module-specific parameters. Let's look at module.config.php file of the Application module: <?php namespace Application; use Laminas\\Router\\Http\\Literal; use Laminas\\Router\\Http\\Segment; use Laminas\\ServiceManager\\Factory\\InvokableFactory; return [ 'router' => [ 'routes' => [ 'home' => [ 'type' => Literal::class, 'options' => [ 'route' => '/', 'defaults' => [ 'controller' => Controller\\IndexController::class, 'action' => 'index', ], ], ], 'application' => [ 'type' => Segment::class, 'options' => [ 'route' => '/application[/:action]', 'defaults' => [ 'controller' => Controller\\IndexController::class, 'action' => 'index', ], ], ], ], ], 'controllers' => [ 'factories' => [ Controller\\IndexController::class => InvokableFactory::class, ], ], 'view_manager' => [ 'display_not_found_reason' => true, 'display_exceptions' => true, 'doctype' => 'HTML5', 'not_found_template' => 'error/404', 'exception_template' => 'error/index', 'template_map' => [ 'layout/layout' => __DIR__ . '/../view/layout/layout.phtml', 'application/index/index' => __DIR__ . '/../view/application/index/index.phtml', 'error/404' => __DIR__ . '/../view/error/404.phtml', 'error/index' => __DIR__ . '/../view/error/index.phtml', ], 'template_path_stack' => [ __DIR__ . '/../view', ], ], ]; In this file, you register the module's controllers, put information about routing rules for mapping URLs to your controllers, register controller plugins, and also register view templates and view helpers (we will learn more about these terms in this chapter and in the next chapters).","title":"Module-Level Config Files"},{"location":"operation/#combining-the-configuration-files","text":"When an application is being created, module-provided configuration files and extra configuration files from APP_DIR/config/autoload directory are being merged into one big nested array, so every configuration parameter becomes available to any piece of the website. So, potentially, you are able to override some parameters specified by the modules. Note You might also have seen the \"combined\" config file when installing PHP, where there is the main php.ini file and several extra config files, which are included into the main one. Such a separation makes your application configuration fine-grained and flexible, because you don't have to put all your params to a single file and edit it each time you need to change something. The configuration files are loaded in the following order: The main application.config.php file is loaded first. It is used to initialize the service manager and load application modules. The data loaded from this config is stored alone and not merged with other config files. Configuration files for each application module are loaded and merged. Modules are loaded in the same order as they are listed in the application.config.php file. If two modules store (either intentionally, or by mistake) parameters in the similar-named keys, these parameters may be overwritten. Extra config files from the APP_DIR/config/autoload folder are loaded and merged into a single array. Then this array is merged with the module config array produced on the previous stage, when loading the module configuration. Application-wide configuration has higher priority than the module configuration, so you can override module keys here, if you wish.","title":"Combining the Configuration Files"},{"location":"operation/#module-entry-point","text":"In Laminas, your web application consists of modules. By default, you have the single Application module, but can create more if needed. Typically, your own modules are stored in APP_DIR/module directory, while third-party modules live in APP_DIR/vendor directory. On start up, when the @ Laminas\\Mvc\\Application object is created, it uses the @ Laminas\\ModuleManager component to find and load all modules registered in application config. Each module of the web application has the Module.php file which is some kind of entry point for the module. This file provides the Module class. Below, the contents of skeleton application's Module class is presented: <?php namespace Application; class Module { public function getConfig() { return include __DIR__ . '/../config/module.config.php'; } } The class Module belongs to the module's namespace (for the main module it belongs to the Application namespace). The getConfig() method is typically used to provide module's configuration to Laminas Framework ( module.config.php file). Note You can also register some event listeners here, we'll see how to do this later in Creating a New Module chapter.","title":"Module Entry Point"},{"location":"operation/#service-manager","text":"You can imagine the web application as a set of services . For example, you can have an authentication service responsible for logging in the site users, entity manager service responsible for accessing the database, event manager service responsible for triggering events and delivering them to event listeners, etc. In Laminas Framework, the @ ServiceManager class is a centralized container for all application services. The service manager is implemented in @ Laminas\\ServiceManager component, as the @ ServiceManager class. Class inheritance diagram is shown in figure 3.5 below: The service manager is created on application start up (inside of init() static method of @ Laminas\\Mvc\\Application class). The standard services available through service manager are presented in table 3.1. This table is incomplete, because the actual number of services registered in service manager may be much bigger. Service Name Description Application Allows to retrieve the singleton of @ Laminas\\Mvc\\Application class. ApplicationConfig Configuration array extracted from application.config.php file. Merged configuration array extracted from module.config.php files merged with autoload/global.php and autoload/local.php . EventManager Allows to retrieve a new instance of @ Laminas\\EventManager\\EventManager class. The event manager allows to send (trigger) events and attach event listeners. SharedEventManager Allows to retrieve the singleton instance of @ Laminas\\EventManager\\SharedEventManager class. The shared event manager allows to listen to events defined by other classes and components. ModuleManager Allows to retrieve the singleton of @ Laminas\\ModuleManager\\ModuleManager class. The module manager is responsible for loading application modules. Request The singleton of @ Laminas\\Http\\Request class. Represents HTTP request received from client. Response The singleton of @ Laminas\\Http\\Response class. Represents HTTP response that will be sent to client. Router The singleton of @ Laminas\\Router\\Http\\TreeRouteStack . Performs URL routing. ServiceManager Service manager itself. ViewManager The singleton of @ Laminas\\Mvc\\View\\Http\\ViewManager class. Responsible for preparing the view layer for page rendering. Table 3.1. Standard services A service is typically an arbitrary PHP class, but not always. For example, when Laminas loads the configuration files and merges the data into nested arrays, it saves the arrays in the service manager as a couple of services (!): ApplicationConfig and Config . The first one is the array loaded from application-level configuration file application.config.php , and the later one is the merged array from module-level config files and auto-loaded application-level config files. Thus, in the service manager you can store anything you want: a PHP class, a simple variable or an array. From table 3.1, you can see that in Laminas almost everything can be considered as a service. The service manager is itself registered as a service. Moreover, the @ Application class is also registered as a service. Note An important thing you should note about the services is that they are typically stored in a single instance only (this is also called the singleton pattern). Obviously, you don't need the second instance of the @ Application class (in that case you would have a nightmare). But, there is an important exception from the rule above. It may be confusing at first, but the @ EventManager is not a singleton. Each time you retrieve the event manager service from service manager, you receive a new object. This is done for performance reasons and to avoid possible event conflicts between different components. We will discuss this further in the About Event Manager section later in this chapter. The service manager defines several methods needed for locating and retrieving a service from the service manager (see the table 3.2 below). Method Name Description has($name) Checks if such a service is registered. get($name) Retrieves a registered service's instance. build($name, $options) Always returns a new instance of the requested service. Table 3.2. ServiceManager methods You can test if a service is registered by passing its name to the service manager's has() method. It returns a boolean true if the service is registered, or false if the service with such a name is not registered. You can retrieve a service by its name later with the help of the service manager's get() method. This method takes a single parameter representing the service name. Look at the following example: <?php // Retrieve the application config array. $appConfig = $serviceManager->get('ApplicationConfig'); // Use it (for example, retrieve the module list). $modules = $appConfig['modules']; And the build() method always creates a new instance of the service when you call it (comparing to get() , which typically creates the instance of the service only once and returns it on later requests). Note You will typically retrieve services from service manager not in any place of your code, but inside of a factory . A factory is a code responsible for creation of an object. When creating the object, you can retrieve services it depends on from the service manager and pass those services (dependencies) to the object's constructor. This is also called dependency injection .","title":"Service Manager"},{"location":"operation/#registering-a-service","text":"When writing your website, you will often need to register your own service in the service manager. One of the ways to register a service is using the setService() method of the service manager. For example, let's create and register the currency converter service class, which will be used, for example, on a shopping cart page to convert EUR currency to USD: <?php // Define a namespace where our custom service lives. namespace Application\\Service; // Define a currency converter service class. class CurrencyConverter { // Converts euros to US dollars. public function convertEURtoUSD($amount) { return $amount*1.25; } //... } Above, in lines 6-15 we define an example CurrencyConverter class (for simplicity, we implement only a single method convertEURtoUSD() which is able to convert euros to US dollars). // Create an instance of the class. $service = new CurrencyConverter(); // Save the instance to service manager. $serviceManager->setService(CurrencyConverter::class, $service); In the example above, we instantiate the class with the new operator, and register it with the service manager using the setService() method (we assume that the $serviceManager variable is of type @ Laminas\\ServiceManager\\ServiceManager class, and that it was declared somewhere else). The setService() method takes two parameters: the service name string, and the service instance. The service name should be unique within all other possible services. Once the service is stored in service manager, you can retrieve it by name at any place of your application with the help of the service manager's get() method. Look at the following example: <?php // Retrieve the currency converter service. $service = $serviceManager->get(CurrencyConverter::class); // Use it (convert money amount). $convertedAmount = $service->convertEURtoUSD(50);","title":"Registering a Service"},{"location":"operation/#service-names","text":"Different services can use different naming styles. For example, the same currency converter service may be registered under the different names: CurrencyConverter , currency_converter and so on. To introduce some uniform naming convention, it is recommended to register a service by its fully qualified class name, as follows: $serviceManager->setService(CurrencyConverter::class); In the example above, we used the keyword class . It is available since PHP 5.5 and is used for class name resolution. CurrencyConverter::class is expanded to the fully qualified name of the class, like \\Application\\Service\\CurrencyConverter .","title":"Service Names"},{"location":"operation/#overriding-an-existing-service","text":"If you are trying to register the service name which is already present, the setService() method will throw an exception. But sometimes you want to override the service with the same name (to replace it by the new one). For this purpose, you can use the setAllowOverride() method of the service manager: <?php // Allow to replace services $serviceManager->setAllowOverride(true); // Save the instance to service manager. There will be no exception // even if there is another service with such a name. $serviceManager->setService(CurrencyConverter::class, $service); Above, the setAllowOverride() method takes the single boolean parameter defining whether to allow you replace the service CurrencyConverter if such a name is already present, or not.","title":"Overriding an Existing Service"},{"location":"operation/#registering-invokable-classes","text":"What is bad with the setService() method is that you have to create the service instance before you really need it. If you never use the service, the service instantiation will only waste the time and memory. To resolve this issue, the service manager provides you with the setInvokableClass() method. <?php // Register an invokable class $serviceManager->setInvokableClass(CurrencyConverter::class); In the example above, we pass to the service manager the fully qualified class name of the service instead of passing its instance. With this technique, the service will be instantiated by the service manager only when someone calls the get(CurrencyConverter::class) method. This is also called lazy loading. Note Services often depend on each other. For example, the currency converter service may use entity manager service to read money exchange rates from database. The disadvantage of setInvokableClass() method is that it doesn't allow to pass parameters (dependencies) to the service on object instantiation. To resolve this issue, you can use factories , as described below.","title":"Registering Invokable Classes"},{"location":"operation/#registering-a-factory","text":"A factory is a class that can do only one thing - to create other objects. You register a factory for a service with the setFactory() method of the service manager: The simplest factory is @ InvokableFactory - it is analogous to the setInvokableClass() method from the previous section. <?php use Laminas\\ServiceManager\\Factory\\InvokableFactory; // This is equivalent to the setInvokableClass() method from previous section. $serviceManager->setFactory(CurrencyConverter::class, InvokableFactory::class); After you have registered the factory you can retrieve the service from service manager as usual with the get() method. The service will be instantiated only when you retrieve it from service manager (lazy loading). Sometimes, service instantiation is more complex than just creating the service instance with new operator (like @ InvokableFactory does). You may need to pass some parameters to the service's constructor or invoke some service methods just after construction. This complex instantiation logic can be encapsulated inside of your own custom factory class. The factory class typically implements the @ FactoryInterface [Laminas\\ServiceManager\\Factory\\FactoryInterface]: <?php namespace Laminas\\ServiceManager\\Factory; use Interop\\Container\\ContainerInterface; interface FactoryInterface { public function __invoke(ContainerInterface $container, $requestedName, array $options = null); } As we see from the definition of the @ FactoryInterface [Laminas\\ServiceManager\\Factory\\FactoryInterface], the factory class must provide the __invoke magic method returning the instance of a single service. The service manager is passed to the __invoke method as the $container parameter; it can be used during the construction of the service for accessing other services (to inject dependencies ). The second argument ( $requestedName ) is the service name. The third argument ( $options ) can be used to pass some parameters to the service, and is used only when you request the service with the build() method of the service manager. As an example, let's write a factory for our currency converter service (see the code below). We don't use complex construction logics for our CurrencyConverter service, but for more complex services, you may need to use one. <?php namespace Application\\Service\\Factory; use Laminas\\ServiceManager\\Factory\\FactoryInterface; use Application\\Service\\CurrencyConverter; // Factory class class CurrencyConverterFactory implements FactoryInterface { public function __invoke(ContainerInterface $container, $requestedName, array $options = null) { // Create an instance of the class. $service = new CurrencyConverter(); return $service; } } Note Technically, in Laminas you can use the same factory class for instantiating several services that have similar instantiation code (for that purpose, you can use the $requestedName argument passed to the __invoke() method of the factory). However, mostly you will create a different factory per each service.","title":"Registering a Factory"},{"location":"operation/#registering-an-abstract-factory","text":"Even more complex case of a factory is when you need to determine at run time which service names should be registered. For such a situation, you can use an abstract factory . An abstract factory class should implement the @ AbstractFactoryInterface [Laminas\\ServiceManager\\Factory\\AbstractFactoryInterface] interface: <?php namespace Laminas\\ServiceManager\\Factory; use Interop\\Container\\ContainerInterface; interface AbstractFactoryInterface extends FactoryInterface { public function canCreate(ContainerInterface $container, $requestedName); } An abstract factory has two methods: canCreate() and __invoke() . The first one is needed to test if the factory can create the service with the certain name, and the latter one allows to actually create the service. The methods take two parameters: service manager ( $container ) and service name ( $requestedName ). Comparing to usual factory class, the difference is that the usual factory class typically creates only a single type of service, but an abstract factory can dynamically create as many types of services as it wants. You register an abstract factory with the setAbstractFactory() method of the service manager. Note Abstract factories are a powerful feature, but you should use them only when really necessary, because they negatively impact the performance. It is better to use the usual (non-abstract) factories.","title":"Registering an Abstract Factory"},{"location":"operation/#registering-service-aliases","text":"Sometimes, you may want to define an alias for a service. The alias is like a symbolic link: it references the already registered service. To create an alias, you use the service manager's setAlias() method: <?php // Register an alias for the CurrencyConverter service $serviceManager->setAlias('CurConv', CurrencyConverter::class); Once registered, you can retrieve the service by both its name and alias using the service manager's get() method.","title":"Registering Service Aliases"},{"location":"operation/#shared-and-non-shared-services","text":"By default, services are stored in service manager in single instance only. This is also called the singleton design pattern. For example, when you try to retrieve the CurrencyConverter service twice, you will receive the same object. This is also called a shared service. But, in some (rare) situations, you will need to create a new instance of a service each time someone requests it from service manager. An example is the @ EventManager - you get a new instance of it each time you request it. To mark a service as a non-shared, you can use service manager's setShared() method: $serviceManager->setShared('EventManager', false);","title":"Shared and Non-Shared Services"},{"location":"operation/#service-manager-configuration","text":"In your website, you typically use service manager configuration to register your services (instead of calling service manager's methods as described above). To automatically register a service within the service manager, typically the service_manager key of a configuration file is used. You can put this key either inside of an application-level configuration file or in a module-level configuration file. Important If you are putting this key in a module-level configuration file, be careful about the danger of name overwriting during the configs merge. Do not register the same service name in different modules. This service_manager key should look like below: <?php return [ //... // Register the services under this key 'service_manager' => [ 'services' => [ // Register service class instances here //... ], 'invokables' => [ // Register invokable classes here //... ], 'factories' => [ // Register factories here //... ], 'abstract_factories' => [ // Register abstract factories here //... ], 'aliases' => [ // Register service aliases here //... ], 'shared' => [ // Specify here which services must be non-shared ] ], //... ]; In the example above, you can see that the service_manager key may contain several subkeys for registering services in different ways: the services subkey (line 7) allows to register class instances; the invokables subkey (line 11) allows to register full class name of a service; the service will be instantiated using lazy loading; the factories subkey (line 15) allows for registering a factory, which is able to create instances of a single service; the abstract_factories (line 19) can be used for registering abstract factories, which are able to register several services by name; the aliases subkey (line 23) provides an ability to register an alias for a service. the shared subkey (line 27) allows to specify which services must be non-shared. As an example, let's register our CurrencyConverter service and create an alias for it: <?php use Laminas\\ServiceManager\\Factory\\InvokableFactory; use Application\\Service\\CurrencyConverter; return [ //... // Register the services under this key 'service_manager' => [ 'factories' => [ // Register CurrencyConverter service. CurrencyConverter::class => InvokableFactory::class ], 'aliases' => [ // Register an alias for the CurrencyConverter service. 'CurConv' => CurrencyConverter::class ], ], //... ];","title":"Service Manager Configuration"},{"location":"operation/#plugin-managers","text":"Now that you understand what service manager is, it shouldn't be very difficult for you to learn the concept of plugin managers . A plugin manager is almost the same as the service manager, but it can instantiate services of the single type only. Which plugin type a plugin manager may be hard-coded instantiated inside the plugin manager class. Why would you need such thing? Actually, in Laminas, plugin managers are widely used, because they allow to instantiate a plugin only when it is needed (this reduces CPU and memory usage). There is a separate plugin manager for: controllers (the @ Laminas\\Mvc\\Controller\\ControllerManager class) controller plugins (the @ Laminas\\Mvc\\Controller\\PluginManager class) view helpers (the @ Laminas\\View\\HelperPluginManager class) form elements (the @ Laminas\\Form\\FormElementManager\\FormElementManagerV3Polyfill class) filters (the @ Laminas\\Filter\\FilterPluginManager class) validators (the @ Laminas\\Validator\\ValidatorPluginManager class) and probably other stuff The fact that each plugin manager inherits from the @ Laminas\\ServiceManager\\ServiceManager base class allows all plugin managers to have similar configuration. For example, controllers are registered under the controllers key in module.config.php file, and this key may have the same subkeys: services , invokables , factories , abstract_factories , and aliases . The same structure has the view_helpers key that is used for registering view helpers, the controller_plugins key that is used for registering controller plugins, and so on.","title":"Plugin Managers"},{"location":"operation/#about-event-manager","text":"Note In this section, we will give some advanced information about event manager. You can relatively safely skip this section, however refer to it if you plan to implement some advanced event listeners in your website. Previously in this chapter we have mentioned that the application life cycle consists of events . One class can trigger an event, and other classes may listen to events. Technically, triggering an event means just calling another class' \"callback\" method. The event management is implemented inside of the @ Laminas\\EventManager component. Laminas (and particularly its @ Laminas\\Mvc component) hardly depends on events to operate, and because of that its source code is a combination of event listeners which is rather difficult to understand. Fortunately, in most cases you do not need to understand how Laminas triggers and handles events internally, you just need to understand what event is, what events present in application life cycle and what is the difference between usual event manager and shared event manager .","title":"About Event Manager"},{"location":"operation/#event-mvcevent","text":"An event is technically an instance of the @ Laminas\\EventManager\\Event class. An event can basically have at least the following parts: name - uniquely identifies the event; target - this is typically a pointer to the object which triggered the event; and params - event-specific arguments passed to the event listeners. It is possible to create custom types of events by extending the @ Event [Laminas\\EventManager\\Event] class. For example, the @ Laminas\\Mvc component defines the custom event type named @ Laminas\\Mvc\\MvcEvent , which extends the Event class and adds several properties and methods needed for the @ Laminas\\Mvc component to work.","title":"Event &amp; MvcEvent"},{"location":"operation/#eventmanager-sharedeventmanager","text":"It is important to understand the difference between the usual event manager and the shared event manager. The usual event manager is not stored as a singleton in the service manager. Every time you request the @ EventManager service from the service manager, you receive a new instance of it. This is done for privacy and performance reasons: It is assumed by default that the class triggering events will request and save somewhere its own private event manager, because it doesn't want other classes to automatically listen to those events. Events triggered by the class are assumed to belong to that class privately. If anyone would be able to listen to any event triggered by any class, there would be performance hell - too many event listeners would be invoked, thus increasing page load time. It is better to avoid this by keeping events private. But, in case if someone intentionally needs to listen to other's events, there is a special shared event manager. The @ SharedEventManager service is stored in the service manager as a singleton, so you can be sure everyone will have the same instance of it. With the @ SharedEventManager , you can attach a listener to private events triggered by certain class (or several classes). You specify the unique class identifier(s) to which you would like to listen. That simple! Note Some practical examples of how to listen and react to an event can be found in Creating a New Module chapter and User Management, Authentication & Access Filtering chapter.","title":"EventManager &amp; SharedEventManager"},{"location":"operation/#summary","text":"In this chapter, we've learned some theory about laminas-based website operation basics. Laminas uses PHP namespaces and class autoloading features, simplifying the development of applications which use many third-party components. The namespaces allow to solve the name collisions between code components, and provide you with the ability to make the long names shorter. The class autoloading makes it possible to use any PHP class in any library installed with Composer without the use of require_once statement. Composer also provides a PSR-4 autoloader for the classes located in the modules of your web application. Most of Laminas Framework components require configuration. You can define the configuration parameters either at the application level, or at the module level. The main goal of any web application is handling the HTTP request and producing an HTTP response typically containing the HTML code of the requested web page. When Apache web server receives an HTTP request from a client browser, it executes the index.php file, which is also called the site's entry script. On every HTTP request, the @ Laminas\\Mvc\\Application object is created, whose \"life cycle\" consists of several stages (or events). The web application's business logic can be also considered as a set of services. In Laminas Framework, the service manager is a centralized container for all the application services. A service is typically a PHP class, but in general it can be a variable or an array, if needed. IndexController class is the default controller for the skeleton website. We will talk about controllers later in chapter Model-View-Controller . \u21a9","title":"Summary"},{"location":"roles/","text":"Role-Based Access Control If you remember, in the previous chapter we created the User Demo website which allowed us to manage users and permit access to some web pages to authenticated users only. In this chapter, we will extend the User Demo and show how to implement the Role-Based Access Control (RBAC). The RBAC allows to permit or deny access for certain users to certain website pages based on roles and permissions . Since you have already known a lot about Laminas from reading previous chapters, in this chapter we will omit discussing some obvious things and concentrate on conceptual moments only. It is recommended that you refer to the Role Demo sample bundled with this book, which is a complete website that you can run and see everything in action. All code discussed in this chapter is part of this sample application. Laminas components covered in this chapter: Component Description @ Laminas\\Permissions\\Rbac Provides RBAC container implementation. @ Laminas\\Cache Provides functionality for storing data in cache. Get Role Demo Sample from GitHub For demonstration, in this chapter, we will create a real-life Role Demo website that shows how to: Implement roles and permissions in your website Organize roles in database into an hierarchy Manage roles and permissions in user interface Use @ Laminas\\Permissions\\Rbac component to implement role-based access control Use dynamic assertions to implement complex access control rules The Role Demo sample will be based on the User Demo sample that we created in the previous chapter. To download the Role Demo application, visit this page and click the Clone or Download button to download the code as a ZIP archive. When download is complete, unpack the archive to some directory. Then navigate to the roledemo directory containing the source code of the Role Demo web application: /using-laminas-book-samples /roledemo ... The Role Demo is a website which can be installed on your machine. Note Detailed instructions on how to install the Role Demo sample can be found in README.md file located in the sample directory. Introduction to RBAC Laminas provides a special component named @ Laminas\\Permissions\\Rbac which implements a container for roles and permissions. To install the @ Laminas\\Permissions\\Rbac component in your web application, type the following command: php composer.phar require laminas/laminas-permissions-rbac Roles and Permissions A role is a group of users. For example, in a Blog application, there may be the following roles: Viewer, Author, Editor, and Administrator. Role Name Description Viewer Can read any post and can do nothing else. Author Can view posts plus create a post, edit it and finally publish it. Editor Can view posts plus edit and publish any post. Administrator Can do anything a Viewer and Editor can do plus delete posts. Table 17.1. Example roles in a Blog website A user may be assigned a role or several roles at once. For example, user John may be a Viewer and Editor at the same time. A role may inherit permissions from other roles. In other words, roles may be organized into an hierarchy when parent roles inherit permissions of child roles. For example, in our Blog application, Administrator role would inherit permissions from Editor role (see figure 17.1 below). This is because Administrator can do the same things as Editor plus delete posts. Editor and Author roles would inherit permissions from the Viewer role. A role may be assigned with several permissions . A permission is a single typical action in the system. Here are several examples of permissions in a Blog website: Permission Name Description post.view View any post. post.edit Edit any post. post.own.edit Edit only owned posts. post.publish Publish any post. post.own.publish Publish only owned post. post.delete Delete any post. Table 17.2. Example permissions in a Blog website For example, the Viewer role would be assigned the post.view permission. The Editor role would be assigned the post.edit and post.publish permissions. The Author role would be assigned with the post.own.edit and post.own.publish permissions. And the role Administrator would be assigned with the post.delete permission. RBAC Container In Laminas, you can use the @ Rbac class living in @ Laminas\\Permissions\\Rbac namespace as a simple container for your roles and permissions. With this container, you store your roles in memory organized in an hierarchy and assigned with permissions. For example, let's create an @ Rbac container for the Blog application and fill it with roles and permissions: use Laminas\\Permissions\\Rbac\\Rbac; // Create Rbac container. $rbac = new Rbac(); // The following is to tell Rbac to create some parent roles if not exist yet $rbac->setCreateMissingRoles(true); // Create role hierarchy $rbac->addRole('Viewer', ['Editor', 'Author']); $rbac->addRole('Editor', ['Administrator']); $rbac->addRole('Author'); $rbac->addRole('Administrator'); // Assign permissions to the Viewer role. $rbac->getRole('Viewer')->addPermission('post.view'); // Assign permissions to the Author role. $rbac->getRole('Author')->addPermission('post.own.edit'); $rbac->getRole('Author')->addPermission('post.own.publish'); // Assign permissions to the Editor role. $rbac->getRole('Editor')->addPermission('post.edit'); $rbac->getRole('Editor')->addPermission('post.publish'); // Assign permissions to the Administrator role. $rbac->getRole('Administrator')->addPermission('post.delete'); As you can see, a role is added to the @ Rbac container with the help of the addRole() method. The addRole() method takes two arguments: the name of the role to be created, and the name(s) of its parent role(s). If the parent roles do not exist yet, they are created automatically (for that purpose we use the setCreateMissingRoles() method). Permissions are assigned to the created role with the help of role's addPermission() method. Checking Permissions When you have an @ Rbac container set up, you can query if the role has certain permission with the isGranted() method, as follows: // The following will return false, because the Viewer can't delete posts $rbac->isGranted('Viewer', 'post.delete'); // The following will return true, because admins can delete posts $rbac->isGranted('Administrator', 'post.delete'); The isGranted() method checks the role and its children and looks for the given permission. If it finds the permission, it returns true ; otherwise false . Default Roles in the Role Demo Sample Since our Role Demo application is designed to be the base for your own more complex websites, for our Role Demo sample, we will have only the following simple default roles: Administrator and Guest. You will be able to add more roles via user interface of the website. We will have the following default permissions: Permission Name Description user.manage Manage users (add/edit/delete). role.manage Manage roles (add/edit/delete). permission.manage Manage permissions (add/edit/delete). profile.any.view View any user profile in the system. profile.own.view View own profile. Table 17.3. Default permissions in the Role Demo website The first three permissions will allow Administrator to manage users, roles and permissions via user interface. The last two permissions ( profile.any.view and profile.own.view ) are mostly for demonstration of how Rbac works and can in theory be deleted from your own website if you do not have the user profile page. The profile.any.view allows Administrator to access http://localhost/application/settings/<user_id> page, which is the user profile of a user with the given ID. The profile.own.view allows Guest to access their own profile page http://localhost/application/settings . You will be able to create additional permissions via the user interface of the website. Introduction to Dynamic Assertions You might notice that for the Blog example we had two \"special\" permissions named post.own.edit and post.own.publish . Those permissions are special, because they allow the author to edit only the posts he is the creator of. To \"check\" such permission against the real user, we need to additionally determine if the post really belongs to that user. This is called a dynamic assertion . In the Role Demo website, we also will have a special permission called profile.own.view . What makes it special is that it allows the user to view a profile the user is the owner of. To implement dynamic assertions in the Role Demo sample, we will use a special service called the assertion manager . This assertion manager will be implemented as the RbacAssertionManager class, which lives in the Application\\Service namespace and looks like the following: <?php namespace Application\\Service; use Laminas\\Permissions\\Rbac\\Rbac; use User\\Entity\\User; /** * This service is used for invoking user-defined RBAC dynamic assertions. */ class RbacAssertionManager { /** * Entity manager. * @var Doctrine\\ORM\\EntityManager */ private $entityManager; /** * Auth service. * @var Laminas\\Authentication\\AuthenticationService */ private $authService; /** * Constructs the service. */ public function __construct($entityManager, $authService) { $this->entityManager = $entityManager; $this->authService = $authService; } /** * This method is used for dynamic assertions. */ public function assert(Rbac $rbac, $permission, $params) { $currentUser = $this->entityManager->getRepository(User::class) ->findOneByEmail($this->authService->getIdentity()); if ($permission=='profile.own.view' && $params['user']->getId()==$currentUser->getId()) return true; return false; } } As you can see from the code above, the class has the assert() method which accepts three arguments: the $rbac is the container of our roles and permissions; the $permission is the name of the permission to check; the $params is an array of parameters (it can be used for example to pass the user owning the blog post). Inside the assert() method, we can get the currently logged in user and compare it with the user passed, this way we can return true if the user is trying to open its own profile; otherwise false . Note In theory, you can have many assertion managers in your website (for example, if your Blog module has some dynamic assertions, you can create and register an assertion manager for that module). Setting Up the Database In our Role Demo sample, we will store the role hierarchy in the \"roledemo\" database. We will create the following tables (see figure 17.2): role table will contain data related to a role (its name and description) role_hierarchy table will contain parent-child relationships between roles permission table will contain permissions role_permission table will allow to assign permissions to roles user_role table will allow to assign roles to users user table will contain data of users (we created this table earlier in User Demo sample) You can find a database migration, which creates these tables, in the Role Demo sample application. To run migrations, type the following command: ./vendor/bin/doctrine-module migrations:migrate Note If you are new to migrations, refer to chapter Database Migrations . Implementing Entities The Role Demo sample uses Doctrine ORM for managing database. We have already learned how to use Doctrine in Database Management with Doctrine ORM . For storing information about roles and permissions in database, we will create the Role and Permission entities. The Role entity is mapped onto the role database table, while the Permission entity is mapped onto the permission table. Those are typical Doctrine entity classes. Create the Role.php file inside the Entity directory under the User module's source directory. Put the following code into that file: <?php namespace User\\Entity; use Doctrine\\ORM\\Mapping as ORM; use Doctrine\\Common\\Collections\\ArrayCollection; /** * This class represents a role. * @ORM\\Entity() * @ORM\\Table(name=\"role\") */ class Role { /** * @ORM\\Id * @ORM\\Column(name=\"id\") * @ORM\\GeneratedValue */ protected $id; /** * @ORM\\Column(name=\"name\") */ protected $name; /** * @ORM\\Column(name=\"description\") */ protected $description; /** * @ORM\\Column(name=\"date_created\") */ protected $dateCreated; /** * @ORM\\ManyToMany(targetEntity=\"User\\Entity\\Role\") * @ORM\\JoinTable(name=\"role_hierarchy\", * joinColumns={@ORM\\JoinColumn(name=\"child_role_id\", referencedColumnName=\"id\")}, * inverseJoinColumns={@ORM\\JoinColumn(name=\"parent_role_id\", referencedColumnName=\"id\")} * ) */ private $parentRoles; /** * @ORM\\ManyToMany(targetEntity=\"User\\Entity\\Role\") * @ORM\\JoinTable(name=\"role_hierarchy\", * joinColumns={@ORM\\JoinColumn(name=\"parent_role_id\", referencedColumnName=\"id\")}, * inverseJoinColumns={@ORM\\JoinColumn(name=\"child_role_id\", referencedColumnName=\"id\")} * ) */ protected $childRoles; /** * @ORM\\ManyToMany(targetEntity=\"User\\Entity\\Permission\") * @ORM\\JoinTable(name=\"role_permission\", * joinColumns={@ORM\\JoinColumn(name=\"role_id\", referencedColumnName=\"id\")}, * inverseJoinColumns={@ORM\\JoinColumn(name=\"permission_id\", referencedColumnName=\"id\")} * ) */ private $permissions; /** * Constructor. */ public function __construct() { $this->parentRoles = new ArrayCollection(); $this->childRoles = new ArrayCollection(); $this->permissions = new ArrayCollection(); } /** * Returns role ID. * @return integer */ public function getId() { return $this->id; } /** * Sets role ID. * @param int $id */ public function setId($id) { $this->id = $id; } public function getName() { return $this->name; } public function setName($name) { $this->name = $name; } public function getDescription() { return $this->description; } public function setDescription($description) { $this->description = $description; } public function getDateCreated() { return $this->dateCreated; } public function setDateCreated($dateCreated) { $this->dateCreated = $dateCreated; } public function getParentRoles() { return $this->parentRoles; } public function getChildRoles() { return $this->childRoles; } public function getPermissions() { return $this->permissions; } public function addParent(Role $role) { if ($this->getId() == $role->getId()) { return false; } if (!$this->hasParent($role)) { $this->parentRoles[] = $role; return true; } return false; } public function clearParentRoles() { $this->parentRoles = new ArrayCollection(); } public function hasParent(Role $role) { if ($this->getParentRoles()->contains($role)) { return true; } return false; } } As you could determine from the code above, the Role entity is a typical Doctrine entity having annotated properties and getter and setter methods for retrieving/setting those properties. Next, create the Permission.php file inside the Entity directory under the User module's source directory. Put the following code into that file: <?php namespace User\\Entity; use Doctrine\\ORM\\Mapping as ORM; use Doctrine\\Common\\Collections\\ArrayCollection; /** * This class represents a permission. * @ORM\\Entity() * @ORM\\Table(name=\"permission\") */ class Permission { /** * @ORM\\Id * @ORM\\Column(name=\"id\") * @ORM\\GeneratedValue */ protected $id; /** * @ORM\\Column(name=\"name\") */ protected $name; /** * @ORM\\Column(name=\"description\") */ protected $description; /** * @ORM\\Column(name=\"date_created\") */ protected $dateCreated; /** * @ORM\\ManyToMany(targetEntity=\"User\\Entity\\Role\") * @ORM\\JoinTable(name=\"role_permission\", * joinColumns={@ORM\\JoinColumn(name=\"permission_id\", referencedColumnName=\"id\")}, * inverseJoinColumns={@ORM\\JoinColumn(name=\"role_id\", referencedColumnName=\"id\")} * ) */ private $roles; /** * Constructor. */ public function __construct() { $this->roles = new ArrayCollection(); } public function getId() { return $this->id; } public function setId($id) { $this->id = $id; } public function getName() { return $this->name; } public function setName($name) { $this->name = $name; } public function getDescription() { return $this->description; } public function setDescription($description) { $this->description = $description; } public function getDateCreated() { return $this->dateCreated; } public function setDateCreated($dateCreated) { $this->dateCreated = $dateCreated; } public function getRoles() { return $this->roles; } } Finally, we will slightly extend the User entity that already created in the User Demo website and add the property and methods related to roles: <?php namespace User\\Entity; use Doctrine\\ORM\\Mapping as ORM; use Doctrine\\Common\\Collections\\ArrayCollection; /** * This class represents a registered user. * @ORM\\Entity() * @ORM\\Table(name=\"user\") */ class User { // User status constants. const STATUS_ACTIVE = 1; // Active user. const STATUS_RETIRED = 2; // Retired user. /** * @ORM\\Id * @ORM\\Column(name=\"id\") * @ORM\\GeneratedValue */ protected $id; /** * @ORM\\Column(name=\"email\") */ protected $email; /** * @ORM\\Column(name=\"full_name\") */ protected $fullName; /** * @ORM\\Column(name=\"password\") */ protected $password; /** * @ORM\\Column(name=\"status\") */ protected $status; /** * @ORM\\Column(name=\"date_created\") */ protected $dateCreated; /** * @ORM\\Column(name=\"pwd_reset_token\") */ protected $passwordResetToken; /** * @ORM\\Column(name=\"pwd_reset_token_creation_date\") */ protected $passwordResetTokenCreationDate; /** * @ORM\\ManyToMany(targetEntity=\"User\\Entity\\Role\") * @ORM\\JoinTable(name=\"user_role\", * joinColumns={@ORM\\JoinColumn(name=\"user_id\", referencedColumnName=\"id\")}, * inverseJoinColumns={@ORM\\JoinColumn(name=\"role_id\", referencedColumnName=\"id\")} * ) */ private $roles; /** * Constructor. */ public function __construct() { $this->roles = new ArrayCollection(); } /** * Returns user ID. * @return integer */ public function getId() { return $this->id; } /** * Sets user ID. * @param int $id */ public function setId($id) { $this->id = $id; } /** * Returns email. * @return string */ public function getEmail() { return $this->email; } /** * Sets email. * @param string $email */ public function setEmail($email) { $this->email = $email; } /** * Returns full name. * @return string */ public function getFullName() { return $this->fullName; } /** * Sets full name. * @param string $fullName */ public function setFullName($fullName) { $this->fullName = $fullName; } /** * Returns status. * @return int */ public function getStatus() { return $this->status; } /** * Returns possible statuses as array. * @return array */ public static function getStatusList() { return [ self::STATUS_ACTIVE => 'Active', self::STATUS_RETIRED => 'Retired' ]; } /** * Returns user status as string. * @return string */ public function getStatusAsString() { $list = self::getStatusList(); if (isset($list[$this->status])) return $list[$this->status]; return 'Unknown'; } /** * Sets status. * @param int $status */ public function setStatus($status) { $this->status = $status; } /** * Returns password. * @return string */ public function getPassword() { return $this->password; } /** * Sets password. * @param string $password */ public function setPassword($password) { $this->password = $password; } /** * Returns the date of user creation. * @return string */ public function getDateCreated() { return $this->dateCreated; } /** * Sets the date when this user was created. * @param string $dateCreated */ public function setDateCreated($dateCreated) { $this->dateCreated = $dateCreated; } /** * Returns password reset token. * @return string */ public function getResetPasswordToken() { return $this->passwordResetToken; } /** * Sets password reset token. * @param string $token */ public function setPasswordResetToken($token) { $this->passwordResetToken = $token; } /** * Returns password reset token's creation date. * @return string */ public function getPasswordResetTokenCreationDate() { return $this->passwordResetTokenCreationDate; } /** * Sets password reset token's creation date. * @param string $date */ public function setPasswordResetTokenCreationDate($date) { $this->passwordResetTokenCreationDate = $date; } /** * Returns the array of roles assigned to this user. * @return array */ public function getRoles() { return $this->roles; } /** * Returns the string of assigned role names. */ public function getRolesAsString() { $roleList = ''; $count = count($this->roles); $i = 0; foreach ($this->roles as $role) { $roleList .= $role->getName(); if ($i<$count-1) $roleList .= ', '; $i++; } return $roleList; } /** * Assigns a role to user. */ public function addRole($role) { $this->roles->add($role); } } Implementing Role Management In the Role Demo sample, we will create a convenient user interface for managing roles. Note You can access the role management page by logging in as admin@example.com and opening menu Admin -> Manage Roles. The role management will be implemented inside the RoleController controller living in the User\\Controller namespace. The action methods of the RoleController are listed in table 17.4: Action Name Description addAction() Allows to add a new role. deleteAction() Deletes an existing role. editAction() Allows to edit an existing role. editPermissionsAction() Allows to assign permissions to a role. indexAction() Displays the list of existing roles. viewAction() Displays the details of a role. Table 17.4. Actions of the RoleController controller The RoleController works in pair with the RoleManager service which lives in User\\Service namespace. The RoleController and RoleManager contain nothing new and special, so we will skip their discussion here and will just provide some screenshots of the resulting user interface below. Note You can find the complete code of the RoleController and RoleManager classes in the Role Demo sample. Implementing Permission Management In the Role Demo sample, we will create a convenient user interface for managing permissions. It will be useful if you plan to add new permissions or remove existing ones. Note You can access the permission management page by logging in as admin@example.com and opening menu Admin -> Manage Permissions. The permission management will be implemented inside the PermissionController controller living in the User\\Controller namespace. The action methods of the PermissionController are listed in table 17.5: Action Name Description addAction() Allows to add a new permission. deleteAction() Deletes an existing permission. editAction() Allows to edit an existing permission. indexAction() Displays the list of existing permissions. viewAction() Displays the details of a permission. Table 17.5. Actions of the PermissionController controller The PermissionController works in pair with the PermissionManager service which lives in User\\Service namespace. The PermissionController and PermissionManager contain nothing new and special, so we will skip their discussion here and will just provide some screenshots of the resulting user interface below. Note You can find the complete code of the PermissionController and PermissionManager classes in the Role Demo sample. Assigning Roles to a User In the Role Demo website, you can assign roles to a user via the convenient user interface. Open the Admin -> Manage Users menu and click Edit on the user of your choice. On the page that appears, select the roles you'd like to assign to the user and click the Save button. This functionality contain nothing new and special, so we will skip its detailed discussion here and will just provide a screenshot of the user interface below. Implementing RbacManager The next thing we will discuss will be the functionality for creating the Rbac container, whose purpose is loading the role hierarchy from the database, and caching the data in the filesystem cache. Note The cache allows to store frequently used data in fast storage. For example, retrieving roles and permissions from database on each page load may be rather slow, while storing the precomputed role hierarchy in a file may be faster. Setting Up Caching First, let's set up caching. To do that, you need to install the Laminas\\Cache and Laminas\\Serializer components with the following commands: php composer.phar require laminas/laminas-cache php composer.phar require laminas/laminas-serializer Finally, edit the config/autoload/global.php and add the following lines: use Laminas\\Cache\\Storage\\Adapter\\Filesystem; return [ //... // Cache configuration. 'caches' => [ 'FilesystemCache' => [ 'adapter' => [ 'name' => Filesystem::class, 'options' => [ // Store cached data in this directory. 'cache_dir' => './data/cache', // Store cached data for 1 hour. 'ttl' => 60*60*1 ], ], 'plugins' => [ [ 'name' => 'serializer', 'options' => [ ], ], ], ], ], //... ]; This will allow you to use the Filesystem cache and store cached data in APP_DIR/data/cache directory. Note If you want to learn more about caching, please refer to the Laminas\\Cache Laminas component documentation. Writing the RbacManager Service The purpose of the RbacManager service will be to construct the Rbac container and load the roles and permissions from database. If the needed information is already saved to cache, it will load it from cache instead of loading from database. Another goal of the RbacManager service will be to use the assertion manager we wrote earlier and check for dynamic assertions. The RbacManager class will have two methods: the init() method will be used to load role hierarchy from database and save it in cache; the isGranted() method will be used to query the Rbac container if the given user has the given permission (and checking the assertion manager(s) for the dynamic assertions). The RbacManager class will read the configuration and look for the rbac_manager key. The key should contain the assertions subkey, in which you can register all assertion managers that you have. return [ //... // This key stores configuration for RBAC manager. 'rbac_manager' => [ 'assertions' => [Service\\RbacAssertionManager::class], ], ]; The code of the RbacManager class living in User\\Service namespace is presented below. <?php namespace User\\Service; use Laminas\\Permissions\\Rbac\\Rbac; use Laminas\\Permissions\\Rbac\\Role as RbacRole; use User\\Entity\\User; use User\\Entity\\Role; use User\\Entity\\Permission; /** * This service is responsible for initialzing RBAC (Role-Based Access Control). */ class RbacManager { /** * Doctrine entity manager. * @var Doctrine\\ORM\\EntityManager */ private $entityManager; /** * RBAC service. * @var Laminas\\Permissions\\Rbac\\Rbac */ private $rbac; /** * Auth service. * @var Laminas\\Authentication\\AuthenticationService */ private $authService; /** * Filesystem cache. * @var Laminas\\Cache\\Storage\\StorageInterface */ private $cache; /** * Assertion managers. * @var array */ private $assertionManagers = []; /** * Constructs the service. */ public function __construct($entityManager, $authService, $cache, $assertionManagers) { $this->entityManager = $entityManager; $this->authService = $authService; $this->cache = $cache; $this->assertionManagers = $assertionManagers; } /** * Initializes the RBAC container. */ public function init($forceCreate = false) { if ($this->rbac!=null && !$forceCreate) { // Already initialized; do nothing. return; } // If user wants us to reinit RBAC container, clear cache now. if ($forceCreate) { $this->cache->removeItem('rbac_container'); } // Try to load Rbac container from cache. $this->rbac = $this->cache->getItem('rbac_container', $result); if (!$result) { // Create Rbac container. $rbac = new Rbac(); $this->rbac = $rbac; // Construct role hierarchy by loading roles and permissions from database. $rbac->setCreateMissingRoles(true); $roles = $this->entityManager->getRepository(Role::class) ->findBy([], ['id'=>'ASC']); foreach ($roles as $role) { $roleName = $role->getName(); $parentRoleNames = []; foreach ($role->getParentRoles() as $parentRole) { $parentRoleNames[] = $parentRole->getName(); } $rbac->addRole($roleName, $parentRoleNames); foreach ($role->getPermissions() as $permission) { $rbac->getRole($roleName)->addPermission($permission->getName()); } } // Save Rbac container to cache. $this->cache->setItem('rbac_container', $rbac); } } /** * Checks whether the given user has permission. * @param User|null $user * @param string $permission * @param array|null $params */ public function isGranted($user, $permission, $params = null) { if ($this->rbac==null) { $this->init(); } if ($user==null) { $identity = $this->authService->getIdentity(); if ($identity==null) { return false; } $user = $this->entityManager->getRepository(User::class) ->findOneByEmail($identity); if ($user==null) { // Oops.. the identity presents in session, but there is no such user in database. // We throw an exception, because this is a possible security problem. throw new \\Exception('There is no user with such identity'); } } $roles = $user->getRoles(); foreach ($roles as $role) { if ($this->rbac->isGranted($role->getName(), $permission)) { if ($params==null) return true; foreach ($this->assertionManagers as $assertionManager) { if ($assertionManager->assert($this->rbac, $permission, $params)) return true; } } $parentRoles = $role->getParentRoles(); foreach ($parentRoles as $parentRole) { if ($this->rbac->isGranted($parentRole->getName(), $permission)) { return true; } } } return false; } } The factory for the RbacManager class looks like the following: <?php namespace User\\Service\\Factory; use Interop\\Container\\ContainerInterface; use User\\Service\\RbacManager; use Laminas\\Authentication\\AuthenticationService; /** * This is the factory class for RbacManager service. The purpose of the factory * is to instantiate the service and pass it dependencies (inject dependencies). */ class RbacManagerFactory { /** * This method creates the RbacManager service and returns its instance. */ public function __invoke(ContainerInterface $container, $requestedName, array $options = null) { $entityManager = $container->get('doctrine.entitymanager.orm_default'); $authService = $container->get(\\Laminas\\Authentication\\AuthenticationService::class); $cache = $container->get('FilesystemCache'); $assertionManagers = []; $config = $container->get('Config'); if (isset($config['rbac_manager']['assertions'])) { foreach ($config['rbac_manager']['assertions'] as $serviceName) { $assertionManagers[$serviceName] = $container->get($serviceName); } } return new RbacManager($entityManager, $authService, $cache, $assertionManagers); } } Adding the Not Authorized Page Next we will create the Not Authorized page (see figure 17.13) on which we will redirect the user when they are not allowed to access some web page. Add the following route to the module.config.php file of the User module: return [ 'router' => [ 'routes' => [ 'not-authorized' => [ 'type' => Literal::class, 'options' => [ 'route' => '/not-authorized', 'defaults' => [ 'controller' => Controller\\AuthController::class, 'action' => 'notAuthorized', ], ], ], ], ], ]; Then add the notAuthorizedAction() method to the AuthController in the User module: /** * Displays the \"Not Authorized\" page. */ public function notAuthorizedAction() { $this->getResponse()->setStatusCode(403); return new ViewModel(); } Finally, add the not-authorized.phtml view template file under the user/auth directory under the User module's view directory: <?php $this->headTitle(\"Not Authorized\"); ?> <h1>Not Authorized</h1> <div class=\"alert alert-warning\">Sorry, you have no permission to see this page.</div> Now you can see the Not Authorized page if you type the following URL into the address bar of the browser: \"http://localhost/not-authorized\". Modifying the AuthManager Service The next thing we will do is modifying the access filter inside the AuthManager service we wrote for the User Demo sample. Particularly, we want to modify the filterAccess() method. We want the filterAccess() method to use our RbacManager class. But first we will modify the format of the access_filter key in the configuration. We want the key to allow to permit access to: anyone if we specify the asterisk ( * ); any authenticated user if we specify the \"commercial at\" ( @ ); a concrete authenticated user with the given identity email address if we specify ( @identity ) any authenticated user with the given permission if we specify the plus sign followed by the permission name ( +permission ). For example, here how the access_filter key would look like for the User module: <?php return [ //... // The 'access_filter' key is used by the User module to restrict or permit // access to certain controller actions for unauthorized visitors. 'access_filter' => [ 'controllers' => [ Controller\\UserController::class => [ // Give access to \"resetPassword\", \"message\" and \"setPassword\" actions // to anyone. ['actions' => ['resetPassword', 'message', 'setPassword'], 'allow' => '*'], // Give access to \"index\", \"add\", \"edit\", \"view\", \"changePassword\" actions // to users having the \"user.manage\" permission. ['actions' => ['index', 'add', 'edit', 'view', 'changePassword'], 'allow' => '+user.manage'] ], Controller\\RoleController::class => [ // Allow access to authenticated users having the \"role.manage\" permission. ['actions' => '*', 'allow' => '+role.manage'] ], Controller\\PermissionController::class => [ // Allow access to authenticated users having \"permission.manage\" permission. ['actions' => '*', 'allow' => '+permission.manage'] ], ] ], //... ]; Below you can find the source code of the filterAccess() method of the AuthManager service: /** * This is a simple access control filter. It is able to restrict unauthorized * users to visit certain pages. * * This method uses the 'access_filter' key in the config file and determines * whenther the current visitor is allowed to access the given controller action * or not. It returns true if allowed; otherwise false. */ public function filterAccess($controllerName, $actionName) { // Determine mode - 'restrictive' (default) or 'permissive'. In restrictive // mode all controller actions must be explicitly listed under the 'access_filter' // config key, and access is denied to any not listed action for unauthorized users. // In permissive mode, if an action is not listed under the 'access_filter' key, // access to it is permitted to anyone (even for not logged in users. // Restrictive mode is more secure and recommended to use. $mode = isset($this->config['options']['mode'])?$this->config['options']['mode']:'restrictive'; if ($mode!='restrictive' && $mode!='permissive') throw new \\Exception('Invalid access filter mode (expected either restrictive or permissive mode'); if (isset($this->config['controllers'][$controllerName])) { $items = $this->config['controllers'][$controllerName]; foreach ($items as $item) { $actionList = $item['actions']; $allow = $item['allow']; if (is_array($actionList) && in_array($actionName, $actionList) || $actionList=='*') { if ($allow=='*') // Anyone is allowed to see the page. return self::ACCESS_GRANTED; else if (!$this->authService->hasIdentity()) { // Only authenticated user is allowed to see the page. return self::AUTH_REQUIRED; } if ($allow=='@') { // Any authenticated user is allowed to see the page. return self::ACCESS_GRANTED; } else if (substr($allow, 0, 1)=='@') { // Only the user with specific identity is allowed to see the page. $identity = substr($allow, 1); if ($this->authService->getIdentity()==$identity) return self::ACCESS_GRANTED; else return self::ACCESS_DENIED; } else if (substr($allow, 0, 1)=='+') { // Only the user with this permission is allowed to see the page. $permission = substr($allow, 1); if ($this->rbacManager->isGranted(null, $permission)) return self::ACCESS_GRANTED; else return self::ACCESS_DENIED; } else { throw new \\Exception('Unexpected value for \"allow\" - expected ' . 'either \"?\", \"@\", \"@identity\" or \"+permission\"'); } } } } // In restrictive mode, we require authentication for any action not // listed under 'access_filter' key and deny access to authorized users // (for security reasons). if ($mode=='restrictive') { if(!$this->authService->hasIdentity()) return self::AUTH_REQUIRED; else return self::ACCESS_DENIED; } // Permit access to this page. return self::ACCESS_GRANTED; } As you could see from the code, the method returns one of three constants: ACCESS_GRANTED if user is allowed to see the given page; AUTH_REQUIRED if user needs to authenticate first; ACCESS_DENIED if user is denied to see the page. Modifying the Dispatch Event Listener Next, we will modify the Module class living in User namespace and particularly its onDispatch() method. The main goal of this is that if the access filter returns ACCESS_DENIED , we redirect the user to the Not Authorized page. <?php namespace User; use Laminas\\Mvc\\MvcEvent; use Laminas\\Mvc\\Controller\\AbstractActionController; use User\\Controller\\AuthController; use User\\Service\\AuthManager; class Module { //... /** * Event listener method for the 'Dispatch' event. We listen to the Dispatch * event to call the access filter. The access filter allows to determine if * the current visitor is allowed to see the page or not. If he/she * is not authorized and is not allowed to see the page, we redirect the user * to the login page. */ public function onDispatch(MvcEvent $event) { // Get controller and action to which the HTTP request was dispatched. $controller = $event->getTarget(); $controllerName = $event->getRouteMatch()->getParam('controller', null); $actionName = $event->getRouteMatch()->getParam('action', null); // Convert dash-style action name to camel-case. $actionName = str_replace('-', '', lcfirst(ucwords($actionName, '-'))); // Get the instance of AuthManager service. $authManager = $event->getApplication()->getServiceManager()->get(AuthManager::class); // Execute the access filter on every controller except AuthController // (to avoid infinite redirect). if ($controllerName!=AuthController::class) { $result = $authManager->filterAccess($controllerName, $actionName); if ($result==AuthManager::AUTH_REQUIRED) { // Remember the URL of the page the user tried to access. We will // redirect the user to that URL after successful login. $uri = $event->getApplication()->getRequest()->getUri(); // Make the URL relative (remove scheme, user info, host name and port) // to avoid redirecting to other domain by a malicious user. $uri->setScheme(null) ->setHost(null) ->setPort(null) ->setUserInfo(null); $redirectUrl = $uri->toString(); // Redirect the user to the \"Login\" page. return $controller->redirect()->toRoute('login', [], ['query'=>['redirectUrl'=>$redirectUrl]]); } else if ($result==AuthManager::ACCESS_DENIED) { // Redirect the user to the \"Not Authorized\" page. return $controller->redirect()->toRoute('not-authorized'); } } } } Adding Access Controller Plugin and View Helper To query RbacManager inside of controllers and view templates, we need to create a special controller plugin (which we will name Access ) and a special view helper (which we will name Access too). Access Controller Plugin Sometimes it is required to check some permission inside the controller. For example, this is needed for the profile.own.view permission, which uses the dynamic assertion. For this purpose, we will create the Access controller plugin. The plugin code will be located inside the AccessPlugin.php file inside the Controller/Plugin directory of the User module's source directory: <?php namespace User\\Controller\\Plugin; use Laminas\\Mvc\\Controller\\Plugin\\AbstractPlugin; /** * This controller plugin is used for role-based access control (RBAC). */ class AccessPlugin extends AbstractPlugin { private $rbacManager; public function __construct($rbacManager) { $this->rbacManager = $rbacManager; } /** * Checks whether the currently logged in user has the given permission. * @param string $permission Permission name. * @param array $params Optional params (used only if an assertion is associated with permission). */ public function __invoke($permission, $params = []) { return $this->rbacManager->isGranted(null, $permission, $params); } } The Access plugin's factory looks like the following: <?php namespace User\\Controller\\Plugin\\Factory; use Interop\\Container\\ContainerInterface; use Laminas\\ServiceManager\\Factory\\FactoryInterface; use User\\Service\\RbacManager; use User\\Controller\\Plugin\\AccessPlugin; /** * This is the factory for AccessPlugin. Its purpose is to instantiate the plugin * and inject dependencies into its constructor. */ class AccessPluginFactory implements FactoryInterface { public function __invoke(ContainerInterface $container, $requestedName, array $options = null) { $rbacManager = $container->get(RbacManager::class); return new AccessPlugin($rbacManager); } } The plugin is registered inside the module.config.php file as follows: // We register module-provided controller plugins under this key. 'controller_plugins' => [ 'factories' => [ Controller\\Plugin\\AccessPlugin::class => Controller\\Plugin\\Factory\\AccessPluginFactory::class, ], 'aliases' => [ 'access' => Controller\\Plugin\\AccessPlugin::class, ], ], So, in your controller's action, you can easily call this plugin like the following: if (!$this->access('profile.own.view', ['user'=>$user])) { return $this->redirect()->toRoute('not-authorized'); } Access View Helper Sometimes, it may be required to query the RbacManager inside a view template. For example, you may need to hide or show some HTML block based on current user's permissions. To do that, we will implement the Access view helper. The view helper's code will be located inside the Access.php file inside the View/Helper directory of the User module's source directory: <?php namespace User\\View\\Helper; use Laminas\\View\\Helper\\AbstractHelper; /** * This view helper is used to check user permissions. */ class Access extends AbstractHelper { private $rbacManager = null; public function __construct($rbacManager) { $this->rbacManager = $rbacManager; } public function __invoke($permission, $params = []) { return $this->rbacManager->isGranted(null, $permission, $params); } } The Access view helper's factory looks like the following: <?php namespace User\\View\\Helper\\Factory; use Interop\\Container\\ContainerInterface; use Laminas\\ServiceManager\\Factory\\FactoryInterface; use User\\Service\\RbacManager; use User\\View\\Helper\\Access; /** * This is the factory for Access view helper. Its purpose is to instantiate the helper * and inject dependencies into its constructor. */ class AccessFactory implements FactoryInterface { public function __invoke(ContainerInterface $container, $requestedName, array $options = null) { $rbacManager = $container->get(RbacManager::class); return new Access($rbacManager); } } The view helper is registered inside the module.config.php config file as follows: // We register module-provided view helpers under this key. 'view_helpers' => [ 'factories' => [ View\\Helper\\Access::class => View\\Helper\\Factory\\AccessFactory::class, ], 'aliases' => [ 'access' => View\\Helper\\Access::class, ], ], So, you can easily call the view helper from any of your view templates as follows: if ($this->access('profile.own.view, ['user'=>$user]))) { // do something... } Using the User Module Congratulations, now our Role Demo is ready, so we make some resume of how you typically use it if you plan to base your own website on it. First of all, you need to create all needed roles and permissions through the convenient user interface that we created. Assign a role (or several roles) to each website user. Then edit the module.config.php configuration configuration file in your module and add two keys: the rbac_manager key will contain settings for the RbacManager (particularly the configuration of assertion manager(s)); An example of that key is presented below: // This key stores configuration for RBAC manager. 'rbac_manager' => [ 'assertions' => [Service\\RbacAssertionManager::class], ], the access_filter key stores the access rules for the pages of your website. It typically looks like below: 'access_filter' => [ 'options' => [ 'mode' => 'restrictive' ], 'controllers' => [ Controller\\IndexController::class => [ // Allow anyone to visit \"index\" and \"about\" actions ['actions' => ['index', 'about'], 'allow' => '*'], // Allow authorized users to visit \"settings\" action ['actions' => ['settings'], 'allow' => '@'] ], ] ], The * and @ in the allow subkeys are not the only options. You can make the allow subkeys to look as follows. We allow access to the page to: anyone if we specify the asterisk ( * ); any authenticated user if we specify the \"commercial at\" ( @ ); a concrete authenticated user with the given identity email address if we specify ( @identity ) any authenticated user with the given permission if we specify the plus sign followed by the permission name ( +permission ). If your website has some dynamic assertions, extend the assert() method of the existing RbacAssertionManager class (or write and register your own assertion manager): public function assert(Rbac $rbac, $permission, $params) { $currentUser = $this->entityManager->getRepository(User::class) ->findOneByEmail($this->authService->getIdentity()); if ($permission=='post.own.edit' && $params['post']->getUser()->getId()==$currentUser->getId()) return true; if ($permission=='post.own.publish' && $params['post']->getUser()->getId()==$currentUser->getId()) return true; return false; } If you want to check permissions in a controller action, you can use the Access controller plugin as follows: if (!$this->access('profile.own.view', ['user'=>$user])) { return $this->redirect()->toRoute('not-authorized'); } If you want to check permissions in a view template, you can use the Access view helper: if ($this->access('profile.own.view', ['user'=>$user))) { // do something... } That's all! That simple! Enjoy! Summary In this chapter we have implemented the Role Demo website which demonstrates how to use roles and permissions in Laminas. A role is basically a group of users. A user may be assigned with one or several roles at once. A role may be assigned one or more permissions. A permission is a single action in the system. A dynamic assertion is an additional rule associated with the permission. Roles may be organised into an hierarchy, when parent roles inherit permissions from their child roles.","title":"Role-Based Access Control"},{"location":"roles/#role-based-access-control","text":"If you remember, in the previous chapter we created the User Demo website which allowed us to manage users and permit access to some web pages to authenticated users only. In this chapter, we will extend the User Demo and show how to implement the Role-Based Access Control (RBAC). The RBAC allows to permit or deny access for certain users to certain website pages based on roles and permissions . Since you have already known a lot about Laminas from reading previous chapters, in this chapter we will omit discussing some obvious things and concentrate on conceptual moments only. It is recommended that you refer to the Role Demo sample bundled with this book, which is a complete website that you can run and see everything in action. All code discussed in this chapter is part of this sample application. Laminas components covered in this chapter: Component Description @ Laminas\\Permissions\\Rbac Provides RBAC container implementation. @ Laminas\\Cache Provides functionality for storing data in cache.","title":"Role-Based Access Control"},{"location":"roles/#get-role-demo-sample-from-github","text":"For demonstration, in this chapter, we will create a real-life Role Demo website that shows how to: Implement roles and permissions in your website Organize roles in database into an hierarchy Manage roles and permissions in user interface Use @ Laminas\\Permissions\\Rbac component to implement role-based access control Use dynamic assertions to implement complex access control rules The Role Demo sample will be based on the User Demo sample that we created in the previous chapter. To download the Role Demo application, visit this page and click the Clone or Download button to download the code as a ZIP archive. When download is complete, unpack the archive to some directory. Then navigate to the roledemo directory containing the source code of the Role Demo web application: /using-laminas-book-samples /roledemo ... The Role Demo is a website which can be installed on your machine. Note Detailed instructions on how to install the Role Demo sample can be found in README.md file located in the sample directory.","title":"Get Role Demo Sample from GitHub"},{"location":"roles/#introduction-to-rbac","text":"Laminas provides a special component named @ Laminas\\Permissions\\Rbac which implements a container for roles and permissions. To install the @ Laminas\\Permissions\\Rbac component in your web application, type the following command: php composer.phar require laminas/laminas-permissions-rbac","title":"Introduction to RBAC"},{"location":"roles/#roles-and-permissions","text":"A role is a group of users. For example, in a Blog application, there may be the following roles: Viewer, Author, Editor, and Administrator. Role Name Description Viewer Can read any post and can do nothing else. Author Can view posts plus create a post, edit it and finally publish it. Editor Can view posts plus edit and publish any post. Administrator Can do anything a Viewer and Editor can do plus delete posts. Table 17.1. Example roles in a Blog website A user may be assigned a role or several roles at once. For example, user John may be a Viewer and Editor at the same time. A role may inherit permissions from other roles. In other words, roles may be organized into an hierarchy when parent roles inherit permissions of child roles. For example, in our Blog application, Administrator role would inherit permissions from Editor role (see figure 17.1 below). This is because Administrator can do the same things as Editor plus delete posts. Editor and Author roles would inherit permissions from the Viewer role. A role may be assigned with several permissions . A permission is a single typical action in the system. Here are several examples of permissions in a Blog website: Permission Name Description post.view View any post. post.edit Edit any post. post.own.edit Edit only owned posts. post.publish Publish any post. post.own.publish Publish only owned post. post.delete Delete any post. Table 17.2. Example permissions in a Blog website For example, the Viewer role would be assigned the post.view permission. The Editor role would be assigned the post.edit and post.publish permissions. The Author role would be assigned with the post.own.edit and post.own.publish permissions. And the role Administrator would be assigned with the post.delete permission.","title":"Roles and Permissions"},{"location":"roles/#rbac-container","text":"In Laminas, you can use the @ Rbac class living in @ Laminas\\Permissions\\Rbac namespace as a simple container for your roles and permissions. With this container, you store your roles in memory organized in an hierarchy and assigned with permissions. For example, let's create an @ Rbac container for the Blog application and fill it with roles and permissions: use Laminas\\Permissions\\Rbac\\Rbac; // Create Rbac container. $rbac = new Rbac(); // The following is to tell Rbac to create some parent roles if not exist yet $rbac->setCreateMissingRoles(true); // Create role hierarchy $rbac->addRole('Viewer', ['Editor', 'Author']); $rbac->addRole('Editor', ['Administrator']); $rbac->addRole('Author'); $rbac->addRole('Administrator'); // Assign permissions to the Viewer role. $rbac->getRole('Viewer')->addPermission('post.view'); // Assign permissions to the Author role. $rbac->getRole('Author')->addPermission('post.own.edit'); $rbac->getRole('Author')->addPermission('post.own.publish'); // Assign permissions to the Editor role. $rbac->getRole('Editor')->addPermission('post.edit'); $rbac->getRole('Editor')->addPermission('post.publish'); // Assign permissions to the Administrator role. $rbac->getRole('Administrator')->addPermission('post.delete'); As you can see, a role is added to the @ Rbac container with the help of the addRole() method. The addRole() method takes two arguments: the name of the role to be created, and the name(s) of its parent role(s). If the parent roles do not exist yet, they are created automatically (for that purpose we use the setCreateMissingRoles() method). Permissions are assigned to the created role with the help of role's addPermission() method.","title":"RBAC Container"},{"location":"roles/#checking-permissions","text":"When you have an @ Rbac container set up, you can query if the role has certain permission with the isGranted() method, as follows: // The following will return false, because the Viewer can't delete posts $rbac->isGranted('Viewer', 'post.delete'); // The following will return true, because admins can delete posts $rbac->isGranted('Administrator', 'post.delete'); The isGranted() method checks the role and its children and looks for the given permission. If it finds the permission, it returns true ; otherwise false .","title":"Checking Permissions"},{"location":"roles/#default-roles-in-the-role-demo-sample","text":"Since our Role Demo application is designed to be the base for your own more complex websites, for our Role Demo sample, we will have only the following simple default roles: Administrator and Guest. You will be able to add more roles via user interface of the website. We will have the following default permissions: Permission Name Description user.manage Manage users (add/edit/delete). role.manage Manage roles (add/edit/delete). permission.manage Manage permissions (add/edit/delete). profile.any.view View any user profile in the system. profile.own.view View own profile. Table 17.3. Default permissions in the Role Demo website The first three permissions will allow Administrator to manage users, roles and permissions via user interface. The last two permissions ( profile.any.view and profile.own.view ) are mostly for demonstration of how Rbac works and can in theory be deleted from your own website if you do not have the user profile page. The profile.any.view allows Administrator to access http://localhost/application/settings/<user_id> page, which is the user profile of a user with the given ID. The profile.own.view allows Guest to access their own profile page http://localhost/application/settings . You will be able to create additional permissions via the user interface of the website.","title":"Default Roles in the Role Demo Sample"},{"location":"roles/#introduction-to-dynamic-assertions","text":"You might notice that for the Blog example we had two \"special\" permissions named post.own.edit and post.own.publish . Those permissions are special, because they allow the author to edit only the posts he is the creator of. To \"check\" such permission against the real user, we need to additionally determine if the post really belongs to that user. This is called a dynamic assertion . In the Role Demo website, we also will have a special permission called profile.own.view . What makes it special is that it allows the user to view a profile the user is the owner of. To implement dynamic assertions in the Role Demo sample, we will use a special service called the assertion manager . This assertion manager will be implemented as the RbacAssertionManager class, which lives in the Application\\Service namespace and looks like the following: <?php namespace Application\\Service; use Laminas\\Permissions\\Rbac\\Rbac; use User\\Entity\\User; /** * This service is used for invoking user-defined RBAC dynamic assertions. */ class RbacAssertionManager { /** * Entity manager. * @var Doctrine\\ORM\\EntityManager */ private $entityManager; /** * Auth service. * @var Laminas\\Authentication\\AuthenticationService */ private $authService; /** * Constructs the service. */ public function __construct($entityManager, $authService) { $this->entityManager = $entityManager; $this->authService = $authService; } /** * This method is used for dynamic assertions. */ public function assert(Rbac $rbac, $permission, $params) { $currentUser = $this->entityManager->getRepository(User::class) ->findOneByEmail($this->authService->getIdentity()); if ($permission=='profile.own.view' && $params['user']->getId()==$currentUser->getId()) return true; return false; } } As you can see from the code above, the class has the assert() method which accepts three arguments: the $rbac is the container of our roles and permissions; the $permission is the name of the permission to check; the $params is an array of parameters (it can be used for example to pass the user owning the blog post). Inside the assert() method, we can get the currently logged in user and compare it with the user passed, this way we can return true if the user is trying to open its own profile; otherwise false . Note In theory, you can have many assertion managers in your website (for example, if your Blog module has some dynamic assertions, you can create and register an assertion manager for that module).","title":"Introduction to Dynamic Assertions"},{"location":"roles/#setting-up-the-database","text":"In our Role Demo sample, we will store the role hierarchy in the \"roledemo\" database. We will create the following tables (see figure 17.2): role table will contain data related to a role (its name and description) role_hierarchy table will contain parent-child relationships between roles permission table will contain permissions role_permission table will allow to assign permissions to roles user_role table will allow to assign roles to users user table will contain data of users (we created this table earlier in User Demo sample) You can find a database migration, which creates these tables, in the Role Demo sample application. To run migrations, type the following command: ./vendor/bin/doctrine-module migrations:migrate Note If you are new to migrations, refer to chapter Database Migrations .","title":"Setting Up the Database"},{"location":"roles/#implementing-entities","text":"The Role Demo sample uses Doctrine ORM for managing database. We have already learned how to use Doctrine in Database Management with Doctrine ORM . For storing information about roles and permissions in database, we will create the Role and Permission entities. The Role entity is mapped onto the role database table, while the Permission entity is mapped onto the permission table. Those are typical Doctrine entity classes. Create the Role.php file inside the Entity directory under the User module's source directory. Put the following code into that file: <?php namespace User\\Entity; use Doctrine\\ORM\\Mapping as ORM; use Doctrine\\Common\\Collections\\ArrayCollection; /** * This class represents a role. * @ORM\\Entity() * @ORM\\Table(name=\"role\") */ class Role { /** * @ORM\\Id * @ORM\\Column(name=\"id\") * @ORM\\GeneratedValue */ protected $id; /** * @ORM\\Column(name=\"name\") */ protected $name; /** * @ORM\\Column(name=\"description\") */ protected $description; /** * @ORM\\Column(name=\"date_created\") */ protected $dateCreated; /** * @ORM\\ManyToMany(targetEntity=\"User\\Entity\\Role\") * @ORM\\JoinTable(name=\"role_hierarchy\", * joinColumns={@ORM\\JoinColumn(name=\"child_role_id\", referencedColumnName=\"id\")}, * inverseJoinColumns={@ORM\\JoinColumn(name=\"parent_role_id\", referencedColumnName=\"id\")} * ) */ private $parentRoles; /** * @ORM\\ManyToMany(targetEntity=\"User\\Entity\\Role\") * @ORM\\JoinTable(name=\"role_hierarchy\", * joinColumns={@ORM\\JoinColumn(name=\"parent_role_id\", referencedColumnName=\"id\")}, * inverseJoinColumns={@ORM\\JoinColumn(name=\"child_role_id\", referencedColumnName=\"id\")} * ) */ protected $childRoles; /** * @ORM\\ManyToMany(targetEntity=\"User\\Entity\\Permission\") * @ORM\\JoinTable(name=\"role_permission\", * joinColumns={@ORM\\JoinColumn(name=\"role_id\", referencedColumnName=\"id\")}, * inverseJoinColumns={@ORM\\JoinColumn(name=\"permission_id\", referencedColumnName=\"id\")} * ) */ private $permissions; /** * Constructor. */ public function __construct() { $this->parentRoles = new ArrayCollection(); $this->childRoles = new ArrayCollection(); $this->permissions = new ArrayCollection(); } /** * Returns role ID. * @return integer */ public function getId() { return $this->id; } /** * Sets role ID. * @param int $id */ public function setId($id) { $this->id = $id; } public function getName() { return $this->name; } public function setName($name) { $this->name = $name; } public function getDescription() { return $this->description; } public function setDescription($description) { $this->description = $description; } public function getDateCreated() { return $this->dateCreated; } public function setDateCreated($dateCreated) { $this->dateCreated = $dateCreated; } public function getParentRoles() { return $this->parentRoles; } public function getChildRoles() { return $this->childRoles; } public function getPermissions() { return $this->permissions; } public function addParent(Role $role) { if ($this->getId() == $role->getId()) { return false; } if (!$this->hasParent($role)) { $this->parentRoles[] = $role; return true; } return false; } public function clearParentRoles() { $this->parentRoles = new ArrayCollection(); } public function hasParent(Role $role) { if ($this->getParentRoles()->contains($role)) { return true; } return false; } } As you could determine from the code above, the Role entity is a typical Doctrine entity having annotated properties and getter and setter methods for retrieving/setting those properties. Next, create the Permission.php file inside the Entity directory under the User module's source directory. Put the following code into that file: <?php namespace User\\Entity; use Doctrine\\ORM\\Mapping as ORM; use Doctrine\\Common\\Collections\\ArrayCollection; /** * This class represents a permission. * @ORM\\Entity() * @ORM\\Table(name=\"permission\") */ class Permission { /** * @ORM\\Id * @ORM\\Column(name=\"id\") * @ORM\\GeneratedValue */ protected $id; /** * @ORM\\Column(name=\"name\") */ protected $name; /** * @ORM\\Column(name=\"description\") */ protected $description; /** * @ORM\\Column(name=\"date_created\") */ protected $dateCreated; /** * @ORM\\ManyToMany(targetEntity=\"User\\Entity\\Role\") * @ORM\\JoinTable(name=\"role_permission\", * joinColumns={@ORM\\JoinColumn(name=\"permission_id\", referencedColumnName=\"id\")}, * inverseJoinColumns={@ORM\\JoinColumn(name=\"role_id\", referencedColumnName=\"id\")} * ) */ private $roles; /** * Constructor. */ public function __construct() { $this->roles = new ArrayCollection(); } public function getId() { return $this->id; } public function setId($id) { $this->id = $id; } public function getName() { return $this->name; } public function setName($name) { $this->name = $name; } public function getDescription() { return $this->description; } public function setDescription($description) { $this->description = $description; } public function getDateCreated() { return $this->dateCreated; } public function setDateCreated($dateCreated) { $this->dateCreated = $dateCreated; } public function getRoles() { return $this->roles; } } Finally, we will slightly extend the User entity that already created in the User Demo website and add the property and methods related to roles: <?php namespace User\\Entity; use Doctrine\\ORM\\Mapping as ORM; use Doctrine\\Common\\Collections\\ArrayCollection; /** * This class represents a registered user. * @ORM\\Entity() * @ORM\\Table(name=\"user\") */ class User { // User status constants. const STATUS_ACTIVE = 1; // Active user. const STATUS_RETIRED = 2; // Retired user. /** * @ORM\\Id * @ORM\\Column(name=\"id\") * @ORM\\GeneratedValue */ protected $id; /** * @ORM\\Column(name=\"email\") */ protected $email; /** * @ORM\\Column(name=\"full_name\") */ protected $fullName; /** * @ORM\\Column(name=\"password\") */ protected $password; /** * @ORM\\Column(name=\"status\") */ protected $status; /** * @ORM\\Column(name=\"date_created\") */ protected $dateCreated; /** * @ORM\\Column(name=\"pwd_reset_token\") */ protected $passwordResetToken; /** * @ORM\\Column(name=\"pwd_reset_token_creation_date\") */ protected $passwordResetTokenCreationDate; /** * @ORM\\ManyToMany(targetEntity=\"User\\Entity\\Role\") * @ORM\\JoinTable(name=\"user_role\", * joinColumns={@ORM\\JoinColumn(name=\"user_id\", referencedColumnName=\"id\")}, * inverseJoinColumns={@ORM\\JoinColumn(name=\"role_id\", referencedColumnName=\"id\")} * ) */ private $roles; /** * Constructor. */ public function __construct() { $this->roles = new ArrayCollection(); } /** * Returns user ID. * @return integer */ public function getId() { return $this->id; } /** * Sets user ID. * @param int $id */ public function setId($id) { $this->id = $id; } /** * Returns email. * @return string */ public function getEmail() { return $this->email; } /** * Sets email. * @param string $email */ public function setEmail($email) { $this->email = $email; } /** * Returns full name. * @return string */ public function getFullName() { return $this->fullName; } /** * Sets full name. * @param string $fullName */ public function setFullName($fullName) { $this->fullName = $fullName; } /** * Returns status. * @return int */ public function getStatus() { return $this->status; } /** * Returns possible statuses as array. * @return array */ public static function getStatusList() { return [ self::STATUS_ACTIVE => 'Active', self::STATUS_RETIRED => 'Retired' ]; } /** * Returns user status as string. * @return string */ public function getStatusAsString() { $list = self::getStatusList(); if (isset($list[$this->status])) return $list[$this->status]; return 'Unknown'; } /** * Sets status. * @param int $status */ public function setStatus($status) { $this->status = $status; } /** * Returns password. * @return string */ public function getPassword() { return $this->password; } /** * Sets password. * @param string $password */ public function setPassword($password) { $this->password = $password; } /** * Returns the date of user creation. * @return string */ public function getDateCreated() { return $this->dateCreated; } /** * Sets the date when this user was created. * @param string $dateCreated */ public function setDateCreated($dateCreated) { $this->dateCreated = $dateCreated; } /** * Returns password reset token. * @return string */ public function getResetPasswordToken() { return $this->passwordResetToken; } /** * Sets password reset token. * @param string $token */ public function setPasswordResetToken($token) { $this->passwordResetToken = $token; } /** * Returns password reset token's creation date. * @return string */ public function getPasswordResetTokenCreationDate() { return $this->passwordResetTokenCreationDate; } /** * Sets password reset token's creation date. * @param string $date */ public function setPasswordResetTokenCreationDate($date) { $this->passwordResetTokenCreationDate = $date; } /** * Returns the array of roles assigned to this user. * @return array */ public function getRoles() { return $this->roles; } /** * Returns the string of assigned role names. */ public function getRolesAsString() { $roleList = ''; $count = count($this->roles); $i = 0; foreach ($this->roles as $role) { $roleList .= $role->getName(); if ($i<$count-1) $roleList .= ', '; $i++; } return $roleList; } /** * Assigns a role to user. */ public function addRole($role) { $this->roles->add($role); } }","title":"Implementing Entities"},{"location":"roles/#implementing-role-management","text":"In the Role Demo sample, we will create a convenient user interface for managing roles. Note You can access the role management page by logging in as admin@example.com and opening menu Admin -> Manage Roles. The role management will be implemented inside the RoleController controller living in the User\\Controller namespace. The action methods of the RoleController are listed in table 17.4: Action Name Description addAction() Allows to add a new role. deleteAction() Deletes an existing role. editAction() Allows to edit an existing role. editPermissionsAction() Allows to assign permissions to a role. indexAction() Displays the list of existing roles. viewAction() Displays the details of a role. Table 17.4. Actions of the RoleController controller The RoleController works in pair with the RoleManager service which lives in User\\Service namespace. The RoleController and RoleManager contain nothing new and special, so we will skip their discussion here and will just provide some screenshots of the resulting user interface below. Note You can find the complete code of the RoleController and RoleManager classes in the Role Demo sample.","title":"Implementing Role Management"},{"location":"roles/#implementing-permission-management","text":"In the Role Demo sample, we will create a convenient user interface for managing permissions. It will be useful if you plan to add new permissions or remove existing ones. Note You can access the permission management page by logging in as admin@example.com and opening menu Admin -> Manage Permissions. The permission management will be implemented inside the PermissionController controller living in the User\\Controller namespace. The action methods of the PermissionController are listed in table 17.5: Action Name Description addAction() Allows to add a new permission. deleteAction() Deletes an existing permission. editAction() Allows to edit an existing permission. indexAction() Displays the list of existing permissions. viewAction() Displays the details of a permission. Table 17.5. Actions of the PermissionController controller The PermissionController works in pair with the PermissionManager service which lives in User\\Service namespace. The PermissionController and PermissionManager contain nothing new and special, so we will skip their discussion here and will just provide some screenshots of the resulting user interface below. Note You can find the complete code of the PermissionController and PermissionManager classes in the Role Demo sample.","title":"Implementing Permission Management"},{"location":"roles/#assigning-roles-to-a-user","text":"In the Role Demo website, you can assign roles to a user via the convenient user interface. Open the Admin -> Manage Users menu and click Edit on the user of your choice. On the page that appears, select the roles you'd like to assign to the user and click the Save button. This functionality contain nothing new and special, so we will skip its detailed discussion here and will just provide a screenshot of the user interface below.","title":"Assigning Roles to a User"},{"location":"roles/#implementing-rbacmanager","text":"The next thing we will discuss will be the functionality for creating the Rbac container, whose purpose is loading the role hierarchy from the database, and caching the data in the filesystem cache. Note The cache allows to store frequently used data in fast storage. For example, retrieving roles and permissions from database on each page load may be rather slow, while storing the precomputed role hierarchy in a file may be faster.","title":"Implementing RbacManager"},{"location":"roles/#setting-up-caching","text":"First, let's set up caching. To do that, you need to install the Laminas\\Cache and Laminas\\Serializer components with the following commands: php composer.phar require laminas/laminas-cache php composer.phar require laminas/laminas-serializer Finally, edit the config/autoload/global.php and add the following lines: use Laminas\\Cache\\Storage\\Adapter\\Filesystem; return [ //... // Cache configuration. 'caches' => [ 'FilesystemCache' => [ 'adapter' => [ 'name' => Filesystem::class, 'options' => [ // Store cached data in this directory. 'cache_dir' => './data/cache', // Store cached data for 1 hour. 'ttl' => 60*60*1 ], ], 'plugins' => [ [ 'name' => 'serializer', 'options' => [ ], ], ], ], ], //... ]; This will allow you to use the Filesystem cache and store cached data in APP_DIR/data/cache directory. Note If you want to learn more about caching, please refer to the Laminas\\Cache Laminas component documentation.","title":"Setting Up Caching"},{"location":"roles/#writing-the-rbacmanager-service","text":"The purpose of the RbacManager service will be to construct the Rbac container and load the roles and permissions from database. If the needed information is already saved to cache, it will load it from cache instead of loading from database. Another goal of the RbacManager service will be to use the assertion manager we wrote earlier and check for dynamic assertions. The RbacManager class will have two methods: the init() method will be used to load role hierarchy from database and save it in cache; the isGranted() method will be used to query the Rbac container if the given user has the given permission (and checking the assertion manager(s) for the dynamic assertions). The RbacManager class will read the configuration and look for the rbac_manager key. The key should contain the assertions subkey, in which you can register all assertion managers that you have. return [ //... // This key stores configuration for RBAC manager. 'rbac_manager' => [ 'assertions' => [Service\\RbacAssertionManager::class], ], ]; The code of the RbacManager class living in User\\Service namespace is presented below. <?php namespace User\\Service; use Laminas\\Permissions\\Rbac\\Rbac; use Laminas\\Permissions\\Rbac\\Role as RbacRole; use User\\Entity\\User; use User\\Entity\\Role; use User\\Entity\\Permission; /** * This service is responsible for initialzing RBAC (Role-Based Access Control). */ class RbacManager { /** * Doctrine entity manager. * @var Doctrine\\ORM\\EntityManager */ private $entityManager; /** * RBAC service. * @var Laminas\\Permissions\\Rbac\\Rbac */ private $rbac; /** * Auth service. * @var Laminas\\Authentication\\AuthenticationService */ private $authService; /** * Filesystem cache. * @var Laminas\\Cache\\Storage\\StorageInterface */ private $cache; /** * Assertion managers. * @var array */ private $assertionManagers = []; /** * Constructs the service. */ public function __construct($entityManager, $authService, $cache, $assertionManagers) { $this->entityManager = $entityManager; $this->authService = $authService; $this->cache = $cache; $this->assertionManagers = $assertionManagers; } /** * Initializes the RBAC container. */ public function init($forceCreate = false) { if ($this->rbac!=null && !$forceCreate) { // Already initialized; do nothing. return; } // If user wants us to reinit RBAC container, clear cache now. if ($forceCreate) { $this->cache->removeItem('rbac_container'); } // Try to load Rbac container from cache. $this->rbac = $this->cache->getItem('rbac_container', $result); if (!$result) { // Create Rbac container. $rbac = new Rbac(); $this->rbac = $rbac; // Construct role hierarchy by loading roles and permissions from database. $rbac->setCreateMissingRoles(true); $roles = $this->entityManager->getRepository(Role::class) ->findBy([], ['id'=>'ASC']); foreach ($roles as $role) { $roleName = $role->getName(); $parentRoleNames = []; foreach ($role->getParentRoles() as $parentRole) { $parentRoleNames[] = $parentRole->getName(); } $rbac->addRole($roleName, $parentRoleNames); foreach ($role->getPermissions() as $permission) { $rbac->getRole($roleName)->addPermission($permission->getName()); } } // Save Rbac container to cache. $this->cache->setItem('rbac_container', $rbac); } } /** * Checks whether the given user has permission. * @param User|null $user * @param string $permission * @param array|null $params */ public function isGranted($user, $permission, $params = null) { if ($this->rbac==null) { $this->init(); } if ($user==null) { $identity = $this->authService->getIdentity(); if ($identity==null) { return false; } $user = $this->entityManager->getRepository(User::class) ->findOneByEmail($identity); if ($user==null) { // Oops.. the identity presents in session, but there is no such user in database. // We throw an exception, because this is a possible security problem. throw new \\Exception('There is no user with such identity'); } } $roles = $user->getRoles(); foreach ($roles as $role) { if ($this->rbac->isGranted($role->getName(), $permission)) { if ($params==null) return true; foreach ($this->assertionManagers as $assertionManager) { if ($assertionManager->assert($this->rbac, $permission, $params)) return true; } } $parentRoles = $role->getParentRoles(); foreach ($parentRoles as $parentRole) { if ($this->rbac->isGranted($parentRole->getName(), $permission)) { return true; } } } return false; } } The factory for the RbacManager class looks like the following: <?php namespace User\\Service\\Factory; use Interop\\Container\\ContainerInterface; use User\\Service\\RbacManager; use Laminas\\Authentication\\AuthenticationService; /** * This is the factory class for RbacManager service. The purpose of the factory * is to instantiate the service and pass it dependencies (inject dependencies). */ class RbacManagerFactory { /** * This method creates the RbacManager service and returns its instance. */ public function __invoke(ContainerInterface $container, $requestedName, array $options = null) { $entityManager = $container->get('doctrine.entitymanager.orm_default'); $authService = $container->get(\\Laminas\\Authentication\\AuthenticationService::class); $cache = $container->get('FilesystemCache'); $assertionManagers = []; $config = $container->get('Config'); if (isset($config['rbac_manager']['assertions'])) { foreach ($config['rbac_manager']['assertions'] as $serviceName) { $assertionManagers[$serviceName] = $container->get($serviceName); } } return new RbacManager($entityManager, $authService, $cache, $assertionManagers); } }","title":"Writing the RbacManager Service"},{"location":"roles/#adding-the-not-authorized-page","text":"Next we will create the Not Authorized page (see figure 17.13) on which we will redirect the user when they are not allowed to access some web page. Add the following route to the module.config.php file of the User module: return [ 'router' => [ 'routes' => [ 'not-authorized' => [ 'type' => Literal::class, 'options' => [ 'route' => '/not-authorized', 'defaults' => [ 'controller' => Controller\\AuthController::class, 'action' => 'notAuthorized', ], ], ], ], ], ]; Then add the notAuthorizedAction() method to the AuthController in the User module: /** * Displays the \"Not Authorized\" page. */ public function notAuthorizedAction() { $this->getResponse()->setStatusCode(403); return new ViewModel(); } Finally, add the not-authorized.phtml view template file under the user/auth directory under the User module's view directory: <?php $this->headTitle(\"Not Authorized\"); ?> <h1>Not Authorized</h1> <div class=\"alert alert-warning\">Sorry, you have no permission to see this page.</div> Now you can see the Not Authorized page if you type the following URL into the address bar of the browser: \"http://localhost/not-authorized\".","title":"Adding the Not Authorized Page"},{"location":"roles/#modifying-the-authmanager-service","text":"The next thing we will do is modifying the access filter inside the AuthManager service we wrote for the User Demo sample. Particularly, we want to modify the filterAccess() method. We want the filterAccess() method to use our RbacManager class. But first we will modify the format of the access_filter key in the configuration. We want the key to allow to permit access to: anyone if we specify the asterisk ( * ); any authenticated user if we specify the \"commercial at\" ( @ ); a concrete authenticated user with the given identity email address if we specify ( @identity ) any authenticated user with the given permission if we specify the plus sign followed by the permission name ( +permission ). For example, here how the access_filter key would look like for the User module: <?php return [ //... // The 'access_filter' key is used by the User module to restrict or permit // access to certain controller actions for unauthorized visitors. 'access_filter' => [ 'controllers' => [ Controller\\UserController::class => [ // Give access to \"resetPassword\", \"message\" and \"setPassword\" actions // to anyone. ['actions' => ['resetPassword', 'message', 'setPassword'], 'allow' => '*'], // Give access to \"index\", \"add\", \"edit\", \"view\", \"changePassword\" actions // to users having the \"user.manage\" permission. ['actions' => ['index', 'add', 'edit', 'view', 'changePassword'], 'allow' => '+user.manage'] ], Controller\\RoleController::class => [ // Allow access to authenticated users having the \"role.manage\" permission. ['actions' => '*', 'allow' => '+role.manage'] ], Controller\\PermissionController::class => [ // Allow access to authenticated users having \"permission.manage\" permission. ['actions' => '*', 'allow' => '+permission.manage'] ], ] ], //... ]; Below you can find the source code of the filterAccess() method of the AuthManager service: /** * This is a simple access control filter. It is able to restrict unauthorized * users to visit certain pages. * * This method uses the 'access_filter' key in the config file and determines * whenther the current visitor is allowed to access the given controller action * or not. It returns true if allowed; otherwise false. */ public function filterAccess($controllerName, $actionName) { // Determine mode - 'restrictive' (default) or 'permissive'. In restrictive // mode all controller actions must be explicitly listed under the 'access_filter' // config key, and access is denied to any not listed action for unauthorized users. // In permissive mode, if an action is not listed under the 'access_filter' key, // access to it is permitted to anyone (even for not logged in users. // Restrictive mode is more secure and recommended to use. $mode = isset($this->config['options']['mode'])?$this->config['options']['mode']:'restrictive'; if ($mode!='restrictive' && $mode!='permissive') throw new \\Exception('Invalid access filter mode (expected either restrictive or permissive mode'); if (isset($this->config['controllers'][$controllerName])) { $items = $this->config['controllers'][$controllerName]; foreach ($items as $item) { $actionList = $item['actions']; $allow = $item['allow']; if (is_array($actionList) && in_array($actionName, $actionList) || $actionList=='*') { if ($allow=='*') // Anyone is allowed to see the page. return self::ACCESS_GRANTED; else if (!$this->authService->hasIdentity()) { // Only authenticated user is allowed to see the page. return self::AUTH_REQUIRED; } if ($allow=='@') { // Any authenticated user is allowed to see the page. return self::ACCESS_GRANTED; } else if (substr($allow, 0, 1)=='@') { // Only the user with specific identity is allowed to see the page. $identity = substr($allow, 1); if ($this->authService->getIdentity()==$identity) return self::ACCESS_GRANTED; else return self::ACCESS_DENIED; } else if (substr($allow, 0, 1)=='+') { // Only the user with this permission is allowed to see the page. $permission = substr($allow, 1); if ($this->rbacManager->isGranted(null, $permission)) return self::ACCESS_GRANTED; else return self::ACCESS_DENIED; } else { throw new \\Exception('Unexpected value for \"allow\" - expected ' . 'either \"?\", \"@\", \"@identity\" or \"+permission\"'); } } } } // In restrictive mode, we require authentication for any action not // listed under 'access_filter' key and deny access to authorized users // (for security reasons). if ($mode=='restrictive') { if(!$this->authService->hasIdentity()) return self::AUTH_REQUIRED; else return self::ACCESS_DENIED; } // Permit access to this page. return self::ACCESS_GRANTED; } As you could see from the code, the method returns one of three constants: ACCESS_GRANTED if user is allowed to see the given page; AUTH_REQUIRED if user needs to authenticate first; ACCESS_DENIED if user is denied to see the page.","title":"Modifying the AuthManager Service"},{"location":"roles/#modifying-the-dispatch-event-listener","text":"Next, we will modify the Module class living in User namespace and particularly its onDispatch() method. The main goal of this is that if the access filter returns ACCESS_DENIED , we redirect the user to the Not Authorized page. <?php namespace User; use Laminas\\Mvc\\MvcEvent; use Laminas\\Mvc\\Controller\\AbstractActionController; use User\\Controller\\AuthController; use User\\Service\\AuthManager; class Module { //... /** * Event listener method for the 'Dispatch' event. We listen to the Dispatch * event to call the access filter. The access filter allows to determine if * the current visitor is allowed to see the page or not. If he/she * is not authorized and is not allowed to see the page, we redirect the user * to the login page. */ public function onDispatch(MvcEvent $event) { // Get controller and action to which the HTTP request was dispatched. $controller = $event->getTarget(); $controllerName = $event->getRouteMatch()->getParam('controller', null); $actionName = $event->getRouteMatch()->getParam('action', null); // Convert dash-style action name to camel-case. $actionName = str_replace('-', '', lcfirst(ucwords($actionName, '-'))); // Get the instance of AuthManager service. $authManager = $event->getApplication()->getServiceManager()->get(AuthManager::class); // Execute the access filter on every controller except AuthController // (to avoid infinite redirect). if ($controllerName!=AuthController::class) { $result = $authManager->filterAccess($controllerName, $actionName); if ($result==AuthManager::AUTH_REQUIRED) { // Remember the URL of the page the user tried to access. We will // redirect the user to that URL after successful login. $uri = $event->getApplication()->getRequest()->getUri(); // Make the URL relative (remove scheme, user info, host name and port) // to avoid redirecting to other domain by a malicious user. $uri->setScheme(null) ->setHost(null) ->setPort(null) ->setUserInfo(null); $redirectUrl = $uri->toString(); // Redirect the user to the \"Login\" page. return $controller->redirect()->toRoute('login', [], ['query'=>['redirectUrl'=>$redirectUrl]]); } else if ($result==AuthManager::ACCESS_DENIED) { // Redirect the user to the \"Not Authorized\" page. return $controller->redirect()->toRoute('not-authorized'); } } } }","title":"Modifying the Dispatch Event Listener"},{"location":"roles/#adding-access-controller-plugin-and-view-helper","text":"To query RbacManager inside of controllers and view templates, we need to create a special controller plugin (which we will name Access ) and a special view helper (which we will name Access too).","title":"Adding Access Controller Plugin and View Helper"},{"location":"roles/#access-controller-plugin","text":"Sometimes it is required to check some permission inside the controller. For example, this is needed for the profile.own.view permission, which uses the dynamic assertion. For this purpose, we will create the Access controller plugin. The plugin code will be located inside the AccessPlugin.php file inside the Controller/Plugin directory of the User module's source directory: <?php namespace User\\Controller\\Plugin; use Laminas\\Mvc\\Controller\\Plugin\\AbstractPlugin; /** * This controller plugin is used for role-based access control (RBAC). */ class AccessPlugin extends AbstractPlugin { private $rbacManager; public function __construct($rbacManager) { $this->rbacManager = $rbacManager; } /** * Checks whether the currently logged in user has the given permission. * @param string $permission Permission name. * @param array $params Optional params (used only if an assertion is associated with permission). */ public function __invoke($permission, $params = []) { return $this->rbacManager->isGranted(null, $permission, $params); } } The Access plugin's factory looks like the following: <?php namespace User\\Controller\\Plugin\\Factory; use Interop\\Container\\ContainerInterface; use Laminas\\ServiceManager\\Factory\\FactoryInterface; use User\\Service\\RbacManager; use User\\Controller\\Plugin\\AccessPlugin; /** * This is the factory for AccessPlugin. Its purpose is to instantiate the plugin * and inject dependencies into its constructor. */ class AccessPluginFactory implements FactoryInterface { public function __invoke(ContainerInterface $container, $requestedName, array $options = null) { $rbacManager = $container->get(RbacManager::class); return new AccessPlugin($rbacManager); } } The plugin is registered inside the module.config.php file as follows: // We register module-provided controller plugins under this key. 'controller_plugins' => [ 'factories' => [ Controller\\Plugin\\AccessPlugin::class => Controller\\Plugin\\Factory\\AccessPluginFactory::class, ], 'aliases' => [ 'access' => Controller\\Plugin\\AccessPlugin::class, ], ], So, in your controller's action, you can easily call this plugin like the following: if (!$this->access('profile.own.view', ['user'=>$user])) { return $this->redirect()->toRoute('not-authorized'); }","title":"Access Controller Plugin"},{"location":"roles/#access-view-helper","text":"Sometimes, it may be required to query the RbacManager inside a view template. For example, you may need to hide or show some HTML block based on current user's permissions. To do that, we will implement the Access view helper. The view helper's code will be located inside the Access.php file inside the View/Helper directory of the User module's source directory: <?php namespace User\\View\\Helper; use Laminas\\View\\Helper\\AbstractHelper; /** * This view helper is used to check user permissions. */ class Access extends AbstractHelper { private $rbacManager = null; public function __construct($rbacManager) { $this->rbacManager = $rbacManager; } public function __invoke($permission, $params = []) { return $this->rbacManager->isGranted(null, $permission, $params); } } The Access view helper's factory looks like the following: <?php namespace User\\View\\Helper\\Factory; use Interop\\Container\\ContainerInterface; use Laminas\\ServiceManager\\Factory\\FactoryInterface; use User\\Service\\RbacManager; use User\\View\\Helper\\Access; /** * This is the factory for Access view helper. Its purpose is to instantiate the helper * and inject dependencies into its constructor. */ class AccessFactory implements FactoryInterface { public function __invoke(ContainerInterface $container, $requestedName, array $options = null) { $rbacManager = $container->get(RbacManager::class); return new Access($rbacManager); } } The view helper is registered inside the module.config.php config file as follows: // We register module-provided view helpers under this key. 'view_helpers' => [ 'factories' => [ View\\Helper\\Access::class => View\\Helper\\Factory\\AccessFactory::class, ], 'aliases' => [ 'access' => View\\Helper\\Access::class, ], ], So, you can easily call the view helper from any of your view templates as follows: if ($this->access('profile.own.view, ['user'=>$user]))) { // do something... }","title":"Access View Helper"},{"location":"roles/#using-the-user-module","text":"Congratulations, now our Role Demo is ready, so we make some resume of how you typically use it if you plan to base your own website on it. First of all, you need to create all needed roles and permissions through the convenient user interface that we created. Assign a role (or several roles) to each website user. Then edit the module.config.php configuration configuration file in your module and add two keys: the rbac_manager key will contain settings for the RbacManager (particularly the configuration of assertion manager(s)); An example of that key is presented below: // This key stores configuration for RBAC manager. 'rbac_manager' => [ 'assertions' => [Service\\RbacAssertionManager::class], ], the access_filter key stores the access rules for the pages of your website. It typically looks like below: 'access_filter' => [ 'options' => [ 'mode' => 'restrictive' ], 'controllers' => [ Controller\\IndexController::class => [ // Allow anyone to visit \"index\" and \"about\" actions ['actions' => ['index', 'about'], 'allow' => '*'], // Allow authorized users to visit \"settings\" action ['actions' => ['settings'], 'allow' => '@'] ], ] ], The * and @ in the allow subkeys are not the only options. You can make the allow subkeys to look as follows. We allow access to the page to: anyone if we specify the asterisk ( * ); any authenticated user if we specify the \"commercial at\" ( @ ); a concrete authenticated user with the given identity email address if we specify ( @identity ) any authenticated user with the given permission if we specify the plus sign followed by the permission name ( +permission ). If your website has some dynamic assertions, extend the assert() method of the existing RbacAssertionManager class (or write and register your own assertion manager): public function assert(Rbac $rbac, $permission, $params) { $currentUser = $this->entityManager->getRepository(User::class) ->findOneByEmail($this->authService->getIdentity()); if ($permission=='post.own.edit' && $params['post']->getUser()->getId()==$currentUser->getId()) return true; if ($permission=='post.own.publish' && $params['post']->getUser()->getId()==$currentUser->getId()) return true; return false; } If you want to check permissions in a controller action, you can use the Access controller plugin as follows: if (!$this->access('profile.own.view', ['user'=>$user])) { return $this->redirect()->toRoute('not-authorized'); } If you want to check permissions in a view template, you can use the Access view helper: if ($this->access('profile.own.view', ['user'=>$user))) { // do something... } That's all! That simple! Enjoy!","title":"Using the User Module"},{"location":"roles/#summary","text":"In this chapter we have implemented the Role Demo website which demonstrates how to use roles and permissions in Laminas. A role is basically a group of users. A user may be assigned with one or several roles at once. A role may be assigned one or more permissions. A permission is a single action in the system. A dynamic assertion is an additional rule associated with the permission. Roles may be organised into an hierarchy, when parent roles inherit permissions from their child roles.","title":"Summary"},{"location":"routing/","text":"Routing When a site user enters a URL in a web browser, the HTTP request is finally dispatched to controller's action in your laminas-based website. In this chapter, we will learn about how laminas-based application maps page URLs to controllers and their actions. This mapping is accomplished with the help of routing. Routing is implemented as a part of @ Laminas\\Router component. Laminas components covered in this chapter: Component Description @ Laminas\\Router Implements support of routing. @ Laminas\\Barcode Auxiliary component implementing barcodes. URL Structure To better understand routing, we first need to look at the URL structure. A typical URL from an HTTP request consists of several parts. There are scheme, host name, path, fragment and query parts. For example, let's look at the URL \"http://site1.yourserver.com/path/to/page?a=1&b=2#section\" (figure 5.1). This URL begins with the scheme (the scheme typically looks like http or https ). Then, the host name follows which is the domain name of your web server (like site1.yourserver.com ). Optional path segments (separated by '/' character) follow the host name. So if you have the path part \"/path/to/page\" then \"path\", \"to\", and \"page\" would each be a path segment. Next, after the question mark, the optional query part follows. It consists of one or several \"name=value\" parameters separated from each other by an ampersand character ('&'). Finally, after the hash ('#'), we have the fragment name. Each part in a URL uses special character encoding, which is named the URL encoding . This encoding ensures that the URL contains only \"safe\" characters from the ASCII 1 table. If a URL contains unsafe characters, they are replaced with a percentage character ('%') followed by two hexadecimal digits (for example, the space character will be replaced by '%20'). Route Types Routing is a mechanism which allows to map HTTP request to a controller's action. With routing, Laminas knows which of the controller's action method to execute as the result of the request. For example, you can map \"http://localhost/\" URL to IndexController::indexAction() method, and \"http://localhost/about\" URL to IndexController::aboutAction() method. You define the mapping between URLs and controllers with the help of routes . There are several standard route types provided by Laminas Framework (shown in table 5.1). These route types are implemented as classes living in the @ Laminas\\Router\\Http [Laminas\\Router] namespace. Route Type Description Literal Exact matching against the path part of a URL. Segment Matching against a path segment (or several segments) of a URL. Regex Matching the path part of a URL against a regular expression template. Hostname Matching the host name against some criteria. Scheme Matching URL scheme against some criteria. Method Matching an HTTP method (e.g. GET, POST, etc.) against some criteria. Table 5.1. Route Types Each route type in the table above (except the Method type) may be matched against a specific part (or several parts) of a URL. The Method route type is matched against the HTTP method (either GET or POST) retrieved from HTTP request. Combining Route Types Routes may be combined with the help of \"aggregate\" route types (shown in table 5.2). The compound route types allow to define arbitrarily complex URL mapping rules. Route Type Description SimpleRouteStack Aggregates different route types in a list with priorities. TreeRouteStack Aggregates different route types in a tree-like structure. Part Aggregates different route types in a subtree. Chain Aggregates different route types in a chain (degenerated subtree). Table 5.2. Aggregate Route Types The @ TreeRouteStack [Laminas\\Router\\Http\\TreeRouteStack] and @ SimpleRouteStack [Laminas\\Router\\SimpleRouteStack] are used as the \"top-level\" route types. The SimpleRouteStack allows to organize different routes in a priority list. The TreeRouteStack allows to nest different routes, forming a \"tree\". Figure 5.2 shows the route class inheritance diagram. As you can see from the image, all route classes are inherited from @ RouteInterface [Laminas\\Router\\RouteInterface] interface (we will learn this interface in details in the Writing Own Route Type section later in this chapter). The @ SimpleRouteStack [Laminas\\Router\\SimpleRouteStack] is a parent class for @ TreeRouteStack [Laminas\\Router\\Http\\TreeRouteStack] class, which inherits the behavior of the simple route stack (allows to organize routes in priority list) and extends it (allows to organize routes in subtrees). The @ Part [Laminas\\Router\\Http\\Part] and @ Chain [Laminas\\Router\\Http\\Chain] classes are derived from @ TreeRouteStack [Laminas\\Router\\Http\\TreeRouteStack] class and are used internally by the @ TreeRouteStack [Laminas\\Router\\Http\\TreeRouteStack] for building subtrees and chains of child routes. Simple Route Stack The @ SimpleRouteStack [Laminas\\Router\\SimpleRouteStack] allows to combine different routes in a priority list. For an example of such a list, look at the route stack in the left part of figure 5.3. The example list contains several Literal routes and several Segment routes. When matching against the HTTP request, the @ SimpleRouteStack [Laminas\\Router\\SimpleRouteStack] walks through the list of routes and tries to match each route in turn. Each route in the list has a priority; the routes with the higher priority are visited first. The lookup is finished once some route matches the HTTP request. If none of the routes match, the \"not found\" error is raised. Tree Route Stack The @ TreeRouteStack [Laminas\\Router\\Http\\TreeRouteStack] class extends the @ SimpleRouteStack [Laminas\\Router\\SimpleRouteStack] class, which means it can organize routes in a priority list, plus it provides an ability to nest routes in subtrees and chains. An example tree route stack is presented in the right part of figure 5.3. The list contains of one @ Literal [Laminas\\Router\\Http\\Literal] route, a chain of @ Literal [Laminas\\Router\\Http\\Literal] and @ Segment routes, and a subtree consisting of two branches: a branch containing a single @ Segment route, and a branch consisting of @ Scheme , @ Hostname [Laminas\\Router\\Http\\Hostname] and @ Segment routes. The tree route stack performs request matching in the following way. It walks through its priority list items (denoted by dashed lines in figure 5.3), starting from high-priority routes. If a certain item is a @ Chain [Laminas\\Router\\Http\\Chain] route or a @ Part [Laminas\\Router\\Http\\Part] route, it processes such a nested route from its parent route to children. If the parent route matches, the children (denoted with solid lines) are analyzed then. The nested route is considered matching if at least one route matches in each tree (or chain) level. Each route in a tree (or chain) consumes a part of the URL (figure 5.4). The parent route is matched against the first part of the URL, its child is matched again the next part, and so on, until the end of the URL string is reached. Routing Configuration You typically do not create the route stack (or tree) yourself, instead you provide the instructions for Laminas on how to do that. The routing configuration for a module is stored in module.config.php configuration file: <?php use Laminas\\Router\\Http\\TreeRouteStack; return [ //... 'router' => [ 'router_class' => TreeRouteStack::class, 'routes' => [ // Register your routing rules here... ], 'default_params' => [ // Specify default parameters here for all routes here ... ] ], ]; Above, in line 6 we have the router key, under which there is the routes subkey (line 8), containing the routing rules. You can specify which top-level route class to use (either @ TreeRouteStack [Laminas\\Router\\Http\\TreeRouteStack] or @ SimpleRouteStack [Laminas\\Router\\SimpleRouteStack]) with the router_class parameter (line 7). If this parameter is not present, the @ TreeRouteStack [Laminas\\Router\\Http\\TreeRouteStack] is used by default. You can use the optional default_params key (line 11) to define the default values for parameters for all routes at once. However, you typically do not use this key and define the defaults on a per-route basis. Note We will show how you extract parameters from route later in this chapter. Configuration for Simple Routes A typical route has the name , type and options : The name is used to uniquely identify the route. The type defines the fully qualified name of the route type (PHP class which implements the matching algorithm). The options is an array that includes the route string which should be compared against the URL part, and several parameters called the defaults . Configuration for each route under the routes subkey may have the following format: '<route_name>' => [ 'type' => '<route_type_class>', 'priority' => <priority>, 'options' => [ 'route' => '<route>', 'defaults' => [ //... ], ], ] Above, the <route_name> placeholder should be the name of the route. A route name must be in lower case, like \"home\" or \"about\". The type key specifies the fully qualified route class name. The optional priority key allows to define the priority (which should be an integer number) of the route in the priority list (routes with higher priority will be visited first). If you omit the priority key, the routes will be visited in the LIFO 2 order. Note Routes having equal priority will be visited in the LIFO order. Thus, for the best performance, you should register routes that will match most often in the last turn, and least common routes should be registered first. The options key defines the array of route's options. We will discuss the options in the following sections of this chapter. Configuration for Nested Routes To organize routes in a subtree, you add the child_routes key to the route definition, and add your child routes under that key, like below: '<route_name>' => [ 'type' => '<route_type_class>', 'priority' => <priority>, 'options' => [ //... ], 'child_routes' => [ // Add child routes here. // ... ] ], If you need to organize the routes in a chain (degenerated subtree), you add the chain_routes key to your route configuration: '<route_name>' => [ 'type' => '<route_type_class>', 'priority' => <priority>, 'options' => [ //... ], 'chain_routes' => [ // Add chained routes here. // ... ] ], Note Looking at the two examples above, you won't see the explicit usage of @ Part [Laminas\\Router\\Http\\Part] and @ Chain [Laminas\\Router\\Http\\Chain] route types, because (for your convenience) they are used by the Laminas automatically when it encounters the child_routes and chain_routes keys in your routing configuration. Default Routing Configuration in Laminas Skeleton Application Now that you know how to configure routes and organize them in compound structures, let's look at the real life example. In a fresh Laminas Skeleton Application, the routing configuration looks like below: <?php use Laminas\\Router\\Http\\Literal; use Laminas\\Router\\Http\\Segment; return [ 'router' => [ 'routes' => [ 'home' => [ 'type' => Literal::class, 'options' => [ 'route' => '/', 'defaults' => [ 'controller' => Controller\\IndexController::class, 'action' => 'index', ], ], ], 'application' => [ 'type' => Segment::class, 'options' => [ 'route' => '/application[/:action]', 'defaults' => [ 'controller' => Controller\\IndexController::class, 'action' => 'index', ], ], ], ], ], //... ]; In the configuration presented above, we have two routing rules listed in turn: first we have the \"home\" route (line 8) and then we have the \"application\" route (line 18). The \"home\" route maps the empty URL path to the \"index\" action of the IndexController controller. For example, enter \"http://localhost/\" in your browser to see the Home page of your website. This route is of type \"Literal\". The \"application\" route (of type \"Segment\") maps URLs looking like \"http://localhost/application\", \"http://localhost/application/about\", \"http://localhost/application/news\", etc onto the corresponding action of the IndexController controller. The actual action name is determined by the \"action\" parameter. The default value for this parameter is \"index\". That means that if you do not specify any action, the request will be dispatched to \"index\" action. This configuration corresponds to the tree route stack shown in figure 5.5: In the next sections, we will provide some examples on how to use the route types in your website. Literal Route Type With Literal route type, the route match is achieved only when you have the exact match of the route string against the URL path part. You typically use the Literal type for URLs which should be short and memorable, like '/about' or '/news'. Below, the definition of the route named \"home\" is presented. The \"home\" route is usually mapped to the \"index\" action of the IndexController and points to the Home page of your site: 'home' => [ 'type' => Literal::class, 'options' => [ 'route' => '/', 'defaults' => [ 'controller' => Controller\\IndexController::class, 'action' => 'index', ], ], ], Line 2 of this example says that the route's type is Literal . The actual route matching algorithm is implemented in the @ Laminas\\Router\\Http\\Literal class. Line 4 defines the route string to match against the URL path (the forward slash '/' means the empty URL part). Because we have the literal route type, the route match is achieved only when you have the exact literal path match. For example, if you have the URL \"http://localhost/\" or \"http://localhost\", it will match the '/' route string. Lines 5-8 define the defaults , which are the parameters returned by the router if the route matches. The controller and action parameters define the controller and controller's action method which should be executed. You can also define other parameters here, if needed. As another example of the Literal route type, let's add the '/about' route for the About page we've created earlier in the Views section of the chapter Model-View-Controller . To create the route, add the following lines right after the \"home\" route definition inside of your module.config.php file: 'about' => [ 'type' => Literal::class, 'options' => [ 'route' => '/about', 'defaults' => [ 'controller' => Controller\\IndexController::class, 'action' => 'about', ], ], ], If you now open the \"http://localhost/about\" URL in your web browser, you should see the About page. Segment Route Type The Segment route type allows for matching the route string against one or several URL path segments. Note If you look at the module.config.php file, you can see the Segment route type is used inside of the \"application\" route to make actions of your IndexController automatically mapped to site URLs. You just add an action method to your IndexController class, and it becomes available by a URL like \"http://localhost/application/<action>\". For example, you can see the About page of your site with the following URL: \"http://localhost/application/about\". To demonstrate the creation of the Segment route type, let's implement a controller action which will generate a simple barcode image. The barcodes may be of different types and have different labels. We will use the Segment route type to map the action to a URL like \"http://localhost/barcode/<type>/<label>\". Note Barcodes are widely used in supermarkets for optically recognizing goods in your shopping cart. To be able to use barcodes, you need to install the @ Laminas\\Barcode component with Composer, by typing the following command: php composer.phar require laminas/laminas-barcode Note Please note that for barcode images to work, you need to have the GD 3 extension of the PHP engine installed and enabled. In Linux Ubuntu, you can install this extension with the following command: sudo apt-get install php-gd After installing the extension, restart Apache to apply your changes. First, we define the \"barcode\" route in the module.config.php file: 'barcode' => [ 'type' => Segment::class, 'options' => [ 'route' => '/barcode[/:type/:label]', 'constraints' => [ 'type' => '[a-zA-Z][a-zA-Z0-9_-]*', 'label' => '[a-zA-Z0-9_-]*' ], 'defaults' => [ 'controller' => Controller\\IndexController::class, 'action' => 'barcode', ], ], ], Segments of the route string (line 4) may be constant or variable. You can define the variable segments by using \"wildcards\". We have three segments: barcode , :type and :label . The barcode segment is constant, while the latter two are wildcards (wildcard's name should start with a colon). You specify how a wildcard should look like inside of the constraints subkey (lines 5-8). We define the regular expression [a-zA-Z][a-zA-Z0-9_-]* which constraints our :type wildcard to begin with a letter and (optionally) contain several letters, digits, underscores or minus characters. The constraint for the :label wildcard is almost the same, but this segment can start with any allowed character (either letter, digit, underscore or minus sign character). Optional segments can be enclosed in square brackets. In our example, we have both the :type and :label segments as optional. In lines 9-12, we define the defaults , the parameters that will be returned by the router. The controller and action defaults specify which controller and action method to execute on route match. Next, we add the barcodeAction() method into the IndexController class: // Add name alias in the beginning of the file use Laminas\\Barcode\\Barcode; // ... // The \"barcode\" action public function barcodeAction() { // Get parameters from route. $type = $this->params()->fromRoute('type', 'code39'); $label = $this->params()->fromRoute('label', 'HELLO-WORLD'); // Set barcode options. $barcodeOptions = ['text' => $label]; $rendererOptions = []; // Create barcode object $barcode = Barcode::factory($type, 'image', $barcodeOptions, $rendererOptions); // The line below will output barcode image to standard // output stream. $barcode->render(); // Return Response object to disable default view rendering. return $this->getResponse(); } In lines 10-11 we get the values of the type and label wildcards from route. We do that with the help of @ Params controller plugin's fromRoute() method. Analogous to fromQuery() method, it takes two arguments: the variable name and its default value. For generating the barcode image, we use the @ Laminas\\Barcode component. In line 14 we define the label text for the barcode. In lines 18-19 we create the @ Barcode [Laminas\\Barcode\\Barcode] object with the factory method. Finally, in line 23 we render the image file by dumping it to PHP output stream. Note @ Laminas\\Barcode is an auxiliary component used for generation of various barcode images. For additional information about this component, please refer to the corresponding section of Laminas Framework reference manual. In line 26 we return the @ Response [Laminas\\Http\\PhpEnvironment\\Response] object to suppress the default view rendering. Now, enter the \"http://localhost/barcode\" URL into your browser to see the barcode image (shown in figure 5.6): Because we have the wildcards in the route, you can pass the type and label parameters of the barcode image in the URL. Below, several URL examples are provided (corresponding barcodes are presented in figure 5.7): a. http://localhost/barcode/code39/HELLO-WORLD b. http://localhost/barcode/leitcode/12345 c. http://localhost/barcode/identcode/98765453212 d. http://localhost/barcode/postnet/123456 e. http://localhost/barcode/planet/1234567890123 f. http://localhost/barcode/upca/12345678901 g. http://localhost/barcode/code128/ABCDEF h. http://localhost/barcode/ean2/12 Regex Route Type The regular expression route type ( Regex ) is useful if you have URLs which can be matched against a regular expression. For example, assume you want to create a simple documentation system for your website. The documentation would consist of \"static\" pages mapped to URLs like /doc/<page_name>.html . Note By the term \"static page\" we refer to a page which mostly contains static HTML code plus several PHP inline fragments. For such simple pages you do not need to create separate controller actions. All \"static\" pages can be served by the single controller action. Let's implement the route which will serve the \"static\" pages of the site. Because \"static\" pages are simple, you typically won't need to add per-page action methods to the controller. All pages will be handled by the single action IndexController::docAction() . First, we add the Regex route named \"doc\" to the module.config.php file: 'doc' => [ 'type' => Regex::class, 'options' => [ 'regex' => '/doc(?<page>\\/[a-zA-Z0-9_\\-]+)\\.html', 'defaults' => [ 'controller' => Controller\\IndexController::class, 'action' => 'doc', ], 'spec'=>'/doc/%page%.html' ], ], Line 2 defines the Regex type for the route. In line 4, we have the regular expression /doc(?<page>\\/[a-zA-Z0-9_\\-]+)\\.html . It will match to URLs like \"/doc/contents.html\", \"/docs/introduction.html\" and so on. The expression contains the named capture 4 \"page\", which will be returned by the router on match together with the default parameters. Line 9 contains spec option, which is used for generating URLs by route (we will discuss generating URLs by route later in this chapter). Do not forget to add the following line to the beginning of module.config.php file: use Laminas\\Router\\Http\\Regex; Next, add the following action to IndexController class: public function docAction() { $pageTemplate = 'application/index/doc'. $this->params()->fromRoute('page', 'documentation.phtml'); $filePath = __DIR__.'/../../view/'.$pageTemplate.'.phtml'; if(!file_exists($filePath) || !is_readable($filePath)) { $this->getResponse()->setStatusCode(404); return; } $viewModel = new ViewModel([ 'page'=>$pageTemplate ]); $viewModel->setTemplate($pageTemplate); return $viewModel; } In lines 3-4 above, we retrieve the page parameter from route (remember the \"page\" named capture from our regular expression?) and save it as the $pageTemplate variable. We will use the $pageTemplate variable for determining the view template name to pass to the view resolver. Then, in lines 6-10, we check if such a file is present, and if not, return the 404 \"Not Found\" status code, which will force Laminas to display the error page. In line 12, we create the @ ViewModel [Laminas\\View\\Model\\ViewModel] variable container, and in line 15 we explicitly set the view template name for rendering. To see the documentation system in action, create a couple of \"static\" view template files: the Table of Contents page ( contents.phtml ) and the Introduction page ( introduction.phtml ). Create the doc subdirectory under the view/application/index directory of the Application module and put the contents.phtml view template there: <h1>Table of Contents</h1> <ul> <li> <a href=\"<?= $this->url('doc', ['page'=>'introduction']); ?>\"> Introduction </a> </li> </ul> In the lines above, we provide the HTML code for the \"Table of Contents\" page header, and the list which contains the single item named \"Introduction\" pointing to the Introduction \"static\" page. The link URL is generated with the @ Url [Laminas\\View\\Helper\\Url] view helper (for more details on the Url [Laminas\\View\\Helper\\Url] helper, see further sections in this chapter). Then add the introduction.phtml page into the same doc directory: <h1>Introduction</h1> <p>Some introductory materials.</p> In the lines above, we define the HTML markup for the simple Introduction page. Now, if you open the \"http://localhost/doc/contents.html\" URL in your browser, you should see a nice simple documentation system which you can extend and use in your site (figure 5.8): Clicking the Introduction link will direct you to the \"Introduction\" static page. You can also add other pages to the doc directory to make them automatically available for site users through our Regex route. Note One disadvantage of such a documentation system is that it does not work well if you place nested pages in subdirectories under the doc directory. The reason of this limitation lies in the way the Regex route assembles URLs. You can't generate URLs containing slash characters, as these \"unsafe\" characters will be automatically URL-encoded. We will work-around this problem with our custom route type that we will create at the end of this chapter. Other Route Types The Hostname , Scheme , and Method route types are used less commonly compared to the route types mentioned previously. Hostname The Hostname route type can be used, for example, if you develop a content management system (CMS) 5 engine, which should serve several websites at once, each site using a different sub-domain. In that case you will define the Hostname route as the parent, and nest child routes of other types inside of it: 'routename' => [ 'type' => Hostname::class, 'options' => [ 'route' => ':subdomain.yourserver.com', 'constraints' => [ 'subdomain' => '[a-zA-Z][a-zA-Z0-9_-]*' ], 'defaults' => [ ], ], 'child_routes'=>[ //... ], ], In the example above, in line 1 we define the route which has the Hostname type. The route option (line 4) defines the domain name to match against. The :subdomain is a wildcard, which can take different sub-domain values. The constraints key defines the regular expression this sub-domain parameter must match. The Hostname route will differentiate your domains, so each site will behave differently, depending on the value of the subdomain parameter returned: // An example of an action that uses parameters returned by // Hostname route. public function someAction() { // Get the 'subdomain' parameter from the route. $subdomain = $this->params()->fromRoute('subdomain', null); // Use different logic based on sub-domain. //... // Render the view template. return new ViewModel(); } Scheme The Scheme route type is useful if you need to handle HTTP and HTTPS 6 protocols in different ways. The typical Scheme route configuration is presented below: 'routename' => [ 'type' => Scheme::class, 'options' => [ 'scheme' => 'https', 'defaults' => [ 'https' => true, ], ], 'child_routes'=>[ //... ], ], Above, we define the route of type Scheme . It takes the scheme option, which should be the scheme to match against (like http or https ). If the scheme in HTTP request's URL is exactly the same as the scheme option, the route is considered matching. You can use the defaults key to return some parameters on route match. In the example above, the https boolean parameter will be returned. Method The Method route type can be used if you need to direct GET and POST requests into different controller's actions. Its typical configuration is presented below: 'routename' => [ 'type' => Method::class, 'options' => [ 'verb' => 'post', 'defaults' => [ ], ], 'child_routes'=>[ //... ], ], Above, we define the route which has the Method type. It takes the verb option, which may be the comma-separated list of acceptable HTTP verbs (like get , post , put , etc.) Extracting Parameters from Route On route match, the router (top-level route class) returns some parameters: the \"defaults\" (parameters listed in the defaults section of routing configuration) plus any wildcard parameters extracted from URL string. In your controller, you will often need to retrieve these parameters. We already did this in the examples above. In this section, we will give some summary. To retrieve a parameter from the route in your controller's action method, you typically use the @ Params controller plugin and its fromRoute() method, which takes two arguments: the name of the parameter to retrieve and the value to return if the parameter is not present. The fromRoute() method can also be used to retrieve all parameters at once as an array. To do that, call the fromRoute() without arguments, as shown in the example below: // An example action. public function someAction() { // Get the single 'id' parameter from route. $id = $this->params()->fromRoute('id', -1); // Get all route parameters at once as an array. $params = $this->params()->fromRoute(); //... } Retrieving the RouteMatch and the Router Object On route match, the router class internally creates an instance of @ Laminas\\Router\\RouteMatch class, providing the methods for extracting the matched route name and parameters extracted from route. The useful methods of the @ RouteMatch [Laminas\\Router\\RouteMatch] class are listed in table 5.3: Method Name Description getMatchedRouteName() Gets the name of matched route. getParams() Get all parameters. getParam($name, $default) Get a specific parameter. Table 5.3. Laminas\\Router\\RouteMatch class methods Note In most cases, it will be sufficient to use the @ Params controller plugin, but alternatively you can use the @ RouteMatch [Laminas\\Router\\RouteMatch] object for accomplishing the same task. To get the @ RouteMatch [Laminas\\Router\\RouteMatch] object from your controller's action method, you can use the following code: // An example action. public function someAction() { // Get the RouteMatch object. $routeMatch = $this->getEvent()->getRouteMatch(); // Get matched route's name. $routeName = $routeMatch->getMatchedRouteName(); // Get all route parameters at once as an array. $params = $routeMatch->getParams(); //... } In line 5 of the code above, we use the getEvent() method of the AbstractActionController base class to retrieve the @ MvcEvent object, which represents the event (in Laminas, the application life cycle consists of events). We then use the getRouteMatch() method of the @ MvcEvent class to retrieve the RouteMatch object. In line 8, we use the getMatchedRouteName() method to retrieve the name of the route that matched the HTTP request, and in line 11 we retrieve all the parameters from the route. The @ MvcEvent class can also be used for retrieving the router (the top-level route class). You can do this with the getRouter() method of the @ MvcEvent class, as below: // Call this inside of your action method // to retrieve the RouteStackInterface for the router class. $router = $this->getEvent()->getRouter(); In the code above, we use the getRouter() method, which returns the @ RouteStackInterface interface. This interface is the base interface for both @ SimpleRouteStack [Laminas\\Router\\SimpleRouteStack] and @ TreeRouteStack [Laminas\\Router\\Http\\TreeRouteStack], and it provides the methods for working with the routes contained inside the route stack. Generating URLs from Route The main task of any route class is to determine whether this given route matches the HTTP request, and on match return the set of parameters by which a controller and action can be determined. An opposite task a route class allows to generate a URL by parameters. This feature can be used in your controller action methods for generating URLs, for example, for redirecting a user to another page. It can also be used inside view templates for generating hyperlinks. Generating URLs in View Templates Your web pages usually contain hyperlinks to other pages. These links may point either to a page internal to your site or to a page on another site. A hyperlink is represented by <a> HTML tag having href attribute specifying the URL of the destination page. Below, an example of a hyperlink pointing to an external page is presented: <a href=\"http://example.com/path/to/page\">A link to another site page</a> When you generate a hyperlink to a resource internal to your site, you typically use relative URL (without host name): <a href=\"/path/to/internal/page\">A link to internal page</a> To generate URLs in your view templates ( .phtml files), you can use the @ Url [Laminas\\View\\Helper\\Url] view helper class, which takes the route name as an input argument: <!-- A hyperlink to Home page --> <a href=\"<?= $this->url('home'); ?>\">Home page</a> <!-- A hyperlink to About page --> <a href=\"<?= $this->url('about'); ?>\">About page</a> In the lines above, we generate two relative URLs. In line 2, we call the @ Url [Laminas\\View\\Helper\\Url] view helper and pass the \"home\" route name as its parameter. In line 5, we pass the \"about\" route name as an argument for the @ Url [Laminas\\View\\Helper\\Url] view helper. Note In the example above, the @ Url [Laminas\\View\\Helper\\Url] view helper internally uses the @ RouteMatch [Laminas\\Router\\RouteMatch] object and calls the @ Literal [Laminas\\Router\\Http\\Literal] route to assemble the URL string by route name. After the @ PhpRenderer class executes the view template's code, the output HTML markup will be the following: <!-- A hyperlink to Home page --> <a href=\"/\">Home page</a> <!-- A hyperlink to About page --> <a href=\"/about\">About page</a> Passing Parameters If a route uses some variable parameters, you should pass them to the @ Url [Laminas\\View\\Helper\\Url] view helper as the second argument: <!-- A hyperlink to About page --> <a href=\"<?= $this->url('application', ['action' => 'about']); ?>\" > About page </a> <!-- A hyperlink to Barcode image --> <a href=\"<?= $this->url('application', ['action' => 'barcode', 'type' => 'code39', 'text' => 'HELLO-WORLD']); ?>\" > Barcode image </a> In the example above, we use @ Url [Laminas\\View\\Helper\\Url] view helper to generate the two URLs by route name and parameters. We pass the \"application\" route name as the first argument, and an array of parameters as the second argument. In line 2, we pass the \"action\" parameter to tell the Segment route class that it should substitute the corresponding wildcard in the route string with the \"about\" string. After the @ PhpRenderer class executes the view template's code, the output HTML markup will be the following: <!-- A hyperlink to About page --> <a href=\"/application/about\" > About page </a> <!-- A hyperlink to Barcode image --> <a href=\"/application/barcode/code39/HELLO-WORLD\" > Barcode image </a> As another example, let's try to generate a URL for our Regex route (the one which serves our \"static\" pages): <!-- A hyperlink to Introduction page --> <a href=\"<?= $this->url('doc', ['page'=>'introduction']); ?>\"> Introduction </a> This will generate the following HTML markup: <!-- A hyperlink to Introduction page --> <a href=\"/doc/introduction.html\"> Introduction </a> Generating Absolute URLs If you need to generate an absolute URL (having the scheme and host name), you can specify the third parameter for the @ Url [Laminas\\View\\Helper\\Url] view helper. The third parameter should be an array containing one or several options. For assembling the absolute URL, pass the force_canonical option, as in the example below: <!-- A hyperlink to Home page --> <a href=\"<?= $this->url('home', [], ['force_canonical' => true]); ?>\" > Home page </a> <!-- A hyperlink to About page --> <a href=\"<?php echo $this->url('application', ['action' => 'about'], ['force_canonical' => true]); ?>\" > About page </a> In line 2 of the example above, we pass the \"home\" route name as the first argument, empty array as the second argument, and an array containing force_canonical option as the third argument. In lines 6-7, we also pass the force_canonical option as the third argument for generating the URL of the About page. The resulting HTML markup of the code above will be as follows: <!-- A hyperlink to Home page --> <a href=\"http://localhost/\" > Home page </a> <!-- A hyperlink to About page --> <a href=\"http://localhost/application/index/about\" > About page </a> Specifying Query Part If you want your URL to have a query part, you can specify the query option in the third argument of the Url view helper. For example, assume you have the \"search\" action in some controller (and a route mapped to this action), and you want to pass it search query string and count of output results per page. The URL for this action would be like this: \"http://localhost/search?q=topic&count=10\". To generate such a URL, you can use the following code: <a href=\"<?= $this->url('search', [], ['force_canonical' => true, 'query'=>['q'=>'topic', 'count'=>10]]); ?>\" > Search </a> In the code above, we specified the query option, which is the array containing name=>value pairs of the query parameters. Generating URLs in Controllers You can generate URLs inside your controller's action methods using the Url controller plugin. To generate a URL, you call the @ Url [Laminas\\Mvc\\Controller\\Plugin\\Url] controller plugin's fromRoute() method, as in the example below: // An example action method public function someAction() { // Generate a URL pointing to the Home page ('/') $url1 = $this->url()->fromRoute('home'); // Generate an absolute URL pointing to the About page // ('http://localhost/application/about') $url2 = $this->url()->fromRoute('application', ['action'=>'about'], ['force_canonical'=>true]); } Note The arguments the Url plugin takes and their meaning are identical to the @ Url [Laminas\\View\\Helper\\Url] view helper's ones. So, you can generate absolute or relative URLs the same way you did in your view templates. URL Encoding When generating URLs either with the @ Url [Laminas\\View\\Helper\\Url] view helper or with the @ Url [Laminas\\Mvc\\Controller\\Plugin\\Url] controller plugin, you should remember that URLs may only contain \"safe\" characters from ASCII character set. Thus, if you pass the parameter containing unsafe characters, these characters will be replaced with the sequence of the percentage character and two digits. For example, let's try to generate a URL for our Regex route and pass it the \"page\" parameter with the value \"/chapter1/introduction\". <!-- A hyperlink to Introduction page --> <a href=\"<?= $this->url('doc', ['page'=>'chapter1/introduction']); ?>\"> Introduction </a> We could assume it generates the URL like \"/doc/chapter1/introduction.html\". But because the slash ('/') character is unsafe, it will be replaced with the \"%2F\" characters for security reasons, and we will have the following HTML code: <!-- A hyperlink to Introduction page --> <a href=\"/doc/chapter1%2Fintroduction.html\"> Introduction </a> Unfortunately, this hyperlink is unusable, because it won't match our Regex route. Writing Own Route Type Although Laminas provides you with many route types, in some situations, you will need to write your own route type. One example of the need for such a custom route type is when you have to define the URL mapping rules dynamically. Usually, you store the routing configuration in module's config file, but in some CMS systems you will have documents stored in the database. For such a system, you would need to develop a custom route type which would connect to the database and perform route matching against the data stored in the database. You cannot store this information in config file, because new documents are created by system administrators, not programmers. RouteInterface We know that every route class must implement the @ Laminas\\Router\\Http\\RouteInterface interface. The methods of this interface are presented in table 5.4: Method Name Description factory($options) Static method for creation of the route class. match($request) Method which performs match against the HTTP request data. assemble($params, $options) Method for generating URL by route parameters. getAssembledParams() Method for retrieving parameters that were utilized for URL generation. Table 5.4. RouteInterface methods The static factory() method is used by the Laminas router (@ TreeRouteStack [Laminas\\Router\\Http\\TreeRouteStack] or @ SimpleRouteStack [Laminas\\Router\\SimpleRouteStack]) for instantiating the route class. The router passes the options array an argument for the factory() method. The match() method is used to perform the matching of the HTTP request (or, particularly its URL) against the options data passed to the route class through the factory() . The match() method should return either an instance of the RouteMatch class on successful match, or null on failure. The assemble() method is used for generating URL string by route parameters and options. The getAssembledParams() helper method's purpose is to return the array of parameters which were used on URL generation. Custom Route Class To demonstrate the creation of a custom route type, let's improve our previous approach to building the simple documentation system with Regex route type. The disadvantage of the Regex route type is that you cannot organize the static pages in a hierarchy by creating subdirectories under the doc directory (when generating an URL for such a page, the slash directory separator will be URL-encoded making the hyperlink unusable). We will create our custom StaticRoute class that allows to fix this issue. Moreover, the class we will create is more powerful, because it will not only recognize URLs starting with \"/doc\" and ending with \".html\". Instead, it will recognize generic URLs, like \"/help\" or \"/support/chapter1/introduction\". What we want to achieve: The StaticRoute class should be insertable to the route stack (to SimpleRouteStack or to TreeRouteStack ) and usable together with other route types. The route class should recognize generic URLs, like \"/help\" or \"/introduction\". The route class should match the URL against the directory structure. For example, if the URL is \"/chapter1/introduction\", then the route should check if the corresponding view template file <base_dir>/chapter1/introduction.phtml exists and is readable, and if so, report match. If the file does not exist (or not readable), return the failure status. The route class should check the URL for acceptable file names using a regular expression. For example, the file name \"introduction\" is acceptable, but the name \"*int$roduction\" is not. If the file name is not acceptable, the failure status should be returned. The route should be able to assemble the URL string by route name and parameters. To start, create the Route subdirectory under the module's source directory and put the StaticRoute.php file inside of it (figure 5.9). Inside that file, paste the stub code presented below: <?php namespace Application\\Route; use Traversable; use \\Laminas\\Router\\Exception; use \\Laminas\\Stdlib\\ArrayUtils; use \\Laminas\\Stdlib\\RequestInterface as Request; use \\Laminas\\Router\\Http\\RouteInterface; use \\Laminas\\Router\\Http\\RouteMatch; // Custom route that serves \"static\" web pages. class StaticRoute implements RouteInterface { // Create a new route with given options. public static function factory($options = []) { } // Match a given request. public function match(Request $request, $pathOffset = null) { } // Assembles a URL by route params. public function assemble(array $params = [], array $options = []) { } // Get a list of parameters used while assembling. public function getAssembledParams() { } } From the code above, you can see that we placed the StaticRoute class inside the Application\\Route namespace (line 2). In lines 4-9, we define some class name aliases for making the class names shorter. In lines 12-33, we define the stub for the StaticRoute class. The StaticRoute class implements the @ RouteInterface [Laminas\\Router\\RouteInterface] interface and defines all the methods specified by the interface: factory() , match() , assemble() and getAssembledParams() . Next, let's add several protected properties and the constructor method to the StaticRoute class, as shown below: <?php //... class StaticRoute implements RouteInterface { // Base view directory. protected $dirName; // Path prefix for the view templates. protected $templatePrefix; // File name pattern. protected $fileNamePattern = '/[a-zA-Z0-9_\\-]+/'; // Defaults. protected $defaults; // List of assembled parameters. protected $assembledParams = []; // Constructor. public function __construct($dirName, $templatePrefix, $fileNamePattern, array $defaults = []) { $this->dirName = $dirName; $this->templatePrefix = $templatePrefix; $this->fileNamePattern = $fileNamePattern; $this->defaults = $defaults; } // ... } Above, in line 7, we define the $dirName property that is intended for storing the name of the base directory where the \"static\" view templates will be located. In line 10, we define the $templatePrefix class variable for storing the prefix for prepending to all view template names. Line 13 contains the $fileNamePattern variable that will be used for checking the file name. In lines 22-29, we define the constructor method that is called on instance creation for initializing the protected properties. Next, let's implement the factory() method for our StaticRoute custom route class. The factory() method will be called by the router for instantiating the route class: <?php //... class StaticRoute implements RouteInterface { //... // Create a new route with given options. public static function factory($options = []) { if ($options instanceof Traversable) { $options = ArrayUtils::iteratorToArray($options); } elseif (!is_array($options)) { throw new Exception\\InvalidArgumentException(__METHOD__ . ' expects an array or Traversable set of options'); } if (!isset($options['dir_name'])) { throw new Exception\\InvalidArgumentException( 'Missing \"dir_name\" in options array'); } if (!isset($options['template_prefix'])) { throw new Exception\\InvalidArgumentException( 'Missing \"template_prefix\" in options array'); } if (!isset($options['filename_pattern'])) { throw new Exception\\InvalidArgumentException( 'Missing \"filename_pattern\" in options array'); } if (!isset($options['defaults'])) { $options['defaults'] = []; } return new static( $options['dir_name'], $options['template_prefix'], $options['filename_pattern'], $options['defaults']); } } In the code above, we see that the factory() method takes the options array as the argument (line 9). The options array may contain the options for configuring the route class. The StaticRoute class will accept the following options: dir_name - the base directory where to store all \"static\" view templates. template_prefix - the prefix to prepend to all template names. filename_pattern - the regular expression for checking the file names. defaults - parameters returned by router by default. Once we parsed the options, in lines 37-41 we call the class' constructor method to instantiate and return the StaticRoute object. The next method we add to the StaticRoute route class is the match() method: <?php //... class StaticRoute implements RouteInterface { //... // Match a given request. public function match(Request $request, $pathOffset=null) { // Ensure this route type is used in an HTTP request if (!method_exists($request, 'getUri')) { return null; } // Get the URL and its path part. $uri = $request->getUri(); $path = $uri->getPath(); if($pathOffset!=null) $path = substr($path, $pathOffset); // Get the array of path segments. $segments = explode('/', $path); // Check each segment against allowed file name template. foreach ($segments as $segment) { if(strlen($segment)==0) continue; if(!preg_match($this->fileNamePattern, $segment)) return null; } // Check if such a .phtml file exists on disk $fileName = $this->dirName . '/'. $this->templatePrefix.$path.'.phtml'; if(!is_file($fileName) || !is_readable($fileName)) { return null; } $matchedLength = strlen($path); // Prepare the RouteMatch object. return new RouteMatch(array_merge( $this->defaults, ['page'=>$this->templatePrefix.$path] ), $matchedLength); } } In the code above, we see that the match() method takes two arguments: the HTTP request object (an instance of @ Laminas\\Stdlib\\Request class) and the URL path offset. The request object is used for accessing the request URL (line 17). The path offset parameter is a non-negative integer, which points to the portion of the URL the route is matched against (line 21). In line 24, we extract the segments from URL. Then we check if every segment is an acceptable file (directory) name (lines 27-32). If the segment is not a valid file name, we return null as a failure status. In line 35, we calculate the path to the view template, and in lines 37-39 we check if such a file really exists and accessible for reading. This way we match the URL against the directory structure. In lines 44-48, we prepare and return the @ RouteMatch [Laminas\\Router\\RouteMatch] object with the default parameters plus the \"page\" parameter containing the view template name for rendering. To complete the implementation of our StaticRoute class, we add the assemble() and getAssembledParams() methods, that will be used for generation of URLs by route parameters. The code for these methods is presented below: <?php //... class StaticRoute implements RouteInterface { //... // Assembles a URL by route params public function assemble(array $params = [], array $options = []) { $mergedParams = array_merge($this->defaults, $params); $this->assembledParams = []; if(!isset($params['page'])) { throw new Exception\\InvalidArgumentException(__METHOD__ . ' expects the \"page\" parameter'); } $segments = explode('/', $params['page']); $url = ''; foreach($segments as $segment) { if(strlen($segment)==0) continue; $url .= '/' . rawurlencode($segment); } $this->assembledParams[] = 'page'; return $url; } // Get a list of parameters used while assembling. public function getAssembledParams() { return $this->assembledParams; } } In the code above, we define the assemble() method, which takes the two arguments: the parameters array and the options array (line 9). The method constructs the URL by encoding the segments with URL encoding and concatenating them (line 20-26). The method getAssembledParams() just returns the names of the parameters we used for URL generation (line 36). Now we've finished the StaticRoute route class. To use our custom route type, we add the following configuration to the module.config.php configuration file: 'static' => [ 'type' => StaticRoute::class, 'options' => [ 'dir_name' => __DIR__ . '/../view', 'template_prefix' => 'application/index/static', 'filename_pattern' => '/[a-z0-9_\\-]+/', 'defaults' => [ 'controller' => Controller\\IndexController::class, 'action' => 'static', ], ], ], In line 1 of the configuration above, we define the routing rule named \"static\". The type parameter defines the fully qualified StaticRoute class name (line 2). In the options array, we define the base directory where the \"static\" pages will be placed (line 4), the template prefix (line 5), the filename pattern (line 6), and the defaults array, containing the name of the controller and the action that will serve all the static pages. Do not forget to insert the following line to the beginning of the module.config.php class: use Application\\Route\\StaticRoute; The final step is creating the action method in the IndexController class: public function staticAction() { // Get path to view template from route params $pageTemplate = $this->params()->fromRoute('page', null); if($pageTemplate==null) { $this->getResponse()->setStatusCode(404); return; } // Render the page $viewModel = new ViewModel([ 'page'=>$pageTemplate ]); $viewModel->setTemplate($pageTemplate); return $viewModel; } The action above is almost identical to the action we used for the Regex route. In line 4, we retrieve the page parameter from route and save it as the $pageTemplate variable. In line 11, we create the ViewModel variable container, and in line 14 we explicitly set the view template name for rendering. To see the system in action, let's add a couple of \"static\" view pages: the Help page ( help.phtml ) and the introduction page ( intro.phtml ). Create the static subdirectory under the view/application/index directory of the Application module and put the help.phtml view template there: <h1>Help</h1> <p> See the help <a href=\"<?= $this->url('static', ['page'=>'/chapter1/intro']); ?>\">introduction</a> here. </p> Then create the chapter1 subdirectory in the static directory and put the following chapter1/intro.phtml file in there: <h1>Introduction</h1> <p> Write the help introduction here. </p> Finally, you should receive the following directory structure (see figure 5.10): Eventually, open the following URL in your browser: http://localhost/help . The Help page should appear (see figure 5.11 for example). If you type the http://localhost/chapter1/intro URL in your browser, you should see the Introduction page (figure 5.12). You can create static pages just by adding the phtml files under the static directory, and they will automatically become available to site users. Note If you are stuck, you can find this complete working example inside the Hello World application. Summary In this chapter, we've learned about routing. Routing is used for mapping HTTP request to controller's action method. There are several route types ( Literal , Segment , Regex , Hostname , Scheme , Method etc.). Each route type uses different URL parts (and, possibly, other data from HTTP request) to compare the URL with the specified route template. We also learned how to write custom route class if the capabilities of standard route types are not sufficient. The main task of a route class is to return a route match containing the set of parameters, by which a controller and action can be determined. An opposite task a route class allows to generate a URL by parameters. This feature is widely used in view layer of the application for generating hyperlinks. Route types can be combined in a nested tree with the help of TreeRouteStack router, or organized in a chain with SimpleRouteStack router. These two routers allow to define arbitrarily complex rules. Routing configuration is stored in module's configuration file under the router key. Each module exposes its own routing rules, which are merged with other modules' configuration upon application start up. ASCII (American Standard Code for Information Interchange) is a character set which can be used to encode characters from the English alphabet. It encodes 128 characters: digits, letters, punctuation marks and several control codes inherited from Teletype machines. \u21a9 LIFO (stands for Last In, First Out) is used to organize items in a stack, where the topmost item, which is added last, is taken out first. \u21a9 PHP GD extension allows to create image files in different formats (like JPEG, PNG, GIF, etc.) \u21a9 In PHP PCRE regular expressions, it is possible to name a sub-pattern using the syntax (?P<name>pattern) . This sub-pattern will then be indexed in the matches array by its name. \u21a9 A Content Management System (CMS) is a website allowing for collaborative creating, editing and publishing content (blogs, pages, documents, videos etc.) using a centralized web interface. CMS systems make it possible for non-programmers to perform the website's daily tasks, like content publishing. \u21a9 The HTTPS protocol is typically used for secure connections, like account page or shopping cart page. When you use HTTPS, the request data is tunnelled through Secure Socket Layer (SSL) channel and not available to third parties. \u21a9","title":"Routing"},{"location":"routing/#routing","text":"When a site user enters a URL in a web browser, the HTTP request is finally dispatched to controller's action in your laminas-based website. In this chapter, we will learn about how laminas-based application maps page URLs to controllers and their actions. This mapping is accomplished with the help of routing. Routing is implemented as a part of @ Laminas\\Router component. Laminas components covered in this chapter: Component Description @ Laminas\\Router Implements support of routing. @ Laminas\\Barcode Auxiliary component implementing barcodes.","title":"Routing"},{"location":"routing/#url-structure","text":"To better understand routing, we first need to look at the URL structure. A typical URL from an HTTP request consists of several parts. There are scheme, host name, path, fragment and query parts. For example, let's look at the URL \"http://site1.yourserver.com/path/to/page?a=1&b=2#section\" (figure 5.1). This URL begins with the scheme (the scheme typically looks like http or https ). Then, the host name follows which is the domain name of your web server (like site1.yourserver.com ). Optional path segments (separated by '/' character) follow the host name. So if you have the path part \"/path/to/page\" then \"path\", \"to\", and \"page\" would each be a path segment. Next, after the question mark, the optional query part follows. It consists of one or several \"name=value\" parameters separated from each other by an ampersand character ('&'). Finally, after the hash ('#'), we have the fragment name. Each part in a URL uses special character encoding, which is named the URL encoding . This encoding ensures that the URL contains only \"safe\" characters from the ASCII 1 table. If a URL contains unsafe characters, they are replaced with a percentage character ('%') followed by two hexadecimal digits (for example, the space character will be replaced by '%20').","title":"URL Structure"},{"location":"routing/#route-types","text":"Routing is a mechanism which allows to map HTTP request to a controller's action. With routing, Laminas knows which of the controller's action method to execute as the result of the request. For example, you can map \"http://localhost/\" URL to IndexController::indexAction() method, and \"http://localhost/about\" URL to IndexController::aboutAction() method. You define the mapping between URLs and controllers with the help of routes . There are several standard route types provided by Laminas Framework (shown in table 5.1). These route types are implemented as classes living in the @ Laminas\\Router\\Http [Laminas\\Router] namespace. Route Type Description Literal Exact matching against the path part of a URL. Segment Matching against a path segment (or several segments) of a URL. Regex Matching the path part of a URL against a regular expression template. Hostname Matching the host name against some criteria. Scheme Matching URL scheme against some criteria. Method Matching an HTTP method (e.g. GET, POST, etc.) against some criteria. Table 5.1. Route Types Each route type in the table above (except the Method type) may be matched against a specific part (or several parts) of a URL. The Method route type is matched against the HTTP method (either GET or POST) retrieved from HTTP request.","title":"Route Types"},{"location":"routing/#combining-route-types","text":"Routes may be combined with the help of \"aggregate\" route types (shown in table 5.2). The compound route types allow to define arbitrarily complex URL mapping rules. Route Type Description SimpleRouteStack Aggregates different route types in a list with priorities. TreeRouteStack Aggregates different route types in a tree-like structure. Part Aggregates different route types in a subtree. Chain Aggregates different route types in a chain (degenerated subtree). Table 5.2. Aggregate Route Types The @ TreeRouteStack [Laminas\\Router\\Http\\TreeRouteStack] and @ SimpleRouteStack [Laminas\\Router\\SimpleRouteStack] are used as the \"top-level\" route types. The SimpleRouteStack allows to organize different routes in a priority list. The TreeRouteStack allows to nest different routes, forming a \"tree\". Figure 5.2 shows the route class inheritance diagram. As you can see from the image, all route classes are inherited from @ RouteInterface [Laminas\\Router\\RouteInterface] interface (we will learn this interface in details in the Writing Own Route Type section later in this chapter). The @ SimpleRouteStack [Laminas\\Router\\SimpleRouteStack] is a parent class for @ TreeRouteStack [Laminas\\Router\\Http\\TreeRouteStack] class, which inherits the behavior of the simple route stack (allows to organize routes in priority list) and extends it (allows to organize routes in subtrees). The @ Part [Laminas\\Router\\Http\\Part] and @ Chain [Laminas\\Router\\Http\\Chain] classes are derived from @ TreeRouteStack [Laminas\\Router\\Http\\TreeRouteStack] class and are used internally by the @ TreeRouteStack [Laminas\\Router\\Http\\TreeRouteStack] for building subtrees and chains of child routes.","title":"Combining Route Types"},{"location":"routing/#simple-route-stack","text":"The @ SimpleRouteStack [Laminas\\Router\\SimpleRouteStack] allows to combine different routes in a priority list. For an example of such a list, look at the route stack in the left part of figure 5.3. The example list contains several Literal routes and several Segment routes. When matching against the HTTP request, the @ SimpleRouteStack [Laminas\\Router\\SimpleRouteStack] walks through the list of routes and tries to match each route in turn. Each route in the list has a priority; the routes with the higher priority are visited first. The lookup is finished once some route matches the HTTP request. If none of the routes match, the \"not found\" error is raised.","title":"Simple Route Stack"},{"location":"routing/#tree-route-stack","text":"The @ TreeRouteStack [Laminas\\Router\\Http\\TreeRouteStack] class extends the @ SimpleRouteStack [Laminas\\Router\\SimpleRouteStack] class, which means it can organize routes in a priority list, plus it provides an ability to nest routes in subtrees and chains. An example tree route stack is presented in the right part of figure 5.3. The list contains of one @ Literal [Laminas\\Router\\Http\\Literal] route, a chain of @ Literal [Laminas\\Router\\Http\\Literal] and @ Segment routes, and a subtree consisting of two branches: a branch containing a single @ Segment route, and a branch consisting of @ Scheme , @ Hostname [Laminas\\Router\\Http\\Hostname] and @ Segment routes. The tree route stack performs request matching in the following way. It walks through its priority list items (denoted by dashed lines in figure 5.3), starting from high-priority routes. If a certain item is a @ Chain [Laminas\\Router\\Http\\Chain] route or a @ Part [Laminas\\Router\\Http\\Part] route, it processes such a nested route from its parent route to children. If the parent route matches, the children (denoted with solid lines) are analyzed then. The nested route is considered matching if at least one route matches in each tree (or chain) level. Each route in a tree (or chain) consumes a part of the URL (figure 5.4). The parent route is matched against the first part of the URL, its child is matched again the next part, and so on, until the end of the URL string is reached.","title":"Tree Route Stack"},{"location":"routing/#routing-configuration","text":"You typically do not create the route stack (or tree) yourself, instead you provide the instructions for Laminas on how to do that. The routing configuration for a module is stored in module.config.php configuration file: <?php use Laminas\\Router\\Http\\TreeRouteStack; return [ //... 'router' => [ 'router_class' => TreeRouteStack::class, 'routes' => [ // Register your routing rules here... ], 'default_params' => [ // Specify default parameters here for all routes here ... ] ], ]; Above, in line 6 we have the router key, under which there is the routes subkey (line 8), containing the routing rules. You can specify which top-level route class to use (either @ TreeRouteStack [Laminas\\Router\\Http\\TreeRouteStack] or @ SimpleRouteStack [Laminas\\Router\\SimpleRouteStack]) with the router_class parameter (line 7). If this parameter is not present, the @ TreeRouteStack [Laminas\\Router\\Http\\TreeRouteStack] is used by default. You can use the optional default_params key (line 11) to define the default values for parameters for all routes at once. However, you typically do not use this key and define the defaults on a per-route basis. Note We will show how you extract parameters from route later in this chapter.","title":"Routing Configuration"},{"location":"routing/#configuration-for-simple-routes","text":"A typical route has the name , type and options : The name is used to uniquely identify the route. The type defines the fully qualified name of the route type (PHP class which implements the matching algorithm). The options is an array that includes the route string which should be compared against the URL part, and several parameters called the defaults . Configuration for each route under the routes subkey may have the following format: '<route_name>' => [ 'type' => '<route_type_class>', 'priority' => <priority>, 'options' => [ 'route' => '<route>', 'defaults' => [ //... ], ], ] Above, the <route_name> placeholder should be the name of the route. A route name must be in lower case, like \"home\" or \"about\". The type key specifies the fully qualified route class name. The optional priority key allows to define the priority (which should be an integer number) of the route in the priority list (routes with higher priority will be visited first). If you omit the priority key, the routes will be visited in the LIFO 2 order. Note Routes having equal priority will be visited in the LIFO order. Thus, for the best performance, you should register routes that will match most often in the last turn, and least common routes should be registered first. The options key defines the array of route's options. We will discuss the options in the following sections of this chapter.","title":"Configuration for Simple Routes"},{"location":"routing/#configuration-for-nested-routes","text":"To organize routes in a subtree, you add the child_routes key to the route definition, and add your child routes under that key, like below: '<route_name>' => [ 'type' => '<route_type_class>', 'priority' => <priority>, 'options' => [ //... ], 'child_routes' => [ // Add child routes here. // ... ] ], If you need to organize the routes in a chain (degenerated subtree), you add the chain_routes key to your route configuration: '<route_name>' => [ 'type' => '<route_type_class>', 'priority' => <priority>, 'options' => [ //... ], 'chain_routes' => [ // Add chained routes here. // ... ] ], Note Looking at the two examples above, you won't see the explicit usage of @ Part [Laminas\\Router\\Http\\Part] and @ Chain [Laminas\\Router\\Http\\Chain] route types, because (for your convenience) they are used by the Laminas automatically when it encounters the child_routes and chain_routes keys in your routing configuration.","title":"Configuration for Nested Routes"},{"location":"routing/#default-routing-configuration-in-laminas-skeleton-application","text":"Now that you know how to configure routes and organize them in compound structures, let's look at the real life example. In a fresh Laminas Skeleton Application, the routing configuration looks like below: <?php use Laminas\\Router\\Http\\Literal; use Laminas\\Router\\Http\\Segment; return [ 'router' => [ 'routes' => [ 'home' => [ 'type' => Literal::class, 'options' => [ 'route' => '/', 'defaults' => [ 'controller' => Controller\\IndexController::class, 'action' => 'index', ], ], ], 'application' => [ 'type' => Segment::class, 'options' => [ 'route' => '/application[/:action]', 'defaults' => [ 'controller' => Controller\\IndexController::class, 'action' => 'index', ], ], ], ], ], //... ]; In the configuration presented above, we have two routing rules listed in turn: first we have the \"home\" route (line 8) and then we have the \"application\" route (line 18). The \"home\" route maps the empty URL path to the \"index\" action of the IndexController controller. For example, enter \"http://localhost/\" in your browser to see the Home page of your website. This route is of type \"Literal\". The \"application\" route (of type \"Segment\") maps URLs looking like \"http://localhost/application\", \"http://localhost/application/about\", \"http://localhost/application/news\", etc onto the corresponding action of the IndexController controller. The actual action name is determined by the \"action\" parameter. The default value for this parameter is \"index\". That means that if you do not specify any action, the request will be dispatched to \"index\" action. This configuration corresponds to the tree route stack shown in figure 5.5: In the next sections, we will provide some examples on how to use the route types in your website.","title":"Default Routing Configuration in Laminas Skeleton Application"},{"location":"routing/#literal-route-type","text":"With Literal route type, the route match is achieved only when you have the exact match of the route string against the URL path part. You typically use the Literal type for URLs which should be short and memorable, like '/about' or '/news'. Below, the definition of the route named \"home\" is presented. The \"home\" route is usually mapped to the \"index\" action of the IndexController and points to the Home page of your site: 'home' => [ 'type' => Literal::class, 'options' => [ 'route' => '/', 'defaults' => [ 'controller' => Controller\\IndexController::class, 'action' => 'index', ], ], ], Line 2 of this example says that the route's type is Literal . The actual route matching algorithm is implemented in the @ Laminas\\Router\\Http\\Literal class. Line 4 defines the route string to match against the URL path (the forward slash '/' means the empty URL part). Because we have the literal route type, the route match is achieved only when you have the exact literal path match. For example, if you have the URL \"http://localhost/\" or \"http://localhost\", it will match the '/' route string. Lines 5-8 define the defaults , which are the parameters returned by the router if the route matches. The controller and action parameters define the controller and controller's action method which should be executed. You can also define other parameters here, if needed. As another example of the Literal route type, let's add the '/about' route for the About page we've created earlier in the Views section of the chapter Model-View-Controller . To create the route, add the following lines right after the \"home\" route definition inside of your module.config.php file: 'about' => [ 'type' => Literal::class, 'options' => [ 'route' => '/about', 'defaults' => [ 'controller' => Controller\\IndexController::class, 'action' => 'about', ], ], ], If you now open the \"http://localhost/about\" URL in your web browser, you should see the About page.","title":"Literal Route Type"},{"location":"routing/#segment-route-type","text":"The Segment route type allows for matching the route string against one or several URL path segments. Note If you look at the module.config.php file, you can see the Segment route type is used inside of the \"application\" route to make actions of your IndexController automatically mapped to site URLs. You just add an action method to your IndexController class, and it becomes available by a URL like \"http://localhost/application/<action>\". For example, you can see the About page of your site with the following URL: \"http://localhost/application/about\". To demonstrate the creation of the Segment route type, let's implement a controller action which will generate a simple barcode image. The barcodes may be of different types and have different labels. We will use the Segment route type to map the action to a URL like \"http://localhost/barcode/<type>/<label>\". Note Barcodes are widely used in supermarkets for optically recognizing goods in your shopping cart. To be able to use barcodes, you need to install the @ Laminas\\Barcode component with Composer, by typing the following command: php composer.phar require laminas/laminas-barcode Note Please note that for barcode images to work, you need to have the GD 3 extension of the PHP engine installed and enabled. In Linux Ubuntu, you can install this extension with the following command: sudo apt-get install php-gd After installing the extension, restart Apache to apply your changes. First, we define the \"barcode\" route in the module.config.php file: 'barcode' => [ 'type' => Segment::class, 'options' => [ 'route' => '/barcode[/:type/:label]', 'constraints' => [ 'type' => '[a-zA-Z][a-zA-Z0-9_-]*', 'label' => '[a-zA-Z0-9_-]*' ], 'defaults' => [ 'controller' => Controller\\IndexController::class, 'action' => 'barcode', ], ], ], Segments of the route string (line 4) may be constant or variable. You can define the variable segments by using \"wildcards\". We have three segments: barcode , :type and :label . The barcode segment is constant, while the latter two are wildcards (wildcard's name should start with a colon). You specify how a wildcard should look like inside of the constraints subkey (lines 5-8). We define the regular expression [a-zA-Z][a-zA-Z0-9_-]* which constraints our :type wildcard to begin with a letter and (optionally) contain several letters, digits, underscores or minus characters. The constraint for the :label wildcard is almost the same, but this segment can start with any allowed character (either letter, digit, underscore or minus sign character). Optional segments can be enclosed in square brackets. In our example, we have both the :type and :label segments as optional. In lines 9-12, we define the defaults , the parameters that will be returned by the router. The controller and action defaults specify which controller and action method to execute on route match. Next, we add the barcodeAction() method into the IndexController class: // Add name alias in the beginning of the file use Laminas\\Barcode\\Barcode; // ... // The \"barcode\" action public function barcodeAction() { // Get parameters from route. $type = $this->params()->fromRoute('type', 'code39'); $label = $this->params()->fromRoute('label', 'HELLO-WORLD'); // Set barcode options. $barcodeOptions = ['text' => $label]; $rendererOptions = []; // Create barcode object $barcode = Barcode::factory($type, 'image', $barcodeOptions, $rendererOptions); // The line below will output barcode image to standard // output stream. $barcode->render(); // Return Response object to disable default view rendering. return $this->getResponse(); } In lines 10-11 we get the values of the type and label wildcards from route. We do that with the help of @ Params controller plugin's fromRoute() method. Analogous to fromQuery() method, it takes two arguments: the variable name and its default value. For generating the barcode image, we use the @ Laminas\\Barcode component. In line 14 we define the label text for the barcode. In lines 18-19 we create the @ Barcode [Laminas\\Barcode\\Barcode] object with the factory method. Finally, in line 23 we render the image file by dumping it to PHP output stream. Note @ Laminas\\Barcode is an auxiliary component used for generation of various barcode images. For additional information about this component, please refer to the corresponding section of Laminas Framework reference manual. In line 26 we return the @ Response [Laminas\\Http\\PhpEnvironment\\Response] object to suppress the default view rendering. Now, enter the \"http://localhost/barcode\" URL into your browser to see the barcode image (shown in figure 5.6): Because we have the wildcards in the route, you can pass the type and label parameters of the barcode image in the URL. Below, several URL examples are provided (corresponding barcodes are presented in figure 5.7): a. http://localhost/barcode/code39/HELLO-WORLD b. http://localhost/barcode/leitcode/12345 c. http://localhost/barcode/identcode/98765453212 d. http://localhost/barcode/postnet/123456 e. http://localhost/barcode/planet/1234567890123 f. http://localhost/barcode/upca/12345678901 g. http://localhost/barcode/code128/ABCDEF h. http://localhost/barcode/ean2/12","title":"Segment Route Type"},{"location":"routing/#regex-route-type","text":"The regular expression route type ( Regex ) is useful if you have URLs which can be matched against a regular expression. For example, assume you want to create a simple documentation system for your website. The documentation would consist of \"static\" pages mapped to URLs like /doc/<page_name>.html . Note By the term \"static page\" we refer to a page which mostly contains static HTML code plus several PHP inline fragments. For such simple pages you do not need to create separate controller actions. All \"static\" pages can be served by the single controller action. Let's implement the route which will serve the \"static\" pages of the site. Because \"static\" pages are simple, you typically won't need to add per-page action methods to the controller. All pages will be handled by the single action IndexController::docAction() . First, we add the Regex route named \"doc\" to the module.config.php file: 'doc' => [ 'type' => Regex::class, 'options' => [ 'regex' => '/doc(?<page>\\/[a-zA-Z0-9_\\-]+)\\.html', 'defaults' => [ 'controller' => Controller\\IndexController::class, 'action' => 'doc', ], 'spec'=>'/doc/%page%.html' ], ], Line 2 defines the Regex type for the route. In line 4, we have the regular expression /doc(?<page>\\/[a-zA-Z0-9_\\-]+)\\.html . It will match to URLs like \"/doc/contents.html\", \"/docs/introduction.html\" and so on. The expression contains the named capture 4 \"page\", which will be returned by the router on match together with the default parameters. Line 9 contains spec option, which is used for generating URLs by route (we will discuss generating URLs by route later in this chapter). Do not forget to add the following line to the beginning of module.config.php file: use Laminas\\Router\\Http\\Regex; Next, add the following action to IndexController class: public function docAction() { $pageTemplate = 'application/index/doc'. $this->params()->fromRoute('page', 'documentation.phtml'); $filePath = __DIR__.'/../../view/'.$pageTemplate.'.phtml'; if(!file_exists($filePath) || !is_readable($filePath)) { $this->getResponse()->setStatusCode(404); return; } $viewModel = new ViewModel([ 'page'=>$pageTemplate ]); $viewModel->setTemplate($pageTemplate); return $viewModel; } In lines 3-4 above, we retrieve the page parameter from route (remember the \"page\" named capture from our regular expression?) and save it as the $pageTemplate variable. We will use the $pageTemplate variable for determining the view template name to pass to the view resolver. Then, in lines 6-10, we check if such a file is present, and if not, return the 404 \"Not Found\" status code, which will force Laminas to display the error page. In line 12, we create the @ ViewModel [Laminas\\View\\Model\\ViewModel] variable container, and in line 15 we explicitly set the view template name for rendering. To see the documentation system in action, create a couple of \"static\" view template files: the Table of Contents page ( contents.phtml ) and the Introduction page ( introduction.phtml ). Create the doc subdirectory under the view/application/index directory of the Application module and put the contents.phtml view template there: <h1>Table of Contents</h1> <ul> <li> <a href=\"<?= $this->url('doc', ['page'=>'introduction']); ?>\"> Introduction </a> </li> </ul> In the lines above, we provide the HTML code for the \"Table of Contents\" page header, and the list which contains the single item named \"Introduction\" pointing to the Introduction \"static\" page. The link URL is generated with the @ Url [Laminas\\View\\Helper\\Url] view helper (for more details on the Url [Laminas\\View\\Helper\\Url] helper, see further sections in this chapter). Then add the introduction.phtml page into the same doc directory: <h1>Introduction</h1> <p>Some introductory materials.</p> In the lines above, we define the HTML markup for the simple Introduction page. Now, if you open the \"http://localhost/doc/contents.html\" URL in your browser, you should see a nice simple documentation system which you can extend and use in your site (figure 5.8): Clicking the Introduction link will direct you to the \"Introduction\" static page. You can also add other pages to the doc directory to make them automatically available for site users through our Regex route. Note One disadvantage of such a documentation system is that it does not work well if you place nested pages in subdirectories under the doc directory. The reason of this limitation lies in the way the Regex route assembles URLs. You can't generate URLs containing slash characters, as these \"unsafe\" characters will be automatically URL-encoded. We will work-around this problem with our custom route type that we will create at the end of this chapter.","title":"Regex Route Type"},{"location":"routing/#other-route-types","text":"The Hostname , Scheme , and Method route types are used less commonly compared to the route types mentioned previously.","title":"Other Route Types"},{"location":"routing/#hostname","text":"The Hostname route type can be used, for example, if you develop a content management system (CMS) 5 engine, which should serve several websites at once, each site using a different sub-domain. In that case you will define the Hostname route as the parent, and nest child routes of other types inside of it: 'routename' => [ 'type' => Hostname::class, 'options' => [ 'route' => ':subdomain.yourserver.com', 'constraints' => [ 'subdomain' => '[a-zA-Z][a-zA-Z0-9_-]*' ], 'defaults' => [ ], ], 'child_routes'=>[ //... ], ], In the example above, in line 1 we define the route which has the Hostname type. The route option (line 4) defines the domain name to match against. The :subdomain is a wildcard, which can take different sub-domain values. The constraints key defines the regular expression this sub-domain parameter must match. The Hostname route will differentiate your domains, so each site will behave differently, depending on the value of the subdomain parameter returned: // An example of an action that uses parameters returned by // Hostname route. public function someAction() { // Get the 'subdomain' parameter from the route. $subdomain = $this->params()->fromRoute('subdomain', null); // Use different logic based on sub-domain. //... // Render the view template. return new ViewModel(); }","title":"Hostname"},{"location":"routing/#scheme","text":"The Scheme route type is useful if you need to handle HTTP and HTTPS 6 protocols in different ways. The typical Scheme route configuration is presented below: 'routename' => [ 'type' => Scheme::class, 'options' => [ 'scheme' => 'https', 'defaults' => [ 'https' => true, ], ], 'child_routes'=>[ //... ], ], Above, we define the route of type Scheme . It takes the scheme option, which should be the scheme to match against (like http or https ). If the scheme in HTTP request's URL is exactly the same as the scheme option, the route is considered matching. You can use the defaults key to return some parameters on route match. In the example above, the https boolean parameter will be returned.","title":"Scheme"},{"location":"routing/#method","text":"The Method route type can be used if you need to direct GET and POST requests into different controller's actions. Its typical configuration is presented below: 'routename' => [ 'type' => Method::class, 'options' => [ 'verb' => 'post', 'defaults' => [ ], ], 'child_routes'=>[ //... ], ], Above, we define the route which has the Method type. It takes the verb option, which may be the comma-separated list of acceptable HTTP verbs (like get , post , put , etc.)","title":"Method"},{"location":"routing/#extracting-parameters-from-route","text":"On route match, the router (top-level route class) returns some parameters: the \"defaults\" (parameters listed in the defaults section of routing configuration) plus any wildcard parameters extracted from URL string. In your controller, you will often need to retrieve these parameters. We already did this in the examples above. In this section, we will give some summary. To retrieve a parameter from the route in your controller's action method, you typically use the @ Params controller plugin and its fromRoute() method, which takes two arguments: the name of the parameter to retrieve and the value to return if the parameter is not present. The fromRoute() method can also be used to retrieve all parameters at once as an array. To do that, call the fromRoute() without arguments, as shown in the example below: // An example action. public function someAction() { // Get the single 'id' parameter from route. $id = $this->params()->fromRoute('id', -1); // Get all route parameters at once as an array. $params = $this->params()->fromRoute(); //... }","title":"Extracting Parameters from Route"},{"location":"routing/#retrieving-the-routematch-and-the-router-object","text":"On route match, the router class internally creates an instance of @ Laminas\\Router\\RouteMatch class, providing the methods for extracting the matched route name and parameters extracted from route. The useful methods of the @ RouteMatch [Laminas\\Router\\RouteMatch] class are listed in table 5.3: Method Name Description getMatchedRouteName() Gets the name of matched route. getParams() Get all parameters. getParam($name, $default) Get a specific parameter. Table 5.3. Laminas\\Router\\RouteMatch class methods Note In most cases, it will be sufficient to use the @ Params controller plugin, but alternatively you can use the @ RouteMatch [Laminas\\Router\\RouteMatch] object for accomplishing the same task. To get the @ RouteMatch [Laminas\\Router\\RouteMatch] object from your controller's action method, you can use the following code: // An example action. public function someAction() { // Get the RouteMatch object. $routeMatch = $this->getEvent()->getRouteMatch(); // Get matched route's name. $routeName = $routeMatch->getMatchedRouteName(); // Get all route parameters at once as an array. $params = $routeMatch->getParams(); //... } In line 5 of the code above, we use the getEvent() method of the AbstractActionController base class to retrieve the @ MvcEvent object, which represents the event (in Laminas, the application life cycle consists of events). We then use the getRouteMatch() method of the @ MvcEvent class to retrieve the RouteMatch object. In line 8, we use the getMatchedRouteName() method to retrieve the name of the route that matched the HTTP request, and in line 11 we retrieve all the parameters from the route. The @ MvcEvent class can also be used for retrieving the router (the top-level route class). You can do this with the getRouter() method of the @ MvcEvent class, as below: // Call this inside of your action method // to retrieve the RouteStackInterface for the router class. $router = $this->getEvent()->getRouter(); In the code above, we use the getRouter() method, which returns the @ RouteStackInterface interface. This interface is the base interface for both @ SimpleRouteStack [Laminas\\Router\\SimpleRouteStack] and @ TreeRouteStack [Laminas\\Router\\Http\\TreeRouteStack], and it provides the methods for working with the routes contained inside the route stack.","title":"Retrieving the RouteMatch and the Router Object"},{"location":"routing/#generating-urls-from-route","text":"The main task of any route class is to determine whether this given route matches the HTTP request, and on match return the set of parameters by which a controller and action can be determined. An opposite task a route class allows to generate a URL by parameters. This feature can be used in your controller action methods for generating URLs, for example, for redirecting a user to another page. It can also be used inside view templates for generating hyperlinks.","title":"Generating URLs from Route"},{"location":"routing/#generating-urls-in-view-templates","text":"Your web pages usually contain hyperlinks to other pages. These links may point either to a page internal to your site or to a page on another site. A hyperlink is represented by <a> HTML tag having href attribute specifying the URL of the destination page. Below, an example of a hyperlink pointing to an external page is presented: <a href=\"http://example.com/path/to/page\">A link to another site page</a> When you generate a hyperlink to a resource internal to your site, you typically use relative URL (without host name): <a href=\"/path/to/internal/page\">A link to internal page</a> To generate URLs in your view templates ( .phtml files), you can use the @ Url [Laminas\\View\\Helper\\Url] view helper class, which takes the route name as an input argument: <!-- A hyperlink to Home page --> <a href=\"<?= $this->url('home'); ?>\">Home page</a> <!-- A hyperlink to About page --> <a href=\"<?= $this->url('about'); ?>\">About page</a> In the lines above, we generate two relative URLs. In line 2, we call the @ Url [Laminas\\View\\Helper\\Url] view helper and pass the \"home\" route name as its parameter. In line 5, we pass the \"about\" route name as an argument for the @ Url [Laminas\\View\\Helper\\Url] view helper. Note In the example above, the @ Url [Laminas\\View\\Helper\\Url] view helper internally uses the @ RouteMatch [Laminas\\Router\\RouteMatch] object and calls the @ Literal [Laminas\\Router\\Http\\Literal] route to assemble the URL string by route name. After the @ PhpRenderer class executes the view template's code, the output HTML markup will be the following: <!-- A hyperlink to Home page --> <a href=\"/\">Home page</a> <!-- A hyperlink to About page --> <a href=\"/about\">About page</a>","title":"Generating URLs in View Templates"},{"location":"routing/#passing-parameters","text":"If a route uses some variable parameters, you should pass them to the @ Url [Laminas\\View\\Helper\\Url] view helper as the second argument: <!-- A hyperlink to About page --> <a href=\"<?= $this->url('application', ['action' => 'about']); ?>\" > About page </a> <!-- A hyperlink to Barcode image --> <a href=\"<?= $this->url('application', ['action' => 'barcode', 'type' => 'code39', 'text' => 'HELLO-WORLD']); ?>\" > Barcode image </a> In the example above, we use @ Url [Laminas\\View\\Helper\\Url] view helper to generate the two URLs by route name and parameters. We pass the \"application\" route name as the first argument, and an array of parameters as the second argument. In line 2, we pass the \"action\" parameter to tell the Segment route class that it should substitute the corresponding wildcard in the route string with the \"about\" string. After the @ PhpRenderer class executes the view template's code, the output HTML markup will be the following: <!-- A hyperlink to About page --> <a href=\"/application/about\" > About page </a> <!-- A hyperlink to Barcode image --> <a href=\"/application/barcode/code39/HELLO-WORLD\" > Barcode image </a> As another example, let's try to generate a URL for our Regex route (the one which serves our \"static\" pages): <!-- A hyperlink to Introduction page --> <a href=\"<?= $this->url('doc', ['page'=>'introduction']); ?>\"> Introduction </a> This will generate the following HTML markup: <!-- A hyperlink to Introduction page --> <a href=\"/doc/introduction.html\"> Introduction </a>","title":"Passing Parameters"},{"location":"routing/#generating-absolute-urls","text":"If you need to generate an absolute URL (having the scheme and host name), you can specify the third parameter for the @ Url [Laminas\\View\\Helper\\Url] view helper. The third parameter should be an array containing one or several options. For assembling the absolute URL, pass the force_canonical option, as in the example below: <!-- A hyperlink to Home page --> <a href=\"<?= $this->url('home', [], ['force_canonical' => true]); ?>\" > Home page </a> <!-- A hyperlink to About page --> <a href=\"<?php echo $this->url('application', ['action' => 'about'], ['force_canonical' => true]); ?>\" > About page </a> In line 2 of the example above, we pass the \"home\" route name as the first argument, empty array as the second argument, and an array containing force_canonical option as the third argument. In lines 6-7, we also pass the force_canonical option as the third argument for generating the URL of the About page. The resulting HTML markup of the code above will be as follows: <!-- A hyperlink to Home page --> <a href=\"http://localhost/\" > Home page </a> <!-- A hyperlink to About page --> <a href=\"http://localhost/application/index/about\" > About page </a>","title":"Generating Absolute URLs"},{"location":"routing/#specifying-query-part","text":"If you want your URL to have a query part, you can specify the query option in the third argument of the Url view helper. For example, assume you have the \"search\" action in some controller (and a route mapped to this action), and you want to pass it search query string and count of output results per page. The URL for this action would be like this: \"http://localhost/search?q=topic&count=10\". To generate such a URL, you can use the following code: <a href=\"<?= $this->url('search', [], ['force_canonical' => true, 'query'=>['q'=>'topic', 'count'=>10]]); ?>\" > Search </a> In the code above, we specified the query option, which is the array containing name=>value pairs of the query parameters.","title":"Specifying Query Part"},{"location":"routing/#generating-urls-in-controllers","text":"You can generate URLs inside your controller's action methods using the Url controller plugin. To generate a URL, you call the @ Url [Laminas\\Mvc\\Controller\\Plugin\\Url] controller plugin's fromRoute() method, as in the example below: // An example action method public function someAction() { // Generate a URL pointing to the Home page ('/') $url1 = $this->url()->fromRoute('home'); // Generate an absolute URL pointing to the About page // ('http://localhost/application/about') $url2 = $this->url()->fromRoute('application', ['action'=>'about'], ['force_canonical'=>true]); } Note The arguments the Url plugin takes and their meaning are identical to the @ Url [Laminas\\View\\Helper\\Url] view helper's ones. So, you can generate absolute or relative URLs the same way you did in your view templates.","title":"Generating URLs in Controllers"},{"location":"routing/#url-encoding","text":"When generating URLs either with the @ Url [Laminas\\View\\Helper\\Url] view helper or with the @ Url [Laminas\\Mvc\\Controller\\Plugin\\Url] controller plugin, you should remember that URLs may only contain \"safe\" characters from ASCII character set. Thus, if you pass the parameter containing unsafe characters, these characters will be replaced with the sequence of the percentage character and two digits. For example, let's try to generate a URL for our Regex route and pass it the \"page\" parameter with the value \"/chapter1/introduction\". <!-- A hyperlink to Introduction page --> <a href=\"<?= $this->url('doc', ['page'=>'chapter1/introduction']); ?>\"> Introduction </a> We could assume it generates the URL like \"/doc/chapter1/introduction.html\". But because the slash ('/') character is unsafe, it will be replaced with the \"%2F\" characters for security reasons, and we will have the following HTML code: <!-- A hyperlink to Introduction page --> <a href=\"/doc/chapter1%2Fintroduction.html\"> Introduction </a> Unfortunately, this hyperlink is unusable, because it won't match our Regex route.","title":"URL Encoding"},{"location":"routing/#writing-own-route-type","text":"Although Laminas provides you with many route types, in some situations, you will need to write your own route type. One example of the need for such a custom route type is when you have to define the URL mapping rules dynamically. Usually, you store the routing configuration in module's config file, but in some CMS systems you will have documents stored in the database. For such a system, you would need to develop a custom route type which would connect to the database and perform route matching against the data stored in the database. You cannot store this information in config file, because new documents are created by system administrators, not programmers.","title":"Writing Own Route Type"},{"location":"routing/#routeinterface","text":"We know that every route class must implement the @ Laminas\\Router\\Http\\RouteInterface interface. The methods of this interface are presented in table 5.4: Method Name Description factory($options) Static method for creation of the route class. match($request) Method which performs match against the HTTP request data. assemble($params, $options) Method for generating URL by route parameters. getAssembledParams() Method for retrieving parameters that were utilized for URL generation. Table 5.4. RouteInterface methods The static factory() method is used by the Laminas router (@ TreeRouteStack [Laminas\\Router\\Http\\TreeRouteStack] or @ SimpleRouteStack [Laminas\\Router\\SimpleRouteStack]) for instantiating the route class. The router passes the options array an argument for the factory() method. The match() method is used to perform the matching of the HTTP request (or, particularly its URL) against the options data passed to the route class through the factory() . The match() method should return either an instance of the RouteMatch class on successful match, or null on failure. The assemble() method is used for generating URL string by route parameters and options. The getAssembledParams() helper method's purpose is to return the array of parameters which were used on URL generation.","title":"RouteInterface"},{"location":"routing/#custom-route-class","text":"To demonstrate the creation of a custom route type, let's improve our previous approach to building the simple documentation system with Regex route type. The disadvantage of the Regex route type is that you cannot organize the static pages in a hierarchy by creating subdirectories under the doc directory (when generating an URL for such a page, the slash directory separator will be URL-encoded making the hyperlink unusable). We will create our custom StaticRoute class that allows to fix this issue. Moreover, the class we will create is more powerful, because it will not only recognize URLs starting with \"/doc\" and ending with \".html\". Instead, it will recognize generic URLs, like \"/help\" or \"/support/chapter1/introduction\". What we want to achieve: The StaticRoute class should be insertable to the route stack (to SimpleRouteStack or to TreeRouteStack ) and usable together with other route types. The route class should recognize generic URLs, like \"/help\" or \"/introduction\". The route class should match the URL against the directory structure. For example, if the URL is \"/chapter1/introduction\", then the route should check if the corresponding view template file <base_dir>/chapter1/introduction.phtml exists and is readable, and if so, report match. If the file does not exist (or not readable), return the failure status. The route class should check the URL for acceptable file names using a regular expression. For example, the file name \"introduction\" is acceptable, but the name \"*int$roduction\" is not. If the file name is not acceptable, the failure status should be returned. The route should be able to assemble the URL string by route name and parameters. To start, create the Route subdirectory under the module's source directory and put the StaticRoute.php file inside of it (figure 5.9). Inside that file, paste the stub code presented below: <?php namespace Application\\Route; use Traversable; use \\Laminas\\Router\\Exception; use \\Laminas\\Stdlib\\ArrayUtils; use \\Laminas\\Stdlib\\RequestInterface as Request; use \\Laminas\\Router\\Http\\RouteInterface; use \\Laminas\\Router\\Http\\RouteMatch; // Custom route that serves \"static\" web pages. class StaticRoute implements RouteInterface { // Create a new route with given options. public static function factory($options = []) { } // Match a given request. public function match(Request $request, $pathOffset = null) { } // Assembles a URL by route params. public function assemble(array $params = [], array $options = []) { } // Get a list of parameters used while assembling. public function getAssembledParams() { } } From the code above, you can see that we placed the StaticRoute class inside the Application\\Route namespace (line 2). In lines 4-9, we define some class name aliases for making the class names shorter. In lines 12-33, we define the stub for the StaticRoute class. The StaticRoute class implements the @ RouteInterface [Laminas\\Router\\RouteInterface] interface and defines all the methods specified by the interface: factory() , match() , assemble() and getAssembledParams() . Next, let's add several protected properties and the constructor method to the StaticRoute class, as shown below: <?php //... class StaticRoute implements RouteInterface { // Base view directory. protected $dirName; // Path prefix for the view templates. protected $templatePrefix; // File name pattern. protected $fileNamePattern = '/[a-zA-Z0-9_\\-]+/'; // Defaults. protected $defaults; // List of assembled parameters. protected $assembledParams = []; // Constructor. public function __construct($dirName, $templatePrefix, $fileNamePattern, array $defaults = []) { $this->dirName = $dirName; $this->templatePrefix = $templatePrefix; $this->fileNamePattern = $fileNamePattern; $this->defaults = $defaults; } // ... } Above, in line 7, we define the $dirName property that is intended for storing the name of the base directory where the \"static\" view templates will be located. In line 10, we define the $templatePrefix class variable for storing the prefix for prepending to all view template names. Line 13 contains the $fileNamePattern variable that will be used for checking the file name. In lines 22-29, we define the constructor method that is called on instance creation for initializing the protected properties. Next, let's implement the factory() method for our StaticRoute custom route class. The factory() method will be called by the router for instantiating the route class: <?php //... class StaticRoute implements RouteInterface { //... // Create a new route with given options. public static function factory($options = []) { if ($options instanceof Traversable) { $options = ArrayUtils::iteratorToArray($options); } elseif (!is_array($options)) { throw new Exception\\InvalidArgumentException(__METHOD__ . ' expects an array or Traversable set of options'); } if (!isset($options['dir_name'])) { throw new Exception\\InvalidArgumentException( 'Missing \"dir_name\" in options array'); } if (!isset($options['template_prefix'])) { throw new Exception\\InvalidArgumentException( 'Missing \"template_prefix\" in options array'); } if (!isset($options['filename_pattern'])) { throw new Exception\\InvalidArgumentException( 'Missing \"filename_pattern\" in options array'); } if (!isset($options['defaults'])) { $options['defaults'] = []; } return new static( $options['dir_name'], $options['template_prefix'], $options['filename_pattern'], $options['defaults']); } } In the code above, we see that the factory() method takes the options array as the argument (line 9). The options array may contain the options for configuring the route class. The StaticRoute class will accept the following options: dir_name - the base directory where to store all \"static\" view templates. template_prefix - the prefix to prepend to all template names. filename_pattern - the regular expression for checking the file names. defaults - parameters returned by router by default. Once we parsed the options, in lines 37-41 we call the class' constructor method to instantiate and return the StaticRoute object. The next method we add to the StaticRoute route class is the match() method: <?php //... class StaticRoute implements RouteInterface { //... // Match a given request. public function match(Request $request, $pathOffset=null) { // Ensure this route type is used in an HTTP request if (!method_exists($request, 'getUri')) { return null; } // Get the URL and its path part. $uri = $request->getUri(); $path = $uri->getPath(); if($pathOffset!=null) $path = substr($path, $pathOffset); // Get the array of path segments. $segments = explode('/', $path); // Check each segment against allowed file name template. foreach ($segments as $segment) { if(strlen($segment)==0) continue; if(!preg_match($this->fileNamePattern, $segment)) return null; } // Check if such a .phtml file exists on disk $fileName = $this->dirName . '/'. $this->templatePrefix.$path.'.phtml'; if(!is_file($fileName) || !is_readable($fileName)) { return null; } $matchedLength = strlen($path); // Prepare the RouteMatch object. return new RouteMatch(array_merge( $this->defaults, ['page'=>$this->templatePrefix.$path] ), $matchedLength); } } In the code above, we see that the match() method takes two arguments: the HTTP request object (an instance of @ Laminas\\Stdlib\\Request class) and the URL path offset. The request object is used for accessing the request URL (line 17). The path offset parameter is a non-negative integer, which points to the portion of the URL the route is matched against (line 21). In line 24, we extract the segments from URL. Then we check if every segment is an acceptable file (directory) name (lines 27-32). If the segment is not a valid file name, we return null as a failure status. In line 35, we calculate the path to the view template, and in lines 37-39 we check if such a file really exists and accessible for reading. This way we match the URL against the directory structure. In lines 44-48, we prepare and return the @ RouteMatch [Laminas\\Router\\RouteMatch] object with the default parameters plus the \"page\" parameter containing the view template name for rendering. To complete the implementation of our StaticRoute class, we add the assemble() and getAssembledParams() methods, that will be used for generation of URLs by route parameters. The code for these methods is presented below: <?php //... class StaticRoute implements RouteInterface { //... // Assembles a URL by route params public function assemble(array $params = [], array $options = []) { $mergedParams = array_merge($this->defaults, $params); $this->assembledParams = []; if(!isset($params['page'])) { throw new Exception\\InvalidArgumentException(__METHOD__ . ' expects the \"page\" parameter'); } $segments = explode('/', $params['page']); $url = ''; foreach($segments as $segment) { if(strlen($segment)==0) continue; $url .= '/' . rawurlencode($segment); } $this->assembledParams[] = 'page'; return $url; } // Get a list of parameters used while assembling. public function getAssembledParams() { return $this->assembledParams; } } In the code above, we define the assemble() method, which takes the two arguments: the parameters array and the options array (line 9). The method constructs the URL by encoding the segments with URL encoding and concatenating them (line 20-26). The method getAssembledParams() just returns the names of the parameters we used for URL generation (line 36). Now we've finished the StaticRoute route class. To use our custom route type, we add the following configuration to the module.config.php configuration file: 'static' => [ 'type' => StaticRoute::class, 'options' => [ 'dir_name' => __DIR__ . '/../view', 'template_prefix' => 'application/index/static', 'filename_pattern' => '/[a-z0-9_\\-]+/', 'defaults' => [ 'controller' => Controller\\IndexController::class, 'action' => 'static', ], ], ], In line 1 of the configuration above, we define the routing rule named \"static\". The type parameter defines the fully qualified StaticRoute class name (line 2). In the options array, we define the base directory where the \"static\" pages will be placed (line 4), the template prefix (line 5), the filename pattern (line 6), and the defaults array, containing the name of the controller and the action that will serve all the static pages. Do not forget to insert the following line to the beginning of the module.config.php class: use Application\\Route\\StaticRoute; The final step is creating the action method in the IndexController class: public function staticAction() { // Get path to view template from route params $pageTemplate = $this->params()->fromRoute('page', null); if($pageTemplate==null) { $this->getResponse()->setStatusCode(404); return; } // Render the page $viewModel = new ViewModel([ 'page'=>$pageTemplate ]); $viewModel->setTemplate($pageTemplate); return $viewModel; } The action above is almost identical to the action we used for the Regex route. In line 4, we retrieve the page parameter from route and save it as the $pageTemplate variable. In line 11, we create the ViewModel variable container, and in line 14 we explicitly set the view template name for rendering. To see the system in action, let's add a couple of \"static\" view pages: the Help page ( help.phtml ) and the introduction page ( intro.phtml ). Create the static subdirectory under the view/application/index directory of the Application module and put the help.phtml view template there: <h1>Help</h1> <p> See the help <a href=\"<?= $this->url('static', ['page'=>'/chapter1/intro']); ?>\">introduction</a> here. </p> Then create the chapter1 subdirectory in the static directory and put the following chapter1/intro.phtml file in there: <h1>Introduction</h1> <p> Write the help introduction here. </p> Finally, you should receive the following directory structure (see figure 5.10): Eventually, open the following URL in your browser: http://localhost/help . The Help page should appear (see figure 5.11 for example). If you type the http://localhost/chapter1/intro URL in your browser, you should see the Introduction page (figure 5.12). You can create static pages just by adding the phtml files under the static directory, and they will automatically become available to site users. Note If you are stuck, you can find this complete working example inside the Hello World application.","title":"Custom Route Class"},{"location":"routing/#summary","text":"In this chapter, we've learned about routing. Routing is used for mapping HTTP request to controller's action method. There are several route types ( Literal , Segment , Regex , Hostname , Scheme , Method etc.). Each route type uses different URL parts (and, possibly, other data from HTTP request) to compare the URL with the specified route template. We also learned how to write custom route class if the capabilities of standard route types are not sufficient. The main task of a route class is to return a route match containing the set of parameters, by which a controller and action can be determined. An opposite task a route class allows to generate a URL by parameters. This feature is widely used in view layer of the application for generating hyperlinks. Route types can be combined in a nested tree with the help of TreeRouteStack router, or organized in a chain with SimpleRouteStack router. These two routers allow to define arbitrarily complex rules. Routing configuration is stored in module's configuration file under the router key. Each module exposes its own routing rules, which are merged with other modules' configuration upon application start up. ASCII (American Standard Code for Information Interchange) is a character set which can be used to encode characters from the English alphabet. It encodes 128 characters: digits, letters, punctuation marks and several control codes inherited from Teletype machines. \u21a9 LIFO (stands for Last In, First Out) is used to organize items in a stack, where the topmost item, which is added last, is taken out first. \u21a9 PHP GD extension allows to create image files in different formats (like JPEG, PNG, GIF, etc.) \u21a9 In PHP PCRE regular expressions, it is possible to name a sub-pattern using the syntax (?P<name>pattern) . This sub-pattern will then be indexed in the matches array by its name. \u21a9 A Content Management System (CMS) is a website allowing for collaborative creating, editing and publishing content (blogs, pages, documents, videos etc.) using a centralized web interface. CMS systems make it possible for non-programmers to perform the website's daily tasks, like content publishing. \u21a9 The HTTPS protocol is typically used for secure connections, like account page or shopping cart page. When you use HTTPS, the request data is tunnelled through Secure Socket Layer (SSL) channel and not available to third parties. \u21a9","title":"Summary"},{"location":"session/","text":"Working with Sessions In this chapter, you will learn about sessions . The HTTP protocol is stateless, so you can't share data between two HTTP requests by default. PHP sessions allow to workaround this by saving data on server during one page request and retrieve it later during another page request. For example, you can remember that the user has logged in, and show a personalized web page the next time he visits the website. Laminas Framework internally uses the PHP sessions, but additionally provides a convenient wrapper around PHP sessions, so you don't access $_SESSION super-global array directly. Laminas components covered in this chapter: Component Description @ Laminas\\Session Implements a wrapper around PHP sessions. PHP Sessions First, let's give some theory on what PHP sessions are. In PHP, sessions work as follows: when a site visitor opens the website for the first time, PHP sets a cookie 1 in the client browser. the website may save any information to session with the help of special super-global array named $_SESSION . The data saved to session is stored on server in form of disk files. when the same visitor opens the website again, the web browser sends the saved cookie to server, so PHP determines that this is the same visitor and loads the session data again to the $_SESSION array. From PHP application developer's point of view, the work with sessions is simple. First, initialise the session by calling session_start() PHP function. Then, use $_SESSION super-global array for setting/retrieving session data. For example, to save some data to session, use the following code: session_start(); $_SESSION['my_var'] = 'Some data'; To later retrieve the data from session, use the following code: session_start(); if (isset($_SESSION['my_var'])) $sessionVar = $_SESSION['my_var']; else $sessionVar = 'Some default value'; To clear the data, use the unset() PHP function, as follows: unset($_SESSION['my_var']); Note that sessions do not last forever (they expire sooner or later when the user's cookie expires or when PHP engine cleans up the session storage files). How long the session lasts is defined in php.ini configuration file. It is possible to override the default expiration parameters with the help of ini_set() function, as follows: // Set session cookie lifetime (in seconds) to be 1 hour. ini_set('session.cookie_lifetime', 60*60*1); // Store session data on server for maximum 1 month. ini_set('session.gc_maxlifetime', 60*60*24*30); There are several other \"advanced\" session-related PHP configuration settings in php.ini . We do not cover them here, because they are usually not needed. So, if PHP sessions is so simple, why do I need additional wrapper provided by Laminas Framework? laminas-provided wrapper around the PHP sessions is useful, because: Laminas session wrapper is object-oriented, so you can use it consistently in your MVC application. Laminas provides the concept of session namespaces, so different models can store data without naming conflicts. Laminas provides security features (session validators), so it is more difficult for a malicious user to hack and substitute your session data. Using $_SESSION super-global array directly is not good, because it makes testing your website more difficult. When you use a wrapper around PHP sessions, it is easier to supply test data. With Laminas session classes, it is possible to implement custom session data storages (for example, store session data in database instead of files). Installing Laminas\\Session Component In Laminas, the session functionality is implemented inside of @ Laminas\\Session component. If you haven't yet installed this component in your web application, do this now with Composer by typing the following command: php composer.phar require laminas/laminas-session The command above downloads the component code from GitHub and installs it in the APP_DIR/vendor directory. It also injects the information about the installed module inside of your APP_DIR/config/modules.config.php configuration file. Session Manager Laminas provides a special service called @ SessionManager which belongs to @ Laminas\\Session namespace. This service is a usual Laminas service and is automatically registered in service manager. You can get an instance of the @ SessionManager service in a factory class with the following code: // Use alias for the SessionManager class. use Laminas\\Session\\SessionManager; // Retrieve an instance of the session manager from the service manager. $sessionManager = $container->get(SessionManager::class); So, what does the @ SessionManager do? Actually, it does everything for session to run. The summary of its most useful methods is provided in the table 15.1 below: Method Description sessionExists() Checks whether session exists and currently active. start($preserveStorage = false) Starts the session (if not started yet). destroy(array $options = null) Ends the session. getId() Returns session ID. setId() Sets session ID. regenerateId() Regenerates the session ID. getName() Returns session name. setName() Overrides the default session name from php.ini . rememberMe($ttl = null) Sets session cookie lifetime (in seconds). forgetMe() Set a zero lifetime for the session cookie (the cookie will expire when browser is closed). expireSessionCookie() Expires the session cookie immediately. isValid() Executes session validators. Table 15.1. Methods provided by the SessionManager class As you can see from the table above, the @ SessionManager can start the session and end it, check if session exists, and set session parameters (such as cookie expiration). It also provides a validator chain that may contain session validators (those validators allow to prevent hacker attacks on session data). Providing Session Configuration The @ SessionManager class on initialization reads the application configuration, so you can set up the session parameters conveniently. To do that, modify your APP_DIR/config/autoload/global.php as follows: <?php use Laminas\\Session\\Storage\\SessionArrayStorage; use Laminas\\Session\\Validator\\RemoteAddr; use Laminas\\Session\\Validator\\HttpUserAgent; return [ // Session configuration. 'session_config' => [ // Session cookie will expire in 1 hour. 'cookie_lifetime' => 60*60*1, // Session data will be stored on server maximum for 30 days. 'gc_maxlifetime' => 60*60*24*30, ], // Session manager configuration. 'session_manager' => [ // Session validators (used for security). 'validators' => [ RemoteAddr::class, HttpUserAgent::class, ] ], // Session storage configuration. 'session_storage' => [ 'type' => SessionArrayStorage::class ], // ... ]; Note We modify global.php file here, because sessions may be used by any module in your website and do not depend on environment. As you can see, the session configuration is stored under three keys: The session_config key allows to define how long the session cookie will live and how long the PHP engine will store your session data on server. Actually, this key may contain additional session options, but we omit them for simplicity (if you'd like to override those advanced options, please refer to Laminas Framework documentation). The session_manager key allows to set session validators. These are used to enhance the security. It is recommended that you always specify these validators here. The session_storage key allows to specify the session storage class. We use the @ SessionArrayStorage class, which is the default storage and is sufficient for the most cases. Session Containers Once you have configured the session manager, you can actually store and retrieve data to/from session. To do that, you use session containers . Session containers are implemented by the @ Container [Laminas\\Session\\Container] class living in @ Laminas\\Session namespace. The session container can be used to save your data to session and retrieve it from session. To avoid naming conflicts between different classes, modules and components that use sessions, the session container allows you to specify the namespace under which the data will be stored. A container namespace may contain upper-case and lower-case characters, underscores and back-slashes. So, for example, \"Session\\ContainerName\", \"session_container_name\" and \"SessionContainerName\" are all valid container namespaces. Note Session containers work closely with the session manager. When you create a session container, it calls the session manager's start() method automatically, so session is started and initialized. Now let's start using containers. You can create a container using two equivalent ways: either manually instantiating a container or let a factory do that for you. The second one is easier, so we recommend it. Method 1. Manual Instantiation of a Session Container You can just create a session container with the new operator, but you need to pass an instance of the session manager service to container's constructor: use Laminas\\Session\\Container; // We assume that $sessionManager variable is an instance of the session manager. $sessionContainer = new Container('ContainerNamespace', $sessionManager); So, before you create the container, be sure you have injected the session manager in your controller, service or wherever you need to create the container. Method 2. Creating a Session Container Using Factory This method is equivalent to the first one, but the session container is created by the factory. You just need to register what container namespaces you need. To do that, add the session_containers key to your module.config.php file as follows: <?php return [ // ... 'session_containers' => [ 'ContainerNamespace' ], ]; You may list the allowable container names under this key. Choosing a container name is up to you, just be sure it is unique among all other service names. Once you registered a container name (or several container names), you can create the container and work with it. You typically do that in a factory with the help of the service manager: // The $container variable is the service manager. $sessionContainer = $container->get('ContainerNamespace'); As you can see, you retrieve a session container from the service manager by its registered name. Saving Data to Session with Session Container When you created the session container, you are able to save data to it as follows: $sessionContainer->myVar = 'Some data'; To retrieve the data from session container, you use the following code: if(isset($sessionContainer->myVar)) $myVar = $sessionContainer->myVar; else $myVar = null; To remove data from session, use the following code: unset($sessionContainer->myVar); For some practical examples of using session containers, please refer to Implementing Multi-Step Forms section. Summary PHP sessions is a useful feature allowing you to store some data between page requests. PHP engine stores session data on server in form of files, and uses browser cookies to identify the same visitor the next time and load his session data to memory. For example, you can remember the user and show him personalized pages. The session doesn't last forever - it expires in some time. Laminas Framework provides a convenient wrapper around PHP sessions. With this wrapper, you can store data in session containers in object-oriented way. Laminas also provides security features allowing to automatically validate session and prevent hacker attacks. An HTTP cookie is a small piece of data sent from a website and stored in the user's web browser while the user is browsing. Cookies are used to remember some state between HTTP requests. \u21a9","title":"Working with Sessions"},{"location":"session/#working-with-sessions","text":"In this chapter, you will learn about sessions . The HTTP protocol is stateless, so you can't share data between two HTTP requests by default. PHP sessions allow to workaround this by saving data on server during one page request and retrieve it later during another page request. For example, you can remember that the user has logged in, and show a personalized web page the next time he visits the website. Laminas Framework internally uses the PHP sessions, but additionally provides a convenient wrapper around PHP sessions, so you don't access $_SESSION super-global array directly. Laminas components covered in this chapter: Component Description @ Laminas\\Session Implements a wrapper around PHP sessions.","title":"Working with Sessions"},{"location":"session/#php-sessions","text":"First, let's give some theory on what PHP sessions are. In PHP, sessions work as follows: when a site visitor opens the website for the first time, PHP sets a cookie 1 in the client browser. the website may save any information to session with the help of special super-global array named $_SESSION . The data saved to session is stored on server in form of disk files. when the same visitor opens the website again, the web browser sends the saved cookie to server, so PHP determines that this is the same visitor and loads the session data again to the $_SESSION array. From PHP application developer's point of view, the work with sessions is simple. First, initialise the session by calling session_start() PHP function. Then, use $_SESSION super-global array for setting/retrieving session data. For example, to save some data to session, use the following code: session_start(); $_SESSION['my_var'] = 'Some data'; To later retrieve the data from session, use the following code: session_start(); if (isset($_SESSION['my_var'])) $sessionVar = $_SESSION['my_var']; else $sessionVar = 'Some default value'; To clear the data, use the unset() PHP function, as follows: unset($_SESSION['my_var']); Note that sessions do not last forever (they expire sooner or later when the user's cookie expires or when PHP engine cleans up the session storage files). How long the session lasts is defined in php.ini configuration file. It is possible to override the default expiration parameters with the help of ini_set() function, as follows: // Set session cookie lifetime (in seconds) to be 1 hour. ini_set('session.cookie_lifetime', 60*60*1); // Store session data on server for maximum 1 month. ini_set('session.gc_maxlifetime', 60*60*24*30); There are several other \"advanced\" session-related PHP configuration settings in php.ini . We do not cover them here, because they are usually not needed. So, if PHP sessions is so simple, why do I need additional wrapper provided by Laminas Framework? laminas-provided wrapper around the PHP sessions is useful, because: Laminas session wrapper is object-oriented, so you can use it consistently in your MVC application. Laminas provides the concept of session namespaces, so different models can store data without naming conflicts. Laminas provides security features (session validators), so it is more difficult for a malicious user to hack and substitute your session data. Using $_SESSION super-global array directly is not good, because it makes testing your website more difficult. When you use a wrapper around PHP sessions, it is easier to supply test data. With Laminas session classes, it is possible to implement custom session data storages (for example, store session data in database instead of files).","title":"PHP Sessions"},{"location":"session/#installing-laminassession-component","text":"In Laminas, the session functionality is implemented inside of @ Laminas\\Session component. If you haven't yet installed this component in your web application, do this now with Composer by typing the following command: php composer.phar require laminas/laminas-session The command above downloads the component code from GitHub and installs it in the APP_DIR/vendor directory. It also injects the information about the installed module inside of your APP_DIR/config/modules.config.php configuration file.","title":"Installing Laminas\\Session Component"},{"location":"session/#session-manager","text":"Laminas provides a special service called @ SessionManager which belongs to @ Laminas\\Session namespace. This service is a usual Laminas service and is automatically registered in service manager. You can get an instance of the @ SessionManager service in a factory class with the following code: // Use alias for the SessionManager class. use Laminas\\Session\\SessionManager; // Retrieve an instance of the session manager from the service manager. $sessionManager = $container->get(SessionManager::class); So, what does the @ SessionManager do? Actually, it does everything for session to run. The summary of its most useful methods is provided in the table 15.1 below: Method Description sessionExists() Checks whether session exists and currently active. start($preserveStorage = false) Starts the session (if not started yet). destroy(array $options = null) Ends the session. getId() Returns session ID. setId() Sets session ID. regenerateId() Regenerates the session ID. getName() Returns session name. setName() Overrides the default session name from php.ini . rememberMe($ttl = null) Sets session cookie lifetime (in seconds). forgetMe() Set a zero lifetime for the session cookie (the cookie will expire when browser is closed). expireSessionCookie() Expires the session cookie immediately. isValid() Executes session validators. Table 15.1. Methods provided by the SessionManager class As you can see from the table above, the @ SessionManager can start the session and end it, check if session exists, and set session parameters (such as cookie expiration). It also provides a validator chain that may contain session validators (those validators allow to prevent hacker attacks on session data).","title":"Session Manager"},{"location":"session/#providing-session-configuration","text":"The @ SessionManager class on initialization reads the application configuration, so you can set up the session parameters conveniently. To do that, modify your APP_DIR/config/autoload/global.php as follows: <?php use Laminas\\Session\\Storage\\SessionArrayStorage; use Laminas\\Session\\Validator\\RemoteAddr; use Laminas\\Session\\Validator\\HttpUserAgent; return [ // Session configuration. 'session_config' => [ // Session cookie will expire in 1 hour. 'cookie_lifetime' => 60*60*1, // Session data will be stored on server maximum for 30 days. 'gc_maxlifetime' => 60*60*24*30, ], // Session manager configuration. 'session_manager' => [ // Session validators (used for security). 'validators' => [ RemoteAddr::class, HttpUserAgent::class, ] ], // Session storage configuration. 'session_storage' => [ 'type' => SessionArrayStorage::class ], // ... ]; Note We modify global.php file here, because sessions may be used by any module in your website and do not depend on environment. As you can see, the session configuration is stored under three keys: The session_config key allows to define how long the session cookie will live and how long the PHP engine will store your session data on server. Actually, this key may contain additional session options, but we omit them for simplicity (if you'd like to override those advanced options, please refer to Laminas Framework documentation). The session_manager key allows to set session validators. These are used to enhance the security. It is recommended that you always specify these validators here. The session_storage key allows to specify the session storage class. We use the @ SessionArrayStorage class, which is the default storage and is sufficient for the most cases.","title":"Providing Session Configuration"},{"location":"session/#session-containers","text":"Once you have configured the session manager, you can actually store and retrieve data to/from session. To do that, you use session containers . Session containers are implemented by the @ Container [Laminas\\Session\\Container] class living in @ Laminas\\Session namespace. The session container can be used to save your data to session and retrieve it from session. To avoid naming conflicts between different classes, modules and components that use sessions, the session container allows you to specify the namespace under which the data will be stored. A container namespace may contain upper-case and lower-case characters, underscores and back-slashes. So, for example, \"Session\\ContainerName\", \"session_container_name\" and \"SessionContainerName\" are all valid container namespaces. Note Session containers work closely with the session manager. When you create a session container, it calls the session manager's start() method automatically, so session is started and initialized. Now let's start using containers. You can create a container using two equivalent ways: either manually instantiating a container or let a factory do that for you. The second one is easier, so we recommend it.","title":"Session Containers"},{"location":"session/#method-1-manual-instantiation-of-a-session-container","text":"You can just create a session container with the new operator, but you need to pass an instance of the session manager service to container's constructor: use Laminas\\Session\\Container; // We assume that $sessionManager variable is an instance of the session manager. $sessionContainer = new Container('ContainerNamespace', $sessionManager); So, before you create the container, be sure you have injected the session manager in your controller, service or wherever you need to create the container.","title":"Method 1. Manual Instantiation of a Session Container"},{"location":"session/#method-2-creating-a-session-container-using-factory","text":"This method is equivalent to the first one, but the session container is created by the factory. You just need to register what container namespaces you need. To do that, add the session_containers key to your module.config.php file as follows: <?php return [ // ... 'session_containers' => [ 'ContainerNamespace' ], ]; You may list the allowable container names under this key. Choosing a container name is up to you, just be sure it is unique among all other service names. Once you registered a container name (or several container names), you can create the container and work with it. You typically do that in a factory with the help of the service manager: // The $container variable is the service manager. $sessionContainer = $container->get('ContainerNamespace'); As you can see, you retrieve a session container from the service manager by its registered name.","title":"Method 2. Creating a Session Container Using Factory"},{"location":"session/#saving-data-to-session-with-session-container","text":"When you created the session container, you are able to save data to it as follows: $sessionContainer->myVar = 'Some data'; To retrieve the data from session container, you use the following code: if(isset($sessionContainer->myVar)) $myVar = $sessionContainer->myVar; else $myVar = null; To remove data from session, use the following code: unset($sessionContainer->myVar); For some practical examples of using session containers, please refer to Implementing Multi-Step Forms section.","title":"Saving Data to Session with Session Container"},{"location":"session/#summary","text":"PHP sessions is a useful feature allowing you to store some data between page requests. PHP engine stores session data on server in form of files, and uses browser cookies to identify the same visitor the next time and load his session data to memory. For example, you can remember the user and show him personalized pages. The session doesn't last forever - it expires in some time. Laminas Framework provides a convenient wrapper around PHP sessions. With this wrapper, you can store data in session containers in object-oriented way. Laminas also provides security features allowing to automatically validate session and prevent hacker attacks. An HTTP cookie is a small piece of data sent from a website and stored in the user's web browser while the user is browsing. Cookies are used to remember some state between HTTP requests. \u21a9","title":"Summary"},{"location":"skeleton/","text":"Laminas Skeleton Application Laminas Framework provides you with the so called \"skeleton application\" to make it easier to create your new websites from scratch. In this chapter, we will show how to install the skeleton application and how to create an Apache virtual host. It is recommended that you refer to Appendix A. Configuring Web Development Environment before reading this chapter to get your development environment configured. Getting Laminas Skeleton Application The Skeleton Application is a simple laminas-based application that contains most necessary things for creating your own website. The skeleton application's code is stored on GitHub code hosting and can be publicly accessed by this link . However, you typically do not download the source code of the skeleton application directly, instead you use Composer dependency manager, as shown below. First, you need to get the latest version of Composer. You do this with the following commands: cd ~ php -r \"copy('https://getcomposer.org/installer', 'composer-setup.php');\" php composer-setup.php php -r \"unlink('composer-setup.php');\" The commands above change your working directory to be your home directory, download the composer-setup.php installer script to your working directory, run it, and, finally, remove the installer. Once you run the commands above, you should have the composer.phar file in your working directory. Now, type the following command from your command prompt: php composer.phar create-project -sdev laminas/skeleton-application helloworld The command above downloads the Laminas Skeleton Application to helloworld directory and runs its interactive installer. You now should answer several yes/no questions by typing y or n and pressing Enter. Your answers will help the installer to determine which dependencies to install. If you don't know what to answer, answer 'n' (no); you will be able to install additional dependencies later at any time. For the beginning, you can answer the questions the following way: Do you want a minimal install (no optional packages)? Y/n n Would you like to install the developer toolbar? y/N n Would you like to install caching support? y/N n Would you like to install database support (installs laminas-db)? y/N n Would you like to install forms support? y/N y Will install laminas/laminas-mvc-form (^1.0) When prompted to install as a module, select application.config.php or modules.config.php Would you like to install JSON de/serialization support? y/N n Would you like to install logging support? y/N n Would you like to install MVC-based console support? (We recommend migrating to zf-console, symfony/console, or Aura.CLI) y/N n Would you like to install i18n support? y/N n Would you like to install the official MVC plugins, including PRG support, identity, and flash messages? y/N n Would you like to use the PSR-7 middleware dispatcher? y/N n Would you like to install sessions support? y/N n Would you like to install MVC testing support? y/N n Would you like to install the laminas-di integration for laminas-servicemanager? y/N n Once you answer the questions, the installer will download and install all necessary packages and asks you to which config file you would like to inject information about installed modules. When prompted, type '1' and press Enter: Please select which config file you wish to inject 'Laminas\\Form' into: [0] Do not inject [1] config/modules.config.php [2] config/development.config.php.dist Make your selection (default is 0):1 Remember this option for other packages of the same type? (y/N) y Next, the installer will ask you if you would like to remove existing version control files from the project. Since you will probably store your web application in your own version control system (like Git) and do not need existing VCS files, type 'y' and press Enter: Do you want to remove the existing VCS (.git, .svn..) history? [Y,n]? y Now copy composer.phar file to your new helloworld directory: cp composer.phar helloworld And final and very important step is enabling the development mode by typing the following command: cd helloworld php composer.phar development-enable Note The development mode is typically used when you develop your application. When you enable the development mode additional \"development\" configuration files are created in your web application's config directory. In this mode your application may optionally load additional \"development\" modules. Configuration caching is also disabled in this mode allowing you to change your website's configuration files and see the changes immediately. Once you have finished the development, you can enable the production mode by typing the following: php composer.phar development-disable Congratulations! The hard work is done. Now let's look inside the helloworld directory. Typical Directory Structure Every laminas-based website (including the skeleton application) is organized in the same recommended way. Of course, you can configure your application to use a different directory layout, but this may make it difficult to support your website by other people who are not familiar with such a directory structure. Let's have a brief look at the typical directory structure (see figure 2.1): As you can see, in the top-level directory (we will denote it APP_DIR from now on), there are several files: composer.json is a JSON configuration file for Composer. composer.lock file contains information about packages installed with Composer. composer.phar is an executable PHP archive containing the code of Composer dependency management tool. docker-compose.yml and Dockerfile files are auxiliary files used only if you use Docker container manager tool. In this book, we do not cover usage of Docker. LICENSE.md is a text file containing Laminas license (you had a chance to read it in Introduction to Laminas Framework ). Do not remove or modify this file, because Laminas license doesn't allow to do so. phpunit.xml.dist file is a configuration for PHPUnit (unit testing framework). You use this file when you want to create unit tests for your website. README.md is a text file containing a brief description of the skeleton application. You typically will replace this file contents with the information about your website: its name, what it does, and how to install it. TODO.md is an auxiliary file that can be safely removed. Vagrantfile is an auxiliary file that contains configuration for Vagrant , which is a virtual development environment manager. You can ignore this file if you don't know what is Vagrant. In this book, we do not use Vagrant. And we also have several subdirectories: The config directory contains application-level configuration files. The data directory contains the data your application might create; it may also contain cache used to speed-up Laminas Framework. The module directory contains all application modules. Currently there is a single module called Application . The Application is the main module of your website. You can also put other modules here, if you wish. We will talk about the modules a little bit later. The vendor directory's purpose is to contain third-party library files, including Laminas Framework library files. This directory is typically populated by Composer. The public directory contains data publicly accessible by the web-user. As you can see, web-users will mainly communicate with the index.php , which is also called the entry point of your website. Note Your website will have a single entry point, index.php , because this is more secure than allowing anyone to access all your PHP files. Inside of the public directory, you can also find hidden .htaccess file. Its main purpose is to define URL rewriting rules. The public directory contains several subdirectories also publicly accessible by web-users: css subdirectory contains all publicly accessible CSS files; fonts subdirectory contains application-specific web-fonts; img subdirectory contains publicly accessible images ( .JPG, .PNG, .GIF, .ICO, etc.); and js subdirectory stores publicly accessible JavaScript files used by your web-pages. Typically, files of jQuery library are placed here, but you can put your own JavaScript files here, too. What is jQuery library? jQuery is a JavaScript library which was created to simplify the client-side scripting of HTML pages. jQuery's selector mechanism allows to easily attach event handlers to certain HTML elements, making it really simple to make your HTML pages interactive. Because the Laminas Skeleton Application is stored on GitHub, inside of the directory structure, you can find hidden .gitignore file. This is a GIT version control system's files. You can ignore it (or even remove them if you do not plan to store your code in a GIT repository). Application Dependencies A dependence is some third-party code your app uses. For example Laminas Framework is the dependence for your website. In Composer, any library is called a package . All packages installable by Composer are registered on Packagist.org site. With Composer, you can identify the packages that your app requires and have Composer to download and install them automatically. The dependencies of the skeleton application are declared in APP_DIR/composer.json file (see below): { \"name\": \"laminas/skeleton-application\", \"description\": \"Skeleton Application for Laminas Framework laminas-mvc applications\", \"type\": \"project\", \"license\": \"BSD-3-Clause\", \"keywords\": [ \"framework\", \"mvc\", \"zf2\" ], \"homepage\": \"http://framework.Laminas.com/\", \"minimum-stability\": \"dev\", \"prefer-stable\": true, \"require\": { \"php\": \"^5.6 || ^7.0\", \"laminas/laminas-component-installer\": \"^1.0 || ^0.3 || ^1.0.0-dev@dev\", \"laminas/laminas-mvc\": \"^3.0.1\", \"zfcampus/zf-development-mode\": \"^3.0\", \"laminas/laminas-mvc-form\": \"^1.0\", \"laminas/laminas-mvc-plugins\": \"^1.0.1\", \"laminas/laminas-session\": \"^2.7.1\" }, \"autoload\": { \"psr-4\": { \"Application\\\\\": \"module/Application/src/\" } }, \"autoload-dev\": { \"psr-4\": { \"ApplicationTest\\\\\": \"module/Application/test/\" } }, \"extra\": [], \"scripts\": { \"development-disable\": \"zf-development-mode disable\", \"development-enable\": \"zf-development-mode enable\", \"development-status\": \"zf-development-mode status\", \"serve\": \"php -S 0.0.0.0:8080 -t public/ public/index.php\" } } What is JSON? JSON (JavaScript Object Notation), is a text-based file format used for human-readable representation of simple structures and nested associative arrays. Although JSON originates from JavaScript, it is used in PHP and in other languages, because it is convenient for storing configuration data. In that file, we see some basic info on the skeleton application (its name, description, license, keywords and home page). You will typically change this info for your future websites. This information is optional, so you can even safely remove it, if you do not plan to publish your web application on Packagist catalog. What is interesting for us now is the require key. The require key contains the dependencies declarations for our application. We see that we require PHP engine version 5.6 or later and several Laminas Framework components, like laminas-mvc , laminas-mvc-form , etc. The information contained in composer.json file is enough to locate the dependencies, download and install them into the vendor subdirectory. If at any time you determine that you need to install another dependency, you can do that by editing composer.json and adding your dependency in it, and then typing the following commands from your command shell: php composer.phar self-update php composer.phar install The commands above will self-update the Composer to the latest available version, and then install your dependencies. By the way, Composer does not install PHP for you, it just ensures PHP has an appropriate version, and if not, it will warn you. If you look inside the vendor subdirectory, you can see that it contains a lot of files. Laminas Framework files can be found inside the APP_DIR/vendor/laminas/ directory (figure 2.2). Note In some other frameworks, another (conventional) way of dependency installation is used. You just download the dependency library as an archive, unpack it and put it somewhere inside of your directory structure (typically, to vendor directory). This approach was used in Zend Framework 1. But, in Laminas Framework, you are recommended to install dependencies with Composer. Apache Virtual Host Now we are almost ready to get our skeleton website live! The last thing we are going to do is configure an Apache virtual host. A virtual host term means that you can run several websites on the same machine. The virtual sites are differentiated by domain name (like site.mydomain.com and site2.mydomain.com ) or by port number (like localhost and localhost:8080 ). Virtual hosts work transparently for site users, that means users have no idea whether the sites are working on the same machine or on different ones. Currently, we have the skeleton application inside of your home directory. To let Apache know about it, we need to edit the virtual host file. Note Virtual host file may be located at a different path, depending on your operating system type. For example, in Linux Ubuntu it is located in /etc/apache2/sites-available/000-default.conf file. For OS- and server-specific information about virtual hosts, please refer to Appendix A. Configuring Web Development Environment . Let's now edit the default virtual host file to make it look like below (we assume you use Apache v2.4): <VirtualHost *:80> ServerAdmin webmaster@localhost DocumentRoot /home/username/helloworld/public <Directory /home/username/helloworld/public/> DirectoryIndex index.php AllowOverride All Require all granted </Directory> </VirtualHost> Line 1 of the file makes Apache to listen to all (*) IP addresses on port 80. Line 2 defines the web master's E-mail address. If something bad happens to the site, Apache sends an alert E-mail to this address. You can enter your E-mail here. Line 4 defines the document root directory ( APP_DIR/public ). All files and directories under the document root will be accessible by web-users. You should set this to be the absolute path to skeleton application's public directory. So, the directories and files inside public (like index.php , css , js , etc.) will be accessible, while directories and files above public directory (like config , module , etc.) wont' be accessible by web users, which enhances the security of the website. Lines 6-10 define rules for the document root directory ( APP_DIR/public ). For example, the DirectoryIndex directive tells Apache that index.php should be used as the default index file. The AllowOverride All directive allows to define any rules in .htaccess files. The Require all granted directive allows everyone to visit the website. Note Laminas Framework utilizes Apache's URL rewriting module for redirecting web-users to entry script of your website. Please ensure that your web server has mod_rewrite module enabled. For instructions on how to enable the module, please refer to Appendix A. Configuring Web Development Environment . Note After editing the config file, do not forget to restart Apache to apply your changes. Opening the Website in Your Browser To open the website, type \"http://localhost\" in your browser's navigation bar and press Enter. Figure 2.3 shows the site in action. On the page that appears, you can see the navigation menu at the top. The navigation bar currently contains the single link named Home . Under the navigation bar, you can see the \"Welcome to Laminas Framework\" caption. Below the caption, you can find some advices for beginners on how to develop new laminas-based applications. Creating NetBeans Project Now that we have the skeleton application set up and working, we will want to change something with it in the future. To easily navigate the directory structure, edit files and debug the website, the common practice is to use an IDE (Integrated Development Environment). In this book, we use NetBeans IDE (see Appendix A. Configuring Web Development Environment for more information on how to install NetBeans). To create NetBeans project for our skeleton application, run NetBeans and open menu File->New Project... . The New Project dialog appears (see figure 2.4). In the Choose Project page that appears, you should choose PHP project type and in the right list select Application with Existing Sources (because we already have the skeleton application's code). Then click the Next button to go to the next page (shown in figure 2.5). In the Name and Location dialog page, you should enter the path to the code (like /home/username/helloworld ), the name for the project (for example, helloworld ) and specify the version of PHP your code uses (PHP 5.6 or later). The PHP version is needed for the NetBeans PHP syntax checker which will scan your PHP code for errors and highlight them. Press the Next button to go to the next dialog page (shown in figure 2.6). In the Run Configuration page, it is recommended that you specify the way you run the website (Local Web Site) and website URL ( http://localhost ). Keep the Index File field empty (because we are using mod_rewrite , the actual path to your index.php file is hidden by Apache). If you are seeing the warning message like \"Index File must be specified in order to run or debug project in command line\", just ignore it. Click the Finish button to create the project. When the helloworld project has been successfully created, you should see the project window (see the figure 2.7). In the project window, you can see the menu bar, the tool bar, the Projects pane where your project files are listed, and, in the right part of the window, you can see the code of the index.php entry file. Please refer to Appendix B. Introduction to PHP Development in NetBeans IDE for more NetBeans usage tips, including launching and interactively debugging laminas-based websites. It's time for some advanced stuff... Congratulations! We've done the hard work of installing and running the Laminas Skeleton Application, and now it's time to have a rest and read about some advanced things in the last part of this chapter. Hypertext Access File (.htaccess) We've mentioned the APP_DIR/public/.htaccess file when talking about typical directory structure. Now let's try to understand the role of this file. The .htaccess (hypertext access) file is actually an Apache web server's configuration file allowing to override some web server's global configuration. The .htaccess file is a directory-level configuration, which means it affects only its owning directory and all sub-directories. The content of .htaccess file is presented below: RewriteEngine On # The following rule tells Apache that if the requested filename # exists, simply serve it. RewriteCond %{REQUEST_FILENAME} -s [OR] RewriteCond %{REQUEST_FILENAME} -l [OR] RewriteCond %{REQUEST_FILENAME} -d RewriteRule ^.*$ - [L] # The following rewrites all other queries to index.php. The # condition ensures that if you are using Apache aliases to do # mass virtual hosting or installed the project in a subdirectory, # the base path will be prepended to allow proper resolution of # the index.php file; it will work in non-aliased environments # as well, providing a safe, one-size fits all solution. RewriteCond %{REQUEST_URI}::$1 ^(/.+)/(.*)::\\2$ RewriteRule ^(.*) - [E=BASE:%1] RewriteRule ^(.*)$ %{ENV:BASE}/index.php [L] Line 1 tells Apache web server to enable URL rewrite engine ( mod_rewrite ). The rewrite engine modifies the incoming URL requests, based on regular expression rules. This allows you to map arbitrary URLs onto your internal URL structure in any way you like. Lines 4 - 7 define rewrite rules that tell the web server that if the client (web browser) requests a file that exists in the document root directory, than to return the contents of that file as HTTP response. Because we have our public directory inside of the virtual host's document root, we allow site users to see all files inside of the public directory, including index.php , CSS files, JavaScript files and image files. Lines 14 - 16 define rewrite rules that tell Apache what to do if the site user requests a file which does not exist in document root. In such a case, the user should be redirected to index.php . Table 2.1 contains several URL rewrite examples. The first and second URLs point to existing files, so mod_rewrite returns the requested file paths. The URL in the third example points to a non-existent file htpasswd (which may be a symptom of a hacker attack), and based on our rewrite rules, the engine returns index.php file. Requested URL Rewritten URL http://localhost/index.php File exists; return the local file APP_DIR/public/index.php http://localhost/css/bootstrap.css File exists; return the local file APP_DIR/public/css/bootstrap.css http://localhost/htpasswd File does not exist; return APP_DIR/public/index.php instead. Table 2.1. URL rewrite examples Blocking Access to the Website by IP Address Sometimes it may be required to block access to your website from all other IP addresses except yours. For example, when you develop a website, you don't want someone to see your incomplete work. Also, you may not want to let Google or other search engines to index your website. To forbid access to your site, you can modify the virtual host and add the following line to it: Require ip <your_ip_address> How do I determine my IP address? You can use the http://www.whatismyip.com website to determine your external IP address. The external IP address is the address by which other computers on the Internet may access your site. HTTP Authentication You may want to allow access to your site to certain users. For example, when you are demonstrating your website to your boss, you will give her username and password for logging into your site. To allow access to your website by username and password, you can modify the virtual host file as follows: ... <Directory /home/username/helloworld/public/> DirectoryIndex index.php AllowOverride All AuthType Basic AuthName \"Authentication Required\" AuthUserFile /usr/local/apache/passwd/passwords Require valid-user </Directory> ... Line 5 defines Basic authentication method. The most common method is Basic. It is important to be aware, however, that Basic authentication sends the password from the client to the server unencrypted. This method should therefore not be used for highly sensitive data. Apache supports one other authentication method: AuthType Digest . This method is much more secure. Most recent browsers support Digest authentication. Line 6 defines the text that will be displayed to user when he tries to log in. Line 7 defines the file where passwords will be stored. This file should be created with the htpasswd utility. Line 8 will allow anyone to log in that is listed in the password file, and who correctly enters their password. To create passwords file, type the following command: htpasswd -c /usr/local/apache/passwd/passwords <username> In the command above, you should replace the <username> placeholder with the name of the user. You can choose an arbitrary name, for example \"admin\". The command will request the user's password and write the password to the file: # htpasswd -c /usr/local/apache/passwd/passwords <username> New password: Re-type new password: Adding password for user <username> When the user tries to visit the site, he/she sees the HTTP authentication dialog. To log into your site, the visitor should enter the correct username and password. Note For additional information on HTTP authentication, you can refer to Authentication and Authorization topic of Apache documentation. Having Multiple Virtual Hosts When developing several websites on the same machine, you will want to create several virtual hosts. For each virtual host you need to specify a domain name (like site1.mydomain.com ). But if you currently don't have a domain name, you can specify a different port instead (see the example below). # Listen directive tells Apache to listen requests on port 8080 Listen 8080 <VirtualHost *:8080> ... </VirtualHost> To access the website, in your browser's navigation bar, enter \"http://localhost:8080\". Note After editing the virtual host config file, you should restart Apache to apply changes. Hosts File When you have multiple local websites mapped to different ports, it becomes difficult to remember on which port each site presents. To simplify this, you can use name-based virtual host and define an alias for your website in your system hosts file. First, modify your Apache virtual host file to be name-based virtual host: <VirtualHost *:80> # Add the ServerName directive ServerName site1.localhost ... </VirtualHost> Next, you should edit the hosts file. The hosts file is a system file which contains mappings between IP addresses and host names. The hosts file contains lines of text consisting of an IP address in the first text field followed by one or more host names. To add an alias for your local websites, add lines for each of your website as shown in the example below. 127.0.0.1 site1.localhost So now you'll be able to simply enter \"site1.localhost\" in your browser's address bar instead of remembering the port number. Note In Linux, the hosts file is located in /etc/hosts . In Windows, the file is typically located in C:\\Windows\\System32\\drivers\\etc\\hosts . To edit the file, you need to be an administrator. Please also note that some anti-virus software may block changes to hosts file, so you'll have to temporarily disable your anti-virus to edit the file, and enable it after. Note If you have purchased a real domain name for your website (like example.com ), you do not need to modify your hosts file, because Apache will be able to resolve the IP address of your website using the DNS system. You modify your hosts file only when DNS system knows nothing about the domain name and can't resolve the IP address of your website. Advanced Composer Usage Earlier in this chapter, we have used Composer to install Laminas Framework library code. Now let's briefly describe some advanced Composer usage examples. As we already know, the only required key in the composer.json file is require . This key tells what packages are required by your application: { \"require\": { \"php\": \"^5.6 || ^7.0\", \"laminas/laminas-component-installer\": \"^1.0 || ^0.3 || ^1.0.0-dev@dev\", \"laminas/laminas-mvc\": \"^3.0.1\", \"zfcampus/zf-development-mode\": \"^3.0\", \"laminas/laminas-mvc-form\": \"^1.0\", \"laminas/laminas-mvc-plugins\": \"^1.0.1\", \"laminas/laminas-session\": \"^2.7.1\" } } Package Names and Versions A package name consists of two parts: vendor name and project name. For example \"laminas/laminas-mvc\" package name consists of \"laminas\" vendor name and \"laminas-mvc\" project name. You can search for other packages from \"laminas\" vendor through Packagist.org website (see the figure 2.8 for an example). A package also has an associated version number. A version number consists of major number, minor number, optional build number, and optional stability suffix (e.g. b1, rc1). Within the require key we specify which versions of the package are acceptable. For example, \"^5.6\" means that we can install versions greater than \"5.6\", but lower than \"6.0\" (that we can install only those packages that do not break backward compatibility). In table 2.2, possible ways of specifying acceptable versions are presented: Definition Example Description 3.0.1 Exact version. In this example, only the version 3.0.1 can be installed. >=3.0.1 Greater or equal version can be installed (3.0.1, 3.2.1, etc.) >3.0.1 Greater version can be installed (3.0.2 etc.) <=3.0.1 Lower or equal version can be installed (1.0, 1.5, 2.0.0 etc.) <3.0.1 Lower version can be installed (1.0, 1.1, 1.9, etc.) !=3.0.1 All versions except this version can be installed. >=3.0,<3.1.0 Any version belonging to this range of versions can be installed. 3.* Any version having major number equal to 3 can be installed (minor number can be any). ~3.0 Any version starting from 3.0, but lower than the next major version (equivalent to >=3.0,<4.0). ^3.0 Any version starting from 3.0, but lower than the next major version (equivalent to >=3.0,<4.0). Similar to ~3.0 , but it sticks closer to semantic versioning, and will always allow non-breaking updates. Table 2.2. Package Version Definitions Installing and Updating Packages We've seen how to use the php composer.phar install command to install our dependencies. As soon as you call this command, Composer will find, download and install the dependencies to your vendor subdirectory. Is it safe to install dependencies with Composer? Well, some people may be afraid of Composer-style dependency management, because they think someone can update the dependencies system-wide by mistake or intentionally, causing the web application to break. Note, that Composer never installs these system-wide, instead it installs them into your APP_DIR/vendor/ directory. After installation, Composer also creates the APP_DIR/composer.lock file. This file now contains actual versions of the packages that were installed. If you run the install command again, Composer will encounter the composer.lock file, check which dependencies already installed and as all packages already installed, it just exits without doing anything. Now assume that in some period of time new security updates for your dependency packages are released. You will want to update your packages to keep your website secure. You can do that by typing the following: php composer.phar update If you want to update only a single dependency, type its name as the following: php composer.phar update laminas/laminas-mvc After the update command, your composer.lock file will be updated, too. What do I do if I want to roll back to a previous version of the package? If the update procedure resulted in unwanted problems with your system, you can roll back by reverting the changes to your composer.lock file and issuing the install command again. Reverting changes to composer.lock is easy if you use a version control system, like GIT or SVN. If you don't use a version control system, make a backup copy of composer.lock before updating. Adding a New Dependency If you want to add new dependency to the application, you can either edit composer.json manually, or issue require command. For example, to install Doctrine ORM module to your web site (to add the \"doctrine/doctrine-module\" package to the application dependencies), type the following: php composer.phar require doctrine/doctrine-module 2.* The command above edits composer.json file, and downloads and installs the package. We will use this command later in chapter Managing Database with Doctrine , when becoming familiar with database management. Virtual Packages Composer can be used to require some functionality to present on your system. You've already seen how we require \"php:^5.6\". PHP package is a virtual package representing PHP itself. You can also require other stuff, like PHP extensions (see table 2.3 below). Definition Example Description \"php\":\"^5.6\" Require PHP version greater or equal than 5.6, but lower than 6.0. ext-dom, ext-pdo-mysql Require PHP DOM and PDO MySQL extensions lib-openssl Require OpenSSL library Table 2.3. Virtual Composer Packages You can use php composer.phar show --platform command to display a list of available virtual packages for your machine. Composer and Version Control Systems If you are using a version control system (like Git), you will be curious about what should be stored in Git: your application code only, or your application code plus all the Composer-installed dependencies in APP_DIR/vendor directory? In general, it is not recommended to store your Composer-dependencies under version control, because this can make your repository really big and slow to check out and branch. Instead, you should store your composer.lock file under version control. The composer.lock file guarantees that everyone will install the same versions of dependencies as you have. This is useful in development teams having more than one developer, because all developers should have the same code to avoid unwanted issues with environment misconfiguration. What if some dependence will be declared obsolete and removed from Packagist.org? Well, the possibility of package removal is minimum. All packages are free and open-source, and the community of users can always restore the dependency even if it is removed from packagist. By the way, the same concept of dependency installation is used in Linux (remember APT or RPM manager?), so did anyone see any Linux package lost? But there may be situations when you should store some dependent libraries under version control: If you have to make custom changes to third-party code. For example, assume you have to fix a bug in a library, and you cannot wait for the library's vendor to fix it for you (or if the library vendor cannot fix the bug). In this case, you should place the library code under version control to ensure your custom changes won't be lost. If you have written a reusable module or library and want to store it in the vendor directory without publishing it on Packagist.org . Because you don't have an ability to install this code from the Packagist, you should store it under version control. If you want a 100% guarantee that a third-party package won't be lost. Although the risk is minimum, for some applications it is critical to be autonomous and not depend on package availability on Packagist.org . Summary In this chapter, we have downloaded the Laminas Skeleton Application project code from GitHub and installed it via Composer dependency manager. We've configured the Apache Virtual Host to tell the web server about location of the website's document root directory. The skeleton application demonstrates the recommended directory structure of a typical website. We have the public directory containing files publicly accessible by site users, including the index.php entry point file, CSS files, JavaScript files and images. All other directories of the application are inaccessible by site users and contain application configuration, data and modules. In the second part of the chapter we discussed some advanced Apache configuration. For example, you can protect your website with password and allow accessing it from certain IP addresses only. The Composer dependency manager is a powerful tool for installing the dependencies of your website. For example, Laminas Framework itself can be considered as a dependency. All packages installable by Composer are registered in a centralized catalog on the Packagist.org site.","title":"Laminas Skeleton Application"},{"location":"skeleton/#laminas-skeleton-application","text":"Laminas Framework provides you with the so called \"skeleton application\" to make it easier to create your new websites from scratch. In this chapter, we will show how to install the skeleton application and how to create an Apache virtual host. It is recommended that you refer to Appendix A. Configuring Web Development Environment before reading this chapter to get your development environment configured.","title":"Laminas Skeleton Application"},{"location":"skeleton/#getting-laminas-skeleton-application","text":"The Skeleton Application is a simple laminas-based application that contains most necessary things for creating your own website. The skeleton application's code is stored on GitHub code hosting and can be publicly accessed by this link . However, you typically do not download the source code of the skeleton application directly, instead you use Composer dependency manager, as shown below. First, you need to get the latest version of Composer. You do this with the following commands: cd ~ php -r \"copy('https://getcomposer.org/installer', 'composer-setup.php');\" php composer-setup.php php -r \"unlink('composer-setup.php');\" The commands above change your working directory to be your home directory, download the composer-setup.php installer script to your working directory, run it, and, finally, remove the installer. Once you run the commands above, you should have the composer.phar file in your working directory. Now, type the following command from your command prompt: php composer.phar create-project -sdev laminas/skeleton-application helloworld The command above downloads the Laminas Skeleton Application to helloworld directory and runs its interactive installer. You now should answer several yes/no questions by typing y or n and pressing Enter. Your answers will help the installer to determine which dependencies to install. If you don't know what to answer, answer 'n' (no); you will be able to install additional dependencies later at any time. For the beginning, you can answer the questions the following way: Do you want a minimal install (no optional packages)? Y/n n Would you like to install the developer toolbar? y/N n Would you like to install caching support? y/N n Would you like to install database support (installs laminas-db)? y/N n Would you like to install forms support? y/N y Will install laminas/laminas-mvc-form (^1.0) When prompted to install as a module, select application.config.php or modules.config.php Would you like to install JSON de/serialization support? y/N n Would you like to install logging support? y/N n Would you like to install MVC-based console support? (We recommend migrating to zf-console, symfony/console, or Aura.CLI) y/N n Would you like to install i18n support? y/N n Would you like to install the official MVC plugins, including PRG support, identity, and flash messages? y/N n Would you like to use the PSR-7 middleware dispatcher? y/N n Would you like to install sessions support? y/N n Would you like to install MVC testing support? y/N n Would you like to install the laminas-di integration for laminas-servicemanager? y/N n Once you answer the questions, the installer will download and install all necessary packages and asks you to which config file you would like to inject information about installed modules. When prompted, type '1' and press Enter: Please select which config file you wish to inject 'Laminas\\Form' into: [0] Do not inject [1] config/modules.config.php [2] config/development.config.php.dist Make your selection (default is 0):1 Remember this option for other packages of the same type? (y/N) y Next, the installer will ask you if you would like to remove existing version control files from the project. Since you will probably store your web application in your own version control system (like Git) and do not need existing VCS files, type 'y' and press Enter: Do you want to remove the existing VCS (.git, .svn..) history? [Y,n]? y Now copy composer.phar file to your new helloworld directory: cp composer.phar helloworld And final and very important step is enabling the development mode by typing the following command: cd helloworld php composer.phar development-enable Note The development mode is typically used when you develop your application. When you enable the development mode additional \"development\" configuration files are created in your web application's config directory. In this mode your application may optionally load additional \"development\" modules. Configuration caching is also disabled in this mode allowing you to change your website's configuration files and see the changes immediately. Once you have finished the development, you can enable the production mode by typing the following: php composer.phar development-disable Congratulations! The hard work is done. Now let's look inside the helloworld directory.","title":"Getting Laminas Skeleton Application"},{"location":"skeleton/#typical-directory-structure","text":"Every laminas-based website (including the skeleton application) is organized in the same recommended way. Of course, you can configure your application to use a different directory layout, but this may make it difficult to support your website by other people who are not familiar with such a directory structure. Let's have a brief look at the typical directory structure (see figure 2.1): As you can see, in the top-level directory (we will denote it APP_DIR from now on), there are several files: composer.json is a JSON configuration file for Composer. composer.lock file contains information about packages installed with Composer. composer.phar is an executable PHP archive containing the code of Composer dependency management tool. docker-compose.yml and Dockerfile files are auxiliary files used only if you use Docker container manager tool. In this book, we do not cover usage of Docker. LICENSE.md is a text file containing Laminas license (you had a chance to read it in Introduction to Laminas Framework ). Do not remove or modify this file, because Laminas license doesn't allow to do so. phpunit.xml.dist file is a configuration for PHPUnit (unit testing framework). You use this file when you want to create unit tests for your website. README.md is a text file containing a brief description of the skeleton application. You typically will replace this file contents with the information about your website: its name, what it does, and how to install it. TODO.md is an auxiliary file that can be safely removed. Vagrantfile is an auxiliary file that contains configuration for Vagrant , which is a virtual development environment manager. You can ignore this file if you don't know what is Vagrant. In this book, we do not use Vagrant. And we also have several subdirectories: The config directory contains application-level configuration files. The data directory contains the data your application might create; it may also contain cache used to speed-up Laminas Framework. The module directory contains all application modules. Currently there is a single module called Application . The Application is the main module of your website. You can also put other modules here, if you wish. We will talk about the modules a little bit later. The vendor directory's purpose is to contain third-party library files, including Laminas Framework library files. This directory is typically populated by Composer. The public directory contains data publicly accessible by the web-user. As you can see, web-users will mainly communicate with the index.php , which is also called the entry point of your website. Note Your website will have a single entry point, index.php , because this is more secure than allowing anyone to access all your PHP files. Inside of the public directory, you can also find hidden .htaccess file. Its main purpose is to define URL rewriting rules. The public directory contains several subdirectories also publicly accessible by web-users: css subdirectory contains all publicly accessible CSS files; fonts subdirectory contains application-specific web-fonts; img subdirectory contains publicly accessible images ( .JPG, .PNG, .GIF, .ICO, etc.); and js subdirectory stores publicly accessible JavaScript files used by your web-pages. Typically, files of jQuery library are placed here, but you can put your own JavaScript files here, too. What is jQuery library? jQuery is a JavaScript library which was created to simplify the client-side scripting of HTML pages. jQuery's selector mechanism allows to easily attach event handlers to certain HTML elements, making it really simple to make your HTML pages interactive. Because the Laminas Skeleton Application is stored on GitHub, inside of the directory structure, you can find hidden .gitignore file. This is a GIT version control system's files. You can ignore it (or even remove them if you do not plan to store your code in a GIT repository).","title":"Typical Directory Structure"},{"location":"skeleton/#application-dependencies","text":"A dependence is some third-party code your app uses. For example Laminas Framework is the dependence for your website. In Composer, any library is called a package . All packages installable by Composer are registered on Packagist.org site. With Composer, you can identify the packages that your app requires and have Composer to download and install them automatically. The dependencies of the skeleton application are declared in APP_DIR/composer.json file (see below): { \"name\": \"laminas/skeleton-application\", \"description\": \"Skeleton Application for Laminas Framework laminas-mvc applications\", \"type\": \"project\", \"license\": \"BSD-3-Clause\", \"keywords\": [ \"framework\", \"mvc\", \"zf2\" ], \"homepage\": \"http://framework.Laminas.com/\", \"minimum-stability\": \"dev\", \"prefer-stable\": true, \"require\": { \"php\": \"^5.6 || ^7.0\", \"laminas/laminas-component-installer\": \"^1.0 || ^0.3 || ^1.0.0-dev@dev\", \"laminas/laminas-mvc\": \"^3.0.1\", \"zfcampus/zf-development-mode\": \"^3.0\", \"laminas/laminas-mvc-form\": \"^1.0\", \"laminas/laminas-mvc-plugins\": \"^1.0.1\", \"laminas/laminas-session\": \"^2.7.1\" }, \"autoload\": { \"psr-4\": { \"Application\\\\\": \"module/Application/src/\" } }, \"autoload-dev\": { \"psr-4\": { \"ApplicationTest\\\\\": \"module/Application/test/\" } }, \"extra\": [], \"scripts\": { \"development-disable\": \"zf-development-mode disable\", \"development-enable\": \"zf-development-mode enable\", \"development-status\": \"zf-development-mode status\", \"serve\": \"php -S 0.0.0.0:8080 -t public/ public/index.php\" } } What is JSON? JSON (JavaScript Object Notation), is a text-based file format used for human-readable representation of simple structures and nested associative arrays. Although JSON originates from JavaScript, it is used in PHP and in other languages, because it is convenient for storing configuration data. In that file, we see some basic info on the skeleton application (its name, description, license, keywords and home page). You will typically change this info for your future websites. This information is optional, so you can even safely remove it, if you do not plan to publish your web application on Packagist catalog. What is interesting for us now is the require key. The require key contains the dependencies declarations for our application. We see that we require PHP engine version 5.6 or later and several Laminas Framework components, like laminas-mvc , laminas-mvc-form , etc. The information contained in composer.json file is enough to locate the dependencies, download and install them into the vendor subdirectory. If at any time you determine that you need to install another dependency, you can do that by editing composer.json and adding your dependency in it, and then typing the following commands from your command shell: php composer.phar self-update php composer.phar install The commands above will self-update the Composer to the latest available version, and then install your dependencies. By the way, Composer does not install PHP for you, it just ensures PHP has an appropriate version, and if not, it will warn you. If you look inside the vendor subdirectory, you can see that it contains a lot of files. Laminas Framework files can be found inside the APP_DIR/vendor/laminas/ directory (figure 2.2). Note In some other frameworks, another (conventional) way of dependency installation is used. You just download the dependency library as an archive, unpack it and put it somewhere inside of your directory structure (typically, to vendor directory). This approach was used in Zend Framework 1. But, in Laminas Framework, you are recommended to install dependencies with Composer.","title":"Application Dependencies"},{"location":"skeleton/#apache-virtual-host","text":"Now we are almost ready to get our skeleton website live! The last thing we are going to do is configure an Apache virtual host. A virtual host term means that you can run several websites on the same machine. The virtual sites are differentiated by domain name (like site.mydomain.com and site2.mydomain.com ) or by port number (like localhost and localhost:8080 ). Virtual hosts work transparently for site users, that means users have no idea whether the sites are working on the same machine or on different ones. Currently, we have the skeleton application inside of your home directory. To let Apache know about it, we need to edit the virtual host file. Note Virtual host file may be located at a different path, depending on your operating system type. For example, in Linux Ubuntu it is located in /etc/apache2/sites-available/000-default.conf file. For OS- and server-specific information about virtual hosts, please refer to Appendix A. Configuring Web Development Environment . Let's now edit the default virtual host file to make it look like below (we assume you use Apache v2.4): <VirtualHost *:80> ServerAdmin webmaster@localhost DocumentRoot /home/username/helloworld/public <Directory /home/username/helloworld/public/> DirectoryIndex index.php AllowOverride All Require all granted </Directory> </VirtualHost> Line 1 of the file makes Apache to listen to all (*) IP addresses on port 80. Line 2 defines the web master's E-mail address. If something bad happens to the site, Apache sends an alert E-mail to this address. You can enter your E-mail here. Line 4 defines the document root directory ( APP_DIR/public ). All files and directories under the document root will be accessible by web-users. You should set this to be the absolute path to skeleton application's public directory. So, the directories and files inside public (like index.php , css , js , etc.) will be accessible, while directories and files above public directory (like config , module , etc.) wont' be accessible by web users, which enhances the security of the website. Lines 6-10 define rules for the document root directory ( APP_DIR/public ). For example, the DirectoryIndex directive tells Apache that index.php should be used as the default index file. The AllowOverride All directive allows to define any rules in .htaccess files. The Require all granted directive allows everyone to visit the website. Note Laminas Framework utilizes Apache's URL rewriting module for redirecting web-users to entry script of your website. Please ensure that your web server has mod_rewrite module enabled. For instructions on how to enable the module, please refer to Appendix A. Configuring Web Development Environment . Note After editing the config file, do not forget to restart Apache to apply your changes.","title":"Apache Virtual Host"},{"location":"skeleton/#opening-the-website-in-your-browser","text":"To open the website, type \"http://localhost\" in your browser's navigation bar and press Enter. Figure 2.3 shows the site in action. On the page that appears, you can see the navigation menu at the top. The navigation bar currently contains the single link named Home . Under the navigation bar, you can see the \"Welcome to Laminas Framework\" caption. Below the caption, you can find some advices for beginners on how to develop new laminas-based applications.","title":"Opening the Website in Your Browser"},{"location":"skeleton/#creating-netbeans-project","text":"Now that we have the skeleton application set up and working, we will want to change something with it in the future. To easily navigate the directory structure, edit files and debug the website, the common practice is to use an IDE (Integrated Development Environment). In this book, we use NetBeans IDE (see Appendix A. Configuring Web Development Environment for more information on how to install NetBeans). To create NetBeans project for our skeleton application, run NetBeans and open menu File->New Project... . The New Project dialog appears (see figure 2.4). In the Choose Project page that appears, you should choose PHP project type and in the right list select Application with Existing Sources (because we already have the skeleton application's code). Then click the Next button to go to the next page (shown in figure 2.5). In the Name and Location dialog page, you should enter the path to the code (like /home/username/helloworld ), the name for the project (for example, helloworld ) and specify the version of PHP your code uses (PHP 5.6 or later). The PHP version is needed for the NetBeans PHP syntax checker which will scan your PHP code for errors and highlight them. Press the Next button to go to the next dialog page (shown in figure 2.6). In the Run Configuration page, it is recommended that you specify the way you run the website (Local Web Site) and website URL ( http://localhost ). Keep the Index File field empty (because we are using mod_rewrite , the actual path to your index.php file is hidden by Apache). If you are seeing the warning message like \"Index File must be specified in order to run or debug project in command line\", just ignore it. Click the Finish button to create the project. When the helloworld project has been successfully created, you should see the project window (see the figure 2.7). In the project window, you can see the menu bar, the tool bar, the Projects pane where your project files are listed, and, in the right part of the window, you can see the code of the index.php entry file. Please refer to Appendix B. Introduction to PHP Development in NetBeans IDE for more NetBeans usage tips, including launching and interactively debugging laminas-based websites. It's time for some advanced stuff... Congratulations! We've done the hard work of installing and running the Laminas Skeleton Application, and now it's time to have a rest and read about some advanced things in the last part of this chapter.","title":"Creating NetBeans Project"},{"location":"skeleton/#hypertext-access-file-htaccess","text":"We've mentioned the APP_DIR/public/.htaccess file when talking about typical directory structure. Now let's try to understand the role of this file. The .htaccess (hypertext access) file is actually an Apache web server's configuration file allowing to override some web server's global configuration. The .htaccess file is a directory-level configuration, which means it affects only its owning directory and all sub-directories. The content of .htaccess file is presented below: RewriteEngine On # The following rule tells Apache that if the requested filename # exists, simply serve it. RewriteCond %{REQUEST_FILENAME} -s [OR] RewriteCond %{REQUEST_FILENAME} -l [OR] RewriteCond %{REQUEST_FILENAME} -d RewriteRule ^.*$ - [L] # The following rewrites all other queries to index.php. The # condition ensures that if you are using Apache aliases to do # mass virtual hosting or installed the project in a subdirectory, # the base path will be prepended to allow proper resolution of # the index.php file; it will work in non-aliased environments # as well, providing a safe, one-size fits all solution. RewriteCond %{REQUEST_URI}::$1 ^(/.+)/(.*)::\\2$ RewriteRule ^(.*) - [E=BASE:%1] RewriteRule ^(.*)$ %{ENV:BASE}/index.php [L] Line 1 tells Apache web server to enable URL rewrite engine ( mod_rewrite ). The rewrite engine modifies the incoming URL requests, based on regular expression rules. This allows you to map arbitrary URLs onto your internal URL structure in any way you like. Lines 4 - 7 define rewrite rules that tell the web server that if the client (web browser) requests a file that exists in the document root directory, than to return the contents of that file as HTTP response. Because we have our public directory inside of the virtual host's document root, we allow site users to see all files inside of the public directory, including index.php , CSS files, JavaScript files and image files. Lines 14 - 16 define rewrite rules that tell Apache what to do if the site user requests a file which does not exist in document root. In such a case, the user should be redirected to index.php . Table 2.1 contains several URL rewrite examples. The first and second URLs point to existing files, so mod_rewrite returns the requested file paths. The URL in the third example points to a non-existent file htpasswd (which may be a symptom of a hacker attack), and based on our rewrite rules, the engine returns index.php file. Requested URL Rewritten URL http://localhost/index.php File exists; return the local file APP_DIR/public/index.php http://localhost/css/bootstrap.css File exists; return the local file APP_DIR/public/css/bootstrap.css http://localhost/htpasswd File does not exist; return APP_DIR/public/index.php instead. Table 2.1. URL rewrite examples","title":"Hypertext Access File (.htaccess)"},{"location":"skeleton/#blocking-access-to-the-website-by-ip-address","text":"Sometimes it may be required to block access to your website from all other IP addresses except yours. For example, when you develop a website, you don't want someone to see your incomplete work. Also, you may not want to let Google or other search engines to index your website. To forbid access to your site, you can modify the virtual host and add the following line to it: Require ip <your_ip_address> How do I determine my IP address? You can use the http://www.whatismyip.com website to determine your external IP address. The external IP address is the address by which other computers on the Internet may access your site.","title":"Blocking Access to the Website by IP Address"},{"location":"skeleton/#http-authentication","text":"You may want to allow access to your site to certain users. For example, when you are demonstrating your website to your boss, you will give her username and password for logging into your site. To allow access to your website by username and password, you can modify the virtual host file as follows: ... <Directory /home/username/helloworld/public/> DirectoryIndex index.php AllowOverride All AuthType Basic AuthName \"Authentication Required\" AuthUserFile /usr/local/apache/passwd/passwords Require valid-user </Directory> ... Line 5 defines Basic authentication method. The most common method is Basic. It is important to be aware, however, that Basic authentication sends the password from the client to the server unencrypted. This method should therefore not be used for highly sensitive data. Apache supports one other authentication method: AuthType Digest . This method is much more secure. Most recent browsers support Digest authentication. Line 6 defines the text that will be displayed to user when he tries to log in. Line 7 defines the file where passwords will be stored. This file should be created with the htpasswd utility. Line 8 will allow anyone to log in that is listed in the password file, and who correctly enters their password. To create passwords file, type the following command: htpasswd -c /usr/local/apache/passwd/passwords <username> In the command above, you should replace the <username> placeholder with the name of the user. You can choose an arbitrary name, for example \"admin\". The command will request the user's password and write the password to the file: # htpasswd -c /usr/local/apache/passwd/passwords <username> New password: Re-type new password: Adding password for user <username> When the user tries to visit the site, he/she sees the HTTP authentication dialog. To log into your site, the visitor should enter the correct username and password. Note For additional information on HTTP authentication, you can refer to Authentication and Authorization topic of Apache documentation.","title":"HTTP Authentication"},{"location":"skeleton/#having-multiple-virtual-hosts","text":"When developing several websites on the same machine, you will want to create several virtual hosts. For each virtual host you need to specify a domain name (like site1.mydomain.com ). But if you currently don't have a domain name, you can specify a different port instead (see the example below). # Listen directive tells Apache to listen requests on port 8080 Listen 8080 <VirtualHost *:8080> ... </VirtualHost> To access the website, in your browser's navigation bar, enter \"http://localhost:8080\". Note After editing the virtual host config file, you should restart Apache to apply changes.","title":"Having Multiple Virtual Hosts"},{"location":"skeleton/#hosts-file","text":"When you have multiple local websites mapped to different ports, it becomes difficult to remember on which port each site presents. To simplify this, you can use name-based virtual host and define an alias for your website in your system hosts file. First, modify your Apache virtual host file to be name-based virtual host: <VirtualHost *:80> # Add the ServerName directive ServerName site1.localhost ... </VirtualHost> Next, you should edit the hosts file. The hosts file is a system file which contains mappings between IP addresses and host names. The hosts file contains lines of text consisting of an IP address in the first text field followed by one or more host names. To add an alias for your local websites, add lines for each of your website as shown in the example below. 127.0.0.1 site1.localhost So now you'll be able to simply enter \"site1.localhost\" in your browser's address bar instead of remembering the port number. Note In Linux, the hosts file is located in /etc/hosts . In Windows, the file is typically located in C:\\Windows\\System32\\drivers\\etc\\hosts . To edit the file, you need to be an administrator. Please also note that some anti-virus software may block changes to hosts file, so you'll have to temporarily disable your anti-virus to edit the file, and enable it after. Note If you have purchased a real domain name for your website (like example.com ), you do not need to modify your hosts file, because Apache will be able to resolve the IP address of your website using the DNS system. You modify your hosts file only when DNS system knows nothing about the domain name and can't resolve the IP address of your website.","title":"Hosts File"},{"location":"skeleton/#advanced-composer-usage","text":"Earlier in this chapter, we have used Composer to install Laminas Framework library code. Now let's briefly describe some advanced Composer usage examples. As we already know, the only required key in the composer.json file is require . This key tells what packages are required by your application: { \"require\": { \"php\": \"^5.6 || ^7.0\", \"laminas/laminas-component-installer\": \"^1.0 || ^0.3 || ^1.0.0-dev@dev\", \"laminas/laminas-mvc\": \"^3.0.1\", \"zfcampus/zf-development-mode\": \"^3.0\", \"laminas/laminas-mvc-form\": \"^1.0\", \"laminas/laminas-mvc-plugins\": \"^1.0.1\", \"laminas/laminas-session\": \"^2.7.1\" } }","title":"Advanced Composer Usage"},{"location":"skeleton/#package-names-and-versions","text":"A package name consists of two parts: vendor name and project name. For example \"laminas/laminas-mvc\" package name consists of \"laminas\" vendor name and \"laminas-mvc\" project name. You can search for other packages from \"laminas\" vendor through Packagist.org website (see the figure 2.8 for an example). A package also has an associated version number. A version number consists of major number, minor number, optional build number, and optional stability suffix (e.g. b1, rc1). Within the require key we specify which versions of the package are acceptable. For example, \"^5.6\" means that we can install versions greater than \"5.6\", but lower than \"6.0\" (that we can install only those packages that do not break backward compatibility). In table 2.2, possible ways of specifying acceptable versions are presented: Definition Example Description 3.0.1 Exact version. In this example, only the version 3.0.1 can be installed. >=3.0.1 Greater or equal version can be installed (3.0.1, 3.2.1, etc.) >3.0.1 Greater version can be installed (3.0.2 etc.) <=3.0.1 Lower or equal version can be installed (1.0, 1.5, 2.0.0 etc.) <3.0.1 Lower version can be installed (1.0, 1.1, 1.9, etc.) !=3.0.1 All versions except this version can be installed. >=3.0,<3.1.0 Any version belonging to this range of versions can be installed. 3.* Any version having major number equal to 3 can be installed (minor number can be any). ~3.0 Any version starting from 3.0, but lower than the next major version (equivalent to >=3.0,<4.0). ^3.0 Any version starting from 3.0, but lower than the next major version (equivalent to >=3.0,<4.0). Similar to ~3.0 , but it sticks closer to semantic versioning, and will always allow non-breaking updates. Table 2.2. Package Version Definitions","title":"Package Names and Versions"},{"location":"skeleton/#installing-and-updating-packages","text":"We've seen how to use the php composer.phar install command to install our dependencies. As soon as you call this command, Composer will find, download and install the dependencies to your vendor subdirectory. Is it safe to install dependencies with Composer? Well, some people may be afraid of Composer-style dependency management, because they think someone can update the dependencies system-wide by mistake or intentionally, causing the web application to break. Note, that Composer never installs these system-wide, instead it installs them into your APP_DIR/vendor/ directory. After installation, Composer also creates the APP_DIR/composer.lock file. This file now contains actual versions of the packages that were installed. If you run the install command again, Composer will encounter the composer.lock file, check which dependencies already installed and as all packages already installed, it just exits without doing anything. Now assume that in some period of time new security updates for your dependency packages are released. You will want to update your packages to keep your website secure. You can do that by typing the following: php composer.phar update If you want to update only a single dependency, type its name as the following: php composer.phar update laminas/laminas-mvc After the update command, your composer.lock file will be updated, too. What do I do if I want to roll back to a previous version of the package? If the update procedure resulted in unwanted problems with your system, you can roll back by reverting the changes to your composer.lock file and issuing the install command again. Reverting changes to composer.lock is easy if you use a version control system, like GIT or SVN. If you don't use a version control system, make a backup copy of composer.lock before updating.","title":"Installing and Updating Packages"},{"location":"skeleton/#adding-a-new-dependency","text":"If you want to add new dependency to the application, you can either edit composer.json manually, or issue require command. For example, to install Doctrine ORM module to your web site (to add the \"doctrine/doctrine-module\" package to the application dependencies), type the following: php composer.phar require doctrine/doctrine-module 2.* The command above edits composer.json file, and downloads and installs the package. We will use this command later in chapter Managing Database with Doctrine , when becoming familiar with database management.","title":"Adding a New Dependency"},{"location":"skeleton/#virtual-packages","text":"Composer can be used to require some functionality to present on your system. You've already seen how we require \"php:^5.6\". PHP package is a virtual package representing PHP itself. You can also require other stuff, like PHP extensions (see table 2.3 below). Definition Example Description \"php\":\"^5.6\" Require PHP version greater or equal than 5.6, but lower than 6.0. ext-dom, ext-pdo-mysql Require PHP DOM and PDO MySQL extensions lib-openssl Require OpenSSL library Table 2.3. Virtual Composer Packages You can use php composer.phar show --platform command to display a list of available virtual packages for your machine.","title":"Virtual Packages"},{"location":"skeleton/#composer-and-version-control-systems","text":"If you are using a version control system (like Git), you will be curious about what should be stored in Git: your application code only, or your application code plus all the Composer-installed dependencies in APP_DIR/vendor directory? In general, it is not recommended to store your Composer-dependencies under version control, because this can make your repository really big and slow to check out and branch. Instead, you should store your composer.lock file under version control. The composer.lock file guarantees that everyone will install the same versions of dependencies as you have. This is useful in development teams having more than one developer, because all developers should have the same code to avoid unwanted issues with environment misconfiguration. What if some dependence will be declared obsolete and removed from Packagist.org? Well, the possibility of package removal is minimum. All packages are free and open-source, and the community of users can always restore the dependency even if it is removed from packagist. By the way, the same concept of dependency installation is used in Linux (remember APT or RPM manager?), so did anyone see any Linux package lost? But there may be situations when you should store some dependent libraries under version control: If you have to make custom changes to third-party code. For example, assume you have to fix a bug in a library, and you cannot wait for the library's vendor to fix it for you (or if the library vendor cannot fix the bug). In this case, you should place the library code under version control to ensure your custom changes won't be lost. If you have written a reusable module or library and want to store it in the vendor directory without publishing it on Packagist.org . Because you don't have an ability to install this code from the Packagist, you should store it under version control. If you want a 100% guarantee that a third-party package won't be lost. Although the risk is minimum, for some applications it is critical to be autonomous and not depend on package availability on Packagist.org .","title":"Composer and Version Control Systems"},{"location":"skeleton/#summary","text":"In this chapter, we have downloaded the Laminas Skeleton Application project code from GitHub and installed it via Composer dependency manager. We've configured the Apache Virtual Host to tell the web server about location of the website's document root directory. The skeleton application demonstrates the recommended directory structure of a typical website. We have the public directory containing files publicly accessible by site users, including the index.php entry point file, CSS files, JavaScript files and images. All other directories of the application are inaccessible by site users and contain application configuration, data and modules. In the second part of the chapter we discussed some advanced Apache configuration. For example, you can protect your website with password and allow accessing it from certain IP addresses only. The Composer dependency manager is a powerful tool for installing the dependencies of your website. For example, Laminas Framework itself can be considered as a dependency. All packages installable by Composer are registered in a centralized catalog on the Packagist.org site.","title":"Summary"},{"location":"uploads/","text":"Uploading Files with Forms In this chapter, you will learn about uploading files with forms. First, we will review the basic theory like HTTP file upload capability and binary content transfer encoding, and then provide a complete working Image Gallery example showing how to upload images to a web server. Laminas components covered in this chapter: Component Description @ Laminas\\Form Contains base form model classes. @ Laminas\\Filter Contains various filters classes. @ Laminas\\Validator Implements various validator classes. @ Laminas\\InputFilter Implements a container for filters/validators. About HTTP File Uploads HTML forms have capability for uploading files of arbitrarily large size 1 . The files are typically transmitted through HTTP POST method 2 . By default, HTTP uses the URL encoding for transfers of form data, and you could see how that encoding looks like in previous chapters. However, this encoding is inefficient for uploading large files, since URL-encoding binary data dramatically increases the length of the HTTP request. For the purpose of uploading files, it is instead recommended to use the so called \"binary transfer encoding\" described in the next section. HTTP Binary Transfer Encoding A simple HTML form capable of file uploads is shown in the code example below. The binary encoding type is enabled by setting the enctype attribute of the form with the value of \"multipart/form-data\": <form action=\"upload\" method=\"POST\" enctype=\"multipart/form-data\"> <input type=\"file\" name=\"myfile\"> <br/> <input type=\"submit\" name=\"Submit\"> </form> In line 1, we explicitly set form encoding ( enctype attribute) to \"multipart/form-data\" to utilize effective binary content transfer encoding for the form. In line 2, we define an input field with type \"file\" and name \"myfile\". This input field will allow site visitor to select the file for upload. If you now save the above mentioned markup to an .html file and open it in your web browser, you will see the page like in figure 10.1. The file element has the Browse... button allowing to pick a file for upload. When the site user picks some file and clicks the Submit button on the form, the web browser will send an HTTP request to the web server, and the request will contain the data of the file being uploaded. The example below illustrates how the HTTP request may look like: POST http://localhost/upload HTTP/1.1 Host: localhost Content-Length: 488 User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) Content-Type: multipart/form-data; boundary=----j1bOrwgLvOC3dy7o Accept-Encoding: gzip,deflate,sdch ------j1bOrwgLvOC3dy7o Content-Disposition: form-data; name=\"myfile\"; filename=\"Somefile.txt\" Content-Type: text/html (file binary data goes here) ------j1bOrwgLvOC3dy7o Content-Disposition: form-data; name=\"Submit\" Submit Request ------j1bOrwgLvOC3dy7o-- As you can see from the example above, the HTTP request with \"multipart/form-data\" encoding type looks analogous to a usual HTTP request (has the status line, the headers, and the content area), however it has the following important differences: Line 5 sets the \"Content-Type\" header with \"multipart/form-data\" value; The form is assembled of the fields marked by the \"boundary\" -- a unique randomly generated sequence of characters delimiting form fields of each other. Lines 8-17 represent the content of the HTTP request. The form fields are delimited by the \"boundary\" sequences (lines 8, 13, 17). The data of the file being uploaded are transmitted in binary format (line 12), and that allows to reduce the content size to its minimum. Note By default, PHP engine's settings do not allow to upload large files (larger than 2MB). In order to upload large files, you may need to edit the php.ini configuration file and modify the post_max_size and upload_max_filesize parameters (please refer to Appendix A. Configuring Web Development Environment for information on how to do that). Setting these with 100M allows to upload files up to 100 Mb in size, and this would typically be sufficient. If you plan to upload very large files up to 1 GB in size, than better set these with 1024M. Do not forget to restart your Apache Web Server after editing the configuration file. $_FILES Super-Global Array in PHP When a site visitor uploads some files to your Apache Web Server, the files are placed to a temporary location (usually to system temporary directory that is /tmp in Linux and C:\\Windows\\Temp in Windows). The PHP script receives the file information to the special super-global array named $_FILES . The $_FILES array is analogous to the $_GET and $_POST super-globals. The latter two are used to store the GET and POST variables, respectively, while the first one is used to store information about uploaded files. For example, for the above mentioned simple upload form, the $_FILES super-global array will look as follows (the output is generated with the var_dump() PHP function): array (size=1) 'myfile' => array (size=5) 'name' => string 'somefile.txt' (length=12) 'type' => string 'text/plain' (length=10) 'tmp_name' => string '/tmp/phpDC66.tmp' (length=16) 'error' => int 0 'size' => int 18 As you can see from the example above, the $_FILES array contains an entry per each uploaded file. For each uploaded file, it contains the following information: name -- original file name (line 4). type -- MIME 3 type of the file (line 5). tmp_name -- temporary name for the uploaded file (line 6). error -- error code signalling about the status of the upload (line 7); error code zero means the file was uploaded correctly. size -- file size in bytes (line 8). PHP engine stores the uploaded files in a temporary location which is cleaned up as soon as the PHP script execution ends. So, if you want to save the uploaded files to some directory for later use, you need to utilize the move_uploaded_file() PHP function. The move_uploaded_file() function takes two arguments: the first one is the name of the temporary file, and the second one is the destination file name. Important You might be confused why you cannot use the usual rename() PHP function for moving the temporary uploaded file to its destination path. PHP has special function for moving uploaded files for security reasons. The move_uploaded_file() function is analogous to rename() function, but it takes some additional checks to ensure the file was really transferred through HTTP POST request, and that the upload process has finished without errors. The following code example shows how to move the file uploaded with the simple form we have considered above: $destPath = '/path/to/your/upload/dir'; $result = move_uploaded_file($_FILES['myfile']['tmp_name'], $destPath); if(!$result) { // Some error occurred. } Above, in line 1, we set the $destPath with the directory name where to save the uploaded file. In line 2, we call the move_uploaded_file() function and pass it two arguments: the path to the temporary file and the destination path. Note Specifying the directory name as the second argument of the move_uploaded_file() function is suitable when you do not want to rename the file. If you need to save the uploaded file under another name than its original name, you can specify the full file path instead of the directory name. In line 3, we check the returned value of the function. If the operation is successful, the function will return true . If some error occurs (for example, if directory permissions are insufficient to save the file), the boolean false will be returned. Accessing Uploaded Files in Laminas In your controller class, you typically do not communicate with the $_FILES array directly, instead you may use the @ Request [Laminas\\Http\\Request] class or the @ Params controller plugin, as shown in code example below: <?php //... class IndexController extends AbstractActionController { // An example controller action intended for handling file uploads. public function uploadAction() { // Get the whole $_FILES array. $files = $this->getRequest()->getFiles(); // The same, but with Params controller plugin. $files = $this->params()->fromFiles(); // Get a single entry of the $_FILES array. $files = $this->params()->fromFiles('myfile'); } } In line 9 of the code above, we use the getRequest() method of the controller class for accessing the @ Request [Laminas\\Http\\Request] object, and the getFiles() method of the request object to retrieve the information about all upload files at once. In line 12, we do the same thing with the @ Params controller plugin. We use its fromFiles() method to get the information about all uploaded files. If needed, you can extract the information for the specific file only. In line 15, we use the same fromFiles() method and pass it the name of the file field to retrieve. This retrieves the single file entry from the $_FILES super-global array. File Uploads & Laminas Form Model To add file uploading capability to your form model, you need to add an element of the @ Laminas\\Form\\Element\\File class as follows: // Add the following code inside of form's addElements() method. // Add the \"file\" field. $this->add([ 'type' => 'file', 'name' => 'file', 'attributes' => [ 'id' => 'file' ], 'options' => [ 'label' => 'Upload file', ], ]); In the code above, we call the add() method provided by the @ Form [Laminas\\Form\\Form] base class and pass it the configuration array describing the element. The type key of the array (line 5) must be either @ Laminas\\Form\\Element\\File class name or its short alias \"file\". Validating Uploaded Files Uploaded files need to be checked for correctness as any other form data. For example, you may need to check that: the file(s) were really uploaded through HTTP POST request, and were not just copied from some directory; the file(s) were uploaded successfully (the error code is zero); the file names and/or extensions are acceptable (e.g., you may want to save JPEG files only, and reject all others); the file size lies in the allowed range (e.g., you may want to ensure that the file is not too big); total count of uploaded files doesn't exceed some allowed limit. For doing the checks like above, Laminas provides a number of useful file validators (listed in table 10.1). Those validator classes belong to @ Laminas\\Validator component and live in @ Laminas\\Validator\\File [Laminas\\Validator] namespace. Class name Short alias Description @ Count FileCount Checks whether the file count is in a given range (min, max). @ WordCount FileWordCount Calculates the number of words in a file and checks whether it lies in a given range. @ Upload FileUpload Performs security checks ensuring that all given files were really uploaded through HTTP POST and there were no upload errors. @ UploadFile FileUploadFile Performs security checks ensuring that a file really was uploaded through HTTP POST and there were no upload errors. @ Size FileSize Checks whether the file size lies in a given range. @ FilesSize FileFilesSize Checks that the summary size of all given files lies in a given range. @ Extension FileExtension Checks that the extension of a file belongs to a set of allowed extensions. @ ExcludeExtension FileExcludeExtension Checks that the extension of a file DOES NOT belong to a set of extensions. @ MimeType FileMimeType Checks that the MIME type of a file belongs to the list of allowed MIME types. @ ExcludeMimeType FileExcludeMimeType Checks that the MIME type of a file DOES NOT belong to the list of MIME types. @ IsImage FileIsImage Checks that the file is a graphical image (JPEG, PNG, GIF, etc.) @ ImageSize FileImageSize Checks that the image file's dimensions lie in a given range. @ Exists FileExists Checks whether the file exists on disk. @ NotExists FileNotExists Checks whether the file doesn't exist on disk. @ IsCompressed FileIsCompressed Checks that the file is an archive (ZIP, TAR, etc.) @ Hash [Laminas\\Validator\\File\\Hash] FileHash Checks that the file content matches the given hash(es). @ Crc32 FileCrc32 Checks that the file content has the given CRC32 check sum. @ Sha1 FileSha1 Checks that the file content has the given SHA-1 hash. @ Md5 FileMd5 Checks that the file content has the given MD5 hash. Table 10.1. Standard File Validators As you can see from the table above, file validators may be roughly divided in the following groups: validators checking whether the file(s) were really uploaded through HTTP POST and upload status is OK; validators checking the uploaded file count and file size; validators checking the file extension and MIME type; validators checking whether the file is a graphical image and checking image dimensions; and validators checking the file hash (or check sum) 4 . Note Please note that since file validators live in @ Laminas\\Validator\\File [Laminas\\Validator] namespace, their short aliases (that you use when creating a validator with the factory) start with File prefix. For example, the @ IsImage validator has FileIsImage alias. We will show how to use some of these file validators in the Image Gallery code example later in this chapter. Filtering Uploaded Files Laminas Framework provides several filters intended for \"transforming\" file fields. Those filter classes (listed in table 10.2) belong to @ Laminas\\Filter component and live in @ Laminas\\Filter\\File [Laminas\\Filter] namespace. Class name Short alias Description @ Rename FileRename Renames/moves an arbitrary file. @ RenameUpload FileRenameUpload Renames/moves the uploaded file with security checks. @ Encrypt [Laminas\\Filter\\File\\Encrypt] FileEncrypt Encrypts a given file and stores the encrypted file content. @ Decrypt [Laminas\\Filter\\File\\Decrypt] FileDecrypt Decrypts a given file and stores the decrypted file content. @ LowerCase FileLowerCase Converts file content to lower case letters. @ UpperCase FileUpperCase Converts file content to upper case letters. Table 10.2. Standard File Filters From the table, you can see that filters can be divided into the following groups: filters for moving uploaded files from a temporary location to their persistent directory; filters for encryption and decryption of files; filters for converting text files to upper-case and lower-case letters. Note Please note that since file filters live in @ Laminas\\Filter\\File [Laminas\\Filter] namespace, their short aliases (that you use when creating a filter with the factory) start with File prefix. For example, the @ RenameUpload filter has FileRenameUpload alias. The @ Encrypt [Laminas\\Filter\\File\\Encrypt] and @ Decrypt [Laminas\\Filter\\File\\Decrypt] filters allow to apply various encryption/decryption algorithms to the uploaded file (concrete algorithm is attached by specifying the certain adapter). The @ LowerCase and @ UpperCase filters are suitable for converting text files to lower- and upper-case, respectively 5 . The @ Rename filter allows to rename and/or move an arbitrary file (not only uploaded file). It uses the rename() PHP function internally, and that's why it is in general not recommended to use this filter with uploaded files because of security reasons. The @ RenameUpload filter seems to be much more useful than other filters, because it allows to encapsulate the call of the move_uploaded_file() function and move/rename the uploaded file from a temporary location to its persistent directory. We will show how to use the @ RenameUpload filter in the Image Gallery code example later in this chapter. InputFilter Container & File Uploads As you might remember, the filters and validators attached to a form model are typically stored in an @ InputFilter [Laminas\\InputFilter\\InputFilter] container which consists of inputs (an input is typically represented by the @ Input [Laminas\\InputFilter\\Input] class belonging to the @ Laminas\\InputFilter namespace). For usual form fields, the filters are executed before validators, and validators are executed after filters. However, for file uploads, there are some important differences: for storing validation rules for uploaded files, a special class called @ FileInput should be utilized instead of the @ Input [Laminas\\InputFilter\\Input] class; and, validators are applied before filters (!). FileInput For storing validation rules for uploaded files, you must use the @ FileInput class instead of the usual @ Input [Laminas\\InputFilter\\Input] class. In your form model's addInputFilter() private method, you add the validation rules for the file input as follows: $inputFilter->add([ 'type' => 'Laminas\\InputFilter\\FileInput', 'name' => 'file', // Element's name. 'required' => true, // Whether the field is required. 'filters' => [ // Filters. // Put filter info here. ], 'validators' => [ // Validators. // Put validator info here. ] ]); Above, we set the \"type\" key (line 2) with the value @ Laminas\\InputFilter\\FileInput class name. The rest of keys is analogous to those we used before when adding validation rules for a form model. The behaviour of @ FileInput class differs from the @ Input [Laminas\\InputFilter\\Input] in the following aspects: It expects the data you pass as input to be in the $_FILES array format (an array entry with tmp_name , error , type keys). A @ Laminas\\Validator\\File\\Upload validator is automatically inserted before all other validators into the validator chain of the input. The validators inserted to the validator chain of the input are executed before the filters inserted into its filter chain. This is opposite to the behaviour of the @ Input [Laminas\\InputFilter\\Input] class. Executing Validators before Filters For usual form fields, the filters are typically executed before validators, and validators are executed after filters. However, for file uploads, this sequence is opposite. Note For file uploads, validators are executed before filters. This behaviour is inverse to the usual behaviour. When working with uploaded files, we first need to check that data extracted from $_FILES super-global array is correct, and then do anything else with the files (moving the file into a storage directory, renaming it, etc.) Because of that, file validators need to be run first turn, and filters to be executed last. To see how this is performed, recall the typical workflow for a form: First, we call the setData() method to fill in the form with data. Call the isValid() method to execute filters and validators in the input filter attached to form. On successful validation, call the getData() to extract the filtered and validated data from the input filter attached to form. On failure, call the getMessages() to retrieve the validation error messages. When using a @ FileInput input, the workflow is the same, however it is important to understand what happens on each of its steps: Call the setData() method to fill in the form with data. Call the isValid() method to execute validators in the input filter attached to form. On successful validation, call the getData() to execute filters and extract the filtered and validated data from the input filter attached to form. On failure, call the getMessages() to retrieve the validation error messages. Note Please note that for @ FileInput input, the attached filters are only run if the getData() method is called. When you use both @ Input [Laminas\\InputFilter\\Input] and @ FileInput inputs in your form's input filter (which is a common case), the filters are still executed first for usual inputs, but validators are executed first for file inputs. Controller Action & File Uploads In this section, we will provide a short code example showing how to handle file uploads in a controller action method. We will attract reader's attention to the aspects specific to file uploads. Assume we want to add a web page displaying a form (let's name it YourForm ) capable of file uploads. For that page, we need to add the uploadAction() method to a controller class: <?php //... class IndexController extends AbstractActionController { // This is the \"upload\" action displaying the Upload page. public function uploadAction() { // Create the form model. $form = new YourForm(); // Check if user has submitted the form. if($this->getRequest()->isPost()) { // Make certain to merge the files info! $request = $this->getRequest(); $data = array_merge_recursive( $request->getPost()->toArray(), $request->getFiles()->toArray() ); // Pass data to form. $form->setData($data); // Execute file validators. if($form->isValid()) { // Execute file filters. $data = $form->getData(); // Redirect the user to another page. return $this->redirect()->toRoute('application', ['action'=>'index']); } } // Render the page. return new ViewModel([ 'form' => $form ]); } } As you can see from the code above, the uploadAction() looks like a usual controller action implementing a typical form workflow, however it has some aspects specific to file uploads (marked with bold ): In line 9, we create an instance of the YourForm form model with the help of the new operator. In line 12, we check whether the request is an HTTP POST request. If so, we get the data from $_POST and $_FILES super-global PHP arrays and merge them into the single array (lines 15-19). This is required to correctly handle uploaded files, if any. Then we pass this array to the form model with the setData() method (line 22) . In line 25, we call the form model's isValid() method. This method runs the input filter attached to the form model. For @ FileInput inputs, this will execute attached validators only . If the data is valid, we call the getData() method (line 28). For the @ FileInput inputs, this will run the attached file filters . The file filters, for example, could move the uploaded files to the directory of residence. On success, in line 31, we redirect the user to the \"index\" action of the controller. Important In the controller action above, you should remember three things: 1) merge $_POST and $_FILES super-global arrays before you pass them to the form's setData() method; 2) use isValid() form's method to check uploaded files for correctness (run validators); 3) use getData() form's method to run file filters. Example: Image Gallery To demonstrate the usage of file uploads in Laminas Framework, we will create an Image Gallery that will consist of two web pages: the image upload page allowing to upload an image (figure 10.2); and the gallery page containing the list of uploaded images (figure 10.3). You can see the working Image Gallery example in the Form Demo sample application bundled with this book. For this example, we will create the following things: the ImageForm form model capable of image file uploads; the ImageManager service class designed for getting the list of uploaded images, retrieving information about an image, and resizing an image; the ImageController class which will contain action methods serving the web pages; the ImageControllerFactory factory that will instantiate the controller and inject dependencies into it; a view template .phtml file per each controller's action method. Adding ImageForm Model For this example, we will need a form model which will be used for image file uploads. We will call that form model class the ImageForm . This class will allow us to upload an image file to the server. The form will have the following fields: the file field will allow the user to pick an image file for upload; and the submit button field allowing to send the form data to server. The code of the ImageForm form model is presented below. It should be put to ImageForm.php file stored in Form directory under the module's source directory: <?php namespace Application\\Form; use Laminas\\Form\\Form; // This form is used for uploading an image file. class ImageForm extends Form { // Constructor. public function __construct() { // Define form name. parent::__construct('image-form'); // Set POST method for this form. $this->setAttribute('method', 'post'); // Set binary content encoding. $this->setAttribute('enctype', 'multipart/form-data'); $this->addElements(); } // This method adds elements to form. protected function addElements() { // Add \"file\" field. $this->add([ 'type' => 'file', 'name' => 'file', 'attributes' => [ 'id' => 'file' ], 'options' => [ 'label' => 'Image file', ], ]); // Add the submit button. $this->add([ 'type' => 'submit', 'name' => 'submit', 'attributes' => [ 'value' => 'Upload', 'id' => 'submitbutton', ], ]); } } We have already discussed the form model creation and the code above should not cause any problems in its understanding. We just want to attract the attention of the reader that in line 19, we set the \"multipart/form-data\" value for the \"enctype\" attribute of the form to make the form use binary encoding for its data. Note Actually, explicitly setting the \"enctype\" attribute in form's constructor is optional, because @ Laminas\\Form\\Element\\File element performs that automatically when you call form's prepare() method. Adding Validation Rules to ImageForm Model To demonstrate the usage of validators and filters designed to work with file uploads, we will add those to the ImageForm form model class. We want to achieve the following goals: check if the uploaded file really was uploaded through HTTP POST method using the @ UploadFile validator; check that the uploaded file is an image (JPEG, PNG, GIF, etc.) using the @ IsImage validator; check that image dimensions are within some allowed boundaries; we will do that with the @ ImageSize validator; move the uploaded file to its residence directory using the @ RenameUpload filter. To add form validation rules, modify the code of the ImageForm class as follows: <?php namespace Application\\Form; use Laminas\\InputFilter\\InputFilter; // This form is used for uploading an image file. class ImageForm extends Form { // Constructor public function __construct() { // ... // Add validation rules $this->addInputFilter(); } // ... // This method creates input filter (used for form filtering/validation). private function addInputFilter() { $inputFilter = new InputFilter(); $this->setInputFilter($inputFilter); // Add validation rules for the \"file\" field. $inputFilter->add([ 'type' => 'Laminas\\InputFilter\\FileInput', 'name' => 'file', 'required' => true, 'validators' => [ ['name' => 'FileUploadFile'], [ 'name' => 'FileMimeType', 'options' => [ 'mimeType' => ['image/jpeg', 'image/png'] ] ], ['name' => 'FileIsImage'], [ 'name' => 'FileImageSize', 'options' => [ 'minWidth' => 128, 'minHeight' => 128, 'maxWidth' => 4096, 'maxHeight' => 4096 ] ], ], 'filters' => [ [ 'name' => 'FileRenameUpload', 'options' => [ 'target' => './data/upload', 'useUploadName' => true, 'useUploadExtension' => true, 'overwrite' => true, 'randomize' => false ] ] ], ]); } } In the code above, we add the following file validators: @ UploadFile validator (line 32) checks whether the uploaded file was really uploaded using the HTTP POST method. @ MimeType validator (line 34) checks whether the uploaded file is a JPEG or PNG image. It does that by extracting MIME information from file data. @ IsImage validator (line 39) checks whether the uploaded file is an image file (PNG, JPG, etc.). It does that by extracting MIME information from file data. @ ImageSize validator (line 41) allows to check that image dimensions lie in an allowed range. In the code above, we check that the image is between 128 pixels and 4096 pixels in width, and that the image height lies between 128 pixels and 4096 pixels. In line 52, we add the @ RenameUpload filter and configure it to save the uploaded file to the APP_DIR/data/upload directory. The filter will use the same file name for the destination file as the name of the original file ( useUploadName option). If the file with such name already exists, the filter will overwrite it ( overwrite option). Note For the @ MimeType and @ IsImage validator to work, you have to enable PHP fileinfo extension. This extension is already enabled in Linux Ubuntu, but not in Windows. After that, do not forget to restart Apache HTTP Server. Writing ImageManager Service Because we strive to write code conforming to Domain Driven Design pattern, we will create a service model class encapsulating the functionality for image management. We will call this class ImageManager and put it to Application\\Service namespace. We will also register this service in the service manager component of the web application. The ImageManager service class will have the following public methods (listed in table 10.3): Method Description getSaveToDir() Returns path to the directory where we save the image files. getSavedFiles() Returns the array of saved file names. getImagePathByName($fileName) Returns the path to the saved image file. getImageFileInfo($filePath) Retrieves the file information (size, MIME type) by image path. getImageFileContent($filePath) Returns the image file content. On error, returns boolean false. resizeImage($filePath, $desiredWidth) Resizes the image, keeping its aspect ratio. Table 10.3. Public methods of the ImageManager class. Note In fact, we could put the code we plan to add into the service into the controller actions, but that would make the controller fat and poorly testable. By introducing the service class, we improve the separation of concerns and code reusability. Add the ImageManager.php file to the Service directory under the module's source directory. Add the following code to the file: <?php namespace Application\\Service; // The image manager service. class ImageManager { // The directory where we save image files. private $saveToDir = './data/upload/'; // Returns path to the directory where we save the image files. public function getSaveToDir() { return $this->saveToDir; } } As you can see from the code above, we define the ImageManager class in line 5. It has the private $saveToDir property 6 which contains the path to the directory containing our uploaded files (line 8) (we store uploaded files in APP_DIR/data/upload directory). The getSaveToDir() public method (line 11) allows to retrieve the path to the upload directory. Next, we want to add the getSavedFiles() public method to the service class. The method will scan the upload directory and return an array containing the names of the uploaded files. To add the getSavedFiles() method, modify the code in the following way: <?php //... // The image manager service. class ImageManager { //... // Returns the array of uploaded file names. public function getSavedFiles() { // The directory where we plan to save uploaded files. // Check whether the directory already exists, and if not, // create the directory. if(!is_dir($this->saveToDir)) { if(!mkdir($this->saveToDir)) { throw new \\Exception('Could not create directory for uploads: ' . error_get_last()); } } // Scan the directory and create the list of uploaded files. $files = []; $handle = opendir($this->saveToDir); while (false !== ($entry = readdir($handle))) { if($entry=='.' || $entry=='..') continue; // Skip current dir and parent dir. $files[] = $entry; } // Return the list of uploaded files. return $files; } } In the getSavedFiles() method above, we first check if the upload directory exists (line 16), and if not, we try to create it (line 17). Then, we get the list of files in the directory (lines 24-32) and return it to the caller. Next, we add the three methods for getting information about an uploaded file: the getImagePathByName() method will take the file name and prepend the path to upload directory to that file name; the getImageFileInfo() method will retrieve MIME information about the file and its size in bytes; and the getImageFileContent() will read file data and return them as a string. To add those three methods, change the code as follows: <?php //... // The image manager service. class ImageManager { //... // Returns the path to the saved image file. public function getImagePathByName($fileName) { // Take some precautions to make file name secure. $fileName = str_replace(\"/\", \"\", $fileName); // Remove slashes. $fileName = str_replace(\"\\\\\", \"\", $fileName); // Remove back-slashes. // Return concatenated directory name and file name. return $this->saveToDir . $fileName; } // Returns the image file content. On error, returns boolean false. public function getImageFileContent($filePath) { return file_get_contents($filePath); } // Retrieves the file information (size, MIME type) by image path. public function getImageFileInfo($filePath) { // Try to open file if (!is_readable($filePath)) { return false; } // Get file size in bytes. $fileSize = filesize($filePath); // Get MIME type of the file. $finfo = finfo_open(FILEINFO_MIME); $mimeType = finfo_file($finfo, $filePath); if($mimeType===false) $mimeType = 'application/octet-stream'; return [ 'size' => $fileSize, 'type' => $mimeType ]; } } Finally, we want to add the image resizing functionality to the ImageManager class. The image resizing functionality will be used for creating small thumbnail images. Add the resizeImage() method to the ImageManager class as follows: <?php //... class ImageManager { //... // Resizes the image, keeping its aspect ratio. public function resizeImage($filePath, $desiredWidth = 240) { // Get original image dimensions. list($originalWidth, $originalHeight) = getimagesize($filePath); // Calculate aspect ratio $aspectRatio = $originalWidth/$originalHeight; // Calculate the resulting height $desiredHeight = $desiredWidth/$aspectRatio; // Get image info $fileInfo = $this->getImageFileInfo($filePath); // Resize the image $resultingImage = imagecreatetruecolor($desiredWidth, $desiredHeight); if (substr($fileInfo['type'], 0, 9) =='image/png') $originalImage = imagecreatefrompng($filePath); else $originalImage = imagecreatefromjpeg($filePath); imagecopyresampled($resultingImage, $originalImage, 0, 0, 0, 0, $desiredWidth, $desiredHeight, $originalWidth, $originalHeight); // Save the resized image to temporary location $tmpFileName = tempnam(\"/tmp\", \"FOO\"); imagejpeg($resultingImage, $tmpFileName, 80); // Return the path to resulting image. return $tmpFileName; } } The resizeImage() method above takes two arguments: $filePath (the path to the image file), and $desiredWidth (the width of the thumbnail image). Inside the method, we first calculate an appropriate thumbnail image height (lines 11-16) preserving its aspect ratio. Then, we resize the original image as needed and save it to a temporary file (lines 19-32). As the ImageManager class is ready, you have to register the ImageManager service in the service manager component of the web application by adding the following lines to the module.config.php configuration file: <?php return [ // ... 'service_manager' => [ // ... 'factories' => [ // Register the ImageManager service Service\\ImageManager::class => InvokableFactory::class, ], ], // ... ]; Adding ImageController For the Image Gallery example, we will create the ImageController controller class. The controller will have the following action methods (listed in table 10.4): Action Method Description __construct() Will allow to inject ImageManager dependency into the controller. uploadAction() Shows the image upload page allowing to upload a single image. indexAction() Displays the image gallery page with the list of uploaded images. fileAction() Provides an ability to download a full-size image or a small thumbnail for an image. Table 10.4. Action methods of the ImageController class. To start, create the ImageController.php file in the Application/Controller directory under the module's source directory. Put the following stub code into the file: <?php namespace Application\\Controller; use Laminas\\Mvc\\Controller\\AbstractActionController; use Laminas\\View\\Model\\ViewModel; use Application\\Form\\ImageForm; // This controller is designed for managing image file uploads. class ImageController extends AbstractActionController { // The image manager. private $imageManager; // The constructor method is used for injecting the dependencies // into the controller. public function __construct($imageManager) { $this->imageManager = $imageManager; } // This is the default \"index\" action of the controller. It displays the // Image Gallery page which contains the list of uploaded images. public function indexAction() { } // This action shows the image upload form. This page allows to upload // a single file. public function uploadAction() { } // This is the 'file' action that is invoked when a user wants to // open the image file in a web browser or generate a thumbnail. public function fileAction() { } } In the code above, we defined the ImageController class living in the Application\\Controller namespace and added the constructor method and three action method stubs into the class: indexAction() , uploadAction() and fileAction() . Next, we will populate those action methods with the code. Adding Upload Action & Corresponding View Template First, we will complete the uploadAction() method of our controller. This action method will handle the Upload a New Image web page containing the upload form. The form will provide an ability to upload an image file to the gallery. Change the ImageController.php file as follows: <?php //... class ImageController extends AbstractActionController { //... public function uploadAction() { // Create the form model. $form = new ImageForm(); // Check if user has submitted the form. if($this->getRequest()->isPost()) { // Make certain to merge the files info! $request = $this->getRequest(); $data = array_merge_recursive( $request->getPost()->toArray(), $request->getFiles()->toArray() ); // Pass data to form. $form->setData($data); // Validate form. if($form->isValid()) { // Move uploaded file to its destination directory. $data = $form->getData(); // Redirect the user to \"Image Gallery\" page. return $this->redirect()->toRoute('images'); } } // Render the page. return new ViewModel([ 'form' => $form ]); } } In the uploadAction() method above, we do the following. In line 9, we create an instance of the ImageForm form model with the help of the new operator. In line 12, we check whether the request is an HTTP POST request. If so, we get the data from $_POST and $_FILES super-global PHP arrays and merge them into the single array (lines 15-19). This is required to correctly handle uploaded files, if any. Then we pass this array to the form model with the setData() method (line 22). In line 25, we call the form model's isValid() method. This method runs the input filter attached to the form model. Since we have only one file input in the input filter, this will only run our three file validators: @ UploadFile , @ IsImage and @ ImageSize . If the data is valid, we call the getData() method (line 28). For our file field, this will run the @ RenameUpload filter, which moves our uploaded file to its persistent directory. After that, in line 31, we redirect the user to the \"index\" action of the controller (we will populate that action method a little bit later. Now, its time to add the view template for the \"upload\" action. Add the upload.phtml view template file under the application/image directory under the module's view directory: <?php $form = $this->form; $form->get('submit')->setAttributes(['class'=>'btn btn-primary']); $form->prepare(); ?> <h1>Upload a New Image</h1> <p> Please fill out the following form and press the <i>Upload</i> button. </p> <div class=\"row\"> <div class=\"col-md-6\"> <?= $this->form()->openTag($form); ?> <div class=\"form-group\"> <?= $this->formLabel($form->get('file')); ?> <?= $this->formElement($form->get('file')); ?> <?= $this->formElementErrors($form->get('file')); ?> <div class=\"hint\">(PNG and JPG formats are allowed)</div> </div> <?= $this->formElement($form->get('submit')); ?> <?= $this->form()->closeTag(); ?> </div> </div> In the code of the view template, we first set \"class\" attribute (line 3). This is to apply nice-looking Twitter Bootstrap styles to the form's Submit button. Then, we render the form with the common view helpers that we discussed in Collecting User Input with Forms . For rendering the \"file\" field, we use the generic @ FormElement view helper. Note Typically, you use the @ FormElement generic view helper for rendering the file field. The @ FormElement internally calls the @ FormFile view helper, which performs the actual rendering. Adding Index Action & Corresponding View Template The second action method we will complete is the indexAction() . This action will handle the Image Gallery page containing the list of uploaded files and their small thumbnails. For each image, there will be a button \"Show In Natural Size\" for opening the image in another tab of the web browser. Change the ImageController.php file as follows: <?php //... class ImageController extends AbstractActionController { //... public function indexAction() { // Get the list of already saved files. $files = $this->imageManager->getSavedFiles(); // Render the view template. return new ViewModel([ 'files'=>$files ]); } } In the code above, we use the getSavedFiles() method of the ImageManager class for retrieving the list of uploaded images and pass them to the view for rendering. Note Please note how \"slim\" and clear this controller action is! We achieved this by moving the image management functionality to the ImageManager service model. Add the index.phtml view template to application/image directory under the module's view directory. The contents of the file is shown below: <h1>Image Gallery</h1> <p> This page displays the list of uploaded images. </p> <p> <a href=\"<?= $this->url('images', ['action'=>'upload']); ?>\" class=\"btn btn-primary\" role=\"button\">Upload More</a> </p> <hr/> <?php if(count($files)==0): ?> <p> <i>There are no files to display.</i> </p> <?php else: ?> <div class=\"row\"> <div class=\"col-sm-6 col-md-12\"> <?php foreach($files as $file): ?> <div class=\"img-thumbnail\"> <img src=\"<?= $this->url('images', ['action'=>'file'], ['query'=>['name'=>$file, 'thumbnail'=>true]]); ?>\"> <div class=\"caption\"> <h3><?php echo $file; ?></h3> <p> <a target=\"_blank\" href=\"<?= $this->url('images', ['action'=>'file'], ['query'=>['name'=>$file]]); ?>\" class=\"btn btn-default\" role=\"button\">Show in Natural Size</a> </p> </div> </div> <?php endforeach; ?> </div> </div> <?php endif; ?> <hr/> In the code above, we create the HTML markup for the Upload More button. Under the button, we use check whether the $files array is empty. If the array is empty, we output the \"There are no files to display\" message; otherwise we walk through the files and output the thumbnails of each uploaded images. For rendering a thumbnail, we use the <img> tag. We set its src attribute with the URL pointing to the \"file\" action of our ImageController controller. We pass two parameters to the action via the query part of the URL: the image name and thumbnail flag. For styling the thumbnails, we use the Twitter Bootstrap provided \".img-thumbnail\" CSS class. Note For additional information about these Twitter Bootstrap styles, please refer to the Bootstrap official documentation. Below each thumbnail, we put the \"Show in Natural Size\" link, which points to the \"file\" action of our ImageController controller. When site visitor clicks the link, he will be shown with the image in natural size, and the image will be opened in another browser's tab (note the target=\"_blank\" attribute of the link). Adding File Action The last action we will populate is the ImageController::fileAction() method. That method will allow to preview an uploaded image or generate a small thumbnail of the image. The action method will take two GET parameters: the \"name\" parameter defines the file name for preview; the \"thumbnail\" parameter is a flag telling whether we want to dump the full image or its small copy. Change the ImageController.php file as follows: <?php //... class ImageController extends AbstractActionController { //... public function fileAction() { // Get the file name from GET variable. $fileName = $this->params()->fromQuery('name', ''); // Check whether the user needs a thumbnail or a full-size image. $isThumbnail = (bool)$this->params()->fromQuery('thumbnail', false); // Get path to image file. $fileName = $this->imageManager->getImagePathByName($fileName); if($isThumbnail) { // Resize the image. $fileName = $this->imageManager->resizeImage($fileName); } // Get image file info (size and MIME type). $fileInfo = $this->imageManager->getImageFileInfo($fileName); if ($fileInfo===false) { // Set 404 Not Found status code $this->getResponse()->setStatusCode(404); return; } // Write HTTP headers. $response = $this->getResponse(); $headers = $response->getHeaders(); $headers->addHeaderLine(\"Content-type: \" . $fileInfo['type']); $headers->addHeaderLine(\"Content-length: \" . $fileInfo['size']); // Write file content. $fileContent = $this->imageManager->getImageFileContent($fileName); if($fileContent!==false) { $response->setContent($fileContent); } else { // Set 500 Server Error status code. $this->getResponse()->setStatusCode(500); return; } if($isThumbnail) { // Remove temporary thumbnail image file. unlink($fileName); } // Return Response to avoid default view rendering. return $this->getResponse(); } } In the code above, we first get the \"name\" and \"thumbnail\" parameters from $_GET super-global array (lines 9, 12). If the parameters are missing, their default values are used instead. In line 15, we use the getImagePathByName() method provided by the ImageManager service to get the absolute path to the image by its name. If a thumbnail is requested, we resize the image with the resizeImage() method of the ImageManager (line 20). That method returns path to a temporary file containing the thumbnail image. Then, we get the information about the image file (its MIME type and file size) with the getImageFileInfo() method of the ImageManager (line 24). Finally, we create a @ Response [Laminas\\Http\\PhpEnvironment\\Response] object, fill its headers with image information, set its content with data of the image file (lines 32-45), and return the @ Response [Laminas\\Http\\PhpEnvironment\\Response] object from the controller action (line 53). Note Note that returning the @ Response [Laminas\\Http\\PhpEnvironment\\Response] object disables the default rendering of the view template for this action method. By this reason, we do not create the file.phtml view template file. Creating Factory for the Controller Because our ImageController uses the ImageManager service, we need to somehow pass it the instance of the ImageManager (to inject the dependency into the controller's constructor). We do this with the help of factory . Create the ImageControllerFactory.php file under the Controller/Factory subdirectory under the module's source directory. Put the following code into the file: <?php namespace Application\\Controller\\Factory; use Interop\\Container\\ContainerInterface; use Laminas\\ServiceManager\\Factory\\FactoryInterface; use Application\\Service\\ImageManager; use Application\\Controller\\ImageController; /** * This is the factory for ImageController. Its purpose is to instantiate the * controller. */ class ImageControllerFactory implements FactoryInterface { public function __invoke(ContainerInterface $container, $requestedName, array $options = null) { $imageManager = $container->get(ImageManager::class); // Instantiate the controller and inject dependencies return new ImageController($imageManager); } } Registering the ImageController To let Laminas know about our controller, register the ImageController in the module.config.php configuration file: <?php return [ //... 'controllers' => [ 'factories' => [ Controller\\ImageController::class => Controller\\Factory\\ImageControllerFactory::class, //... ], ], //... ]; Creating Route We need to add a route for our ImageController controller. To do that, modify the module.config.php file as follows: <?php return [ //... 'router' => [ 'routes' => [ 'images' => [ 'type' => Segment::class, 'options' => [ 'route' => '/images[/:action]', 'constraints' => [ 'action' => '[a-zA-Z][a-zA-Z0-9_-]*' ], 'defaults' => [ 'controller' => Controller\\ImageController::class, 'action' => 'index', ], ], ], ], ], //... ]; After that, you will be able to get access to our image gallery by the URL like \"http://localhost/images\", \"http://localhost/images/upload\" or \"http://localhost/images/file\". Results Finally, adjust directory permissions to make the APP_DIR/data directory writeable by the Apache Web Server. In Linux Ubuntu, this is typically accomplished by the following shell commands (replace the APP_DIR placeholder with the actual directory name of your web application): chown -R www-data:www-data APP_DIR/data chmod -R 775 APP_DIR/data Above, the chown and chmod commands set the Apache user to be the owner of the directory and allow the web server to write to the directory, respectively. If you now enter the URL http://localhost/images into your web browser's navigation bar, you will see the image gallery page like shown in figure 10.4. Clicking the Upload More button will open the Upload a New Image page where you can peek an image file for upload. If you pick an unacceptable file (not an image, or too big image), you will see validation errors (see the figure 10.5 below). If the upload is completed successfully, you will be redirected back to the Image Gallery page and see the uploaded image in the list of thumbnails. Clicking the View Full Size button will open the image in a new browser tab (see the figure 10.6 below for example). You may find the Image Gallery complete example in the Form Demo sample web application bundled with this book. Summary File uploads is a standard HTML form feature. Uploading files is accomplished by setting form content encoding to binary encoding type. Laminas Framework provides convenient functionality for doing file uploads and validating the uploaded files. HTTP file uploads are described in RFC-1867 . This mechanism allows to upload large files by using binary content transfer encoding. The \"multipart/form-data\" encoding type is utilized for this purpose. \u21a9 The HTTP GET method is inefficient for file uploads, because URL length has some upper limit. Also, URL-encoding the file data greatly increases the URL length. \u21a9 MIME type, also known as \"content type\" is a standard identifier used on the Internet to indicate the type of data that a file contains. For example the \"text/plain\" MIME type is assigned to a text file, while the \"application/octet-stream\" MIME type is assigned to a binary file. \u21a9 A file hash is used for checking file data integrity (for example, to ensure that file data is not corrupted). There are several hash algorithms available (MD5, SHA-1, CRC32, etc.) \u21a9 In the author's opinion, the above mentioned four filters are not very useful when working with uploaded files, because you rarely need to encrypt an uploaded file or convert it to lower case letters. \u21a9 Although the ImageManager class is a service and focused on providing services, it can have properties intended for its internal use. \u21a9","title":"Uploading Files with Forms"},{"location":"uploads/#uploading-files-with-forms","text":"In this chapter, you will learn about uploading files with forms. First, we will review the basic theory like HTTP file upload capability and binary content transfer encoding, and then provide a complete working Image Gallery example showing how to upload images to a web server. Laminas components covered in this chapter: Component Description @ Laminas\\Form Contains base form model classes. @ Laminas\\Filter Contains various filters classes. @ Laminas\\Validator Implements various validator classes. @ Laminas\\InputFilter Implements a container for filters/validators.","title":"Uploading Files with Forms"},{"location":"uploads/#about-http-file-uploads","text":"HTML forms have capability for uploading files of arbitrarily large size 1 . The files are typically transmitted through HTTP POST method 2 . By default, HTTP uses the URL encoding for transfers of form data, and you could see how that encoding looks like in previous chapters. However, this encoding is inefficient for uploading large files, since URL-encoding binary data dramatically increases the length of the HTTP request. For the purpose of uploading files, it is instead recommended to use the so called \"binary transfer encoding\" described in the next section.","title":"About HTTP File Uploads"},{"location":"uploads/#http-binary-transfer-encoding","text":"A simple HTML form capable of file uploads is shown in the code example below. The binary encoding type is enabled by setting the enctype attribute of the form with the value of \"multipart/form-data\": <form action=\"upload\" method=\"POST\" enctype=\"multipart/form-data\"> <input type=\"file\" name=\"myfile\"> <br/> <input type=\"submit\" name=\"Submit\"> </form> In line 1, we explicitly set form encoding ( enctype attribute) to \"multipart/form-data\" to utilize effective binary content transfer encoding for the form. In line 2, we define an input field with type \"file\" and name \"myfile\". This input field will allow site visitor to select the file for upload. If you now save the above mentioned markup to an .html file and open it in your web browser, you will see the page like in figure 10.1. The file element has the Browse... button allowing to pick a file for upload. When the site user picks some file and clicks the Submit button on the form, the web browser will send an HTTP request to the web server, and the request will contain the data of the file being uploaded. The example below illustrates how the HTTP request may look like: POST http://localhost/upload HTTP/1.1 Host: localhost Content-Length: 488 User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) Content-Type: multipart/form-data; boundary=----j1bOrwgLvOC3dy7o Accept-Encoding: gzip,deflate,sdch ------j1bOrwgLvOC3dy7o Content-Disposition: form-data; name=\"myfile\"; filename=\"Somefile.txt\" Content-Type: text/html (file binary data goes here) ------j1bOrwgLvOC3dy7o Content-Disposition: form-data; name=\"Submit\" Submit Request ------j1bOrwgLvOC3dy7o-- As you can see from the example above, the HTTP request with \"multipart/form-data\" encoding type looks analogous to a usual HTTP request (has the status line, the headers, and the content area), however it has the following important differences: Line 5 sets the \"Content-Type\" header with \"multipart/form-data\" value; The form is assembled of the fields marked by the \"boundary\" -- a unique randomly generated sequence of characters delimiting form fields of each other. Lines 8-17 represent the content of the HTTP request. The form fields are delimited by the \"boundary\" sequences (lines 8, 13, 17). The data of the file being uploaded are transmitted in binary format (line 12), and that allows to reduce the content size to its minimum. Note By default, PHP engine's settings do not allow to upload large files (larger than 2MB). In order to upload large files, you may need to edit the php.ini configuration file and modify the post_max_size and upload_max_filesize parameters (please refer to Appendix A. Configuring Web Development Environment for information on how to do that). Setting these with 100M allows to upload files up to 100 Mb in size, and this would typically be sufficient. If you plan to upload very large files up to 1 GB in size, than better set these with 1024M. Do not forget to restart your Apache Web Server after editing the configuration file.","title":"HTTP Binary Transfer Encoding"},{"location":"uploads/#_files-super-global-array-in-php","text":"When a site visitor uploads some files to your Apache Web Server, the files are placed to a temporary location (usually to system temporary directory that is /tmp in Linux and C:\\Windows\\Temp in Windows). The PHP script receives the file information to the special super-global array named $_FILES . The $_FILES array is analogous to the $_GET and $_POST super-globals. The latter two are used to store the GET and POST variables, respectively, while the first one is used to store information about uploaded files. For example, for the above mentioned simple upload form, the $_FILES super-global array will look as follows (the output is generated with the var_dump() PHP function): array (size=1) 'myfile' => array (size=5) 'name' => string 'somefile.txt' (length=12) 'type' => string 'text/plain' (length=10) 'tmp_name' => string '/tmp/phpDC66.tmp' (length=16) 'error' => int 0 'size' => int 18 As you can see from the example above, the $_FILES array contains an entry per each uploaded file. For each uploaded file, it contains the following information: name -- original file name (line 4). type -- MIME 3 type of the file (line 5). tmp_name -- temporary name for the uploaded file (line 6). error -- error code signalling about the status of the upload (line 7); error code zero means the file was uploaded correctly. size -- file size in bytes (line 8). PHP engine stores the uploaded files in a temporary location which is cleaned up as soon as the PHP script execution ends. So, if you want to save the uploaded files to some directory for later use, you need to utilize the move_uploaded_file() PHP function. The move_uploaded_file() function takes two arguments: the first one is the name of the temporary file, and the second one is the destination file name. Important You might be confused why you cannot use the usual rename() PHP function for moving the temporary uploaded file to its destination path. PHP has special function for moving uploaded files for security reasons. The move_uploaded_file() function is analogous to rename() function, but it takes some additional checks to ensure the file was really transferred through HTTP POST request, and that the upload process has finished without errors. The following code example shows how to move the file uploaded with the simple form we have considered above: $destPath = '/path/to/your/upload/dir'; $result = move_uploaded_file($_FILES['myfile']['tmp_name'], $destPath); if(!$result) { // Some error occurred. } Above, in line 1, we set the $destPath with the directory name where to save the uploaded file. In line 2, we call the move_uploaded_file() function and pass it two arguments: the path to the temporary file and the destination path. Note Specifying the directory name as the second argument of the move_uploaded_file() function is suitable when you do not want to rename the file. If you need to save the uploaded file under another name than its original name, you can specify the full file path instead of the directory name. In line 3, we check the returned value of the function. If the operation is successful, the function will return true . If some error occurs (for example, if directory permissions are insufficient to save the file), the boolean false will be returned.","title":"$_FILES Super-Global Array in PHP"},{"location":"uploads/#accessing-uploaded-files-in-laminas","text":"In your controller class, you typically do not communicate with the $_FILES array directly, instead you may use the @ Request [Laminas\\Http\\Request] class or the @ Params controller plugin, as shown in code example below: <?php //... class IndexController extends AbstractActionController { // An example controller action intended for handling file uploads. public function uploadAction() { // Get the whole $_FILES array. $files = $this->getRequest()->getFiles(); // The same, but with Params controller plugin. $files = $this->params()->fromFiles(); // Get a single entry of the $_FILES array. $files = $this->params()->fromFiles('myfile'); } } In line 9 of the code above, we use the getRequest() method of the controller class for accessing the @ Request [Laminas\\Http\\Request] object, and the getFiles() method of the request object to retrieve the information about all upload files at once. In line 12, we do the same thing with the @ Params controller plugin. We use its fromFiles() method to get the information about all uploaded files. If needed, you can extract the information for the specific file only. In line 15, we use the same fromFiles() method and pass it the name of the file field to retrieve. This retrieves the single file entry from the $_FILES super-global array.","title":"Accessing Uploaded Files in Laminas"},{"location":"uploads/#file-uploads-laminas-form-model","text":"To add file uploading capability to your form model, you need to add an element of the @ Laminas\\Form\\Element\\File class as follows: // Add the following code inside of form's addElements() method. // Add the \"file\" field. $this->add([ 'type' => 'file', 'name' => 'file', 'attributes' => [ 'id' => 'file' ], 'options' => [ 'label' => 'Upload file', ], ]); In the code above, we call the add() method provided by the @ Form [Laminas\\Form\\Form] base class and pass it the configuration array describing the element. The type key of the array (line 5) must be either @ Laminas\\Form\\Element\\File class name or its short alias \"file\".","title":"File Uploads &amp; Laminas Form Model"},{"location":"uploads/#validating-uploaded-files","text":"Uploaded files need to be checked for correctness as any other form data. For example, you may need to check that: the file(s) were really uploaded through HTTP POST request, and were not just copied from some directory; the file(s) were uploaded successfully (the error code is zero); the file names and/or extensions are acceptable (e.g., you may want to save JPEG files only, and reject all others); the file size lies in the allowed range (e.g., you may want to ensure that the file is not too big); total count of uploaded files doesn't exceed some allowed limit. For doing the checks like above, Laminas provides a number of useful file validators (listed in table 10.1). Those validator classes belong to @ Laminas\\Validator component and live in @ Laminas\\Validator\\File [Laminas\\Validator] namespace. Class name Short alias Description @ Count FileCount Checks whether the file count is in a given range (min, max). @ WordCount FileWordCount Calculates the number of words in a file and checks whether it lies in a given range. @ Upload FileUpload Performs security checks ensuring that all given files were really uploaded through HTTP POST and there were no upload errors. @ UploadFile FileUploadFile Performs security checks ensuring that a file really was uploaded through HTTP POST and there were no upload errors. @ Size FileSize Checks whether the file size lies in a given range. @ FilesSize FileFilesSize Checks that the summary size of all given files lies in a given range. @ Extension FileExtension Checks that the extension of a file belongs to a set of allowed extensions. @ ExcludeExtension FileExcludeExtension Checks that the extension of a file DOES NOT belong to a set of extensions. @ MimeType FileMimeType Checks that the MIME type of a file belongs to the list of allowed MIME types. @ ExcludeMimeType FileExcludeMimeType Checks that the MIME type of a file DOES NOT belong to the list of MIME types. @ IsImage FileIsImage Checks that the file is a graphical image (JPEG, PNG, GIF, etc.) @ ImageSize FileImageSize Checks that the image file's dimensions lie in a given range. @ Exists FileExists Checks whether the file exists on disk. @ NotExists FileNotExists Checks whether the file doesn't exist on disk. @ IsCompressed FileIsCompressed Checks that the file is an archive (ZIP, TAR, etc.) @ Hash [Laminas\\Validator\\File\\Hash] FileHash Checks that the file content matches the given hash(es). @ Crc32 FileCrc32 Checks that the file content has the given CRC32 check sum. @ Sha1 FileSha1 Checks that the file content has the given SHA-1 hash. @ Md5 FileMd5 Checks that the file content has the given MD5 hash. Table 10.1. Standard File Validators As you can see from the table above, file validators may be roughly divided in the following groups: validators checking whether the file(s) were really uploaded through HTTP POST and upload status is OK; validators checking the uploaded file count and file size; validators checking the file extension and MIME type; validators checking whether the file is a graphical image and checking image dimensions; and validators checking the file hash (or check sum) 4 . Note Please note that since file validators live in @ Laminas\\Validator\\File [Laminas\\Validator] namespace, their short aliases (that you use when creating a validator with the factory) start with File prefix. For example, the @ IsImage validator has FileIsImage alias. We will show how to use some of these file validators in the Image Gallery code example later in this chapter.","title":"Validating Uploaded Files"},{"location":"uploads/#filtering-uploaded-files","text":"Laminas Framework provides several filters intended for \"transforming\" file fields. Those filter classes (listed in table 10.2) belong to @ Laminas\\Filter component and live in @ Laminas\\Filter\\File [Laminas\\Filter] namespace. Class name Short alias Description @ Rename FileRename Renames/moves an arbitrary file. @ RenameUpload FileRenameUpload Renames/moves the uploaded file with security checks. @ Encrypt [Laminas\\Filter\\File\\Encrypt] FileEncrypt Encrypts a given file and stores the encrypted file content. @ Decrypt [Laminas\\Filter\\File\\Decrypt] FileDecrypt Decrypts a given file and stores the decrypted file content. @ LowerCase FileLowerCase Converts file content to lower case letters. @ UpperCase FileUpperCase Converts file content to upper case letters. Table 10.2. Standard File Filters From the table, you can see that filters can be divided into the following groups: filters for moving uploaded files from a temporary location to their persistent directory; filters for encryption and decryption of files; filters for converting text files to upper-case and lower-case letters. Note Please note that since file filters live in @ Laminas\\Filter\\File [Laminas\\Filter] namespace, their short aliases (that you use when creating a filter with the factory) start with File prefix. For example, the @ RenameUpload filter has FileRenameUpload alias. The @ Encrypt [Laminas\\Filter\\File\\Encrypt] and @ Decrypt [Laminas\\Filter\\File\\Decrypt] filters allow to apply various encryption/decryption algorithms to the uploaded file (concrete algorithm is attached by specifying the certain adapter). The @ LowerCase and @ UpperCase filters are suitable for converting text files to lower- and upper-case, respectively 5 . The @ Rename filter allows to rename and/or move an arbitrary file (not only uploaded file). It uses the rename() PHP function internally, and that's why it is in general not recommended to use this filter with uploaded files because of security reasons. The @ RenameUpload filter seems to be much more useful than other filters, because it allows to encapsulate the call of the move_uploaded_file() function and move/rename the uploaded file from a temporary location to its persistent directory. We will show how to use the @ RenameUpload filter in the Image Gallery code example later in this chapter.","title":"Filtering Uploaded Files"},{"location":"uploads/#inputfilter-container-file-uploads","text":"As you might remember, the filters and validators attached to a form model are typically stored in an @ InputFilter [Laminas\\InputFilter\\InputFilter] container which consists of inputs (an input is typically represented by the @ Input [Laminas\\InputFilter\\Input] class belonging to the @ Laminas\\InputFilter namespace). For usual form fields, the filters are executed before validators, and validators are executed after filters. However, for file uploads, there are some important differences: for storing validation rules for uploaded files, a special class called @ FileInput should be utilized instead of the @ Input [Laminas\\InputFilter\\Input] class; and, validators are applied before filters (!).","title":"InputFilter Container &amp; File Uploads"},{"location":"uploads/#fileinput","text":"For storing validation rules for uploaded files, you must use the @ FileInput class instead of the usual @ Input [Laminas\\InputFilter\\Input] class. In your form model's addInputFilter() private method, you add the validation rules for the file input as follows: $inputFilter->add([ 'type' => 'Laminas\\InputFilter\\FileInput', 'name' => 'file', // Element's name. 'required' => true, // Whether the field is required. 'filters' => [ // Filters. // Put filter info here. ], 'validators' => [ // Validators. // Put validator info here. ] ]); Above, we set the \"type\" key (line 2) with the value @ Laminas\\InputFilter\\FileInput class name. The rest of keys is analogous to those we used before when adding validation rules for a form model. The behaviour of @ FileInput class differs from the @ Input [Laminas\\InputFilter\\Input] in the following aspects: It expects the data you pass as input to be in the $_FILES array format (an array entry with tmp_name , error , type keys). A @ Laminas\\Validator\\File\\Upload validator is automatically inserted before all other validators into the validator chain of the input. The validators inserted to the validator chain of the input are executed before the filters inserted into its filter chain. This is opposite to the behaviour of the @ Input [Laminas\\InputFilter\\Input] class.","title":"FileInput"},{"location":"uploads/#executing-validators-before-filters","text":"For usual form fields, the filters are typically executed before validators, and validators are executed after filters. However, for file uploads, this sequence is opposite. Note For file uploads, validators are executed before filters. This behaviour is inverse to the usual behaviour. When working with uploaded files, we first need to check that data extracted from $_FILES super-global array is correct, and then do anything else with the files (moving the file into a storage directory, renaming it, etc.) Because of that, file validators need to be run first turn, and filters to be executed last. To see how this is performed, recall the typical workflow for a form: First, we call the setData() method to fill in the form with data. Call the isValid() method to execute filters and validators in the input filter attached to form. On successful validation, call the getData() to extract the filtered and validated data from the input filter attached to form. On failure, call the getMessages() to retrieve the validation error messages. When using a @ FileInput input, the workflow is the same, however it is important to understand what happens on each of its steps: Call the setData() method to fill in the form with data. Call the isValid() method to execute validators in the input filter attached to form. On successful validation, call the getData() to execute filters and extract the filtered and validated data from the input filter attached to form. On failure, call the getMessages() to retrieve the validation error messages. Note Please note that for @ FileInput input, the attached filters are only run if the getData() method is called. When you use both @ Input [Laminas\\InputFilter\\Input] and @ FileInput inputs in your form's input filter (which is a common case), the filters are still executed first for usual inputs, but validators are executed first for file inputs.","title":"Executing Validators before Filters"},{"location":"uploads/#controller-action-file-uploads","text":"In this section, we will provide a short code example showing how to handle file uploads in a controller action method. We will attract reader's attention to the aspects specific to file uploads. Assume we want to add a web page displaying a form (let's name it YourForm ) capable of file uploads. For that page, we need to add the uploadAction() method to a controller class: <?php //... class IndexController extends AbstractActionController { // This is the \"upload\" action displaying the Upload page. public function uploadAction() { // Create the form model. $form = new YourForm(); // Check if user has submitted the form. if($this->getRequest()->isPost()) { // Make certain to merge the files info! $request = $this->getRequest(); $data = array_merge_recursive( $request->getPost()->toArray(), $request->getFiles()->toArray() ); // Pass data to form. $form->setData($data); // Execute file validators. if($form->isValid()) { // Execute file filters. $data = $form->getData(); // Redirect the user to another page. return $this->redirect()->toRoute('application', ['action'=>'index']); } } // Render the page. return new ViewModel([ 'form' => $form ]); } } As you can see from the code above, the uploadAction() looks like a usual controller action implementing a typical form workflow, however it has some aspects specific to file uploads (marked with bold ): In line 9, we create an instance of the YourForm form model with the help of the new operator. In line 12, we check whether the request is an HTTP POST request. If so, we get the data from $_POST and $_FILES super-global PHP arrays and merge them into the single array (lines 15-19). This is required to correctly handle uploaded files, if any. Then we pass this array to the form model with the setData() method (line 22) . In line 25, we call the form model's isValid() method. This method runs the input filter attached to the form model. For @ FileInput inputs, this will execute attached validators only . If the data is valid, we call the getData() method (line 28). For the @ FileInput inputs, this will run the attached file filters . The file filters, for example, could move the uploaded files to the directory of residence. On success, in line 31, we redirect the user to the \"index\" action of the controller. Important In the controller action above, you should remember three things: 1) merge $_POST and $_FILES super-global arrays before you pass them to the form's setData() method; 2) use isValid() form's method to check uploaded files for correctness (run validators); 3) use getData() form's method to run file filters.","title":"Controller Action &amp; File Uploads"},{"location":"uploads/#example-image-gallery","text":"To demonstrate the usage of file uploads in Laminas Framework, we will create an Image Gallery that will consist of two web pages: the image upload page allowing to upload an image (figure 10.2); and the gallery page containing the list of uploaded images (figure 10.3). You can see the working Image Gallery example in the Form Demo sample application bundled with this book. For this example, we will create the following things: the ImageForm form model capable of image file uploads; the ImageManager service class designed for getting the list of uploaded images, retrieving information about an image, and resizing an image; the ImageController class which will contain action methods serving the web pages; the ImageControllerFactory factory that will instantiate the controller and inject dependencies into it; a view template .phtml file per each controller's action method.","title":"Example: Image Gallery"},{"location":"uploads/#adding-imageform-model","text":"For this example, we will need a form model which will be used for image file uploads. We will call that form model class the ImageForm . This class will allow us to upload an image file to the server. The form will have the following fields: the file field will allow the user to pick an image file for upload; and the submit button field allowing to send the form data to server. The code of the ImageForm form model is presented below. It should be put to ImageForm.php file stored in Form directory under the module's source directory: <?php namespace Application\\Form; use Laminas\\Form\\Form; // This form is used for uploading an image file. class ImageForm extends Form { // Constructor. public function __construct() { // Define form name. parent::__construct('image-form'); // Set POST method for this form. $this->setAttribute('method', 'post'); // Set binary content encoding. $this->setAttribute('enctype', 'multipart/form-data'); $this->addElements(); } // This method adds elements to form. protected function addElements() { // Add \"file\" field. $this->add([ 'type' => 'file', 'name' => 'file', 'attributes' => [ 'id' => 'file' ], 'options' => [ 'label' => 'Image file', ], ]); // Add the submit button. $this->add([ 'type' => 'submit', 'name' => 'submit', 'attributes' => [ 'value' => 'Upload', 'id' => 'submitbutton', ], ]); } } We have already discussed the form model creation and the code above should not cause any problems in its understanding. We just want to attract the attention of the reader that in line 19, we set the \"multipart/form-data\" value for the \"enctype\" attribute of the form to make the form use binary encoding for its data. Note Actually, explicitly setting the \"enctype\" attribute in form's constructor is optional, because @ Laminas\\Form\\Element\\File element performs that automatically when you call form's prepare() method.","title":"Adding ImageForm Model"},{"location":"uploads/#adding-validation-rules-to-imageform-model","text":"To demonstrate the usage of validators and filters designed to work with file uploads, we will add those to the ImageForm form model class. We want to achieve the following goals: check if the uploaded file really was uploaded through HTTP POST method using the @ UploadFile validator; check that the uploaded file is an image (JPEG, PNG, GIF, etc.) using the @ IsImage validator; check that image dimensions are within some allowed boundaries; we will do that with the @ ImageSize validator; move the uploaded file to its residence directory using the @ RenameUpload filter. To add form validation rules, modify the code of the ImageForm class as follows: <?php namespace Application\\Form; use Laminas\\InputFilter\\InputFilter; // This form is used for uploading an image file. class ImageForm extends Form { // Constructor public function __construct() { // ... // Add validation rules $this->addInputFilter(); } // ... // This method creates input filter (used for form filtering/validation). private function addInputFilter() { $inputFilter = new InputFilter(); $this->setInputFilter($inputFilter); // Add validation rules for the \"file\" field. $inputFilter->add([ 'type' => 'Laminas\\InputFilter\\FileInput', 'name' => 'file', 'required' => true, 'validators' => [ ['name' => 'FileUploadFile'], [ 'name' => 'FileMimeType', 'options' => [ 'mimeType' => ['image/jpeg', 'image/png'] ] ], ['name' => 'FileIsImage'], [ 'name' => 'FileImageSize', 'options' => [ 'minWidth' => 128, 'minHeight' => 128, 'maxWidth' => 4096, 'maxHeight' => 4096 ] ], ], 'filters' => [ [ 'name' => 'FileRenameUpload', 'options' => [ 'target' => './data/upload', 'useUploadName' => true, 'useUploadExtension' => true, 'overwrite' => true, 'randomize' => false ] ] ], ]); } } In the code above, we add the following file validators: @ UploadFile validator (line 32) checks whether the uploaded file was really uploaded using the HTTP POST method. @ MimeType validator (line 34) checks whether the uploaded file is a JPEG or PNG image. It does that by extracting MIME information from file data. @ IsImage validator (line 39) checks whether the uploaded file is an image file (PNG, JPG, etc.). It does that by extracting MIME information from file data. @ ImageSize validator (line 41) allows to check that image dimensions lie in an allowed range. In the code above, we check that the image is between 128 pixels and 4096 pixels in width, and that the image height lies between 128 pixels and 4096 pixels. In line 52, we add the @ RenameUpload filter and configure it to save the uploaded file to the APP_DIR/data/upload directory. The filter will use the same file name for the destination file as the name of the original file ( useUploadName option). If the file with such name already exists, the filter will overwrite it ( overwrite option). Note For the @ MimeType and @ IsImage validator to work, you have to enable PHP fileinfo extension. This extension is already enabled in Linux Ubuntu, but not in Windows. After that, do not forget to restart Apache HTTP Server.","title":"Adding Validation Rules to ImageForm Model"},{"location":"uploads/#writing-imagemanager-service","text":"Because we strive to write code conforming to Domain Driven Design pattern, we will create a service model class encapsulating the functionality for image management. We will call this class ImageManager and put it to Application\\Service namespace. We will also register this service in the service manager component of the web application. The ImageManager service class will have the following public methods (listed in table 10.3): Method Description getSaveToDir() Returns path to the directory where we save the image files. getSavedFiles() Returns the array of saved file names. getImagePathByName($fileName) Returns the path to the saved image file. getImageFileInfo($filePath) Retrieves the file information (size, MIME type) by image path. getImageFileContent($filePath) Returns the image file content. On error, returns boolean false. resizeImage($filePath, $desiredWidth) Resizes the image, keeping its aspect ratio. Table 10.3. Public methods of the ImageManager class. Note In fact, we could put the code we plan to add into the service into the controller actions, but that would make the controller fat and poorly testable. By introducing the service class, we improve the separation of concerns and code reusability. Add the ImageManager.php file to the Service directory under the module's source directory. Add the following code to the file: <?php namespace Application\\Service; // The image manager service. class ImageManager { // The directory where we save image files. private $saveToDir = './data/upload/'; // Returns path to the directory where we save the image files. public function getSaveToDir() { return $this->saveToDir; } } As you can see from the code above, we define the ImageManager class in line 5. It has the private $saveToDir property 6 which contains the path to the directory containing our uploaded files (line 8) (we store uploaded files in APP_DIR/data/upload directory). The getSaveToDir() public method (line 11) allows to retrieve the path to the upload directory. Next, we want to add the getSavedFiles() public method to the service class. The method will scan the upload directory and return an array containing the names of the uploaded files. To add the getSavedFiles() method, modify the code in the following way: <?php //... // The image manager service. class ImageManager { //... // Returns the array of uploaded file names. public function getSavedFiles() { // The directory where we plan to save uploaded files. // Check whether the directory already exists, and if not, // create the directory. if(!is_dir($this->saveToDir)) { if(!mkdir($this->saveToDir)) { throw new \\Exception('Could not create directory for uploads: ' . error_get_last()); } } // Scan the directory and create the list of uploaded files. $files = []; $handle = opendir($this->saveToDir); while (false !== ($entry = readdir($handle))) { if($entry=='.' || $entry=='..') continue; // Skip current dir and parent dir. $files[] = $entry; } // Return the list of uploaded files. return $files; } } In the getSavedFiles() method above, we first check if the upload directory exists (line 16), and if not, we try to create it (line 17). Then, we get the list of files in the directory (lines 24-32) and return it to the caller. Next, we add the three methods for getting information about an uploaded file: the getImagePathByName() method will take the file name and prepend the path to upload directory to that file name; the getImageFileInfo() method will retrieve MIME information about the file and its size in bytes; and the getImageFileContent() will read file data and return them as a string. To add those three methods, change the code as follows: <?php //... // The image manager service. class ImageManager { //... // Returns the path to the saved image file. public function getImagePathByName($fileName) { // Take some precautions to make file name secure. $fileName = str_replace(\"/\", \"\", $fileName); // Remove slashes. $fileName = str_replace(\"\\\\\", \"\", $fileName); // Remove back-slashes. // Return concatenated directory name and file name. return $this->saveToDir . $fileName; } // Returns the image file content. On error, returns boolean false. public function getImageFileContent($filePath) { return file_get_contents($filePath); } // Retrieves the file information (size, MIME type) by image path. public function getImageFileInfo($filePath) { // Try to open file if (!is_readable($filePath)) { return false; } // Get file size in bytes. $fileSize = filesize($filePath); // Get MIME type of the file. $finfo = finfo_open(FILEINFO_MIME); $mimeType = finfo_file($finfo, $filePath); if($mimeType===false) $mimeType = 'application/octet-stream'; return [ 'size' => $fileSize, 'type' => $mimeType ]; } } Finally, we want to add the image resizing functionality to the ImageManager class. The image resizing functionality will be used for creating small thumbnail images. Add the resizeImage() method to the ImageManager class as follows: <?php //... class ImageManager { //... // Resizes the image, keeping its aspect ratio. public function resizeImage($filePath, $desiredWidth = 240) { // Get original image dimensions. list($originalWidth, $originalHeight) = getimagesize($filePath); // Calculate aspect ratio $aspectRatio = $originalWidth/$originalHeight; // Calculate the resulting height $desiredHeight = $desiredWidth/$aspectRatio; // Get image info $fileInfo = $this->getImageFileInfo($filePath); // Resize the image $resultingImage = imagecreatetruecolor($desiredWidth, $desiredHeight); if (substr($fileInfo['type'], 0, 9) =='image/png') $originalImage = imagecreatefrompng($filePath); else $originalImage = imagecreatefromjpeg($filePath); imagecopyresampled($resultingImage, $originalImage, 0, 0, 0, 0, $desiredWidth, $desiredHeight, $originalWidth, $originalHeight); // Save the resized image to temporary location $tmpFileName = tempnam(\"/tmp\", \"FOO\"); imagejpeg($resultingImage, $tmpFileName, 80); // Return the path to resulting image. return $tmpFileName; } } The resizeImage() method above takes two arguments: $filePath (the path to the image file), and $desiredWidth (the width of the thumbnail image). Inside the method, we first calculate an appropriate thumbnail image height (lines 11-16) preserving its aspect ratio. Then, we resize the original image as needed and save it to a temporary file (lines 19-32). As the ImageManager class is ready, you have to register the ImageManager service in the service manager component of the web application by adding the following lines to the module.config.php configuration file: <?php return [ // ... 'service_manager' => [ // ... 'factories' => [ // Register the ImageManager service Service\\ImageManager::class => InvokableFactory::class, ], ], // ... ];","title":"Writing ImageManager Service"},{"location":"uploads/#adding-imagecontroller","text":"For the Image Gallery example, we will create the ImageController controller class. The controller will have the following action methods (listed in table 10.4): Action Method Description __construct() Will allow to inject ImageManager dependency into the controller. uploadAction() Shows the image upload page allowing to upload a single image. indexAction() Displays the image gallery page with the list of uploaded images. fileAction() Provides an ability to download a full-size image or a small thumbnail for an image. Table 10.4. Action methods of the ImageController class. To start, create the ImageController.php file in the Application/Controller directory under the module's source directory. Put the following stub code into the file: <?php namespace Application\\Controller; use Laminas\\Mvc\\Controller\\AbstractActionController; use Laminas\\View\\Model\\ViewModel; use Application\\Form\\ImageForm; // This controller is designed for managing image file uploads. class ImageController extends AbstractActionController { // The image manager. private $imageManager; // The constructor method is used for injecting the dependencies // into the controller. public function __construct($imageManager) { $this->imageManager = $imageManager; } // This is the default \"index\" action of the controller. It displays the // Image Gallery page which contains the list of uploaded images. public function indexAction() { } // This action shows the image upload form. This page allows to upload // a single file. public function uploadAction() { } // This is the 'file' action that is invoked when a user wants to // open the image file in a web browser or generate a thumbnail. public function fileAction() { } } In the code above, we defined the ImageController class living in the Application\\Controller namespace and added the constructor method and three action method stubs into the class: indexAction() , uploadAction() and fileAction() . Next, we will populate those action methods with the code.","title":"Adding ImageController"},{"location":"uploads/#adding-upload-action-corresponding-view-template","text":"First, we will complete the uploadAction() method of our controller. This action method will handle the Upload a New Image web page containing the upload form. The form will provide an ability to upload an image file to the gallery. Change the ImageController.php file as follows: <?php //... class ImageController extends AbstractActionController { //... public function uploadAction() { // Create the form model. $form = new ImageForm(); // Check if user has submitted the form. if($this->getRequest()->isPost()) { // Make certain to merge the files info! $request = $this->getRequest(); $data = array_merge_recursive( $request->getPost()->toArray(), $request->getFiles()->toArray() ); // Pass data to form. $form->setData($data); // Validate form. if($form->isValid()) { // Move uploaded file to its destination directory. $data = $form->getData(); // Redirect the user to \"Image Gallery\" page. return $this->redirect()->toRoute('images'); } } // Render the page. return new ViewModel([ 'form' => $form ]); } } In the uploadAction() method above, we do the following. In line 9, we create an instance of the ImageForm form model with the help of the new operator. In line 12, we check whether the request is an HTTP POST request. If so, we get the data from $_POST and $_FILES super-global PHP arrays and merge them into the single array (lines 15-19). This is required to correctly handle uploaded files, if any. Then we pass this array to the form model with the setData() method (line 22). In line 25, we call the form model's isValid() method. This method runs the input filter attached to the form model. Since we have only one file input in the input filter, this will only run our three file validators: @ UploadFile , @ IsImage and @ ImageSize . If the data is valid, we call the getData() method (line 28). For our file field, this will run the @ RenameUpload filter, which moves our uploaded file to its persistent directory. After that, in line 31, we redirect the user to the \"index\" action of the controller (we will populate that action method a little bit later. Now, its time to add the view template for the \"upload\" action. Add the upload.phtml view template file under the application/image directory under the module's view directory: <?php $form = $this->form; $form->get('submit')->setAttributes(['class'=>'btn btn-primary']); $form->prepare(); ?> <h1>Upload a New Image</h1> <p> Please fill out the following form and press the <i>Upload</i> button. </p> <div class=\"row\"> <div class=\"col-md-6\"> <?= $this->form()->openTag($form); ?> <div class=\"form-group\"> <?= $this->formLabel($form->get('file')); ?> <?= $this->formElement($form->get('file')); ?> <?= $this->formElementErrors($form->get('file')); ?> <div class=\"hint\">(PNG and JPG formats are allowed)</div> </div> <?= $this->formElement($form->get('submit')); ?> <?= $this->form()->closeTag(); ?> </div> </div> In the code of the view template, we first set \"class\" attribute (line 3). This is to apply nice-looking Twitter Bootstrap styles to the form's Submit button. Then, we render the form with the common view helpers that we discussed in Collecting User Input with Forms . For rendering the \"file\" field, we use the generic @ FormElement view helper. Note Typically, you use the @ FormElement generic view helper for rendering the file field. The @ FormElement internally calls the @ FormFile view helper, which performs the actual rendering.","title":"Adding Upload Action &amp; Corresponding View Template"},{"location":"uploads/#adding-index-action-corresponding-view-template","text":"The second action method we will complete is the indexAction() . This action will handle the Image Gallery page containing the list of uploaded files and their small thumbnails. For each image, there will be a button \"Show In Natural Size\" for opening the image in another tab of the web browser. Change the ImageController.php file as follows: <?php //... class ImageController extends AbstractActionController { //... public function indexAction() { // Get the list of already saved files. $files = $this->imageManager->getSavedFiles(); // Render the view template. return new ViewModel([ 'files'=>$files ]); } } In the code above, we use the getSavedFiles() method of the ImageManager class for retrieving the list of uploaded images and pass them to the view for rendering. Note Please note how \"slim\" and clear this controller action is! We achieved this by moving the image management functionality to the ImageManager service model. Add the index.phtml view template to application/image directory under the module's view directory. The contents of the file is shown below: <h1>Image Gallery</h1> <p> This page displays the list of uploaded images. </p> <p> <a href=\"<?= $this->url('images', ['action'=>'upload']); ?>\" class=\"btn btn-primary\" role=\"button\">Upload More</a> </p> <hr/> <?php if(count($files)==0): ?> <p> <i>There are no files to display.</i> </p> <?php else: ?> <div class=\"row\"> <div class=\"col-sm-6 col-md-12\"> <?php foreach($files as $file): ?> <div class=\"img-thumbnail\"> <img src=\"<?= $this->url('images', ['action'=>'file'], ['query'=>['name'=>$file, 'thumbnail'=>true]]); ?>\"> <div class=\"caption\"> <h3><?php echo $file; ?></h3> <p> <a target=\"_blank\" href=\"<?= $this->url('images', ['action'=>'file'], ['query'=>['name'=>$file]]); ?>\" class=\"btn btn-default\" role=\"button\">Show in Natural Size</a> </p> </div> </div> <?php endforeach; ?> </div> </div> <?php endif; ?> <hr/> In the code above, we create the HTML markup for the Upload More button. Under the button, we use check whether the $files array is empty. If the array is empty, we output the \"There are no files to display\" message; otherwise we walk through the files and output the thumbnails of each uploaded images. For rendering a thumbnail, we use the <img> tag. We set its src attribute with the URL pointing to the \"file\" action of our ImageController controller. We pass two parameters to the action via the query part of the URL: the image name and thumbnail flag. For styling the thumbnails, we use the Twitter Bootstrap provided \".img-thumbnail\" CSS class. Note For additional information about these Twitter Bootstrap styles, please refer to the Bootstrap official documentation. Below each thumbnail, we put the \"Show in Natural Size\" link, which points to the \"file\" action of our ImageController controller. When site visitor clicks the link, he will be shown with the image in natural size, and the image will be opened in another browser's tab (note the target=\"_blank\" attribute of the link).","title":"Adding Index Action &amp; Corresponding View Template"},{"location":"uploads/#adding-file-action","text":"The last action we will populate is the ImageController::fileAction() method. That method will allow to preview an uploaded image or generate a small thumbnail of the image. The action method will take two GET parameters: the \"name\" parameter defines the file name for preview; the \"thumbnail\" parameter is a flag telling whether we want to dump the full image or its small copy. Change the ImageController.php file as follows: <?php //... class ImageController extends AbstractActionController { //... public function fileAction() { // Get the file name from GET variable. $fileName = $this->params()->fromQuery('name', ''); // Check whether the user needs a thumbnail or a full-size image. $isThumbnail = (bool)$this->params()->fromQuery('thumbnail', false); // Get path to image file. $fileName = $this->imageManager->getImagePathByName($fileName); if($isThumbnail) { // Resize the image. $fileName = $this->imageManager->resizeImage($fileName); } // Get image file info (size and MIME type). $fileInfo = $this->imageManager->getImageFileInfo($fileName); if ($fileInfo===false) { // Set 404 Not Found status code $this->getResponse()->setStatusCode(404); return; } // Write HTTP headers. $response = $this->getResponse(); $headers = $response->getHeaders(); $headers->addHeaderLine(\"Content-type: \" . $fileInfo['type']); $headers->addHeaderLine(\"Content-length: \" . $fileInfo['size']); // Write file content. $fileContent = $this->imageManager->getImageFileContent($fileName); if($fileContent!==false) { $response->setContent($fileContent); } else { // Set 500 Server Error status code. $this->getResponse()->setStatusCode(500); return; } if($isThumbnail) { // Remove temporary thumbnail image file. unlink($fileName); } // Return Response to avoid default view rendering. return $this->getResponse(); } } In the code above, we first get the \"name\" and \"thumbnail\" parameters from $_GET super-global array (lines 9, 12). If the parameters are missing, their default values are used instead. In line 15, we use the getImagePathByName() method provided by the ImageManager service to get the absolute path to the image by its name. If a thumbnail is requested, we resize the image with the resizeImage() method of the ImageManager (line 20). That method returns path to a temporary file containing the thumbnail image. Then, we get the information about the image file (its MIME type and file size) with the getImageFileInfo() method of the ImageManager (line 24). Finally, we create a @ Response [Laminas\\Http\\PhpEnvironment\\Response] object, fill its headers with image information, set its content with data of the image file (lines 32-45), and return the @ Response [Laminas\\Http\\PhpEnvironment\\Response] object from the controller action (line 53). Note Note that returning the @ Response [Laminas\\Http\\PhpEnvironment\\Response] object disables the default rendering of the view template for this action method. By this reason, we do not create the file.phtml view template file.","title":"Adding File Action"},{"location":"uploads/#creating-factory-for-the-controller","text":"Because our ImageController uses the ImageManager service, we need to somehow pass it the instance of the ImageManager (to inject the dependency into the controller's constructor). We do this with the help of factory . Create the ImageControllerFactory.php file under the Controller/Factory subdirectory under the module's source directory. Put the following code into the file: <?php namespace Application\\Controller\\Factory; use Interop\\Container\\ContainerInterface; use Laminas\\ServiceManager\\Factory\\FactoryInterface; use Application\\Service\\ImageManager; use Application\\Controller\\ImageController; /** * This is the factory for ImageController. Its purpose is to instantiate the * controller. */ class ImageControllerFactory implements FactoryInterface { public function __invoke(ContainerInterface $container, $requestedName, array $options = null) { $imageManager = $container->get(ImageManager::class); // Instantiate the controller and inject dependencies return new ImageController($imageManager); } }","title":"Creating Factory for the Controller"},{"location":"uploads/#registering-the-imagecontroller","text":"To let Laminas know about our controller, register the ImageController in the module.config.php configuration file: <?php return [ //... 'controllers' => [ 'factories' => [ Controller\\ImageController::class => Controller\\Factory\\ImageControllerFactory::class, //... ], ], //... ];","title":"Registering the ImageController"},{"location":"uploads/#creating-route","text":"We need to add a route for our ImageController controller. To do that, modify the module.config.php file as follows: <?php return [ //... 'router' => [ 'routes' => [ 'images' => [ 'type' => Segment::class, 'options' => [ 'route' => '/images[/:action]', 'constraints' => [ 'action' => '[a-zA-Z][a-zA-Z0-9_-]*' ], 'defaults' => [ 'controller' => Controller\\ImageController::class, 'action' => 'index', ], ], ], ], ], //... ]; After that, you will be able to get access to our image gallery by the URL like \"http://localhost/images\", \"http://localhost/images/upload\" or \"http://localhost/images/file\".","title":"Creating Route"},{"location":"uploads/#results","text":"Finally, adjust directory permissions to make the APP_DIR/data directory writeable by the Apache Web Server. In Linux Ubuntu, this is typically accomplished by the following shell commands (replace the APP_DIR placeholder with the actual directory name of your web application): chown -R www-data:www-data APP_DIR/data chmod -R 775 APP_DIR/data Above, the chown and chmod commands set the Apache user to be the owner of the directory and allow the web server to write to the directory, respectively. If you now enter the URL http://localhost/images into your web browser's navigation bar, you will see the image gallery page like shown in figure 10.4. Clicking the Upload More button will open the Upload a New Image page where you can peek an image file for upload. If you pick an unacceptable file (not an image, or too big image), you will see validation errors (see the figure 10.5 below). If the upload is completed successfully, you will be redirected back to the Image Gallery page and see the uploaded image in the list of thumbnails. Clicking the View Full Size button will open the image in a new browser tab (see the figure 10.6 below for example). You may find the Image Gallery complete example in the Form Demo sample web application bundled with this book.","title":"Results"},{"location":"uploads/#summary","text":"File uploads is a standard HTML form feature. Uploading files is accomplished by setting form content encoding to binary encoding type. Laminas Framework provides convenient functionality for doing file uploads and validating the uploaded files. HTTP file uploads are described in RFC-1867 . This mechanism allows to upload large files by using binary content transfer encoding. The \"multipart/form-data\" encoding type is utilized for this purpose. \u21a9 The HTTP GET method is inefficient for file uploads, because URL length has some upper limit. Also, URL-encoding the file data greatly increases the URL length. \u21a9 MIME type, also known as \"content type\" is a standard identifier used on the Internet to indicate the type of data that a file contains. For example the \"text/plain\" MIME type is assigned to a text file, while the \"application/octet-stream\" MIME type is assigned to a binary file. \u21a9 A file hash is used for checking file data integrity (for example, to ensure that file data is not corrupted). There are several hash algorithms available (MD5, SHA-1, CRC32, etc.) \u21a9 In the author's opinion, the above mentioned four filters are not very useful when working with uploaded files, because you rarely need to encrypt an uploaded file or convert it to lower case letters. \u21a9 Although the ImageManager class is a service and focused on providing services, it can have properties intended for its internal use. \u21a9","title":"Summary"},{"location":"users/","text":"User Management, Authentication and Access Filtering Most websites on the Internet allow their visitors to register on the site and create a profile. After that, the visitor can log in and have a personalized experience. For example, in a E-commerce website, a registered user can buy goods, manage their shopping cart and make a payment with a credit card. In this chapter, you will learn how to implement user authentication with login and password in a Laminas website. We will show how to manage users (add, edit, view and change/reset password) in your web application and store users' passwords in the database securely. You will also learn how to implement an access filter and allow certain pages to be accessed by authenticated users only. Since you already know a lot about Laminas from reading previous chapters, in this chapter we will omit discussing some obvious things and concentrate on conceptual moments only. It is recommended that you refer to the User Demo sample bundle with this book, which is a complete website that you can run and see everything in action. All code discussed in this chapter is part of this sample application. Laminas components covered in this chapter: Component Description @ Laminas\\Authentication Provides user authentication feature. @ Laminas\\Crypt Provides functionality for password encryption. @ Laminas\\Math Provides functionality for generating secure random tokens. Get User Demo Sample from GitHub For demonstration, in this chapter, we will create a real-life User Demo website that shows how to: Create a new module named User . This module will contain the functionality for user authentication and user management. Create User entity. Implement storing users' passwords in a database securely. Implement user authentication (with login and password). Implement an access filter to provide access to certain pages to authenticated users only. Implement user management UI that allows adding, editing, and viewing a user, and changing user's password. Implement main menu items differently based on whether the current user is logged in or not. To download the User Demo application, visit this page and click the Clone or Download button to download the code as a ZIP archive. When download is complete, unpack the archive to some directory. Then navigate to the userdemo directory containing the source code of the User Demo web application: /using-laminas-book-samples /userdemo ... The User Demo is a website which can be installed on your machine. Detailed instructions on how to install the User Demo sample can be found in README.md file located in the sample directory. Creating the User Module In the User Demo sample, we create a new module called User and add all functionality related to user management and authentication to that module. If you are new to the concept of modules, refer to chapter Creating a New Module . The User module will have very few dependencies on other modules of the website. The idea behind the User module is to give you a reusable unit that you can use in your own web application, without any changes or with some modifications. Note Ideally, you will be able to use the User module in your own website without any changes. But, in real-life websites, you'll probably have to add some fields to the user table, modify the user creation workflow, or modify the access filtering algorithm. It this case, you'll have to customize the code of the User module to feet your needs. The User module will have the following structure (see figure 16.1 below): Let's briefly describe what classes we will have inside module's directory. We will have two controllers: The UserController will contain functionality for managing users (adding, editing, changing password, etc.) The AuthController will implement user authentication functionality (login/logout). There will be one Doctrine entity: The User entity will be used to store information about the user in database (email, full name, password, etc). We will have four forms used to collect data: The LoginForm will be used to collect data for authentication (login and password). The PasswordChangeForm will be used to collect data for changing or resetting user's password. The PasswordResetForm will be used to collect the E-mail of the person who forgot his/her password and wishes to reset the password. The UserForm will be used to collect data about the user (email, full name, password, etc). We will have several services: The AuthAdapter service will implement the authentication algorithm. It will check if the user login (E-mail address) and password are correct. For performing that, it will retrieve the user information from a database. The AuthManager service will perform actual authentication (login/logout). It will also implement the access filter allowing or denying unauthenticated users access to certain web pages. The UserManager will contain business logic of managing users (adding, editing, changing password). Most controllers and services will be instantiated with factories. You can find the factory classes under the Factory subdirectories. Inside the view directory, we will have several view templates which will render HTML markup of the web pages present in the user interface exposed by our module. As usual, inside the config directory, we will have the module.config.php file that will contain routes and registration for our controllers and services. It will also contain the access_filter key defining which pages will be accessible to an unauthenticated user (this key will be read by AuthManager service). As you can see, the User module is a typical Laminas module with the structure conforming to the MVC pattern. Setting Up the Database We will need to set up a sample \"userdemo\" database. The database will have a single table named user for storing data associated with users of our website (see figure 16.2 below). The user table contains the following fields: the id is an auto-incremented integer field (primary key). the email is a string field containing user's E-mail address. Each user will have a unique E-mail address, so this field is a unique key, too. the full_name string field will contain the full name of a user (like \"John Doe\"). the status integer field will contain user's status (either \"active\" or \"retired\"). Retired users are not allowed to log in. the date_created contains date and time when the user was created. the pwd_reset_token and pwd_reset_token_creation_date fields are used for password resetting (when the user forgets his/her password and needs to reset it). Note In your own website, you will likely want to add more fields to the user table. In this sample, we only define some minimum set of fields. You can create the user table with the following SQL statement: CREATE TABLE `user` ( `id` int(11) NOT NULL AUTO_INCREMENT, `email` varchar(128) NOT NULL, `full_name` varchar(512) NOT NULL, `password` varchar(256) NOT NULL, `status` int(11) NOT NULL, `date_created` datetime NOT NULL, `pwd_reset_token` varchar(32) DEFAULT NULL, `pwd_reset_token_creation_date` datetime DEFAULT NULL, PRIMARY KEY (`id`), UNIQUE KEY `email_idx` (`email`) ); You can find a migration, which creates the user table, in the User Demo sample application. Note If you are new to migrations, refer to chapter Database Migrations . Implementing User Entity The User Demo sample uses Doctrine ORM for managing the database. We have already learned how to use Doctrine in Database Management with Doctrine ORM . For storing information about users in the database, we will create the User entity. The User entity is mapped onto the user database table. It is a typical Doctrine entity class. Create the User.php file inside the Entity directory under the module's source directory. Put the following code into that file: <?php namespace User\\Entity; use Doctrine\\ORM\\Mapping as ORM; /** * This class represents a registered user. * @ORM\\Entity() * @ORM\\Table(name=\"user\") */ class User { // User status constants. const STATUS_ACTIVE = 1; // Active user. const STATUS_RETIRED = 2; // Retired user. /** * @ORM\\Id * @ORM\\Column(name=\"id\") * @ORM\\GeneratedValue */ protected $id; /** * @ORM\\Column(name=\"email\") */ protected $email; /** * @ORM\\Column(name=\"full_name\") */ protected $fullName; /** * @ORM\\Column(name=\"password\") */ protected $password; /** * @ORM\\Column(name=\"status\") */ protected $status; /** * @ORM\\Column(name=\"date_created\") */ protected $dateCreated; /** * @ORM\\Column(name=\"pwd_reset_token\") */ protected $passwordResetToken; /** * @ORM\\Column(name=\"pwd_reset_token_creation_date\") */ protected $passwordResetTokenCreationDate; /** * Returns user ID. * @return integer */ public function getId() { return $this->id; } /** * Sets user ID. * @param int $id */ public function setId($id) { $this->id = $id; } /** * Returns email. * @return string */ public function getEmail() { return $this->email; } /** * Sets email. * @param string $email */ public function setEmail($email) { $this->email = $email; } /** * Returns full name. * @return string */ public function getFullName() { return $this->fullName; } /** * Sets full name. * @param string $fullName */ public function setFullName($fullName) { $this->fullName = $fullName; } /** * Returns status. * @return int */ public function getStatus() { return $this->status; } /** * Returns possible statuses as array. * @return array */ public static function getStatusList() { return [ self::STATUS_ACTIVE => 'Active', self::STATUS_RETIRED => 'Retired' ]; } /** * Returns user status as string. * @return string */ public function getStatusAsString() { $list = self::getStatusList(); if (isset($list[$this->status])) return $list[$this->status]; return 'Unknown'; } /** * Sets status. * @param int $status */ public function setStatus($status) { $this->status = $status; } /** * Returns password. * @return string */ public function getPassword() { return $this->password; } /** * Sets password. * @param string $password */ public function setPassword($password) { $this->password = $password; } /** * Returns the date of user creation. * @return string */ public function getDateCreated() { return $this->dateCreated; } /** * Sets the date when this user was created. * @param string $dateCreated */ public function setDateCreated($dateCreated) { $this->dateCreated = $dateCreated; } /** * Returns password reset token. * @return string */ public function getResetPasswordToken() { return $this->passwordResetToken; } /** * Sets password reset token. * @param string $token */ public function setPasswordResetToken($token) { $this->passwordResetToken = $token; } /** * Returns password reset token's creation date. * @return string */ public function getPasswordResetTokenCreationDate() { return $this->passwordResetTokenCreationDate; } /** * Sets password reset token's creation date. * @param string $date */ public function setPasswordResetTokenCreationDate($date) { $this->passwordResetTokenCreationDate = $date; } } As you can see from the code above, the User entity is a typical Doctrine entity having annotated properties and getter and setter methods for retrieving/setting those properties. Adding UserController The UserController class will contain several action methods providing an administrative user interface for managing the registered users. It will have the following actions: The indexAction() action will display a web page containing the list of users (see figure 16.3). Type \"http://localhost/users\" in your web browser's navigation bar to access this page. The addAction() will display a page allowing the creation of a new user (see figure 16.4). Type \"http://localhost/users/add\" in your web browser's navigation bar to access this page. The editAction() action will display a page for updating an existing user (see figure 16.5). Type \"http://localhost/users/edit/<id>\" in your web browser's navigation bar to access this page. The viewAction() will allow viewing an existing user (see figure 16.6). Type \"http://localhost/users/view/<id>\" in your web browser's navigation bar to access this page. The changePasswordAction() action will give the admin the ability to change the password of an existing user (see figure 16.7). Type \"http://localhost/users/changePassword/<id>\" in your web browser's navigation bar to access this page. The resetPasswordAction() action will allow a user to reset his own password (see figure 16.8). Type \"http://localhost/reset-password\" in your web browser's navigation bar to access this page. The UserController controller class is designed to be as \"thin\" as possible. It contains only the code responsible for checking input data, instantiating the needed models, passing input data to the models and returning the output data for rendering in a view template. Because it is a typical controller class and because you can see its complete code in the User Demo sample, we will not describe it here in more detail. Adding UserManager Service The UserController works with the UserManager service, which contains all the business logic related to user management. The service allows an admin to create and update users, change a user's password and reset a user's password. We will describe some parts of it in more detail, omitting other obvious parts (you still can see the complete code in User Demo sample). Creating a New User & Storing Password Encrypted The addUser() method of the UserManager allows us to add a new user. It looks as follows: /** * This method adds a new user. */ public function addUser($data) { // Do not allow several users with the same email address. if($this->checkUserExists($data['email'])) { throw new \\Exception(\"User with email address \" . $data['$email'] . \" already exists\"); } // Create new User entity. $user = new User(); $user->setEmail($data['email']); $user->setFullName($data['full_name']); // Encrypt password and store the password in encrypted state. $bcrypt = new Bcrypt(); $passwordHash = $bcrypt->create($data['password']); $user->setPassword($passwordHash); $user->setStatus($data['status']); $currentDate = date('Y-m-d H:i:s'); $user->setDateCreated($currentDate); // Add the entity to the entity manager. $this->entityManager->persist($user); // Apply changes to database. $this->entityManager->flush(); return $user; } You can see that in this method we first check if another user with the same E-mail address already exists (line 7), and if so we forbid creating the user by throwing an exception. If the user with such E-mail address doesn't exist, we create a new User entity (line 13) and set its properties accordingly. What is interesting here is how we save the user's password to the database. For security reasons, we do not save the password as is, but calculate a hash of it with the @ Bcrypt class provided by @ Laminas\\Crypt component of Laminas Framework (lines 18-19) . You can install @ Laminas\\Crypt with the following command: php composer.phar require laminas/laminas-crypt Note The @ Laminas\\Crypt component also requires that you have mcrypt PHP extension installed. Important The Bcrypt algorithm is a hashing algorithm that is widely used and recommended by the security community for storing user's password. Encrypting password with @ Bcrypt is considered secure nowadays. Some developers still encrypt passwords with MD5 or SHA1 with salt, but this is not considered secure anymore (MD5 and SHA1 hashes can be hacked). Validating Encrypted Password When a user logs in, you'll need to check if the password hash stored in the database is the same as the hash calculated by the password entered by the visitor. You do that with the help of the verify() method provided by the @ Bcrypt class, as follows: /** * Checks that the given password is correct. */ public function validatePassword($user, $password) { $bcrypt = new Bcrypt(); $passwordHash = $user->getPassword(); if ($bcrypt->verify($password, $passwordHash)) { return true; } return false; } Creating Admin User The next important thing to note in UserManager is how we create the Admin user. The Admin user is an initial user that is created automatically when there are not existing users in the database and allows you to login for the first time. /** * This method checks if at least one user presents, and if not, creates * 'Admin' user with email 'admin@example.com' and password 'Secur1ty'. */ public function createAdminUserIfNotExists() { $user = $this->entityManager->getRepository(User::class)->findOneBy([]); if ($user==null) { $user = new User(); $user->setEmail('admin@example.com'); $user->setFullName('Admin'); $bcrypt = new Bcrypt(); $passwordHash = $bcrypt->create('Secur1ty'); $user->setPassword($passwordHash); $user->setStatus(User::STATUS_ACTIVE); $user->setDateCreated(date('Y-m-d H:i:s')); $this->entityManager->persist($user); $this->entityManager->flush(); } } We set the Admin user's email to admin@example.com and password to Secur1ty , so you can login for the first time with these credentials. Resetting User Password Sometimes users forget their password. If that happens, you'll need to let the user reset the password - to securely change the password. Password resetting works as follows: A random password reset token is generated and its hash is saved to database. The password reset token is sent to user's email address as part of an E-mail message. The user checks his mailbox and clicks the password reset link in the E-mail message. The website validates the password reset token and checks it hasn't expired. The user is directed to the form allowing him to enter new password. Important You typically do not store raw password reset tokens in database. Instead, you store a hash of the token. This is done for security reasons. Even if some malicious hacker steals the DB, they won't be able to reset passwords of the users. The password reset token generation algorithm is implemented inside the generatePasswordResetToken() method of UserManager . To generate a random string, we use the @ Rand class provided by @ Laminas\\Math component. /** * Generates a password reset token for the user. This token is then stored in database and * sent to the user's E-mail address. When the user clicks the link in E-mail message, he is * directed to the Set Password page. */ public function generatePasswordResetToken($user) { if ($user->getStatus() != User::STATUS_ACTIVE) { throw new \\Exception('Cannot generate password reset token for inactive user ' . $user->getEmail()); } // Generate a token. $token = Rand::getString(32, '0123456789abcdefghijklmnopqrstuvwxyz', true); // Encrypt the token before storing it in DB. $bcrypt = new Bcrypt(); $tokenHash = $bcrypt->create($token); // Save token to DB $user->setPasswordResetToken($tokenHash); // Save token creation date to DB. $currentDate = date('Y-m-d H:i:s'); $user->setPasswordResetTokenCreationDate($currentDate); // Apply changes to DB. $this->entityManager->flush(); // Send an email to user. $subject = 'Password Reset'; $httpHost = isset($_SERVER['HTTP_HOST'])?$_SERVER['HTTP_HOST']:'localhost'; $passwordResetUrl = 'http://' . $httpHost . '/set-password?token=' . $token . \"&email=\" . $user->getEmail(); // Produce HTML of password reset email $bodyHtml = $this->viewRenderer->render( 'user/email/reset-password-email', [ 'passwordResetUrl' => $passwordResetUrl, ]); $html = new MimePart($bodyHtml); $html->type = \"text/html\"; $body = new MimeMessage(); $body->addPart($html); $mail = new Mail\\Message(); $mail->setEncoding('UTF-8'); $mail->setBody($body); $mail->setFrom('no-reply@example.com', 'User Demo'); $mail->addTo($user->getEmail(), $user->getFullName()); $mail->setSubject($subject); // Setup SMTP transport $transport = new SmtpTransport(); $options = new SmtpOptions($this->config['smtp']); $transport->setOptions($options); $transport->send($mail); } If your web server is as at the same time configured as a mail server then you can send the emails from it. In our example we are sending now the emails over an external SMTP server like e.g. SendGrid or Amazon SES . Password reset token validation is implemented inside the validatePasswordResetToken() method. We check that the token's hash is the same as we saved in database and that the token has not expired (it expires in 1 day since creation). /** * Checks whether the given password reset token is a valid one. */ public function validatePasswordResetToken($email, $passwordResetToken) { // Find user by email. $user = $this->entityManager->getRepository(User::class) ->findOneByEmail($email); if($user==null || $user->getStatus() != User::STATUS_ACTIVE) { return false; } // Check that token hash matches the token hash in our DB. $bcrypt = new Bcrypt(); $tokenHash = $user->getPasswordResetToken(); if (!$bcrypt->verify($passwordResetToken, $tokenHash)) { return false; // mismatch } // Check that token was created not too long ago. $tokenCreationDate = $user->getPasswordResetTokenCreationDate(); $tokenCreationDate = strtotime($tokenCreationDate); $currentDate = strtotime('now'); if ($currentDate - $tokenCreationDate > 24*60*60) { return false; // expired } return true; } And finally, the setPasswordByToken() allows to set new password for the user. /** * This method sets new password by password reset token. */ public function setNewPasswordByToken($email, $passwordResetToken, $newPassword) { if (!$this->validatePasswordResetToken($email, $passwordResetToken)) { return false; } // Find user with the given email. $user = $this->entityManager->getRepository(User::class) ->findOneByEmail($email); if ($user==null || $user->getStatus() != User::STATUS_ACTIVE) { return false; } // Set new password for user $bcrypt = new Bcrypt(); $passwordHash = $bcrypt->create($newPassword); $user->setPassword($passwordHash); // Remove password reset token $user->setPasswordResetToken(null); $user->setPasswordResetTokenCreationDate(null); $this->entityManager->flush(); return true; } Implementing User Authentication Authentication is the process performed when a user provides his login and password and you decide whether these credentials are correct. Authentication typically means you check your database for the given login, and if such login exists, you check if the hash calculated by the given password matches the hash of the password stored in the database. Important You typically do not store raw passwords in database. Instead, you store a hash of the password. This is done for security reasons. Once the authentication algorithm determines that the login and password are correct, it returns user identity - a unique ID of the user. The identity is typically stored to session, so the visitor doesn't need to pass authentication for every HTTP request. In Laminas, there is a special component allowing you to implement user authentication - @ Laminas\\Authentication . You can install this component with Composer by typing the following command: php composer.phar require laminas/laminas-authentication Important For authentication to work, you also need to have @ Laminas\\Session component installed and session manager configured. For information on how to do that, refer to Working with Sessions chapter. AuthenticationService The @ Laminas\\Authentication component provides the special service class called AuthenticationService living in @ Laminas\\Authentication namespace. Most useful methods of this service are shown in table 16.1 below. Method Description authenticate() Performs user authentication using the adapter. getAdapter() Gets authentication adapter. setAdapter() Sets authentication adapter implementing the actual authentication algorithm. getStorage() Returns storage handler. setStorage() Sets storage handler. hasIdentity() Returns true if user identity is already stored in session. getIdentity() Retrieves user identity from session. clearIdentity() Removes user identity from session. Table 16.1. Methods of AuthenticationService class As you can see from the table, you can use the authenticate() method to perform user authentication. Besides that you can use hasIdentity() , getIdentity() and clearIdentity() methods for testing, retrieving and clearing user identity, respectively. However, the @ AuthenticationService service is very generic - it knows nothing about how to actually match login and password against the database. It also knows nothing about how to save the user identity to session. This design allows you to implement any suitable authentication algorithm and any suitable storage. The @ Laminas\\Authentication component provides several authentication adapters implementing some standard authentication algorithms (see figure 16.9), and several storage handlers allowing you to save and retrieve the user identity (see figure 16.10). For our purposes, we can use @ Session [Laminas\\Authentication\\Storage\\Session] storage handler without needing to change any code. However, standard authentication adapters are not suitable for us, because we use Doctrine ORM. Important The following chapters will be rewritten. Since the first version of this book a proper DoctrineModule was written for Laminas\\Authentication. Because of this we do not need to write an adapter. The documentation for the DoctrineModule can be found at: DoctrineModule Writing Authentication Adapter An authentication adapter must implement the @ AdapterInterface [Laminas\\Authentication\\Adapter\\AdapterInterface] interface, which has the single method authenticate() . This method should check the user email and password against the database. We will do this as follows: Find the user with the given email (we use the E-mail address as the user's login). If user with such email doesn't exist - return failure status. Check the status of the user. If the user is \"retired\" - forbid the user to login. Calculate password hash and compare it against the hash stored in database for the user found. If password hash doesn't match, return failure status. If password is correct, return success status. The authenticate() method returns an instance of the @ Laminas\\Authentication\\Result class. The @ Result [Laminas\\Authentication\\Result] class contains the authentication status, the error message and the user identity. The adapter can also have additional methods. For example, we will add the setEmail() and setPassword() methods that we will use to pass user email and password to the adapter. To create the authentication adapter, add the file AuthAdapter.php to the Service directory of the module's source directory. In the User Demo sample, we create a separate module called User and add functionality related to authentication and user management to that module. Put the following code into that file: <?php namespace User\\Service; use Laminas\\Authentication\\Adapter\\AdapterInterface; use Laminas\\Authentication\\Result; use Laminas\\Crypt\\Password\\Bcrypt; use User\\Entity\\User; /** * Adapter used for authenticating user. It takes login and password on input * and checks the database if there is a user with such login (email) and password. * If such user exists, the service returns his identity (email). The identity * is saved to session and can be retrieved later with Identity view helper provided * by Laminas. */ class AuthAdapter implements AdapterInterface { /** * User email. * @var string */ private $email; /** * Password * @var string */ private $password; /** * Entity manager. * @var Doctrine\\ORM\\EntityManager */ private $entityManager; /** * Constructor. */ public function __construct($entityManager) { $this->entityManager = $entityManager; } /** * Sets user email. */ public function setEmail($email) { $this->email = $email; } /** * Sets password. */ public function setPassword($password) { $this->password = (string)$password; } /** * Performs an authentication attempt. */ public function authenticate() { // Check the database if there is a user with such email. $user = $this->entityManager->getRepository(User::class) ->findOneByEmail($this->email); // If there is no such user, return 'Identity Not Found' status. if ($user==null) { return new Result( Result::FAILURE_IDENTITY_NOT_FOUND, null, ['Invalid credentials.']); } // If the user with such email exists, we need to check if it is active or retired. // Do not allow retired users to log in. if ($user->getStatus()==User::STATUS_RETIRED) { return new Result( Result::FAILURE, null, ['User is retired.']); } // Now we need to calculate hash based on user-entered password and compare // it with the password hash stored in database. $bcrypt = new Bcrypt(); $passwordHash = $user->getPassword(); if ($bcrypt->verify($this->password, $passwordHash)) { // Great! The password hash matches. Return user identity (email) to be // saved in session for later use. return new Result( Result::SUCCESS, $this->email, ['Authenticated successfully.']); } // If password check didn't pass return 'Invalid Credential' failure status. return new Result( Result::FAILURE_CREDENTIAL_INVALID, null, ['Invalid credentials.']); } } Creating the Factory for AuthenticationService Once we've implemented the adapter, we can actually create the @ AuthenticationService . Laminas's @ AuthenticationService should be registered in the service manager before you can use it. First of all, we will create a factory for it. Add the AuthenticationServiceFactory.php file under the Service/Factory directory and put the following code there: <?php namespace User\\Service\\Factory; use Interop\\Container\\ContainerInterface; use Laminas\\Authentication\\AuthenticationService; use Laminas\\ServiceManager\\Factory\\FactoryInterface; use Laminas\\Session\\SessionManager; use Laminas\\Authentication\\Storage\\Session as SessionStorage; use User\\Service\\AuthAdapter; /** * The factory responsible for creating of authentication service. */ class AuthenticationServiceFactory implements FactoryInterface { /** * This method creates the Laminas\\Authentication\\AuthenticationService service * and returns its instance. */ public function __invoke(ContainerInterface $container, $requestedName, array $options = null) { $sessionManager = $container->get(SessionManager::class); $authStorage = new SessionStorage('Laminas_Auth', 'session', $sessionManager); $authAdapter = $container->get(AuthAdapter::class); // Create the service and inject dependencies into its constructor. return new AuthenticationService($authStorage, $authAdapter); } } In the factory we do the following: First, we create an instance of the session manager (you should have set up the session manager already) and create an instance of @ Session [Laminas\\Authentication\\Storage\\Session] storage handler. Then we create an instance of AuthAdapter . Finally, we instantiate the @ AuthenticationService and inject dependencies (storage handler and adapter) into it. Register the @ AuthenticationService in your module.config.php config file as follows: <?php return [ 'service_manager' => [ 'factories' => [ \\Laminas\\Authentication\\AuthenticationService::class => Service\\Factory\\AuthenticationServiceFactory::class, // ... ], ], ]; Adding AuthController The AuthController class will have two actions: The loginAction() will allow logging in to the website (see figures 16.11 and 16.12). You can access this page by typing \"http://localhost/login\" URL into your web browser's navigation bar. The logoutAction() will allow logging out from the website. You can access this page by typing \"http://localhost/logout\" URL into your web browser's navigation bar. The code of the AuthController controller class is presented below: <?php namespace User\\Controller; use Laminas\\Mvc\\Controller\\AbstractActionController; use Laminas\\View\\Model\\ViewModel; use Laminas\\Authentication\\Result; use Laminas\\Uri\\Uri; use User\\Form\\LoginForm; use User\\Entity\\User; /** * This controller is responsible for letting the user to log in and log out. */ class AuthController extends AbstractActionController { /** * Entity manager. * @var Doctrine\\ORM\\EntityManager */ private $entityManager; /** * Auth manager. * @var User\\Service\\AuthManager */ private $authManager; /** * Auth service. * @var \\Laminas\\Authentication\\AuthenticationService */ private $authService; /** * User manager. * @var User\\Service\\UserManager */ private $userManager; /** * Constructor. */ public function __construct($entityManager, $authManager, $authService, $userManager) { $this->entityManager = $entityManager; $this->authManager = $authManager; $this->authService = $authService; $this->userManager = $userManager; } /** * Authenticates user given email address and password credentials. */ public function loginAction() { // Retrieve the redirect URL (if passed). We will redirect the user to this // URL after successfull login. $redirectUrl = (string)$this->params()->fromQuery('redirectUrl', ''); if (strlen($redirectUrl)>2048) { throw new \\Exception(\"Too long redirectUrl argument passed\"); } // Check if we do not have users in database at all. If so, create // the 'Admin' user. $this->userManager->createAdminUserIfNotExists(); // Create login form $form = new LoginForm(); $form->get('redirect_url')->setValue($redirectUrl); // Store login status. $isLoginError = false; // Check if user has submitted the form if ($this->getRequest()->isPost()) { // Fill in the form with POST data $data = $this->params()->fromPost(); $form->setData($data); // Validate form if($form->isValid()) { // Get filtered and validated data $data = $form->getData(); // Perform login attempt. $result = $this->authManager->login($data['email'], $data['password'], $data['remember_me']); // Check result. if ($result->getCode()==Result::SUCCESS) { // Get redirect URL. $redirectUrl = $this->params()->fromPost('redirect_url', ''); if (!empty($redirectUrl)) { // The below check is to prevent possible redirect attack // (if someone tries to redirect user to another domain). $uri = new Uri($redirectUrl); if (!$uri->isValid() || $uri->getHost()!=null) throw new \\Exception('Incorrect redirect URL: ' . $redirectUrl); } // If redirect URL is provided, redirect the user to that URL; // otherwise redirect to Home page. if(empty($redirectUrl)) { return $this->redirect()->toRoute('home'); } else { $this->redirect()->toUrl($redirectUrl); } } else { $isLoginError = true; } } else { $isLoginError = true; } } return new ViewModel([ 'form' => $form, 'isLoginError' => $isLoginError, 'redirectUrl' => $redirectUrl ]); } /** * The \"logout\" action performs logout operation. */ public function logoutAction() { $this->authManager->logout(); return $this->redirect()->toRoute('login'); } } The loginAction() method accepts the redirectUrl GET parameter. The \"redirect URL\" is a convenience feature working with the access filter that we will describe later in this chapter. When the site visitor tries to access a web page, the access filter forbids access, and he/she is redirected to the \"Login\" page, passing the URL of the original page as the \"redirect URL\". When the user logs in, he/she is redirected back to the original page automatically, improving user experience. Adding View Template for Login Page The view template ( .phtml file) for our Login page looks as follows: <?php $this->headTitle('Sign in'); $this->mainMenu()->setActiveItemId('login'); $form->get('email')->setAttributes([ 'class'=>'form-control', 'placeholder'=>'Email address', 'required' => true, 'autofocus' => true ]) ->setLabelAttributes([ 'class' => 'sr-only' ]); $form->get('password')->setAttributes([ 'class'=>'form-control', 'placeholder'=>'Password', 'required' => true, ]) ->setLabelAttributes([ 'class' => 'sr-only' ]); ?> <div class=\"row\"> <div class=\"col-md-offset-4 col-md-3\"> <form class=\"form-signin\" method=\"post\"> <h2 class=\"form-signin-heading\">Please sign in</h2> <?php if ($isLoginError): ?> <div class=\"alert alert-warning\" role=\"alert\"> Incorrect login and/or password. <a href=\"<?= $this->url('reset-password') ?>\">Forgot password?</a> </div> <?php endif; ?> <?= $this->formLabel($form->get('email')); ?> <?= $this->formElement($form->get('email')); ?> <?= $this->formLabel($form->get('password')); ?> <?= $this->formElement($form->get('password')); ?> <div class=\"checkbox\"> <label> <?= $this->formElement($form->get('remember_me')); ?> Remember me </label> </div> <?= $this->formElement($form->get('redirect_url')); ?> <?= $this->formElement($form->get('csrf')) ?> <button class=\"btn btn-lg btn-primary btn-block\" type=\"submit\">Sign in</button> </form> </div> </div> Note The view template uses the Sign In page template provided by Bootstrap CSS Framework. You can find the original template here . Adding AuthManager Service The AuthController works with the AuthManager service. The main business logic behind the authentication is implemented in the service. Let's describe the AuthManager in detail. The AuthManager service has the following methods responsible for authentication: the login() method the logout() method. The login() method (see below) uses the Laminas's @ AuthenticationService and the AuthAdapter we wrote earlier for performing user authentication. The method additionally accepts the $rememberMe argument which extends the session cookie lifetime to 30 days. /** * Performs a login attempt. If $rememberMe argument is true, it forces the session * to last for one month (otherwise the session expires on one hour). */ public function login($email, $password, $rememberMe) { // Check if user has already logged in. If so, do not allow to log in // twice. if ($this->authService->getIdentity()!=null) { throw new \\Exception('Already logged in'); } // Authenticate with login/password. $authAdapter = $this->authService->getAdapter(); $authAdapter->setEmail($email); $authAdapter->setPassword($password); $result = $this->authService->authenticate(); // If user wants to \"remember him\", we will make session to expire in // one month. By default session expires in 1 hour (as specified in our // config/global.php file). if ($result->getCode()==Result::SUCCESS && $rememberMe) { // Session cookie will expire in 1 month (30 days). $this->sessionManager->rememberMe(60*60*24*30); } return $result; } The logout() method removes the user identity from session, so the visitor becomes unauthenticated. /** * Performs user logout. */ public function logout() { // Allow to log out only when user is logged in. if ($this->authService->getIdentity()==null) { throw new \\Exception('The user is not logged in'); } // Remove identity from session. $this->authService->clearIdentity(); } Access Filtering The last thing we implement in the User module is the access filter . The access filter will be used for restricting access to certain web pages to authenticated users only. The access filter will work as follows: When someone tries to access a web page, check the access_filter key of the app configuration and check whether this page is allowed to access by anyone or by authenticated users only. If the page is allowed to be accessed by anyone, allow the visitor to see the page. If the page is allowed to be accessed by authenticated users only, check if the user is authenticated or not. If the user is not authenticated, redirect him to the Login page and ask to log in. Once the user logs in, redirect him back to the original page automatically. The access filter is designed to function in one of two modes: restrictive (default) and permissive. In restrictive mode the filter forbids access to any page not listed under the access_filter key. The access_filter configuration key will be located inside the module.config.php file and will be used by the access filter. It will contain the list of controllers and action names, and for each action it will either allow to anyone to see the page or allow to authenticated users only to see the page. An example structure of the key is presented below: // The 'access_filter' key is used by the User module to restrict or permit // access to certain controller actions for unauthenticated visitors. 'access_filter' => [ 'options' => [ // The access filter can work in 'restrictive' (recommended) or 'permissive' // mode. In restrictive mode all controller actions must be explicitly listed // under the 'access_filter' config key, and access is denied to any not listed // action for users not logged in. In permissive mode, if an action is not listed // under the 'access_filter' key, access to it is permitted to anyone (even for // users not logged in. Restrictive mode is more secure and recommended. 'mode' => 'restrictive' ], 'controllers' => [ Controller\\IndexController::class => [ // Allow anyone to visit \"index\" and \"about\" actions ['actions' => ['index', 'about'], 'allow' => '*'], // Allow authenticated users to visit \"settings\" action ['actions' => ['settings'], 'allow' => '@'] ], ] ], Under the access_filter key, we have two subkeys: The options key can be used to define the mode in which the filter functions (\"restrictive\" or \"permissive\"). The controllers key lists the controllers and their actions, specifying the access type for each action. The asterisk character (*) means that everyone will be able to access the web page. The \"at\" character (@) means that only authenticated users will be able to access the page. Note The access filter implementation is very simple. It can't, for example, allow access based on username or by user role. However, you can easily modify and extend it as you wish. If you plan to introduce role-based access control (RBAC), refer to the Role-Based Access Control chapter. Adding Dispatch Event Listener To implement access filtering, we will use an event listener. You have already become familiar with event listening in the Creating a New Module chapter. Particularly, we will listen to the Dispatch event. The Dispatch event is triggered after the Route event, when the controller and action are already determined. To implement the listener, we modify the Module.php file of the User module as follows: <?php namespace User; use Laminas\\Mvc\\MvcEvent; use Laminas\\Mvc\\Controller\\AbstractActionController; use User\\Controller\\AuthController; use User\\Service\\AuthManager; class Module { /** * This method returns the path to module.config.php file. */ public function getConfig() { return include __DIR__ . '/../config/module.config.php'; } /** * This method is called once the MVC bootstrapping is complete and allows * to register event listeners. */ public function onBootstrap(MvcEvent $event) { // Get event manager. $eventManager = $event->getApplication()->getEventManager(); $sharedEventManager = $eventManager->getSharedManager(); // Register the event listener method. $sharedEventManager->attach(AbstractActionController::class, MvcEvent::EVENT_DISPATCH, [$this, 'onDispatch'], 100); } /** * Event listener method for the 'Dispatch' event. We listen to the Dispatch * event to call the access filter. The access filter allows to determine if * the current visitor is allowed to see the page or not. If he/she * is not authenticated and is not allowed to see the page, we redirect the user * to the login page. */ public function onDispatch(MvcEvent $event) { // Get controller and action to which the HTTP request was dispatched. $controller = $event->getTarget(); $controllerName = $event->getRouteMatch()->getParam('controller', null); $actionName = $event->getRouteMatch()->getParam('action', null); // Convert dash-style action name to camel-case. $actionName = str_replace('-', '', lcfirst(ucwords($actionName, '-'))); // Get the instance of AuthManager service. $authManager = $event->getApplication()->getServiceManager()->get(AuthManager::class); // Execute the access filter on every controller except AuthController // (to avoid infinite redirect). if ($controllerName!=AuthController::class && !$authManager->filterAccess($controllerName, $actionName)) { // Remember the URL of the page the user tried to access. We will // redirect the user to that URL after successful login. $uri = $event->getApplication()->getRequest()->getUri(); // Make the URL relative (remove scheme, user info, host name and port) // to avoid redirecting to other domain by a malicious user. $uri->setScheme(null) ->setHost(null) ->setPort(null) ->setUserInfo(null); $redirectUrl = $uri->toString(); // Redirect the user to the \"Login\" page. return $controller->redirect()->toRoute('login', [], ['query'=>['redirectUrl'=>$redirectUrl]]); } } } Implementing Access Filtering Algorithm The onDispatch() event listener calls the filterAccess() method of AuthManager service to determine if the page can be seen or not. The code of the filterAccess() method is presented below: /** * This is a simple access control filter. It allows vistors to visit certain pages only, * the rest requiring the user to be authenticated. * * This method uses the 'access_filter' key in the config file and determines * whenther the current visitor is allowed to access the given controller action * or not. It returns true if allowed; otherwise false. */ public function filterAccess($controllerName, $actionName) { // Determine mode - 'restrictive' (default) or 'permissive'. In restrictive // mode all controller actions must be explicitly listed under the 'access_filter' // config key, and access is denied to any not listed action for unauthenticated users. // In permissive mode, if an action is not listed under the 'access_filter' key, // access to it is permitted to anyone (even for not logged in users. // Restrictive mode is more secure and recommended to use. $mode = isset($this->config['options']['mode'])?$this->config['options']['mode']:'restrictive'; if ($mode!='restrictive' && $mode!='permissive') throw new \\Exception('Invalid access filter mode (expected either restrictive or permissive mode'); if (isset($this->config['controllers'][$controllerName])) { $items = $this->config['controllers'][$controllerName]; foreach ($items as $item) { $actionList = $item['actions']; $allow = $item['allow']; if (is_array($actionList) && in_array($actionName, $actionList) || $actionList=='*') { if ($allow=='*') return true; // Anyone is allowed to see the page. else if ($allow=='@' && $this->authService->hasIdentity()) { return true; // Only authenticated user is allowed to see the page. } else { return false; // Access denied. } } } } // In restrictive mode, we forbid access for authenticated users to any // action not listed under 'access_filter' key (for security reasons). if ($mode=='restrictive' && !$this->authService->hasIdentity()) return false; // Permit access to this page. return true; } Testing Access Filter To test the access filter, try to visit the \"http://localhost/users\" or \"http://localhost/settings\" page when you are not logged in. The access filter will direct you to Login page. However, you can easily visit the \"http://localhost/about\" page - it is open to anyone. Identity Controller Plugin and View Helper One last thing we will discuss is how to check in your website if the user is logged in or not and retrieve the user identity. You can do that with the help of the @ Identity [Laminas\\Mvc\\Plugin\\Identity] controller plugin and the @ Identity [Laminas\\View\\Helper\\Identity] view helper. To use the @ Identity [Laminas\\Mvc\\Plugin\\Identity] plugin, you need to install laminas/laminas-mvc-plugins package with Composer, as follows: `php composer.phar require laminas/laminas-mvc-plugins` In your controller action method, you can check if user is logged in with the following code: if ($this->identity()!=null) { // User is logged in // Retrieve user identity $userEmail = $this->identity(); } In your view template, you can use @ Identity [Laminas\\View\\Helper\\Identity] view helper for the same purpose: // Echo user identity <?= $this->escapeHtml($this->identity()) ?> Summary In this chapter, we learned about user management, user authentication and access filtering. User management means providing the UI for adding, editing, viewing users and changing their password. Authentication is when a user provides his login and password and you decide whether these credentials are correct. Laminas provides the special service called @ AuthenticationService that you can use for this purpose, but first you need to implement an authentication adapter. Access filtering allows access to certain pages to authenticated users only. You can implement access filtering with the help of an event listener.","title":"User Management, Authentication and Access Filtering"},{"location":"users/#user-management-authentication-and-access-filtering","text":"Most websites on the Internet allow their visitors to register on the site and create a profile. After that, the visitor can log in and have a personalized experience. For example, in a E-commerce website, a registered user can buy goods, manage their shopping cart and make a payment with a credit card. In this chapter, you will learn how to implement user authentication with login and password in a Laminas website. We will show how to manage users (add, edit, view and change/reset password) in your web application and store users' passwords in the database securely. You will also learn how to implement an access filter and allow certain pages to be accessed by authenticated users only. Since you already know a lot about Laminas from reading previous chapters, in this chapter we will omit discussing some obvious things and concentrate on conceptual moments only. It is recommended that you refer to the User Demo sample bundle with this book, which is a complete website that you can run and see everything in action. All code discussed in this chapter is part of this sample application. Laminas components covered in this chapter: Component Description @ Laminas\\Authentication Provides user authentication feature. @ Laminas\\Crypt Provides functionality for password encryption. @ Laminas\\Math Provides functionality for generating secure random tokens.","title":"User Management, Authentication and Access Filtering"},{"location":"users/#get-user-demo-sample-from-github","text":"For demonstration, in this chapter, we will create a real-life User Demo website that shows how to: Create a new module named User . This module will contain the functionality for user authentication and user management. Create User entity. Implement storing users' passwords in a database securely. Implement user authentication (with login and password). Implement an access filter to provide access to certain pages to authenticated users only. Implement user management UI that allows adding, editing, and viewing a user, and changing user's password. Implement main menu items differently based on whether the current user is logged in or not. To download the User Demo application, visit this page and click the Clone or Download button to download the code as a ZIP archive. When download is complete, unpack the archive to some directory. Then navigate to the userdemo directory containing the source code of the User Demo web application: /using-laminas-book-samples /userdemo ... The User Demo is a website which can be installed on your machine. Detailed instructions on how to install the User Demo sample can be found in README.md file located in the sample directory.","title":"Get User Demo Sample from GitHub"},{"location":"users/#creating-the-user-module","text":"In the User Demo sample, we create a new module called User and add all functionality related to user management and authentication to that module. If you are new to the concept of modules, refer to chapter Creating a New Module . The User module will have very few dependencies on other modules of the website. The idea behind the User module is to give you a reusable unit that you can use in your own web application, without any changes or with some modifications. Note Ideally, you will be able to use the User module in your own website without any changes. But, in real-life websites, you'll probably have to add some fields to the user table, modify the user creation workflow, or modify the access filtering algorithm. It this case, you'll have to customize the code of the User module to feet your needs. The User module will have the following structure (see figure 16.1 below): Let's briefly describe what classes we will have inside module's directory. We will have two controllers: The UserController will contain functionality for managing users (adding, editing, changing password, etc.) The AuthController will implement user authentication functionality (login/logout). There will be one Doctrine entity: The User entity will be used to store information about the user in database (email, full name, password, etc). We will have four forms used to collect data: The LoginForm will be used to collect data for authentication (login and password). The PasswordChangeForm will be used to collect data for changing or resetting user's password. The PasswordResetForm will be used to collect the E-mail of the person who forgot his/her password and wishes to reset the password. The UserForm will be used to collect data about the user (email, full name, password, etc). We will have several services: The AuthAdapter service will implement the authentication algorithm. It will check if the user login (E-mail address) and password are correct. For performing that, it will retrieve the user information from a database. The AuthManager service will perform actual authentication (login/logout). It will also implement the access filter allowing or denying unauthenticated users access to certain web pages. The UserManager will contain business logic of managing users (adding, editing, changing password). Most controllers and services will be instantiated with factories. You can find the factory classes under the Factory subdirectories. Inside the view directory, we will have several view templates which will render HTML markup of the web pages present in the user interface exposed by our module. As usual, inside the config directory, we will have the module.config.php file that will contain routes and registration for our controllers and services. It will also contain the access_filter key defining which pages will be accessible to an unauthenticated user (this key will be read by AuthManager service). As you can see, the User module is a typical Laminas module with the structure conforming to the MVC pattern.","title":"Creating the User Module"},{"location":"users/#setting-up-the-database","text":"We will need to set up a sample \"userdemo\" database. The database will have a single table named user for storing data associated with users of our website (see figure 16.2 below). The user table contains the following fields: the id is an auto-incremented integer field (primary key). the email is a string field containing user's E-mail address. Each user will have a unique E-mail address, so this field is a unique key, too. the full_name string field will contain the full name of a user (like \"John Doe\"). the status integer field will contain user's status (either \"active\" or \"retired\"). Retired users are not allowed to log in. the date_created contains date and time when the user was created. the pwd_reset_token and pwd_reset_token_creation_date fields are used for password resetting (when the user forgets his/her password and needs to reset it). Note In your own website, you will likely want to add more fields to the user table. In this sample, we only define some minimum set of fields. You can create the user table with the following SQL statement: CREATE TABLE `user` ( `id` int(11) NOT NULL AUTO_INCREMENT, `email` varchar(128) NOT NULL, `full_name` varchar(512) NOT NULL, `password` varchar(256) NOT NULL, `status` int(11) NOT NULL, `date_created` datetime NOT NULL, `pwd_reset_token` varchar(32) DEFAULT NULL, `pwd_reset_token_creation_date` datetime DEFAULT NULL, PRIMARY KEY (`id`), UNIQUE KEY `email_idx` (`email`) ); You can find a migration, which creates the user table, in the User Demo sample application. Note If you are new to migrations, refer to chapter Database Migrations .","title":"Setting Up the Database"},{"location":"users/#implementing-user-entity","text":"The User Demo sample uses Doctrine ORM for managing the database. We have already learned how to use Doctrine in Database Management with Doctrine ORM . For storing information about users in the database, we will create the User entity. The User entity is mapped onto the user database table. It is a typical Doctrine entity class. Create the User.php file inside the Entity directory under the module's source directory. Put the following code into that file: <?php namespace User\\Entity; use Doctrine\\ORM\\Mapping as ORM; /** * This class represents a registered user. * @ORM\\Entity() * @ORM\\Table(name=\"user\") */ class User { // User status constants. const STATUS_ACTIVE = 1; // Active user. const STATUS_RETIRED = 2; // Retired user. /** * @ORM\\Id * @ORM\\Column(name=\"id\") * @ORM\\GeneratedValue */ protected $id; /** * @ORM\\Column(name=\"email\") */ protected $email; /** * @ORM\\Column(name=\"full_name\") */ protected $fullName; /** * @ORM\\Column(name=\"password\") */ protected $password; /** * @ORM\\Column(name=\"status\") */ protected $status; /** * @ORM\\Column(name=\"date_created\") */ protected $dateCreated; /** * @ORM\\Column(name=\"pwd_reset_token\") */ protected $passwordResetToken; /** * @ORM\\Column(name=\"pwd_reset_token_creation_date\") */ protected $passwordResetTokenCreationDate; /** * Returns user ID. * @return integer */ public function getId() { return $this->id; } /** * Sets user ID. * @param int $id */ public function setId($id) { $this->id = $id; } /** * Returns email. * @return string */ public function getEmail() { return $this->email; } /** * Sets email. * @param string $email */ public function setEmail($email) { $this->email = $email; } /** * Returns full name. * @return string */ public function getFullName() { return $this->fullName; } /** * Sets full name. * @param string $fullName */ public function setFullName($fullName) { $this->fullName = $fullName; } /** * Returns status. * @return int */ public function getStatus() { return $this->status; } /** * Returns possible statuses as array. * @return array */ public static function getStatusList() { return [ self::STATUS_ACTIVE => 'Active', self::STATUS_RETIRED => 'Retired' ]; } /** * Returns user status as string. * @return string */ public function getStatusAsString() { $list = self::getStatusList(); if (isset($list[$this->status])) return $list[$this->status]; return 'Unknown'; } /** * Sets status. * @param int $status */ public function setStatus($status) { $this->status = $status; } /** * Returns password. * @return string */ public function getPassword() { return $this->password; } /** * Sets password. * @param string $password */ public function setPassword($password) { $this->password = $password; } /** * Returns the date of user creation. * @return string */ public function getDateCreated() { return $this->dateCreated; } /** * Sets the date when this user was created. * @param string $dateCreated */ public function setDateCreated($dateCreated) { $this->dateCreated = $dateCreated; } /** * Returns password reset token. * @return string */ public function getResetPasswordToken() { return $this->passwordResetToken; } /** * Sets password reset token. * @param string $token */ public function setPasswordResetToken($token) { $this->passwordResetToken = $token; } /** * Returns password reset token's creation date. * @return string */ public function getPasswordResetTokenCreationDate() { return $this->passwordResetTokenCreationDate; } /** * Sets password reset token's creation date. * @param string $date */ public function setPasswordResetTokenCreationDate($date) { $this->passwordResetTokenCreationDate = $date; } } As you can see from the code above, the User entity is a typical Doctrine entity having annotated properties and getter and setter methods for retrieving/setting those properties.","title":"Implementing User Entity"},{"location":"users/#adding-usercontroller","text":"The UserController class will contain several action methods providing an administrative user interface for managing the registered users. It will have the following actions: The indexAction() action will display a web page containing the list of users (see figure 16.3). Type \"http://localhost/users\" in your web browser's navigation bar to access this page. The addAction() will display a page allowing the creation of a new user (see figure 16.4). Type \"http://localhost/users/add\" in your web browser's navigation bar to access this page. The editAction() action will display a page for updating an existing user (see figure 16.5). Type \"http://localhost/users/edit/<id>\" in your web browser's navigation bar to access this page. The viewAction() will allow viewing an existing user (see figure 16.6). Type \"http://localhost/users/view/<id>\" in your web browser's navigation bar to access this page. The changePasswordAction() action will give the admin the ability to change the password of an existing user (see figure 16.7). Type \"http://localhost/users/changePassword/<id>\" in your web browser's navigation bar to access this page. The resetPasswordAction() action will allow a user to reset his own password (see figure 16.8). Type \"http://localhost/reset-password\" in your web browser's navigation bar to access this page. The UserController controller class is designed to be as \"thin\" as possible. It contains only the code responsible for checking input data, instantiating the needed models, passing input data to the models and returning the output data for rendering in a view template. Because it is a typical controller class and because you can see its complete code in the User Demo sample, we will not describe it here in more detail.","title":"Adding UserController"},{"location":"users/#adding-usermanager-service","text":"The UserController works with the UserManager service, which contains all the business logic related to user management. The service allows an admin to create and update users, change a user's password and reset a user's password. We will describe some parts of it in more detail, omitting other obvious parts (you still can see the complete code in User Demo sample).","title":"Adding UserManager Service"},{"location":"users/#creating-a-new-user-storing-password-encrypted","text":"The addUser() method of the UserManager allows us to add a new user. It looks as follows: /** * This method adds a new user. */ public function addUser($data) { // Do not allow several users with the same email address. if($this->checkUserExists($data['email'])) { throw new \\Exception(\"User with email address \" . $data['$email'] . \" already exists\"); } // Create new User entity. $user = new User(); $user->setEmail($data['email']); $user->setFullName($data['full_name']); // Encrypt password and store the password in encrypted state. $bcrypt = new Bcrypt(); $passwordHash = $bcrypt->create($data['password']); $user->setPassword($passwordHash); $user->setStatus($data['status']); $currentDate = date('Y-m-d H:i:s'); $user->setDateCreated($currentDate); // Add the entity to the entity manager. $this->entityManager->persist($user); // Apply changes to database. $this->entityManager->flush(); return $user; } You can see that in this method we first check if another user with the same E-mail address already exists (line 7), and if so we forbid creating the user by throwing an exception. If the user with such E-mail address doesn't exist, we create a new User entity (line 13) and set its properties accordingly. What is interesting here is how we save the user's password to the database. For security reasons, we do not save the password as is, but calculate a hash of it with the @ Bcrypt class provided by @ Laminas\\Crypt component of Laminas Framework (lines 18-19) . You can install @ Laminas\\Crypt with the following command: php composer.phar require laminas/laminas-crypt Note The @ Laminas\\Crypt component also requires that you have mcrypt PHP extension installed. Important The Bcrypt algorithm is a hashing algorithm that is widely used and recommended by the security community for storing user's password. Encrypting password with @ Bcrypt is considered secure nowadays. Some developers still encrypt passwords with MD5 or SHA1 with salt, but this is not considered secure anymore (MD5 and SHA1 hashes can be hacked).","title":"Creating a New User &amp; Storing Password Encrypted"},{"location":"users/#validating-encrypted-password","text":"When a user logs in, you'll need to check if the password hash stored in the database is the same as the hash calculated by the password entered by the visitor. You do that with the help of the verify() method provided by the @ Bcrypt class, as follows: /** * Checks that the given password is correct. */ public function validatePassword($user, $password) { $bcrypt = new Bcrypt(); $passwordHash = $user->getPassword(); if ($bcrypt->verify($password, $passwordHash)) { return true; } return false; }","title":"Validating Encrypted Password"},{"location":"users/#creating-admin-user","text":"The next important thing to note in UserManager is how we create the Admin user. The Admin user is an initial user that is created automatically when there are not existing users in the database and allows you to login for the first time. /** * This method checks if at least one user presents, and if not, creates * 'Admin' user with email 'admin@example.com' and password 'Secur1ty'. */ public function createAdminUserIfNotExists() { $user = $this->entityManager->getRepository(User::class)->findOneBy([]); if ($user==null) { $user = new User(); $user->setEmail('admin@example.com'); $user->setFullName('Admin'); $bcrypt = new Bcrypt(); $passwordHash = $bcrypt->create('Secur1ty'); $user->setPassword($passwordHash); $user->setStatus(User::STATUS_ACTIVE); $user->setDateCreated(date('Y-m-d H:i:s')); $this->entityManager->persist($user); $this->entityManager->flush(); } } We set the Admin user's email to admin@example.com and password to Secur1ty , so you can login for the first time with these credentials.","title":"Creating Admin User"},{"location":"users/#resetting-user-password","text":"Sometimes users forget their password. If that happens, you'll need to let the user reset the password - to securely change the password. Password resetting works as follows: A random password reset token is generated and its hash is saved to database. The password reset token is sent to user's email address as part of an E-mail message. The user checks his mailbox and clicks the password reset link in the E-mail message. The website validates the password reset token and checks it hasn't expired. The user is directed to the form allowing him to enter new password. Important You typically do not store raw password reset tokens in database. Instead, you store a hash of the token. This is done for security reasons. Even if some malicious hacker steals the DB, they won't be able to reset passwords of the users. The password reset token generation algorithm is implemented inside the generatePasswordResetToken() method of UserManager . To generate a random string, we use the @ Rand class provided by @ Laminas\\Math component. /** * Generates a password reset token for the user. This token is then stored in database and * sent to the user's E-mail address. When the user clicks the link in E-mail message, he is * directed to the Set Password page. */ public function generatePasswordResetToken($user) { if ($user->getStatus() != User::STATUS_ACTIVE) { throw new \\Exception('Cannot generate password reset token for inactive user ' . $user->getEmail()); } // Generate a token. $token = Rand::getString(32, '0123456789abcdefghijklmnopqrstuvwxyz', true); // Encrypt the token before storing it in DB. $bcrypt = new Bcrypt(); $tokenHash = $bcrypt->create($token); // Save token to DB $user->setPasswordResetToken($tokenHash); // Save token creation date to DB. $currentDate = date('Y-m-d H:i:s'); $user->setPasswordResetTokenCreationDate($currentDate); // Apply changes to DB. $this->entityManager->flush(); // Send an email to user. $subject = 'Password Reset'; $httpHost = isset($_SERVER['HTTP_HOST'])?$_SERVER['HTTP_HOST']:'localhost'; $passwordResetUrl = 'http://' . $httpHost . '/set-password?token=' . $token . \"&email=\" . $user->getEmail(); // Produce HTML of password reset email $bodyHtml = $this->viewRenderer->render( 'user/email/reset-password-email', [ 'passwordResetUrl' => $passwordResetUrl, ]); $html = new MimePart($bodyHtml); $html->type = \"text/html\"; $body = new MimeMessage(); $body->addPart($html); $mail = new Mail\\Message(); $mail->setEncoding('UTF-8'); $mail->setBody($body); $mail->setFrom('no-reply@example.com', 'User Demo'); $mail->addTo($user->getEmail(), $user->getFullName()); $mail->setSubject($subject); // Setup SMTP transport $transport = new SmtpTransport(); $options = new SmtpOptions($this->config['smtp']); $transport->setOptions($options); $transport->send($mail); } If your web server is as at the same time configured as a mail server then you can send the emails from it. In our example we are sending now the emails over an external SMTP server like e.g. SendGrid or Amazon SES . Password reset token validation is implemented inside the validatePasswordResetToken() method. We check that the token's hash is the same as we saved in database and that the token has not expired (it expires in 1 day since creation). /** * Checks whether the given password reset token is a valid one. */ public function validatePasswordResetToken($email, $passwordResetToken) { // Find user by email. $user = $this->entityManager->getRepository(User::class) ->findOneByEmail($email); if($user==null || $user->getStatus() != User::STATUS_ACTIVE) { return false; } // Check that token hash matches the token hash in our DB. $bcrypt = new Bcrypt(); $tokenHash = $user->getPasswordResetToken(); if (!$bcrypt->verify($passwordResetToken, $tokenHash)) { return false; // mismatch } // Check that token was created not too long ago. $tokenCreationDate = $user->getPasswordResetTokenCreationDate(); $tokenCreationDate = strtotime($tokenCreationDate); $currentDate = strtotime('now'); if ($currentDate - $tokenCreationDate > 24*60*60) { return false; // expired } return true; } And finally, the setPasswordByToken() allows to set new password for the user. /** * This method sets new password by password reset token. */ public function setNewPasswordByToken($email, $passwordResetToken, $newPassword) { if (!$this->validatePasswordResetToken($email, $passwordResetToken)) { return false; } // Find user with the given email. $user = $this->entityManager->getRepository(User::class) ->findOneByEmail($email); if ($user==null || $user->getStatus() != User::STATUS_ACTIVE) { return false; } // Set new password for user $bcrypt = new Bcrypt(); $passwordHash = $bcrypt->create($newPassword); $user->setPassword($passwordHash); // Remove password reset token $user->setPasswordResetToken(null); $user->setPasswordResetTokenCreationDate(null); $this->entityManager->flush(); return true; }","title":"Resetting User Password"},{"location":"users/#implementing-user-authentication","text":"Authentication is the process performed when a user provides his login and password and you decide whether these credentials are correct. Authentication typically means you check your database for the given login, and if such login exists, you check if the hash calculated by the given password matches the hash of the password stored in the database. Important You typically do not store raw passwords in database. Instead, you store a hash of the password. This is done for security reasons. Once the authentication algorithm determines that the login and password are correct, it returns user identity - a unique ID of the user. The identity is typically stored to session, so the visitor doesn't need to pass authentication for every HTTP request. In Laminas, there is a special component allowing you to implement user authentication - @ Laminas\\Authentication . You can install this component with Composer by typing the following command: php composer.phar require laminas/laminas-authentication Important For authentication to work, you also need to have @ Laminas\\Session component installed and session manager configured. For information on how to do that, refer to Working with Sessions chapter.","title":"Implementing User Authentication"},{"location":"users/#authenticationservice","text":"The @ Laminas\\Authentication component provides the special service class called AuthenticationService living in @ Laminas\\Authentication namespace. Most useful methods of this service are shown in table 16.1 below. Method Description authenticate() Performs user authentication using the adapter. getAdapter() Gets authentication adapter. setAdapter() Sets authentication adapter implementing the actual authentication algorithm. getStorage() Returns storage handler. setStorage() Sets storage handler. hasIdentity() Returns true if user identity is already stored in session. getIdentity() Retrieves user identity from session. clearIdentity() Removes user identity from session. Table 16.1. Methods of AuthenticationService class As you can see from the table, you can use the authenticate() method to perform user authentication. Besides that you can use hasIdentity() , getIdentity() and clearIdentity() methods for testing, retrieving and clearing user identity, respectively. However, the @ AuthenticationService service is very generic - it knows nothing about how to actually match login and password against the database. It also knows nothing about how to save the user identity to session. This design allows you to implement any suitable authentication algorithm and any suitable storage. The @ Laminas\\Authentication component provides several authentication adapters implementing some standard authentication algorithms (see figure 16.9), and several storage handlers allowing you to save and retrieve the user identity (see figure 16.10). For our purposes, we can use @ Session [Laminas\\Authentication\\Storage\\Session] storage handler without needing to change any code. However, standard authentication adapters are not suitable for us, because we use Doctrine ORM. Important The following chapters will be rewritten. Since the first version of this book a proper DoctrineModule was written for Laminas\\Authentication. Because of this we do not need to write an adapter. The documentation for the DoctrineModule can be found at: DoctrineModule","title":"AuthenticationService"},{"location":"users/#writing-authentication-adapter","text":"An authentication adapter must implement the @ AdapterInterface [Laminas\\Authentication\\Adapter\\AdapterInterface] interface, which has the single method authenticate() . This method should check the user email and password against the database. We will do this as follows: Find the user with the given email (we use the E-mail address as the user's login). If user with such email doesn't exist - return failure status. Check the status of the user. If the user is \"retired\" - forbid the user to login. Calculate password hash and compare it against the hash stored in database for the user found. If password hash doesn't match, return failure status. If password is correct, return success status. The authenticate() method returns an instance of the @ Laminas\\Authentication\\Result class. The @ Result [Laminas\\Authentication\\Result] class contains the authentication status, the error message and the user identity. The adapter can also have additional methods. For example, we will add the setEmail() and setPassword() methods that we will use to pass user email and password to the adapter. To create the authentication adapter, add the file AuthAdapter.php to the Service directory of the module's source directory. In the User Demo sample, we create a separate module called User and add functionality related to authentication and user management to that module. Put the following code into that file: <?php namespace User\\Service; use Laminas\\Authentication\\Adapter\\AdapterInterface; use Laminas\\Authentication\\Result; use Laminas\\Crypt\\Password\\Bcrypt; use User\\Entity\\User; /** * Adapter used for authenticating user. It takes login and password on input * and checks the database if there is a user with such login (email) and password. * If such user exists, the service returns his identity (email). The identity * is saved to session and can be retrieved later with Identity view helper provided * by Laminas. */ class AuthAdapter implements AdapterInterface { /** * User email. * @var string */ private $email; /** * Password * @var string */ private $password; /** * Entity manager. * @var Doctrine\\ORM\\EntityManager */ private $entityManager; /** * Constructor. */ public function __construct($entityManager) { $this->entityManager = $entityManager; } /** * Sets user email. */ public function setEmail($email) { $this->email = $email; } /** * Sets password. */ public function setPassword($password) { $this->password = (string)$password; } /** * Performs an authentication attempt. */ public function authenticate() { // Check the database if there is a user with such email. $user = $this->entityManager->getRepository(User::class) ->findOneByEmail($this->email); // If there is no such user, return 'Identity Not Found' status. if ($user==null) { return new Result( Result::FAILURE_IDENTITY_NOT_FOUND, null, ['Invalid credentials.']); } // If the user with such email exists, we need to check if it is active or retired. // Do not allow retired users to log in. if ($user->getStatus()==User::STATUS_RETIRED) { return new Result( Result::FAILURE, null, ['User is retired.']); } // Now we need to calculate hash based on user-entered password and compare // it with the password hash stored in database. $bcrypt = new Bcrypt(); $passwordHash = $user->getPassword(); if ($bcrypt->verify($this->password, $passwordHash)) { // Great! The password hash matches. Return user identity (email) to be // saved in session for later use. return new Result( Result::SUCCESS, $this->email, ['Authenticated successfully.']); } // If password check didn't pass return 'Invalid Credential' failure status. return new Result( Result::FAILURE_CREDENTIAL_INVALID, null, ['Invalid credentials.']); } }","title":"Writing Authentication Adapter"},{"location":"users/#creating-the-factory-for-authenticationservice","text":"Once we've implemented the adapter, we can actually create the @ AuthenticationService . Laminas's @ AuthenticationService should be registered in the service manager before you can use it. First of all, we will create a factory for it. Add the AuthenticationServiceFactory.php file under the Service/Factory directory and put the following code there: <?php namespace User\\Service\\Factory; use Interop\\Container\\ContainerInterface; use Laminas\\Authentication\\AuthenticationService; use Laminas\\ServiceManager\\Factory\\FactoryInterface; use Laminas\\Session\\SessionManager; use Laminas\\Authentication\\Storage\\Session as SessionStorage; use User\\Service\\AuthAdapter; /** * The factory responsible for creating of authentication service. */ class AuthenticationServiceFactory implements FactoryInterface { /** * This method creates the Laminas\\Authentication\\AuthenticationService service * and returns its instance. */ public function __invoke(ContainerInterface $container, $requestedName, array $options = null) { $sessionManager = $container->get(SessionManager::class); $authStorage = new SessionStorage('Laminas_Auth', 'session', $sessionManager); $authAdapter = $container->get(AuthAdapter::class); // Create the service and inject dependencies into its constructor. return new AuthenticationService($authStorage, $authAdapter); } } In the factory we do the following: First, we create an instance of the session manager (you should have set up the session manager already) and create an instance of @ Session [Laminas\\Authentication\\Storage\\Session] storage handler. Then we create an instance of AuthAdapter . Finally, we instantiate the @ AuthenticationService and inject dependencies (storage handler and adapter) into it. Register the @ AuthenticationService in your module.config.php config file as follows: <?php return [ 'service_manager' => [ 'factories' => [ \\Laminas\\Authentication\\AuthenticationService::class => Service\\Factory\\AuthenticationServiceFactory::class, // ... ], ], ];","title":"Creating the Factory for AuthenticationService"},{"location":"users/#adding-authcontroller","text":"The AuthController class will have two actions: The loginAction() will allow logging in to the website (see figures 16.11 and 16.12). You can access this page by typing \"http://localhost/login\" URL into your web browser's navigation bar. The logoutAction() will allow logging out from the website. You can access this page by typing \"http://localhost/logout\" URL into your web browser's navigation bar. The code of the AuthController controller class is presented below: <?php namespace User\\Controller; use Laminas\\Mvc\\Controller\\AbstractActionController; use Laminas\\View\\Model\\ViewModel; use Laminas\\Authentication\\Result; use Laminas\\Uri\\Uri; use User\\Form\\LoginForm; use User\\Entity\\User; /** * This controller is responsible for letting the user to log in and log out. */ class AuthController extends AbstractActionController { /** * Entity manager. * @var Doctrine\\ORM\\EntityManager */ private $entityManager; /** * Auth manager. * @var User\\Service\\AuthManager */ private $authManager; /** * Auth service. * @var \\Laminas\\Authentication\\AuthenticationService */ private $authService; /** * User manager. * @var User\\Service\\UserManager */ private $userManager; /** * Constructor. */ public function __construct($entityManager, $authManager, $authService, $userManager) { $this->entityManager = $entityManager; $this->authManager = $authManager; $this->authService = $authService; $this->userManager = $userManager; } /** * Authenticates user given email address and password credentials. */ public function loginAction() { // Retrieve the redirect URL (if passed). We will redirect the user to this // URL after successfull login. $redirectUrl = (string)$this->params()->fromQuery('redirectUrl', ''); if (strlen($redirectUrl)>2048) { throw new \\Exception(\"Too long redirectUrl argument passed\"); } // Check if we do not have users in database at all. If so, create // the 'Admin' user. $this->userManager->createAdminUserIfNotExists(); // Create login form $form = new LoginForm(); $form->get('redirect_url')->setValue($redirectUrl); // Store login status. $isLoginError = false; // Check if user has submitted the form if ($this->getRequest()->isPost()) { // Fill in the form with POST data $data = $this->params()->fromPost(); $form->setData($data); // Validate form if($form->isValid()) { // Get filtered and validated data $data = $form->getData(); // Perform login attempt. $result = $this->authManager->login($data['email'], $data['password'], $data['remember_me']); // Check result. if ($result->getCode()==Result::SUCCESS) { // Get redirect URL. $redirectUrl = $this->params()->fromPost('redirect_url', ''); if (!empty($redirectUrl)) { // The below check is to prevent possible redirect attack // (if someone tries to redirect user to another domain). $uri = new Uri($redirectUrl); if (!$uri->isValid() || $uri->getHost()!=null) throw new \\Exception('Incorrect redirect URL: ' . $redirectUrl); } // If redirect URL is provided, redirect the user to that URL; // otherwise redirect to Home page. if(empty($redirectUrl)) { return $this->redirect()->toRoute('home'); } else { $this->redirect()->toUrl($redirectUrl); } } else { $isLoginError = true; } } else { $isLoginError = true; } } return new ViewModel([ 'form' => $form, 'isLoginError' => $isLoginError, 'redirectUrl' => $redirectUrl ]); } /** * The \"logout\" action performs logout operation. */ public function logoutAction() { $this->authManager->logout(); return $this->redirect()->toRoute('login'); } } The loginAction() method accepts the redirectUrl GET parameter. The \"redirect URL\" is a convenience feature working with the access filter that we will describe later in this chapter. When the site visitor tries to access a web page, the access filter forbids access, and he/she is redirected to the \"Login\" page, passing the URL of the original page as the \"redirect URL\". When the user logs in, he/she is redirected back to the original page automatically, improving user experience.","title":"Adding AuthController"},{"location":"users/#adding-view-template-for-login-page","text":"The view template ( .phtml file) for our Login page looks as follows: <?php $this->headTitle('Sign in'); $this->mainMenu()->setActiveItemId('login'); $form->get('email')->setAttributes([ 'class'=>'form-control', 'placeholder'=>'Email address', 'required' => true, 'autofocus' => true ]) ->setLabelAttributes([ 'class' => 'sr-only' ]); $form->get('password')->setAttributes([ 'class'=>'form-control', 'placeholder'=>'Password', 'required' => true, ]) ->setLabelAttributes([ 'class' => 'sr-only' ]); ?> <div class=\"row\"> <div class=\"col-md-offset-4 col-md-3\"> <form class=\"form-signin\" method=\"post\"> <h2 class=\"form-signin-heading\">Please sign in</h2> <?php if ($isLoginError): ?> <div class=\"alert alert-warning\" role=\"alert\"> Incorrect login and/or password. <a href=\"<?= $this->url('reset-password') ?>\">Forgot password?</a> </div> <?php endif; ?> <?= $this->formLabel($form->get('email')); ?> <?= $this->formElement($form->get('email')); ?> <?= $this->formLabel($form->get('password')); ?> <?= $this->formElement($form->get('password')); ?> <div class=\"checkbox\"> <label> <?= $this->formElement($form->get('remember_me')); ?> Remember me </label> </div> <?= $this->formElement($form->get('redirect_url')); ?> <?= $this->formElement($form->get('csrf')) ?> <button class=\"btn btn-lg btn-primary btn-block\" type=\"submit\">Sign in</button> </form> </div> </div> Note The view template uses the Sign In page template provided by Bootstrap CSS Framework. You can find the original template here .","title":"Adding View Template for Login Page"},{"location":"users/#adding-authmanager-service","text":"The AuthController works with the AuthManager service. The main business logic behind the authentication is implemented in the service. Let's describe the AuthManager in detail. The AuthManager service has the following methods responsible for authentication: the login() method the logout() method. The login() method (see below) uses the Laminas's @ AuthenticationService and the AuthAdapter we wrote earlier for performing user authentication. The method additionally accepts the $rememberMe argument which extends the session cookie lifetime to 30 days. /** * Performs a login attempt. If $rememberMe argument is true, it forces the session * to last for one month (otherwise the session expires on one hour). */ public function login($email, $password, $rememberMe) { // Check if user has already logged in. If so, do not allow to log in // twice. if ($this->authService->getIdentity()!=null) { throw new \\Exception('Already logged in'); } // Authenticate with login/password. $authAdapter = $this->authService->getAdapter(); $authAdapter->setEmail($email); $authAdapter->setPassword($password); $result = $this->authService->authenticate(); // If user wants to \"remember him\", we will make session to expire in // one month. By default session expires in 1 hour (as specified in our // config/global.php file). if ($result->getCode()==Result::SUCCESS && $rememberMe) { // Session cookie will expire in 1 month (30 days). $this->sessionManager->rememberMe(60*60*24*30); } return $result; } The logout() method removes the user identity from session, so the visitor becomes unauthenticated. /** * Performs user logout. */ public function logout() { // Allow to log out only when user is logged in. if ($this->authService->getIdentity()==null) { throw new \\Exception('The user is not logged in'); } // Remove identity from session. $this->authService->clearIdentity(); }","title":"Adding AuthManager Service"},{"location":"users/#access-filtering","text":"The last thing we implement in the User module is the access filter . The access filter will be used for restricting access to certain web pages to authenticated users only. The access filter will work as follows: When someone tries to access a web page, check the access_filter key of the app configuration and check whether this page is allowed to access by anyone or by authenticated users only. If the page is allowed to be accessed by anyone, allow the visitor to see the page. If the page is allowed to be accessed by authenticated users only, check if the user is authenticated or not. If the user is not authenticated, redirect him to the Login page and ask to log in. Once the user logs in, redirect him back to the original page automatically. The access filter is designed to function in one of two modes: restrictive (default) and permissive. In restrictive mode the filter forbids access to any page not listed under the access_filter key. The access_filter configuration key will be located inside the module.config.php file and will be used by the access filter. It will contain the list of controllers and action names, and for each action it will either allow to anyone to see the page or allow to authenticated users only to see the page. An example structure of the key is presented below: // The 'access_filter' key is used by the User module to restrict or permit // access to certain controller actions for unauthenticated visitors. 'access_filter' => [ 'options' => [ // The access filter can work in 'restrictive' (recommended) or 'permissive' // mode. In restrictive mode all controller actions must be explicitly listed // under the 'access_filter' config key, and access is denied to any not listed // action for users not logged in. In permissive mode, if an action is not listed // under the 'access_filter' key, access to it is permitted to anyone (even for // users not logged in. Restrictive mode is more secure and recommended. 'mode' => 'restrictive' ], 'controllers' => [ Controller\\IndexController::class => [ // Allow anyone to visit \"index\" and \"about\" actions ['actions' => ['index', 'about'], 'allow' => '*'], // Allow authenticated users to visit \"settings\" action ['actions' => ['settings'], 'allow' => '@'] ], ] ], Under the access_filter key, we have two subkeys: The options key can be used to define the mode in which the filter functions (\"restrictive\" or \"permissive\"). The controllers key lists the controllers and their actions, specifying the access type for each action. The asterisk character (*) means that everyone will be able to access the web page. The \"at\" character (@) means that only authenticated users will be able to access the page. Note The access filter implementation is very simple. It can't, for example, allow access based on username or by user role. However, you can easily modify and extend it as you wish. If you plan to introduce role-based access control (RBAC), refer to the Role-Based Access Control chapter.","title":"Access Filtering"},{"location":"users/#adding-dispatch-event-listener","text":"To implement access filtering, we will use an event listener. You have already become familiar with event listening in the Creating a New Module chapter. Particularly, we will listen to the Dispatch event. The Dispatch event is triggered after the Route event, when the controller and action are already determined. To implement the listener, we modify the Module.php file of the User module as follows: <?php namespace User; use Laminas\\Mvc\\MvcEvent; use Laminas\\Mvc\\Controller\\AbstractActionController; use User\\Controller\\AuthController; use User\\Service\\AuthManager; class Module { /** * This method returns the path to module.config.php file. */ public function getConfig() { return include __DIR__ . '/../config/module.config.php'; } /** * This method is called once the MVC bootstrapping is complete and allows * to register event listeners. */ public function onBootstrap(MvcEvent $event) { // Get event manager. $eventManager = $event->getApplication()->getEventManager(); $sharedEventManager = $eventManager->getSharedManager(); // Register the event listener method. $sharedEventManager->attach(AbstractActionController::class, MvcEvent::EVENT_DISPATCH, [$this, 'onDispatch'], 100); } /** * Event listener method for the 'Dispatch' event. We listen to the Dispatch * event to call the access filter. The access filter allows to determine if * the current visitor is allowed to see the page or not. If he/she * is not authenticated and is not allowed to see the page, we redirect the user * to the login page. */ public function onDispatch(MvcEvent $event) { // Get controller and action to which the HTTP request was dispatched. $controller = $event->getTarget(); $controllerName = $event->getRouteMatch()->getParam('controller', null); $actionName = $event->getRouteMatch()->getParam('action', null); // Convert dash-style action name to camel-case. $actionName = str_replace('-', '', lcfirst(ucwords($actionName, '-'))); // Get the instance of AuthManager service. $authManager = $event->getApplication()->getServiceManager()->get(AuthManager::class); // Execute the access filter on every controller except AuthController // (to avoid infinite redirect). if ($controllerName!=AuthController::class && !$authManager->filterAccess($controllerName, $actionName)) { // Remember the URL of the page the user tried to access. We will // redirect the user to that URL after successful login. $uri = $event->getApplication()->getRequest()->getUri(); // Make the URL relative (remove scheme, user info, host name and port) // to avoid redirecting to other domain by a malicious user. $uri->setScheme(null) ->setHost(null) ->setPort(null) ->setUserInfo(null); $redirectUrl = $uri->toString(); // Redirect the user to the \"Login\" page. return $controller->redirect()->toRoute('login', [], ['query'=>['redirectUrl'=>$redirectUrl]]); } } }","title":"Adding Dispatch Event Listener"},{"location":"users/#implementing-access-filtering-algorithm","text":"The onDispatch() event listener calls the filterAccess() method of AuthManager service to determine if the page can be seen or not. The code of the filterAccess() method is presented below: /** * This is a simple access control filter. It allows vistors to visit certain pages only, * the rest requiring the user to be authenticated. * * This method uses the 'access_filter' key in the config file and determines * whenther the current visitor is allowed to access the given controller action * or not. It returns true if allowed; otherwise false. */ public function filterAccess($controllerName, $actionName) { // Determine mode - 'restrictive' (default) or 'permissive'. In restrictive // mode all controller actions must be explicitly listed under the 'access_filter' // config key, and access is denied to any not listed action for unauthenticated users. // In permissive mode, if an action is not listed under the 'access_filter' key, // access to it is permitted to anyone (even for not logged in users. // Restrictive mode is more secure and recommended to use. $mode = isset($this->config['options']['mode'])?$this->config['options']['mode']:'restrictive'; if ($mode!='restrictive' && $mode!='permissive') throw new \\Exception('Invalid access filter mode (expected either restrictive or permissive mode'); if (isset($this->config['controllers'][$controllerName])) { $items = $this->config['controllers'][$controllerName]; foreach ($items as $item) { $actionList = $item['actions']; $allow = $item['allow']; if (is_array($actionList) && in_array($actionName, $actionList) || $actionList=='*') { if ($allow=='*') return true; // Anyone is allowed to see the page. else if ($allow=='@' && $this->authService->hasIdentity()) { return true; // Only authenticated user is allowed to see the page. } else { return false; // Access denied. } } } } // In restrictive mode, we forbid access for authenticated users to any // action not listed under 'access_filter' key (for security reasons). if ($mode=='restrictive' && !$this->authService->hasIdentity()) return false; // Permit access to this page. return true; }","title":"Implementing Access Filtering Algorithm"},{"location":"users/#testing-access-filter","text":"To test the access filter, try to visit the \"http://localhost/users\" or \"http://localhost/settings\" page when you are not logged in. The access filter will direct you to Login page. However, you can easily visit the \"http://localhost/about\" page - it is open to anyone.","title":"Testing Access Filter"},{"location":"users/#identity-controller-plugin-and-view-helper","text":"One last thing we will discuss is how to check in your website if the user is logged in or not and retrieve the user identity. You can do that with the help of the @ Identity [Laminas\\Mvc\\Plugin\\Identity] controller plugin and the @ Identity [Laminas\\View\\Helper\\Identity] view helper. To use the @ Identity [Laminas\\Mvc\\Plugin\\Identity] plugin, you need to install laminas/laminas-mvc-plugins package with Composer, as follows: `php composer.phar require laminas/laminas-mvc-plugins` In your controller action method, you can check if user is logged in with the following code: if ($this->identity()!=null) { // User is logged in // Retrieve user identity $userEmail = $this->identity(); } In your view template, you can use @ Identity [Laminas\\View\\Helper\\Identity] view helper for the same purpose: // Echo user identity <?= $this->escapeHtml($this->identity()) ?>","title":"Identity Controller Plugin and View Helper"},{"location":"users/#summary","text":"In this chapter, we learned about user management, user authentication and access filtering. User management means providing the UI for adding, editing, viewing users and changing their password. Authentication is when a user provides his login and password and you decide whether these credentials are correct. Laminas provides the special service called @ AuthenticationService that you can use for this purpose, but first you need to implement an authentication adapter. Access filtering allows access to certain pages to authenticated users only. You can implement access filtering with the help of an event listener.","title":"Summary"},{"location":"validators/","text":"Checking Input Data with Validators In this chapter, we will provide an overview of standard Laminas validators that can be used with your forms, and will also show how to write a custom validator. A validator is a class designed to take some input data, check it for correctness, and return a boolean result telling whether the data is correct (and error messages if the data has some errors). Note In general, you even can use validators outside forms to process an arbitrary data. For example, validators may be used in a controller action to ensure that data passed as GET and/or POST variables is secure and conform to certain format. Laminas components covered in this chapter: Component Description @ Laminas\\Validator Implements various validator classes. @ Laminas\\InputFilter Implements a container for filters/validators. About Validators A validator is designed to take some input data, check it for correctness, and return a boolean result telling whether the data is correct. If the data is incorrect, the validator generates the list of errors describing why the check didn't pass. ValidatorInterface In Laminas, a validator is a usual PHP class which implements the @ ValidatorInterface [Laminas\\Validator\\ValidatorInterface] interface (it belongs to @ Laminas\\Validator namespace). The interface definition is presented below: <?php namespace Laminas\\Validator; interface ValidatorInterface { // Returns true if and only if $value meets the validation requirements. public function isValid($value); // Returns an array of messages that explain why // the most recent isValid() call returned false. public function getMessages(); } As you can see, the @ ValidatorInterface [Laminas\\Validator\\ValidatorInterface] has two methods: the isValid() method (line 7) and getMessages() method (line 11). The first one, isValid() method, is intended to perform the check of the input value (the $value parameter). If the validation of the $value passes, the isValid() method returns boolean true . If the $value fails validation, then this method returns false . Note A concrete validator class implementing the @ ValidatorInterface [Laminas\\Validator\\ValidatorInterface] interface may have additional methods. For example, many validator classes have methods allowing to configure the validator (set validation options). Standard Validators Overview Standard Laminas validators are provided by the @ Laminas\\Validator component 1 . Standard validator classes inheritance is shown in figure 9.1. As you can see from the figure, most of them are derived from @ AbstractValidator base class. Standard validators together with their brief description are listed in table 9.1. As you may notice from the table, they can be roughly divided into several groups: validators for checking value conformance to certain format (IP address, host name, E-mail address, credit card number, etc.); validators for checking if a numerical value lies in a given range (less than, greater than, between, etc.); validators working as \"proxies\" to other validators (@ ValidatorChain [Laminas\\Validator\\ValidatorChain], @ StaticValidator and @ Callback [Laminas\\Validator\\Callback]). Class name Description @ EmailAddress [Laminas\\Validator\\EmailAddress] Returns boolean true if the value is a valid E-mail address; otherwise returns false . @ Hostname [Laminas\\Validator\\Hostname] Checks whether the value is a valid host name. @ Barcode [Laminas\\Validator\\Barcode] Returns boolean true if and only if the value contains a valid barcode. @ CreditCard Returns true if and only if the value follows the common format of credit card number (Luhn algorithm, mod-10 checksum). @ Iban Returns true if the value is a valid International Bank Account Number (IBAN); otherwise returns false . @ Isbn Returns boolean true if and only if value is a valid International Standard Book Number (ISBN). @ Ip Returns true if value is a valid IP address; otherwise returns false . @ Uri [Laminas\\Validator\\Uri] Returns true if and only if the value is an Uniform Resource Identifier (URI). @ Between [Laminas\\Validator\\Between] Returns true if the value lies in certain range; otherwise returns false . @ LessThan Returns boolean true if the value is less than certain number; otherwise returns false . @ GreaterThan Returns true if and only if value is greater than certain number. @ Identical Returns boolean true if the value matches a given token. @ Step Checks whether the value is a scalar and a valid step value. @ Csrf [Laminas\\Validator\\Csrf] This validator checks if the provided token matches the one previously generated and stored in a PHP session. @ Date [Laminas\\Validator\\Date] Returns true if value is a valid date of the certain format. @ DateStep Returns boolean true if a date is within a valid step. @ InArray Returns true if value is contained in the given array; otherwise returns false . @ Digits [Laminas\\Validator\\Digits] Returns boolean true if and only if $value only contains digit characters. @ Hex Returns true if and only if value contains only hexadecimal digit characters. @ IsInstanceOf Returns true if value is instance of certain class; otherwise returns false . @ NotEmpty Returns true if value is not an empty value. @ Regex [Laminas\\Validator\\Regex] Returns true if value matches against given pattern; otherwise returns false . @ StringLength Returns true if the string length lies within given range. @ Explode Splits the given value in parts and returns true if all parts pass the given check. @ StaticValidator This validator allows to execute another validator without explicitly instantiating it. @ Callback [Laminas\\Validator\\Callback] This validator allows to execute a custom validation algorithm through the user-provided callback function. @ ValidatorChain [Laminas\\Validator\\ValidatorChain] Wrapper validator allowing to organize several validators in a chain. Attached validators are run in the order in which they were added to the chain (FIFO). Table 9.1. Standard validators Validator Behaviour in Case of Invalid or Unacceptable Data If you pass a validator some data that doesn't pass the check, the validator internally creates the list of error messages that can be retrieved with the getMessages() method. For example, look below for possible validation errors that the @ EmailAdrress [Laminas\\Validator\\EmailAddress] returns if you pass it the \"abc@ewr\" value (the back-slash ('\\') character indicates line breaks where code doesn't fit book page): array(3) { [\"emailAddressInvalidHostname\"] => string(51) \"'ewr' is not a valid hostname for the email address\" [\"hostnameInvalidHostname\"] => string(66) \"The input does not match the expected structure for a DNS hostname\" [\"hostnameLocalNameNotAllowed\"] => string(84) \"The input appears to be a local network name but local network names are not allowed\" } Validator's getMessages() method will return an array of messages that explain why the validation failed. The array keys are validation failure message identifiers, and the array values are the corresponding human-readable message strings. If isValid() method was never called or if the most recent isValid() call returned true , then the getMessages() method returns an empty array. Also, when you call isValid() several times, the previous validation messages are cleared, so you see only validation errors from the last call. Some validators may work with input data in certain format only (for example, a validator may require that the input data be a string, but not an array). If you pass it data in unacceptable format, the validator may throw an @ Laminas\\Validator\\Exception\\RuntimeException exception or raise a PHP warning. Note It is recommended to check certain validator's documentation to be aware of its actual behaviour in case of inacceptable data. Instantiating a Validator In Laminas Framework, there are several methods of creating a validator: instantiating it manually (with the new operator); creating it with a factory class (by passing an array configuration); this way is used the most frequently when adding validation rules in a form; instantiating it implicitly with the @ StaticValidator wrapper class. Next, we will cover these three methods in more details. Method 1. Manual Instantiation of a Validator A validator in general can be used not only with forms, but also for validation of an arbitrary data. In order to do that, you simply create an instance of the validator class, configure the validator by using the methods it provides, and call the isValid() method on the validator. For example, let's consider the usage of the @ EmailAddress validator which checks an E-mail address for conformance to RFC-2822 standard. An E-mail address typically consists of the local part (user name) followed by the \"at\" character (@), which is in turn followed by the host name. For example, in the \"name@example.com\" E-mail address, \"name\" is the local part, and \"example.com\" is the host name. Note The @ EmailAddress validator is useful for checking an user-entered E-mail addresses on your forms for correctness. The validator will check for the correctness of the local part and the host name, for presence of the \"at\" character (@) and, optionally, will connect to the recipient's host and query the DNS service for existence of the MX (Mail Exchanger) record 2 . The methods provided by the @ EmailAddress validator are listed in table 9.2: Method name Description __construct($options) Constructs the validator. Accepts the list of options allowing to configure it. isValid($value) Returns true if the value is a valid E-mail address according to RFC-2822; otherwise returns false . getMessages() If validation failed, this method will return an array of error messages. useDomainCheck($domain) Tells the validator to check the host name part for correctness. getDomainCheck() Returns true if host name part check is enabled. setHostnameValidator($hostnameValidator) Attaches the validator to use for checking host name part of the E-mail address. getHostnameValidator() Returns the validator used for checking host name part of the E-mail address. setAllow($allow) Sets the allowed types of host names to be used in an E-mail address. getAllow() Returns the allowed types of host names. useMxCheck($mx) Sets whether to perform the check for a valid MX record via DNS service. getMxCheck($mx) Returns true if MX check mode is enabled. useDeepMxCheck($deep) Sets whether to use deep validation for MX records. getDeepMxCheck() Returns true if the deep MX check mode is enabled; otherwise returns false . isMxSupported() Returns true if MX checking via getmxrr() PHP function is supported in the system; otherwise returns false . getMXRecord() After validation, returns the found MX record information. Table 9.2. Public methods of the EmailAddress validator As you can see from the table, the @ EmailAddress validator, additionally to the isValid() and getMessages() methods, provides the constructor method to which you can (optionally) pass the complete list of options for initializing the validator. All standard validators have the constructor method (optionally) accepting an array of options for configuring the validator when instantiating it manually. The @ EmailAddress class also provides a number of methods that can be used for setting specific validator options. The useDomainCheck() method tells whether to check the host name for correctness, or not. By default, this check is enabled. The setAllow() method provides an ability to specify which types of host names are allowed. You can pass an OR combination of the ALLOW_ -prefixed constants 3 to the setAllow() method: ALLOW_DNS Allow a domain name (this is the default), IP_ADDRESS Allow an IP address, ALLOW_LOCAL Allow local network name, ALLOW_ALL Allow all of the above. Note Internally, the @ EmailAddress validator uses the @ Hostname [Laminas\\Validator\\Hostname] validator for checking the host name part of an E-mail address. Optionally, you can attach a custom host name validator by using the setHostnameValidator() method, however it is unlikely you will need to do such. The useMxCheck() method tells whether the validator should connect to the recipient's host and query the DNS server for the MX record(s). If the server has no MX records, than the validation fails. You can additionally use the useDeepMxCheck() method to tell the validator to compare the mail server addresses extracted from the MX records against the black list of reserved domain names, and perform additional checks per each detected address. Note It is not recommended to perform MX check (and deep MX check), because that may take a lot of time and increase the web page load time. By default, these checks are disabled. Below, we provide code examples showing two equivalent methods of manual creating of an instance of the @ EmailAddress validator, setting its options and checking an input value: Example 1. Passing options to the constructor method. <?php // Optionally, define a short alias for the validator class name. use Laminas\\Validator\\EmailAddress; use Laminas\\Validator\\Hostname; // Create an instance of the validator, passing options to the constructor. $validator = new EmailAddress([ 'allow' => Hostname::ALLOW_DNS|Hostname::ALLOW_IP|Hostname::ALLOW_LOCAL, 'mxCheck' => true, 'deepMxCheck' => true ]); // Validate an E-mail address. $isValid = $validator->isValid('name@example.com'); // Returns true. $isValid2 = $validator->isValid('abc'); // Returns false. if(!$isValid2) { // Get error messages in case of validation failure. $errors = $validator->getMessages(); } In the code above, we create the @ EmailAddress validator object with the help of the new operator (line 7). We pass the array of options to the constructor. We use the allow key to allow an E-mail address to be a domain name, an IP address or local network address. Also, we use the mxCheck and deepMxCheck to enable MX record check and deep MX record check, respectively. In line 14, we call the isValid() method and pass it the string value \"name@example.com\" to be checked. The expected output of this call is the boolean true . In line 15, we pass the \"abc\" string value to the validator. The validation procedure is expected to fail ( false is returned). Then, the error messages are retrieved with the getMessages() method (line 19). Example 2. Without passing options to the constructor. <?php // Optionally, define a short alias for the validator class name. use Laminas\\Validator\\EmailAddress; use Laminas\\Validator\\Hostname; // Create an instance of the validator. $validator = new EmailAddress(); // Optionally, configure the validator $validator->setAllow( Hostname::ALLOW_DNS|Hostname::ALLOW_IP|Hostname::ALLOW_LOCAL); $validator->useMxCheck(true); $validator->useDeepMxCheck(true); // Validate an E-mail address. $isValid = $validator->isValid('name@example.com'); // Returns true. $isValid2 = $validator->isValid('abc'); // Returns false. if(!$isValid2) { // Get error messages in case of validation failure. $errors = $validator->getMessages(); } In the code above, we create the @ EmailAddress validator object with the help of the new operator (line 7). In lines 10-13, we configure the validator. We call the setAllow() method to allow an E-mail address to be a domain name, an IP address or local network address. Also, we use the useMxCheck() and useDeepMxCheck() to enable MX record check and deep MX record check, respectively. In line 16, we call the isValid() method and pass it the string value \"name@example.com\" to be checked. The expected output of this call is the boolean true . In line 17, we pass the \"abc\" string value to the validator. The validation procedure is expected to fail. Then, the error messages are retrieved with the getMessages() method (line 21). Method 2. Using StaticValidator Wrapper An alternative way of manual validator instantiation is by using the @ StaticValidator class. The @ StaticValidator class is some kind of a \"proxy\" designed for automatic validator instantiation, configuration and execution. For example, let's consider how to create the same @ EmailAddress validator, configure it and call its isValid() method: <?php // Create and execute the EmailAddress validator through StaticValidator proxy. $validatedValue = \\Laminas\\Validator\\StaticValidator::execute('name@example.com', 'EmailAddress', [ 'allow' => Hostname::ALLOW_DNS| Hostname::ALLOW_IP| Hostname::ALLOW_LOCAL, 'mxCheck' => true, 'deepMxCheck' => true ]); // The expected output is boolean true. The @ StaticValidator class provides the execute() static method which takes three arguments: the input value, the name of the filter to apply, and the array of filter-specific options. In line 3, we call the execute() method to automatically create the @ EmailAddress validator, call its setAllowDns() , useMxCheck() and useDeepMxCheck() methods, and pass the input value to its isValid() method. This is very useful, because can be accomplished in a single call. Note The @ StaticValidator doesn't provide an ability to extract the list of human-readable validation errors. However, since the @ StaticValidator is designed to be used outside forms, and not intended for displaying results to a human, this seems to be not a big disadvantage. Method 3. Using an Array Configuration When using validators with form's validation rules, you typically do not construct a validator object explicitly as we did in the previous section, instead you pass an array configuration to the factory class which automatically constructs the validator for you and (optionally) configures it. We already saw how this works when adding validation rules for the feedback form in Collecting User Input with Forms . For example, let's show how to construct the same @ EmailAddress filter with the help of the factory: <?php // It is assumed that you call the following code inside of the form model's // addInputFilter() method. $inputFilter->add([ // ... 'validators' => [ [ 'name' => 'EmailAddress', 'options' => [ 'allow' => \\Laminas\\Validator\\Hostname::ALLOW_DNS, 'useMxCheck' => false, 'useDeepMxCheck' => false, ], ], ], // ... ]); In the code above, we call the add() method provided by the @ InputFilter [Laminas\\InputFilter\\InputFilter] container class (line 5). The add() method takes an array which has the validators key. You typically register the validators under that key (line 7). Validators registered under that key are inserted into validator chain in the order they appear in the list. A validator configuration typically consists of the name (line 9) and options (line 10). The name is a fully qualified validator class name (e.g. @ \\Laminas\\Validator\\EmailAddress ) or its short alias (@ EmailAddress ). The options is an array consisting of validator-specific options. When the factory class instantiates the validator, it passes the list of options to the validator's constructor, and the constructor initializes the validator as needed. About Validator Plugin Manager When creating a validator with a factory, you can use either the fully qualified validator class name or its short alias. The short aliases for the standard validators are defined by the @ ValidatorPluginManager class. Note The @ ValidatorPluginManager class defines validator aliases. A standard validator's alias is typically the same as class name. For example, the class @ Laminas\\Validator\\EmailAddress has the short alias @ EmailAddress . The validator plugin manager is internally used by the @ InputFilter [Laminas\\InputFilter\\InputFilter] container class for instantiating the standard validators. Validator Usage Examples Next, we will consider the usage of the most important standard validators. These describe the methods (and options) a validator has, and provide a code example showing how to instantiate and apply the validator to input data. Validators for Checking Value Conformance to Certain Format In this section, we will consider usage examples of the validators from the group of validators designed for checking if input value conforms to certain format. Ip Validator The @ Ip validator class is designed to check if the input value is a valid IP address. If the input value is an IPv4 4 address, IPv6 5 address, IPvFuture 6 address, or IPv6 literal 7 address, the validator returns boolean true ; otherwise it returns false . On failure, error messages can be extracted with the validator's getMessages() method. Public methods provided by the @ Ip validator are listed in table 9.3: Method name Description __construct($options) Constructs the validator. Accepts the list of options. isValid($value) Returns true if and only if value is a valid IP address. getMessages() If validation failed, this method will return an array of error messages. setOptions($options) Sets validator options. Table 9.3. Public methods of the Ip validator The setOptions() method provides an ability to set allowed types of IP addresses: allowipv4 to allow IPv4 addresses; allowipv6 to allow IPv6 addresses; allowipvfuture to allow IPvFuture addresses; allowliteral to allow IPv6 literal addresses. By default all the above are allowed, except the IPv6 literal address. Below, a code example demonstrating the usage of the @ Ip validator is provided. <?php use Laminas\\Validator\\Ip; // Create Ip validator. $validator = new Ip(); // Configure the validator. $validator->setOptions([ 'allowipv4' => true, // Allow IPv4 addresses. 'allowipv6' => true, // Allow IPv6 addresses. 'allowipvfuture' => false, // Allow IPvFuture addresses. 'allowliteral' => true, // Allow IP addresses in literal format. ]); // Check if input value is a valid IP address (IPv4). $isValid = $validator->isValid('192.168.56.101'); // Returns true // Check if input value is a valid IP address (IPv6). $isValid2 = $validator->isValid( '2001:0db8:85a3:0000:0000:8a2e:0370:7334'); // Returns true // Pass an invalid string (not containing an IP address). $isValid3 = $validator->isValid('abc'); // Returns false Hostname Validator The @ Hostname [Laminas\\Validator\\Hostname] validator is designed to check if a given value is a host name belonging to set of allowed host name types. The types are: a DNS Hostname (e.g. \"example.com\"); an IP address (e.g. \"192.168.56.101\"); a local host name (e.g. \"localhost\"). The public methods provided by the validator are listed in table 9.4: Method name Description __construct($options) Constructs the validator. Accepts the list of options. isValid($value) Returns true when the value is a valid host name; otherwise returns false . getMessages() If validation failed, this method will return an array of error messages. setIpValidator($ipValidator) Optionally, allows to set own IP address validator. getIpValidator() Retrieves attached IP address validator. setAllow() Defines the type(s) of host names which are allowed. getAllow() Returns allowed host names types. useIdnCheck() Defines if Internationalized Domain Names (IDN) check is enabled. This option defaults to true . getIdnCheck() Returns true if IDN check is enabled. useTldCheck() Defines if Top Level Domain (TLD) check is enabled. This option defaults to true . getTldCheck() Returns true if TLD check is enabled. Table 9.4. Public methods of the Hostname validator You can set which host name types are allowed with the setAllow() method. It accepts a combination of the following constants: ALLOW_DNS Allows Internet domain names (e.g., example.com ); ALLOW_IP Allows IP addresses; ALLOW_LOCAL Allows local network names (e.g., localhost , www.localdomain ); ALLOW_URI Allows URI host names. ALLOW_ALL Allows all types of host names. By default, only Internet domain names are allowed. The host name check consists of several stages, some of which may be omitted based on validator options: If the input value looks like an IP address, it is checked with the internal IP address validator. You can override which IP address validator to use for this by the setIpValidator() method. The host name is separated into domain parts (separated with dot \".\" character). The top-level domain is checked against the white list of available TLDs. (You can disable this check with the useTldCheck() method.) Each domain part is checked based on the rules for acceptable domain names. If a domain name is an IDN 8 , it is checked against the rules for valid IDNs. (You can disable IDN check with useIdnCheck() method.) Below, a code example demonstrating the usage of the @ Hostname [Laminas\\Validator\\Hostname] validator is provided. <?php use Laminas\\Validator\\Hostname; // Create the Hostname validator. $validator = new Hostname(); // Configure the validator. $validator->setAllow(Hostname::ALLOW_DNS|Hostname::ALLOW_IP); // Check a host name. $isValid = $validator->isValid('site1.example.com'); // Returns true. $isValid2 = $validator->isValid('abc'); // Returns false (not a valid host name). Uri Validator The @ Uri [Laminas\\Validator\\Uri] validator is designed to check whether the input value is a Uniform Resource Identifier (URI) 9 . On failure, error messages can be extracted with the validator's getMessages() method. Note Don't be confused with the term URI. In most cases, you may think of URI as of a usual URL. The public methods provided by the @ Uri [Laminas\\Validator\\Uri] validator are listed in table 9.5: Method name Description __construct($options) Constructs the validator. Accepts the list of options. isValid($value) Returns true when the value is a valid URI; otherwise returns false . getMessages() If validation failed, this method will return an array of error messages. setUriHandler($uriHandler) Sets the URI handler object for this validator. getUriHandler() Retrieves the URI handler object. setAllowAbsolute($allowAbsolute) Tells the validator whether absolute URIs are accepted. getAllowAbsolute() Returns true if absolute URIs are accepted. setAllowRelative($allowRelative) Tells the validator whether relative URIs are accepted. getAllowRelative() Returns true if relative URIs are accepted. Table 9.5. Public methods of the Uri validator Internally, the @ Uri [Laminas\\Validator\\Uri] validator uses so called URI handler object , which is responsible for parsing an URI string. By default, @ Laminas\\Uri\\Uri class is used as the URI handler. (You can set your custom URI handler with the setUriHandler() method, if you wish.) An URI can be absolute or relative. For example, an absolute URI is \"http://example.com/blog/2014/02/02/edit\", while a relative URI is \"2014/02/02/edit\". You can specify whether the validator should consider absolute and/or relative URIs acceptable. For that, you use the setAllowAbsolute() and setAllowRelative() methods, respectively. By default, both are treated as acceptable URI types. Below, a code example demonstrating the usage of the @ Uri [Laminas\\Validator\\Uri] validator is provided. <?php use Laminas\\Validator\\Uri; // Create the Uri validator. $validator = new Uri(); // Configure the validator. $validator->setAllowAbsolute(true); $validator->setAllowRelative(true); // Check an URI. $isValid = $validator->isValid('http://site1.example.com/application/index/index'); // Returns true. $isValid2 = $validator->isValid('index/index'); // Returns true. Date Validator The @ Date [Laminas\\Validator\\Date] validator is intended for checking whether the input data is a date in a given format. On failure, error messages can be extracted with the validator's getMessages() method. Public methods provided by the @ Date [Laminas\\Validator\\Date] validator are listed in table 9.6: Method name Description __construct($options) Constructs the validator. Accepts the list of options. isValid($value) Returns true when the value is a string containing a date in expected format; otherwise returns false . getMessages() If validation failed, this method will return an array of error messages. setFormat($format) Sets an acceptable date format. getFormat() Retrieves the expected format. Table 9.6. Public methods of the Date validator To set the expected date format, you can use the setFormat() method. Note Internally, the @ DateTimeFormatter filter uses the DateTime class from the PHP standard library for converting and formatting dates. For available date formats, please refer to the PHP documentation for the DateTime class. Below, a code example demonstrating the usage of the @ Date [Laminas\\Validator\\Date] validator is provided. <?php use Laminas\\Validator\\Date; // Create validator instance. $validator = new Date(); // Configure validator. $validator->setFormat('Y-m-d'); // Check if the input value is a date having expected format. $isValid = $validator->isValid('2014-04-04'); // Returns true. $isValid2 = $validator->isValid('April 04, 2014'); // Returns false (format is unexpected). Regex Validator This validator allows you to validate if a given string conforms some regular expression. It returns true if the string matches the regular expression, otherwise it returns false . On failure, error messages can be extracted with the validator's getMessages() method. The public methods provided by the @ Regex [Laminas\\Validator\\Regex] validator are listed in table 9.7: Method name Description __construct($options) Constructs the validator. Accepts the list of options. isValid($value) Returns true if and only if $value matches the given regular expression pattern. getMessages() If validation failed, this method will return an array of error messages. setPattern($pattern) Sets the regular expression pattern. getPattern() Retrieves the regular expression pattern. Table 9.7. Public methods of the Regex validator The setPattern() method allows to set the regular expression to match against. Note For regular expressions syntax and examples, it is recommended that your refer to the PCRE Patterns section of the PHP documentation. Below, a code example demonstrating the usage of the @ Regex [Laminas\\Validator\\Regex] validator is provided. It uses the regular expression to check if the input string is a valid IPv4 address (such address typically consists of four groups of digits separated with dots). <?php use Laminas\\Validator\\Regex; // Create Regex validator. $validator = new Regex(); // Set regular expression to check for an IP address. $validator->setPattern('\\b\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\b'); // Check for regular expression match. $isValid = $validator->isValid(\"127.0.0.1\"); // returns true. $isValid2 = $validator->isValid(\"123\"); // returns false. Validators for Checking if a Numerical Value Lies in a Given Range In this section, we will consider usage examples of the validators from the group of validators designed for checking if input value lies in a given range. NotEmpty Validator The @ NotEmpty validator allows to check if input value is not empty. This is often useful when working with form elements or other user input, where you can use it to ensure required elements have values associated with them. The public methods provided by the @ NotEmpty validator are listed in table 9.8: Method name Description __construct($options) Constructs the validator. Accepts the list of options. isValid($value) Returns true if and only if $value is not an empty value. getMessages() If validation failed, this method will return an array of error messages. setType($type) Set the value types that to consider as empty values. getType() Returns the types. getDefaultType() Returns the default types. Table 9.8. Public methods of the NotEmpty validator The setType() method specifies which variable types to consider as an empty value. This method accepts the single argument $type which can be either an OR combination of the constants listed in table 9.9, or an array containing the literal equivalents of those constants. Constant Numeric Value Literal Equivalent Description BOOLEAN 1 \"boolean\" Consider boolean false as an empty value. INTEGER 2 \"integer\" Consider integer 0 as an empty value. FLOAT 4 \"float\" Consider float 0.0 as an empty value. STRING 8 \"string\" Consider empty string '' as an empty value. ZERO 16 \"zero\" Consider string containing the single character zero ('0') as an empty value. EMPTY_ARRAY 32 \"array\" Consider an empty array as an empty value. NULL 64 \"null\" Consider null as an empty value. PHP 127 \"php\" Consider the value empty if the empty() PHP function would return true on it. SPACE 128 \"space\" Consider a string which contains only white spaces as an empty value. OBJECT 256 \"object\" Returns true . false will be returned when object is not allowed but an object is given. OBJECT_STRING 512 \"objectstring\" Returns false when an object is given and it's __toString() method returns an empty string. OBJECT_COUNT 1024 \"objectcount\" Returns false when an object is given, it has an Countable interface and it's count is 0. ALL 2047 \"all\" Consider all above types as empty values. Table 9.9. Type constants Below, a code example demonstrating the usage of the @ NotEmpty validator is provided. <?php use Laminas\\Validator\\NotEmpty; // Create validator instance. $validator = new NotEmpty(); // Configure validator. $validator->setType(NotEmpty::ALL); // Check if input value not empty. $isValid1 = $validator->isValid('some string'); // returns true $isValid2 = $validator->isValid(''); // returns false $isValid3 = $validator->isValid(0); // returns false Between Validator The @ Between [Laminas\\Validator\\Between] validator checks whether a number lies in a certain range (min, max), either inclusively (by default) or exclusively. The public methods provided by the @ Between [Laminas\\Validator\\Between] validator are listed in table 9.10: Method name Description __construct($options) Constructs the validator. Accepts the list of options. isValid($value) Returns true if and only if value's length is within the given range. getMessages() If validation failed, this method will return an array of error messages. setMin($min) Sets the minimum limit. getMin() Retrieves the minimum limit. setMax($max) Sets the maximum limit. getMax() Retrieves the maximum limit. setInclusive($inclusive) Sets whether to compare if the value lies in the given boundaries inclusively. getInclusive() Returns the inclusive option. Table 9.10. Public methods of the Between validator The range can be set with the setMin() and setMax() methods. By default, the validator performs inclusive comparisons (to check if the value belongs to the given range, it compares if the value is greater or equal to its lower bound, and if the value is lower or equal to its upper bound). You can change this with the setInclusive() method. It tells the validator whether to perform inclusive comparisons (pass true as the argument) or exclusive comparisons (pass false as the argument). Below, a code example demonstrating the usage of the @ Between [Laminas\\Validator\\Between] validator is provided. <?php use Laminas\\Validator\\Between; // Create validator instance. $validator = new Between(); // Configure validator. $validator->setMin(1); $validator->setMax(10); $validator->setInclusive(true); $isValid1 = $validator->isValid(5); // returns true. $isValid2 = $validator->isValid(10); // returns true. $isValid3 = $validator->isValid(0); // returns false (value is too small). $isValid4 = $validator->isValid(15); // returns false (value is too big). InArray Validator The @ InArray validator checks whether the input value belongs to the given array of values. The public methods provided by the @ InArray validator are listed in table 9.11: Method name Description __construct($options) Constructs the validator. Accepts the list of options. isValid($value) Returns true if and only if value belongs to the given array. getMessages() If validation failed, this method will return an array of error messages. setHaystack($haystack) Sets the array to search in. getHaystack() Returns the array of allowed values. setStrict($strict) Sets strict comparison mode. getStrict() Whether strict comparison mode enabled? setRecursive($recursive) Tells the validator to search recursively. getRecursive() Whether the recursive search is enabled? Table 9.11. Public methods of the InArray validator The setHaystack() method allows to set the array of allowed values. The isValid() method will search through this array for the presence of the input $value . If the array contains nested values and you want to search among them recursively, then use setRecursive() method. This method takes the single boolean flag. If the flag is true , than the search will be performed recursively; otherwise the nested levels will be ignored. The setStrict() method provides an ability to tell the validator how to compare the input value and the values in array. This may be a combination of the following constants: COMPARE_NOT_STRICT Do not perform strict check of variable type. COMPARE_NOT_STRICT_AND_PREVENT_STR_TO_INT_VULNERABILITY Do not perform strict check of variable type, but prevent false positive comparisons of string to integer (e.g. \"asdf\" == 0 ). This is the default option. COMPARE_STRICT Check both variable type and value. Below, a code example demonstrating the usage of the @ InArray validator is provided. <?php use Laminas\\Validator\\InArray; // Create validator instance. $validator = new InArray(); // Configure validator. $validator->setHaystack([1, 3, 5]); // Perform validation. $isValid1 = $validator->isValid(1); // returns true. $isValid2 = $validator->isValid(2); // returns false. StringLength Validator The @ StringLength validator checks whether the input string length belongs to the given range, inclusively. It returns true if and only if the string length of value is at least the min option and no greater than the max option (when the max option is not null). The public methods provided by the @ StringLength validator are listed in table 9.12: Method name Description __construct($options) Constructs the validator. Accepts the list of options. isValid($value) Returns true if and only if value's length is within the given range. getMessages() If validation failed, this method will return an array of error messages. setMin($min) Sets the minimum limit. getMin() Retrieves the minimum limit. setMax($max) Sets the maximum limit. getMax() Retrieves the maximum limit. setEncoding($encoding) Sets a new encoding to use. getEncoding() Retrieves the encoding. Table 9.12. Public methods of the StringLength validator By default, the @ StringLength validator considers any string length as valid. Use the setMin() and/or setMax() methods to set lower and upper limits for the allowable string length. There are three possible ways you can do that: Use only the setMin() method to allow strings with a lower-bound minimum length, but unbound upper length; Use only the setMax() method to allow strings with zero minimum length and an upper-bound maximum length; Use both the setMin() and setMax() methods to allow strings with a length laying between the lower and upper bounds. By default, the PHP engine uses the UTF-8 encoding for strings. If your input string uses a different encoding, you should specify it encoding with the setEncoding() validator's method. Below, a code example demonstrating the usage of the @ StringLength validator is provided. <?php use Laminas\\Validator\\StringLength; // Create validator instance. $validator = new StringLength(); // Configure the validator. $validator->setMin(1); $validator->setMax(10); $isValid1 = $validator->isValid(\"string\"); // returns true. $isValid2 = $validator->isValid(\"\"); // returns false (value is too short). $isValid3 = $validator->isValid(\"a very long string\"); // returns false (value is too long). Organizing Validators in a Chain Validators can be organized in a sequence. This is accomplished by the @ ValidatorChain [Laminas\\Validator\\ValidatorChain] class. When such a compound validator is run, the input value is passed to all validators in turn. The @ ValidatorChain [Laminas\\Validator\\ValidatorChain] validator's isValid() method returns true if all validators in the chain return true ; otherwise it returns false . Note The @ ValidatorChain [Laminas\\Validator\\ValidatorChain] class is internally used by the @ InputFilter [Laminas\\InputFilter\\InputFilter] container class for storing the sequence of validators attached to a form model's field. Public methods provided by the @ ValidatorChain [Laminas\\Validator\\ValidatorChain] class are presented in table 9.13: Method name Description isValid($value) Returns true if all validators in the chain return true . getMessages() Returns the array of validation error messages. getValidators() Returns the array of validators in the chain. count() Returns count of validators in the chain. attach($validator, $breakChainOnFailure) Attaches a validator to the end of the chain. prependValidator($validator, $breakChainOnFailure) Adds a validator to the beginning of the chain. attachByName($name, $options, $breakChainOnFailure) Use the plugin manager to add a validator by name. prependByName($name, $options, $breakChainOnFailure) Use the plugin manager to prepend a validator by name. merge($validatorChain) Merge the validator chain with the one given in parameter. Table 9.13. Public methods of the ValidatorChain validator An example validator chain is shown in figure 9.2. It consists of the @ NotEmpty validator followed by the @ StringLength validator, which in turn is followed by the @ Date [Laminas\\Validator\\Date] validator. When this chain is executed, first, the @ NotEmpty validator is run checking that the value is a non-empty value, then the @ StringLength validator is run checking that the length of the input string belongs to range (1, 16), inclusively, and finally, the @ Date [Laminas\\Validator\\Date] validator is run checking that the input value is a date in format \"YYYY-MM-DD\". To construct the filter chain like in figure 9.2, we can use the following code: <?php // Instantiate the validator chain. $validator = new \\Laminas\\Validator\\ValidatorChain(); // Insert validators into validator chain. $validator->attachByName('NotEmpty'); $validator->attachByName('StringLength', ['min'=>1, 'max'=>16]); $validator->attachByName('Date', ['format'=>'Y-m-d']); // Execute all validators in the chain. $isValid = $validator->isValid('2014-04-04'); // Returns true. Custom Validation with the Callback Validator The @ Callback [Laminas\\Validator\\Callback] validator can be a wrapper for your custom validation algorithm. For example, this may be useful when a standard validator is not suitable, and you need to apply your own checking algorithm to the data. The public methods provided by the @ Callback [Laminas\\Validator\\Callback] validator are listed in table 9.14. Class name Description isValid($value, $context) Executes a callback function as a validator. getMessages() If validation failed, this method will return an array of error messages. setCallback($callback) Sets a new callback for this filter. getCallback() Returns callback set for the filter. setCallbackOptions($options) Sets options for the callback. getCallbackOptions() Get parameters for the callback. Table 9.14. Public methods of the Callback validator As you can see from the table, the @ Callback [Laminas\\Validator\\Callback] validator provides the setCallback() and setCallbackOptions() methods that can be used to set the callback function or class method and (optionally) pass it one or several parameters. Example To demonstrate the usage of the @ Callback [Laminas\\Validator\\Callback] validator, let's add the phone number validator to our ContactForm form model class. The validator would check a telephone number entered by site visitor. The validator needs to be able to check for two common phone number formats: international format looking like \"1 (234) 567-8901\"; and local format, which looks like \"567-8901\". Because Laminas does not provide a standard validator for accomplishing such phone filtering operation, we will use the @ Callback [Laminas\\Validator\\Callback] wrapper validator. To do that, we will make the following changes to the code of our ContactForm class: <?php // ... class ContactForm extends Form { // .. protected function addElements() { // ... // Add \"phone\" field $this->add([ 'type' => 'text', 'name' => 'phone', 'attributes' => [ 'id' => 'phone' ], 'options' => [ 'label' => 'Your Phone', ], ]); } private function addInputFilter() { // ... $inputFilter->add([ 'name' => 'phone', 'required' => true, 'validators' => [ [ 'name' => 'Callback', 'options' => [ 'callback' => [$this, 'validatePhone'], 'callbackOptions' => [ 'format' => 'intl' ] ] ] ] ); } // Custom validator for a phone number. public function validatePhone($value, $context, $format) { // Determine the correct length and pattern of the phone number, // depending on the format. if($format == 'intl') { $correctLength = 16; $pattern = '/^\\d\\ (\\d{3}\\) \\d{3}-\\d{4}$/'; } else { // 'local' $correctLength = 8; $pattern = '/^\\d{3}-\\d{4}$/'; } // Check phone number length. if(strlen($value)!=$correctLength) return false; // Check if the value matches the pattern. $matchCount = preg_match($pattern, $value); return ($matchCount!=0)?true:false; } } In the code above, we create the phone field in our ContactForm (if you already have such field, just ignore this). In lines 26-40, we add the @ Callback [Laminas\\Validator\\Callback] validator to the input filter's validator chain for the \"phone\" field. In lines 44-64, we have the validatePhone() callback method. The method accepts three arguments: the $value parameter is the phone number to validate, the $context parameter receives the values of every field of the form (it may be needed for some validators to refer to the values of other form fields, too); and the $format parameter is the expected format of the phone number (\"intl\" or \"local\"). Inside of the callback method, we do the following: Calculate the correct length of the phone, check whether the length is correct for the selected phone number format. Match the phone number against the regular expression pattern for the selected phone format. Writing Own Validator An alternative of using the @ Callback [Laminas\\Validator\\Callback] validator is writing your own validator class implementing the @ ValidatorInterface [Laminas\\Validator\\ValidatorInterface] interface. Then, this validator may be used in forms of your web application. To demonstrate how to create your own validator, we will write the PhoneValidator class encapsulating the phone validation algorithm we used with the @ Callback [Laminas\\Validator\\Callback] validator example. As you might remember, the base concrete class for all standard validators is the @ AbstractValidator class. By analogy, we will also derive our custom PhoneValidator validator from that base class. We plan to have the following methods in our PhoneValidator validator class (see table 9.15): Method name Description __construct($options) Constructor. Accepts an optional argument $options which is needed to set validator options at once. setFormat($format) Sets the phone format option. getFormat() Returns the phone format option. isValid($value) Returns true when the value is a valid phone number; otherwise returns false . getMessages() If validation failed, this method will return an array of error messages. Table 9.15. Public methods of the Callback validator For the PhoneValidator , we will have three possible error messages: If a non-scalar value is passed to the validator, it will generate the error message \"The phone number must be a scalar value\"; If the international phone format is selected, and the phone number entered doesn't match this format, the validator will generate the message \"The phone number must be in international format\"; If the local phone format is selected and the phone number entered doesn't match the format, the validator will generate the message \"The phone number must be in local format\". To start, create the PhoneValidator.php file in the Validator directory under the module's source directory 10 . Put the following code into that file: <?php namespace Application\\Validator; use Laminas\\Validator\\AbstractValidator; // This validator class is designed for checking a phone number for // conformance to the local or to the international format. class PhoneValidator extends AbstractValidator { // Phone format constants. const PHONE_FORMAT_LOCAL = 'local'; // Local phone format. const PHONE_FORMAT_INTL = 'intl'; // International phone format. // Available validator options. protected $options = [ 'format' => self::PHONE_FORMAT_INTL ]; // Validation failure message IDs. const NOT_SCALAR = 'notScalar'; const INVALID_FORMAT_INTL = 'invalidFormatIntl'; const INVALID_FORMAT_LOCAL = 'invalidFormatLocal'; // Validation failure messages. protected $messageTemplates = [ self::NOT_SCALAR => \"The phone number must be a scalar value\", self::INVALID_FORMAT_INTL => \"The phone number must be in international format\", self::INVALID_FORMAT_LOCAL => \"The phone number must be in local format\", ]; // Constructor. public function __construct($options = null) { // Set filter options (if provided). if(is_array($options)) { if(isset($options['format'])) $this->setFormat($options['format']); } // Call the parent class constructor. parent::__construct($options); } // Sets phone format. public function setFormat($format) { // Check input argument. if($format!=self::PHONE_FORMAT_LOCAL && $format!=self::PHONE_FORMAT_INTL) { throw new \\Exception('Invalid format argument passed.'); } $this->options['format'] = $format; } // Validates a phone number. public function isValid($value) { if(!is_scalar($value)) { $this->error(self::NOT_SCALAR); return false; // Phone number must be a scalar. } // Convert the value to string. $value = (string)$value; $format = $this->options['format']; // Determine the correct length and pattern of the phone number, // depending on the format. if($format == self::PHONE_FORMAT_INTL) { $correctLength = 16; $pattern = '/^\\d \\(\\d{3}\\) \\d{3}-\\d{4}$/'; } else { // self::PHONE_FORMAT_LOCAL $correctLength = 8; $pattern = '/^\\d{3}-\\d{4}$/'; } // First check phone number length $isValid = false; if(strlen($value)==$correctLength) { // Check if the value matches the pattern. if(preg_match($pattern, $value)) $isValid = true; } // If there was an error, set error message. if(!$isValid) { if($format==self::PHONE_FORMAT_INTL) $this->error(self::INVALID_FORMAT_INTL); else $this->error(self::INVALID_FORMAT_LOCAL); } // Return validation result. return $isValid; } } From line 2, you can see that the validator class lives in the Application\\Validator namespace. In line 8, we define the PhoneValidator class. We derive our validator class from the AbstractValidator base class to reuse the functionality it provides. Line 4 contains the short alias for the @ AbstractValidator class. In lines 11-12, for convenience, we define the phone format constants ( PHONE_FORMAT_INTL for international format and PHONE_FORMAT_LOCAL for local format). These are the equivalents of the \"intl\" and \"local\" strings, respectively. In lines 15-17, we define the $options private array variable which is an array having the single key named \"format\". This key will contain the phone format option for our validator. In lines 20-22, we define the error message identifiers. We have three identifiers ( NOT_SCALAR , INVALID_FORMAT_INTL and INVALID_FORMAT_LOCAL ), because our validator may generate three different error messages. These identifiers are intended for distinguishing different error messages by machine, not by human. In lines 25-29, we have the $messageTemplates array variable that contains mapping before error message identifiers and their textual representations. The textual messages are intended for displaying to a human. In lines 32-43, we have the constructor method which takes the single argument $options . When constructing the validator manually, you may omit this parameter. But, when the validator is constructed by the factory class, the factory will pass validation options to validator's constructor through this argument. In lines 46-55, we have the setFormat() method that allow to set the current phone format, respectively. In lines 58-98, we have the isValid() method. This method encapsulates the phone number checking algorithm. It takes the $value parameter, performs the regular expression match, and returns true on success. On failure, the isValid() method it returns the boolean false , and the list of errors can be retrieved by the getMessages() method. Note You might notice that we didn't define the getMessages() method in our PhoneValidator class. This is because we inherited this method from the @ AbstractValidator base class. Inside of our isValid() method, for generating error messages, we also used the error() protected method provided by the base class (lines 61, 91, 93). Note The PhoneValidator is only for demonstration of how to write custom validators in Laminas. Implementing a validator that will work correctly against all possible phone numbers in the world is beyond the scope of this book. If you'd like to use this validator in a real-life app, you will definitely need to improve it. For example, take a look at the libphonenumber PHP library from Google. Using the PhoneValidator Class When the PhoneValidator validator class is ready, you can easily start using it in the feedback form (or in another form) as follows. It is assumed that you call the following code inside of the ContactForm::addInputFilter() method: $inputFilter->add([ 'name' => 'phone', 'required' => true, 'validators' => [ [ [ 'name' => PhoneValidator::class, 'options' => [ 'format' => PhoneValidator::PHONE_FORMAT_INTL ] ], ], // ... ], // ... ]); You can see how the PhoneValidator validator works in the Form Demo sample application bundled with this book. Open the \"http://localhost/contactus\" page in your web browser. If you enter some phone number in an incorrect format, the validator will display an error (see figure 9.3). If you wish, you can use the PhoneValidator outside of forms, as shown in code example below: <?php use Application\\Validator\\PhoneValidator; // Create PhoneValidator validator $validator = new PhoneValidator(); // Configure the validator. $validator->setFormat(PhoneValidator::PHONE_FORMAT_INTL); // Validate a phone number $isValid = $validator->isValid('1 (234) 567-8901'); // Returns true. $isValid2 = $validator->isValid('12345678901'); // Returns false. if(!$isValid2) { // Get validation errors. $errors = $validator->getMessages(); } Using Filters & Validators Outside a Form In this section, we will provide an example of how you can use filters and/or validators in your controller to transform and check the data extracted from GET and/or POST variables. Let's assume we implement a payment gateway system and need to create a web page displaying a payment history for the given credit card on given date. This page can be handled by some paymentHistoryAction() action of a controller class, and the credit card number and date will be extracted from GET variables. For the paymentHistoryAction() method, we need to implement some security checks: we want to ensure that the credit card number looks like a typical credit card number \"4532-7103-4122-1359\" (conforms to ISO/IEC 7812 standard); and that the date is in 'YYYY-MM-DD' format. Below, you can find the code of the action method: <?php namespace Application\\Controller; use Laminas\\Mvc\\Controller\\AbstractActionController; use Laminas\\View\\Model\\ViewModel; use Laminas\\Filter\\StaticFilter; use Laminas\\Validator\\StaticValidator; class IndexController extends AbstractActionController { // An action which shows the history of a credit // card operations on certain date. public function paymentHistoryAction() { // Get parameters from GET. $cardNumber = (string)$this->params()->fromQuery('card', ''); $date = (string)$this->params()->fromQuery('date', date(\"Y-m-d\")); // Validate credit card number. $isCardNumberValid = StaticValidator::execute($cardNumber, 'CreditCard'); if(!$isCardNumberValid) { throw new \\Exception('Not a credit card number.'); } // Convert date to the right format. $date = StaticFilter::execute($date, 'DateTimeFormatter', ['format'=>'Y-m-d']); // The rest of action code goes here... return new ViewModel(); } } Inside the action method, we use the params() controller plugin (lines 16-17) to retrieve two variables from $_GET super-global array: the card variable (credit card number) and the date variable (the date). In line 20, we validate the credit card number with the help of the CreditCard validator. If the card number is not acceptable, we throw an exception indicating an error (line 22). In line 26, we use the DateTimeFormatter filter to convert the date to the right format. Summary Validators are designed to take some input data, check it for correctness, and return a boolean result telling whether the data is correct (and error messages if the data has some errors). In Laminas Framework, there are several groups of standard validators: validators for checking value conformance to certain format; validators for checking a numerical value lies in a given range; validators working as \"proxies\" to other validators. In some cases, a standard validator is not suitable, and you need to apply your own checking algorithm to the input data. In such case, you may use either the @ Callback [Laminas\\Validator\\Callback] validator or write your own custom validator class. Here, we only consider the standard validator classes belonging to the @ Laminas\\Validator namespace. But, actually there are more validators that can be considered as standard. We will cover them in further chapters. \u21a9 An MX record is a type of record used in the Domain Name System (DNS). MX records define one or several mail server addresses assigned to recipient's domain. \u21a9 The ALLOW_ -prefixed constants are provided by the @ Hostname [Laminas\\Validator\\Hostname] validator. \u21a9 An Internet Protocol version 4 (IPv4) address typically consists of four octets of the address expressed separated by periods, like \"192.168.56.101\". \u21a9 An Internet Protocol version 6 (IPv6) address typically consists of eight groups of four hexadecimal digits separated by colons, such as \"2001:0db8:85a3:0000:0000:8a2e:0370:7334\". \u21a9 IPvFuture is loosely defined in the Section 3.2.2 of RFC 3986. \u21a9 A literal IPv6 address is a modification of a usual IPv6 address for using inside of a URL. (The problem with original IPv6 addresses is that the \":\" and \".\" characters are delimiters in URLs.) \u21a9 An internationalized domain name (IDN) is an Internet domain name that contains at least one label that is displayed, in whole or in part, in a language-specific script or alphabet, like Arabic, Chinese or Russian. \u21a9 A Uniform Resource Identifier (URI) is a compact sequence of characters that identifies an abstract or physical resource. An Uniform Resource Locator (URL) is a type of URI. But, that doesn't mean all URIs are URLs. \u21a9 The PhoneValidator class may be considered as a service model, because its goal is to process data, not to store it. By convention, we store custom validators under the Validator directory. \u21a9","title":"Checking Input Data with Validators"},{"location":"validators/#checking-input-data-with-validators","text":"In this chapter, we will provide an overview of standard Laminas validators that can be used with your forms, and will also show how to write a custom validator. A validator is a class designed to take some input data, check it for correctness, and return a boolean result telling whether the data is correct (and error messages if the data has some errors). Note In general, you even can use validators outside forms to process an arbitrary data. For example, validators may be used in a controller action to ensure that data passed as GET and/or POST variables is secure and conform to certain format. Laminas components covered in this chapter: Component Description @ Laminas\\Validator Implements various validator classes. @ Laminas\\InputFilter Implements a container for filters/validators.","title":"Checking Input Data with Validators"},{"location":"validators/#about-validators","text":"A validator is designed to take some input data, check it for correctness, and return a boolean result telling whether the data is correct. If the data is incorrect, the validator generates the list of errors describing why the check didn't pass.","title":"About Validators"},{"location":"validators/#validatorinterface","text":"In Laminas, a validator is a usual PHP class which implements the @ ValidatorInterface [Laminas\\Validator\\ValidatorInterface] interface (it belongs to @ Laminas\\Validator namespace). The interface definition is presented below: <?php namespace Laminas\\Validator; interface ValidatorInterface { // Returns true if and only if $value meets the validation requirements. public function isValid($value); // Returns an array of messages that explain why // the most recent isValid() call returned false. public function getMessages(); } As you can see, the @ ValidatorInterface [Laminas\\Validator\\ValidatorInterface] has two methods: the isValid() method (line 7) and getMessages() method (line 11). The first one, isValid() method, is intended to perform the check of the input value (the $value parameter). If the validation of the $value passes, the isValid() method returns boolean true . If the $value fails validation, then this method returns false . Note A concrete validator class implementing the @ ValidatorInterface [Laminas\\Validator\\ValidatorInterface] interface may have additional methods. For example, many validator classes have methods allowing to configure the validator (set validation options).","title":"ValidatorInterface"},{"location":"validators/#standard-validators-overview","text":"Standard Laminas validators are provided by the @ Laminas\\Validator component 1 . Standard validator classes inheritance is shown in figure 9.1. As you can see from the figure, most of them are derived from @ AbstractValidator base class. Standard validators together with their brief description are listed in table 9.1. As you may notice from the table, they can be roughly divided into several groups: validators for checking value conformance to certain format (IP address, host name, E-mail address, credit card number, etc.); validators for checking if a numerical value lies in a given range (less than, greater than, between, etc.); validators working as \"proxies\" to other validators (@ ValidatorChain [Laminas\\Validator\\ValidatorChain], @ StaticValidator and @ Callback [Laminas\\Validator\\Callback]). Class name Description @ EmailAddress [Laminas\\Validator\\EmailAddress] Returns boolean true if the value is a valid E-mail address; otherwise returns false . @ Hostname [Laminas\\Validator\\Hostname] Checks whether the value is a valid host name. @ Barcode [Laminas\\Validator\\Barcode] Returns boolean true if and only if the value contains a valid barcode. @ CreditCard Returns true if and only if the value follows the common format of credit card number (Luhn algorithm, mod-10 checksum). @ Iban Returns true if the value is a valid International Bank Account Number (IBAN); otherwise returns false . @ Isbn Returns boolean true if and only if value is a valid International Standard Book Number (ISBN). @ Ip Returns true if value is a valid IP address; otherwise returns false . @ Uri [Laminas\\Validator\\Uri] Returns true if and only if the value is an Uniform Resource Identifier (URI). @ Between [Laminas\\Validator\\Between] Returns true if the value lies in certain range; otherwise returns false . @ LessThan Returns boolean true if the value is less than certain number; otherwise returns false . @ GreaterThan Returns true if and only if value is greater than certain number. @ Identical Returns boolean true if the value matches a given token. @ Step Checks whether the value is a scalar and a valid step value. @ Csrf [Laminas\\Validator\\Csrf] This validator checks if the provided token matches the one previously generated and stored in a PHP session. @ Date [Laminas\\Validator\\Date] Returns true if value is a valid date of the certain format. @ DateStep Returns boolean true if a date is within a valid step. @ InArray Returns true if value is contained in the given array; otherwise returns false . @ Digits [Laminas\\Validator\\Digits] Returns boolean true if and only if $value only contains digit characters. @ Hex Returns true if and only if value contains only hexadecimal digit characters. @ IsInstanceOf Returns true if value is instance of certain class; otherwise returns false . @ NotEmpty Returns true if value is not an empty value. @ Regex [Laminas\\Validator\\Regex] Returns true if value matches against given pattern; otherwise returns false . @ StringLength Returns true if the string length lies within given range. @ Explode Splits the given value in parts and returns true if all parts pass the given check. @ StaticValidator This validator allows to execute another validator without explicitly instantiating it. @ Callback [Laminas\\Validator\\Callback] This validator allows to execute a custom validation algorithm through the user-provided callback function. @ ValidatorChain [Laminas\\Validator\\ValidatorChain] Wrapper validator allowing to organize several validators in a chain. Attached validators are run in the order in which they were added to the chain (FIFO). Table 9.1. Standard validators","title":"Standard Validators Overview"},{"location":"validators/#validator-behaviour-in-case-of-invalid-or-unacceptable-data","text":"If you pass a validator some data that doesn't pass the check, the validator internally creates the list of error messages that can be retrieved with the getMessages() method. For example, look below for possible validation errors that the @ EmailAdrress [Laminas\\Validator\\EmailAddress] returns if you pass it the \"abc@ewr\" value (the back-slash ('\\') character indicates line breaks where code doesn't fit book page): array(3) { [\"emailAddressInvalidHostname\"] => string(51) \"'ewr' is not a valid hostname for the email address\" [\"hostnameInvalidHostname\"] => string(66) \"The input does not match the expected structure for a DNS hostname\" [\"hostnameLocalNameNotAllowed\"] => string(84) \"The input appears to be a local network name but local network names are not allowed\" } Validator's getMessages() method will return an array of messages that explain why the validation failed. The array keys are validation failure message identifiers, and the array values are the corresponding human-readable message strings. If isValid() method was never called or if the most recent isValid() call returned true , then the getMessages() method returns an empty array. Also, when you call isValid() several times, the previous validation messages are cleared, so you see only validation errors from the last call. Some validators may work with input data in certain format only (for example, a validator may require that the input data be a string, but not an array). If you pass it data in unacceptable format, the validator may throw an @ Laminas\\Validator\\Exception\\RuntimeException exception or raise a PHP warning. Note It is recommended to check certain validator's documentation to be aware of its actual behaviour in case of inacceptable data.","title":"Validator Behaviour in Case of Invalid or Unacceptable Data"},{"location":"validators/#instantiating-a-validator","text":"In Laminas Framework, there are several methods of creating a validator: instantiating it manually (with the new operator); creating it with a factory class (by passing an array configuration); this way is used the most frequently when adding validation rules in a form; instantiating it implicitly with the @ StaticValidator wrapper class. Next, we will cover these three methods in more details.","title":"Instantiating a Validator"},{"location":"validators/#method-1-manual-instantiation-of-a-validator","text":"A validator in general can be used not only with forms, but also for validation of an arbitrary data. In order to do that, you simply create an instance of the validator class, configure the validator by using the methods it provides, and call the isValid() method on the validator. For example, let's consider the usage of the @ EmailAddress validator which checks an E-mail address for conformance to RFC-2822 standard. An E-mail address typically consists of the local part (user name) followed by the \"at\" character (@), which is in turn followed by the host name. For example, in the \"name@example.com\" E-mail address, \"name\" is the local part, and \"example.com\" is the host name. Note The @ EmailAddress validator is useful for checking an user-entered E-mail addresses on your forms for correctness. The validator will check for the correctness of the local part and the host name, for presence of the \"at\" character (@) and, optionally, will connect to the recipient's host and query the DNS service for existence of the MX (Mail Exchanger) record 2 . The methods provided by the @ EmailAddress validator are listed in table 9.2: Method name Description __construct($options) Constructs the validator. Accepts the list of options allowing to configure it. isValid($value) Returns true if the value is a valid E-mail address according to RFC-2822; otherwise returns false . getMessages() If validation failed, this method will return an array of error messages. useDomainCheck($domain) Tells the validator to check the host name part for correctness. getDomainCheck() Returns true if host name part check is enabled. setHostnameValidator($hostnameValidator) Attaches the validator to use for checking host name part of the E-mail address. getHostnameValidator() Returns the validator used for checking host name part of the E-mail address. setAllow($allow) Sets the allowed types of host names to be used in an E-mail address. getAllow() Returns the allowed types of host names. useMxCheck($mx) Sets whether to perform the check for a valid MX record via DNS service. getMxCheck($mx) Returns true if MX check mode is enabled. useDeepMxCheck($deep) Sets whether to use deep validation for MX records. getDeepMxCheck() Returns true if the deep MX check mode is enabled; otherwise returns false . isMxSupported() Returns true if MX checking via getmxrr() PHP function is supported in the system; otherwise returns false . getMXRecord() After validation, returns the found MX record information. Table 9.2. Public methods of the EmailAddress validator As you can see from the table, the @ EmailAddress validator, additionally to the isValid() and getMessages() methods, provides the constructor method to which you can (optionally) pass the complete list of options for initializing the validator. All standard validators have the constructor method (optionally) accepting an array of options for configuring the validator when instantiating it manually. The @ EmailAddress class also provides a number of methods that can be used for setting specific validator options. The useDomainCheck() method tells whether to check the host name for correctness, or not. By default, this check is enabled. The setAllow() method provides an ability to specify which types of host names are allowed. You can pass an OR combination of the ALLOW_ -prefixed constants 3 to the setAllow() method: ALLOW_DNS Allow a domain name (this is the default), IP_ADDRESS Allow an IP address, ALLOW_LOCAL Allow local network name, ALLOW_ALL Allow all of the above. Note Internally, the @ EmailAddress validator uses the @ Hostname [Laminas\\Validator\\Hostname] validator for checking the host name part of an E-mail address. Optionally, you can attach a custom host name validator by using the setHostnameValidator() method, however it is unlikely you will need to do such. The useMxCheck() method tells whether the validator should connect to the recipient's host and query the DNS server for the MX record(s). If the server has no MX records, than the validation fails. You can additionally use the useDeepMxCheck() method to tell the validator to compare the mail server addresses extracted from the MX records against the black list of reserved domain names, and perform additional checks per each detected address. Note It is not recommended to perform MX check (and deep MX check), because that may take a lot of time and increase the web page load time. By default, these checks are disabled. Below, we provide code examples showing two equivalent methods of manual creating of an instance of the @ EmailAddress validator, setting its options and checking an input value: Example 1. Passing options to the constructor method. <?php // Optionally, define a short alias for the validator class name. use Laminas\\Validator\\EmailAddress; use Laminas\\Validator\\Hostname; // Create an instance of the validator, passing options to the constructor. $validator = new EmailAddress([ 'allow' => Hostname::ALLOW_DNS|Hostname::ALLOW_IP|Hostname::ALLOW_LOCAL, 'mxCheck' => true, 'deepMxCheck' => true ]); // Validate an E-mail address. $isValid = $validator->isValid('name@example.com'); // Returns true. $isValid2 = $validator->isValid('abc'); // Returns false. if(!$isValid2) { // Get error messages in case of validation failure. $errors = $validator->getMessages(); } In the code above, we create the @ EmailAddress validator object with the help of the new operator (line 7). We pass the array of options to the constructor. We use the allow key to allow an E-mail address to be a domain name, an IP address or local network address. Also, we use the mxCheck and deepMxCheck to enable MX record check and deep MX record check, respectively. In line 14, we call the isValid() method and pass it the string value \"name@example.com\" to be checked. The expected output of this call is the boolean true . In line 15, we pass the \"abc\" string value to the validator. The validation procedure is expected to fail ( false is returned). Then, the error messages are retrieved with the getMessages() method (line 19). Example 2. Without passing options to the constructor. <?php // Optionally, define a short alias for the validator class name. use Laminas\\Validator\\EmailAddress; use Laminas\\Validator\\Hostname; // Create an instance of the validator. $validator = new EmailAddress(); // Optionally, configure the validator $validator->setAllow( Hostname::ALLOW_DNS|Hostname::ALLOW_IP|Hostname::ALLOW_LOCAL); $validator->useMxCheck(true); $validator->useDeepMxCheck(true); // Validate an E-mail address. $isValid = $validator->isValid('name@example.com'); // Returns true. $isValid2 = $validator->isValid('abc'); // Returns false. if(!$isValid2) { // Get error messages in case of validation failure. $errors = $validator->getMessages(); } In the code above, we create the @ EmailAddress validator object with the help of the new operator (line 7). In lines 10-13, we configure the validator. We call the setAllow() method to allow an E-mail address to be a domain name, an IP address or local network address. Also, we use the useMxCheck() and useDeepMxCheck() to enable MX record check and deep MX record check, respectively. In line 16, we call the isValid() method and pass it the string value \"name@example.com\" to be checked. The expected output of this call is the boolean true . In line 17, we pass the \"abc\" string value to the validator. The validation procedure is expected to fail. Then, the error messages are retrieved with the getMessages() method (line 21).","title":"Method 1. Manual Instantiation of a Validator"},{"location":"validators/#method-2-using-staticvalidator-wrapper","text":"An alternative way of manual validator instantiation is by using the @ StaticValidator class. The @ StaticValidator class is some kind of a \"proxy\" designed for automatic validator instantiation, configuration and execution. For example, let's consider how to create the same @ EmailAddress validator, configure it and call its isValid() method: <?php // Create and execute the EmailAddress validator through StaticValidator proxy. $validatedValue = \\Laminas\\Validator\\StaticValidator::execute('name@example.com', 'EmailAddress', [ 'allow' => Hostname::ALLOW_DNS| Hostname::ALLOW_IP| Hostname::ALLOW_LOCAL, 'mxCheck' => true, 'deepMxCheck' => true ]); // The expected output is boolean true. The @ StaticValidator class provides the execute() static method which takes three arguments: the input value, the name of the filter to apply, and the array of filter-specific options. In line 3, we call the execute() method to automatically create the @ EmailAddress validator, call its setAllowDns() , useMxCheck() and useDeepMxCheck() methods, and pass the input value to its isValid() method. This is very useful, because can be accomplished in a single call. Note The @ StaticValidator doesn't provide an ability to extract the list of human-readable validation errors. However, since the @ StaticValidator is designed to be used outside forms, and not intended for displaying results to a human, this seems to be not a big disadvantage.","title":"Method 2. Using StaticValidator Wrapper"},{"location":"validators/#method-3-using-an-array-configuration","text":"When using validators with form's validation rules, you typically do not construct a validator object explicitly as we did in the previous section, instead you pass an array configuration to the factory class which automatically constructs the validator for you and (optionally) configures it. We already saw how this works when adding validation rules for the feedback form in Collecting User Input with Forms . For example, let's show how to construct the same @ EmailAddress filter with the help of the factory: <?php // It is assumed that you call the following code inside of the form model's // addInputFilter() method. $inputFilter->add([ // ... 'validators' => [ [ 'name' => 'EmailAddress', 'options' => [ 'allow' => \\Laminas\\Validator\\Hostname::ALLOW_DNS, 'useMxCheck' => false, 'useDeepMxCheck' => false, ], ], ], // ... ]); In the code above, we call the add() method provided by the @ InputFilter [Laminas\\InputFilter\\InputFilter] container class (line 5). The add() method takes an array which has the validators key. You typically register the validators under that key (line 7). Validators registered under that key are inserted into validator chain in the order they appear in the list. A validator configuration typically consists of the name (line 9) and options (line 10). The name is a fully qualified validator class name (e.g. @ \\Laminas\\Validator\\EmailAddress ) or its short alias (@ EmailAddress ). The options is an array consisting of validator-specific options. When the factory class instantiates the validator, it passes the list of options to the validator's constructor, and the constructor initializes the validator as needed.","title":"Method 3. Using an Array Configuration"},{"location":"validators/#about-validator-plugin-manager","text":"When creating a validator with a factory, you can use either the fully qualified validator class name or its short alias. The short aliases for the standard validators are defined by the @ ValidatorPluginManager class. Note The @ ValidatorPluginManager class defines validator aliases. A standard validator's alias is typically the same as class name. For example, the class @ Laminas\\Validator\\EmailAddress has the short alias @ EmailAddress . The validator plugin manager is internally used by the @ InputFilter [Laminas\\InputFilter\\InputFilter] container class for instantiating the standard validators.","title":"About Validator Plugin Manager"},{"location":"validators/#validator-usage-examples","text":"Next, we will consider the usage of the most important standard validators. These describe the methods (and options) a validator has, and provide a code example showing how to instantiate and apply the validator to input data.","title":"Validator Usage Examples"},{"location":"validators/#validators-for-checking-value-conformance-to-certain-format","text":"In this section, we will consider usage examples of the validators from the group of validators designed for checking if input value conforms to certain format.","title":"Validators for Checking Value Conformance to Certain Format"},{"location":"validators/#ip-validator","text":"The @ Ip validator class is designed to check if the input value is a valid IP address. If the input value is an IPv4 4 address, IPv6 5 address, IPvFuture 6 address, or IPv6 literal 7 address, the validator returns boolean true ; otherwise it returns false . On failure, error messages can be extracted with the validator's getMessages() method. Public methods provided by the @ Ip validator are listed in table 9.3: Method name Description __construct($options) Constructs the validator. Accepts the list of options. isValid($value) Returns true if and only if value is a valid IP address. getMessages() If validation failed, this method will return an array of error messages. setOptions($options) Sets validator options. Table 9.3. Public methods of the Ip validator The setOptions() method provides an ability to set allowed types of IP addresses: allowipv4 to allow IPv4 addresses; allowipv6 to allow IPv6 addresses; allowipvfuture to allow IPvFuture addresses; allowliteral to allow IPv6 literal addresses. By default all the above are allowed, except the IPv6 literal address. Below, a code example demonstrating the usage of the @ Ip validator is provided. <?php use Laminas\\Validator\\Ip; // Create Ip validator. $validator = new Ip(); // Configure the validator. $validator->setOptions([ 'allowipv4' => true, // Allow IPv4 addresses. 'allowipv6' => true, // Allow IPv6 addresses. 'allowipvfuture' => false, // Allow IPvFuture addresses. 'allowliteral' => true, // Allow IP addresses in literal format. ]); // Check if input value is a valid IP address (IPv4). $isValid = $validator->isValid('192.168.56.101'); // Returns true // Check if input value is a valid IP address (IPv6). $isValid2 = $validator->isValid( '2001:0db8:85a3:0000:0000:8a2e:0370:7334'); // Returns true // Pass an invalid string (not containing an IP address). $isValid3 = $validator->isValid('abc'); // Returns false","title":"Ip Validator"},{"location":"validators/#hostname-validator","text":"The @ Hostname [Laminas\\Validator\\Hostname] validator is designed to check if a given value is a host name belonging to set of allowed host name types. The types are: a DNS Hostname (e.g. \"example.com\"); an IP address (e.g. \"192.168.56.101\"); a local host name (e.g. \"localhost\"). The public methods provided by the validator are listed in table 9.4: Method name Description __construct($options) Constructs the validator. Accepts the list of options. isValid($value) Returns true when the value is a valid host name; otherwise returns false . getMessages() If validation failed, this method will return an array of error messages. setIpValidator($ipValidator) Optionally, allows to set own IP address validator. getIpValidator() Retrieves attached IP address validator. setAllow() Defines the type(s) of host names which are allowed. getAllow() Returns allowed host names types. useIdnCheck() Defines if Internationalized Domain Names (IDN) check is enabled. This option defaults to true . getIdnCheck() Returns true if IDN check is enabled. useTldCheck() Defines if Top Level Domain (TLD) check is enabled. This option defaults to true . getTldCheck() Returns true if TLD check is enabled. Table 9.4. Public methods of the Hostname validator You can set which host name types are allowed with the setAllow() method. It accepts a combination of the following constants: ALLOW_DNS Allows Internet domain names (e.g., example.com ); ALLOW_IP Allows IP addresses; ALLOW_LOCAL Allows local network names (e.g., localhost , www.localdomain ); ALLOW_URI Allows URI host names. ALLOW_ALL Allows all types of host names. By default, only Internet domain names are allowed. The host name check consists of several stages, some of which may be omitted based on validator options: If the input value looks like an IP address, it is checked with the internal IP address validator. You can override which IP address validator to use for this by the setIpValidator() method. The host name is separated into domain parts (separated with dot \".\" character). The top-level domain is checked against the white list of available TLDs. (You can disable this check with the useTldCheck() method.) Each domain part is checked based on the rules for acceptable domain names. If a domain name is an IDN 8 , it is checked against the rules for valid IDNs. (You can disable IDN check with useIdnCheck() method.) Below, a code example demonstrating the usage of the @ Hostname [Laminas\\Validator\\Hostname] validator is provided. <?php use Laminas\\Validator\\Hostname; // Create the Hostname validator. $validator = new Hostname(); // Configure the validator. $validator->setAllow(Hostname::ALLOW_DNS|Hostname::ALLOW_IP); // Check a host name. $isValid = $validator->isValid('site1.example.com'); // Returns true. $isValid2 = $validator->isValid('abc'); // Returns false (not a valid host name).","title":"Hostname Validator"},{"location":"validators/#uri-validator","text":"The @ Uri [Laminas\\Validator\\Uri] validator is designed to check whether the input value is a Uniform Resource Identifier (URI) 9 . On failure, error messages can be extracted with the validator's getMessages() method. Note Don't be confused with the term URI. In most cases, you may think of URI as of a usual URL. The public methods provided by the @ Uri [Laminas\\Validator\\Uri] validator are listed in table 9.5: Method name Description __construct($options) Constructs the validator. Accepts the list of options. isValid($value) Returns true when the value is a valid URI; otherwise returns false . getMessages() If validation failed, this method will return an array of error messages. setUriHandler($uriHandler) Sets the URI handler object for this validator. getUriHandler() Retrieves the URI handler object. setAllowAbsolute($allowAbsolute) Tells the validator whether absolute URIs are accepted. getAllowAbsolute() Returns true if absolute URIs are accepted. setAllowRelative($allowRelative) Tells the validator whether relative URIs are accepted. getAllowRelative() Returns true if relative URIs are accepted. Table 9.5. Public methods of the Uri validator Internally, the @ Uri [Laminas\\Validator\\Uri] validator uses so called URI handler object , which is responsible for parsing an URI string. By default, @ Laminas\\Uri\\Uri class is used as the URI handler. (You can set your custom URI handler with the setUriHandler() method, if you wish.) An URI can be absolute or relative. For example, an absolute URI is \"http://example.com/blog/2014/02/02/edit\", while a relative URI is \"2014/02/02/edit\". You can specify whether the validator should consider absolute and/or relative URIs acceptable. For that, you use the setAllowAbsolute() and setAllowRelative() methods, respectively. By default, both are treated as acceptable URI types. Below, a code example demonstrating the usage of the @ Uri [Laminas\\Validator\\Uri] validator is provided. <?php use Laminas\\Validator\\Uri; // Create the Uri validator. $validator = new Uri(); // Configure the validator. $validator->setAllowAbsolute(true); $validator->setAllowRelative(true); // Check an URI. $isValid = $validator->isValid('http://site1.example.com/application/index/index'); // Returns true. $isValid2 = $validator->isValid('index/index'); // Returns true.","title":"Uri Validator"},{"location":"validators/#date-validator","text":"The @ Date [Laminas\\Validator\\Date] validator is intended for checking whether the input data is a date in a given format. On failure, error messages can be extracted with the validator's getMessages() method. Public methods provided by the @ Date [Laminas\\Validator\\Date] validator are listed in table 9.6: Method name Description __construct($options) Constructs the validator. Accepts the list of options. isValid($value) Returns true when the value is a string containing a date in expected format; otherwise returns false . getMessages() If validation failed, this method will return an array of error messages. setFormat($format) Sets an acceptable date format. getFormat() Retrieves the expected format. Table 9.6. Public methods of the Date validator To set the expected date format, you can use the setFormat() method. Note Internally, the @ DateTimeFormatter filter uses the DateTime class from the PHP standard library for converting and formatting dates. For available date formats, please refer to the PHP documentation for the DateTime class. Below, a code example demonstrating the usage of the @ Date [Laminas\\Validator\\Date] validator is provided. <?php use Laminas\\Validator\\Date; // Create validator instance. $validator = new Date(); // Configure validator. $validator->setFormat('Y-m-d'); // Check if the input value is a date having expected format. $isValid = $validator->isValid('2014-04-04'); // Returns true. $isValid2 = $validator->isValid('April 04, 2014'); // Returns false (format is unexpected).","title":"Date Validator"},{"location":"validators/#regex-validator","text":"This validator allows you to validate if a given string conforms some regular expression. It returns true if the string matches the regular expression, otherwise it returns false . On failure, error messages can be extracted with the validator's getMessages() method. The public methods provided by the @ Regex [Laminas\\Validator\\Regex] validator are listed in table 9.7: Method name Description __construct($options) Constructs the validator. Accepts the list of options. isValid($value) Returns true if and only if $value matches the given regular expression pattern. getMessages() If validation failed, this method will return an array of error messages. setPattern($pattern) Sets the regular expression pattern. getPattern() Retrieves the regular expression pattern. Table 9.7. Public methods of the Regex validator The setPattern() method allows to set the regular expression to match against. Note For regular expressions syntax and examples, it is recommended that your refer to the PCRE Patterns section of the PHP documentation. Below, a code example demonstrating the usage of the @ Regex [Laminas\\Validator\\Regex] validator is provided. It uses the regular expression to check if the input string is a valid IPv4 address (such address typically consists of four groups of digits separated with dots). <?php use Laminas\\Validator\\Regex; // Create Regex validator. $validator = new Regex(); // Set regular expression to check for an IP address. $validator->setPattern('\\b\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\b'); // Check for regular expression match. $isValid = $validator->isValid(\"127.0.0.1\"); // returns true. $isValid2 = $validator->isValid(\"123\"); // returns false.","title":"Regex Validator"},{"location":"validators/#validators-for-checking-if-a-numerical-value-lies-in-a-given-range","text":"In this section, we will consider usage examples of the validators from the group of validators designed for checking if input value lies in a given range.","title":"Validators for Checking if a Numerical Value Lies in a Given Range"},{"location":"validators/#notempty-validator","text":"The @ NotEmpty validator allows to check if input value is not empty. This is often useful when working with form elements or other user input, where you can use it to ensure required elements have values associated with them. The public methods provided by the @ NotEmpty validator are listed in table 9.8: Method name Description __construct($options) Constructs the validator. Accepts the list of options. isValid($value) Returns true if and only if $value is not an empty value. getMessages() If validation failed, this method will return an array of error messages. setType($type) Set the value types that to consider as empty values. getType() Returns the types. getDefaultType() Returns the default types. Table 9.8. Public methods of the NotEmpty validator The setType() method specifies which variable types to consider as an empty value. This method accepts the single argument $type which can be either an OR combination of the constants listed in table 9.9, or an array containing the literal equivalents of those constants. Constant Numeric Value Literal Equivalent Description BOOLEAN 1 \"boolean\" Consider boolean false as an empty value. INTEGER 2 \"integer\" Consider integer 0 as an empty value. FLOAT 4 \"float\" Consider float 0.0 as an empty value. STRING 8 \"string\" Consider empty string '' as an empty value. ZERO 16 \"zero\" Consider string containing the single character zero ('0') as an empty value. EMPTY_ARRAY 32 \"array\" Consider an empty array as an empty value. NULL 64 \"null\" Consider null as an empty value. PHP 127 \"php\" Consider the value empty if the empty() PHP function would return true on it. SPACE 128 \"space\" Consider a string which contains only white spaces as an empty value. OBJECT 256 \"object\" Returns true . false will be returned when object is not allowed but an object is given. OBJECT_STRING 512 \"objectstring\" Returns false when an object is given and it's __toString() method returns an empty string. OBJECT_COUNT 1024 \"objectcount\" Returns false when an object is given, it has an Countable interface and it's count is 0. ALL 2047 \"all\" Consider all above types as empty values. Table 9.9. Type constants Below, a code example demonstrating the usage of the @ NotEmpty validator is provided. <?php use Laminas\\Validator\\NotEmpty; // Create validator instance. $validator = new NotEmpty(); // Configure validator. $validator->setType(NotEmpty::ALL); // Check if input value not empty. $isValid1 = $validator->isValid('some string'); // returns true $isValid2 = $validator->isValid(''); // returns false $isValid3 = $validator->isValid(0); // returns false","title":"NotEmpty Validator"},{"location":"validators/#between-validator","text":"The @ Between [Laminas\\Validator\\Between] validator checks whether a number lies in a certain range (min, max), either inclusively (by default) or exclusively. The public methods provided by the @ Between [Laminas\\Validator\\Between] validator are listed in table 9.10: Method name Description __construct($options) Constructs the validator. Accepts the list of options. isValid($value) Returns true if and only if value's length is within the given range. getMessages() If validation failed, this method will return an array of error messages. setMin($min) Sets the minimum limit. getMin() Retrieves the minimum limit. setMax($max) Sets the maximum limit. getMax() Retrieves the maximum limit. setInclusive($inclusive) Sets whether to compare if the value lies in the given boundaries inclusively. getInclusive() Returns the inclusive option. Table 9.10. Public methods of the Between validator The range can be set with the setMin() and setMax() methods. By default, the validator performs inclusive comparisons (to check if the value belongs to the given range, it compares if the value is greater or equal to its lower bound, and if the value is lower or equal to its upper bound). You can change this with the setInclusive() method. It tells the validator whether to perform inclusive comparisons (pass true as the argument) or exclusive comparisons (pass false as the argument). Below, a code example demonstrating the usage of the @ Between [Laminas\\Validator\\Between] validator is provided. <?php use Laminas\\Validator\\Between; // Create validator instance. $validator = new Between(); // Configure validator. $validator->setMin(1); $validator->setMax(10); $validator->setInclusive(true); $isValid1 = $validator->isValid(5); // returns true. $isValid2 = $validator->isValid(10); // returns true. $isValid3 = $validator->isValid(0); // returns false (value is too small). $isValid4 = $validator->isValid(15); // returns false (value is too big).","title":"Between Validator"},{"location":"validators/#inarray-validator","text":"The @ InArray validator checks whether the input value belongs to the given array of values. The public methods provided by the @ InArray validator are listed in table 9.11: Method name Description __construct($options) Constructs the validator. Accepts the list of options. isValid($value) Returns true if and only if value belongs to the given array. getMessages() If validation failed, this method will return an array of error messages. setHaystack($haystack) Sets the array to search in. getHaystack() Returns the array of allowed values. setStrict($strict) Sets strict comparison mode. getStrict() Whether strict comparison mode enabled? setRecursive($recursive) Tells the validator to search recursively. getRecursive() Whether the recursive search is enabled? Table 9.11. Public methods of the InArray validator The setHaystack() method allows to set the array of allowed values. The isValid() method will search through this array for the presence of the input $value . If the array contains nested values and you want to search among them recursively, then use setRecursive() method. This method takes the single boolean flag. If the flag is true , than the search will be performed recursively; otherwise the nested levels will be ignored. The setStrict() method provides an ability to tell the validator how to compare the input value and the values in array. This may be a combination of the following constants: COMPARE_NOT_STRICT Do not perform strict check of variable type. COMPARE_NOT_STRICT_AND_PREVENT_STR_TO_INT_VULNERABILITY Do not perform strict check of variable type, but prevent false positive comparisons of string to integer (e.g. \"asdf\" == 0 ). This is the default option. COMPARE_STRICT Check both variable type and value. Below, a code example demonstrating the usage of the @ InArray validator is provided. <?php use Laminas\\Validator\\InArray; // Create validator instance. $validator = new InArray(); // Configure validator. $validator->setHaystack([1, 3, 5]); // Perform validation. $isValid1 = $validator->isValid(1); // returns true. $isValid2 = $validator->isValid(2); // returns false.","title":"InArray Validator"},{"location":"validators/#stringlength-validator","text":"The @ StringLength validator checks whether the input string length belongs to the given range, inclusively. It returns true if and only if the string length of value is at least the min option and no greater than the max option (when the max option is not null). The public methods provided by the @ StringLength validator are listed in table 9.12: Method name Description __construct($options) Constructs the validator. Accepts the list of options. isValid($value) Returns true if and only if value's length is within the given range. getMessages() If validation failed, this method will return an array of error messages. setMin($min) Sets the minimum limit. getMin() Retrieves the minimum limit. setMax($max) Sets the maximum limit. getMax() Retrieves the maximum limit. setEncoding($encoding) Sets a new encoding to use. getEncoding() Retrieves the encoding. Table 9.12. Public methods of the StringLength validator By default, the @ StringLength validator considers any string length as valid. Use the setMin() and/or setMax() methods to set lower and upper limits for the allowable string length. There are three possible ways you can do that: Use only the setMin() method to allow strings with a lower-bound minimum length, but unbound upper length; Use only the setMax() method to allow strings with zero minimum length and an upper-bound maximum length; Use both the setMin() and setMax() methods to allow strings with a length laying between the lower and upper bounds. By default, the PHP engine uses the UTF-8 encoding for strings. If your input string uses a different encoding, you should specify it encoding with the setEncoding() validator's method. Below, a code example demonstrating the usage of the @ StringLength validator is provided. <?php use Laminas\\Validator\\StringLength; // Create validator instance. $validator = new StringLength(); // Configure the validator. $validator->setMin(1); $validator->setMax(10); $isValid1 = $validator->isValid(\"string\"); // returns true. $isValid2 = $validator->isValid(\"\"); // returns false (value is too short). $isValid3 = $validator->isValid(\"a very long string\"); // returns false (value is too long).","title":"StringLength Validator"},{"location":"validators/#organizing-validators-in-a-chain","text":"Validators can be organized in a sequence. This is accomplished by the @ ValidatorChain [Laminas\\Validator\\ValidatorChain] class. When such a compound validator is run, the input value is passed to all validators in turn. The @ ValidatorChain [Laminas\\Validator\\ValidatorChain] validator's isValid() method returns true if all validators in the chain return true ; otherwise it returns false . Note The @ ValidatorChain [Laminas\\Validator\\ValidatorChain] class is internally used by the @ InputFilter [Laminas\\InputFilter\\InputFilter] container class for storing the sequence of validators attached to a form model's field. Public methods provided by the @ ValidatorChain [Laminas\\Validator\\ValidatorChain] class are presented in table 9.13: Method name Description isValid($value) Returns true if all validators in the chain return true . getMessages() Returns the array of validation error messages. getValidators() Returns the array of validators in the chain. count() Returns count of validators in the chain. attach($validator, $breakChainOnFailure) Attaches a validator to the end of the chain. prependValidator($validator, $breakChainOnFailure) Adds a validator to the beginning of the chain. attachByName($name, $options, $breakChainOnFailure) Use the plugin manager to add a validator by name. prependByName($name, $options, $breakChainOnFailure) Use the plugin manager to prepend a validator by name. merge($validatorChain) Merge the validator chain with the one given in parameter. Table 9.13. Public methods of the ValidatorChain validator An example validator chain is shown in figure 9.2. It consists of the @ NotEmpty validator followed by the @ StringLength validator, which in turn is followed by the @ Date [Laminas\\Validator\\Date] validator. When this chain is executed, first, the @ NotEmpty validator is run checking that the value is a non-empty value, then the @ StringLength validator is run checking that the length of the input string belongs to range (1, 16), inclusively, and finally, the @ Date [Laminas\\Validator\\Date] validator is run checking that the input value is a date in format \"YYYY-MM-DD\". To construct the filter chain like in figure 9.2, we can use the following code: <?php // Instantiate the validator chain. $validator = new \\Laminas\\Validator\\ValidatorChain(); // Insert validators into validator chain. $validator->attachByName('NotEmpty'); $validator->attachByName('StringLength', ['min'=>1, 'max'=>16]); $validator->attachByName('Date', ['format'=>'Y-m-d']); // Execute all validators in the chain. $isValid = $validator->isValid('2014-04-04'); // Returns true.","title":"Organizing Validators in a Chain"},{"location":"validators/#custom-validation-with-the-callback-validator","text":"The @ Callback [Laminas\\Validator\\Callback] validator can be a wrapper for your custom validation algorithm. For example, this may be useful when a standard validator is not suitable, and you need to apply your own checking algorithm to the data. The public methods provided by the @ Callback [Laminas\\Validator\\Callback] validator are listed in table 9.14. Class name Description isValid($value, $context) Executes a callback function as a validator. getMessages() If validation failed, this method will return an array of error messages. setCallback($callback) Sets a new callback for this filter. getCallback() Returns callback set for the filter. setCallbackOptions($options) Sets options for the callback. getCallbackOptions() Get parameters for the callback. Table 9.14. Public methods of the Callback validator As you can see from the table, the @ Callback [Laminas\\Validator\\Callback] validator provides the setCallback() and setCallbackOptions() methods that can be used to set the callback function or class method and (optionally) pass it one or several parameters.","title":"Custom Validation with the Callback Validator"},{"location":"validators/#example","text":"To demonstrate the usage of the @ Callback [Laminas\\Validator\\Callback] validator, let's add the phone number validator to our ContactForm form model class. The validator would check a telephone number entered by site visitor. The validator needs to be able to check for two common phone number formats: international format looking like \"1 (234) 567-8901\"; and local format, which looks like \"567-8901\". Because Laminas does not provide a standard validator for accomplishing such phone filtering operation, we will use the @ Callback [Laminas\\Validator\\Callback] wrapper validator. To do that, we will make the following changes to the code of our ContactForm class: <?php // ... class ContactForm extends Form { // .. protected function addElements() { // ... // Add \"phone\" field $this->add([ 'type' => 'text', 'name' => 'phone', 'attributes' => [ 'id' => 'phone' ], 'options' => [ 'label' => 'Your Phone', ], ]); } private function addInputFilter() { // ... $inputFilter->add([ 'name' => 'phone', 'required' => true, 'validators' => [ [ 'name' => 'Callback', 'options' => [ 'callback' => [$this, 'validatePhone'], 'callbackOptions' => [ 'format' => 'intl' ] ] ] ] ); } // Custom validator for a phone number. public function validatePhone($value, $context, $format) { // Determine the correct length and pattern of the phone number, // depending on the format. if($format == 'intl') { $correctLength = 16; $pattern = '/^\\d\\ (\\d{3}\\) \\d{3}-\\d{4}$/'; } else { // 'local' $correctLength = 8; $pattern = '/^\\d{3}-\\d{4}$/'; } // Check phone number length. if(strlen($value)!=$correctLength) return false; // Check if the value matches the pattern. $matchCount = preg_match($pattern, $value); return ($matchCount!=0)?true:false; } } In the code above, we create the phone field in our ContactForm (if you already have such field, just ignore this). In lines 26-40, we add the @ Callback [Laminas\\Validator\\Callback] validator to the input filter's validator chain for the \"phone\" field. In lines 44-64, we have the validatePhone() callback method. The method accepts three arguments: the $value parameter is the phone number to validate, the $context parameter receives the values of every field of the form (it may be needed for some validators to refer to the values of other form fields, too); and the $format parameter is the expected format of the phone number (\"intl\" or \"local\"). Inside of the callback method, we do the following: Calculate the correct length of the phone, check whether the length is correct for the selected phone number format. Match the phone number against the regular expression pattern for the selected phone format.","title":"Example"},{"location":"validators/#writing-own-validator","text":"An alternative of using the @ Callback [Laminas\\Validator\\Callback] validator is writing your own validator class implementing the @ ValidatorInterface [Laminas\\Validator\\ValidatorInterface] interface. Then, this validator may be used in forms of your web application. To demonstrate how to create your own validator, we will write the PhoneValidator class encapsulating the phone validation algorithm we used with the @ Callback [Laminas\\Validator\\Callback] validator example. As you might remember, the base concrete class for all standard validators is the @ AbstractValidator class. By analogy, we will also derive our custom PhoneValidator validator from that base class. We plan to have the following methods in our PhoneValidator validator class (see table 9.15): Method name Description __construct($options) Constructor. Accepts an optional argument $options which is needed to set validator options at once. setFormat($format) Sets the phone format option. getFormat() Returns the phone format option. isValid($value) Returns true when the value is a valid phone number; otherwise returns false . getMessages() If validation failed, this method will return an array of error messages. Table 9.15. Public methods of the Callback validator For the PhoneValidator , we will have three possible error messages: If a non-scalar value is passed to the validator, it will generate the error message \"The phone number must be a scalar value\"; If the international phone format is selected, and the phone number entered doesn't match this format, the validator will generate the message \"The phone number must be in international format\"; If the local phone format is selected and the phone number entered doesn't match the format, the validator will generate the message \"The phone number must be in local format\". To start, create the PhoneValidator.php file in the Validator directory under the module's source directory 10 . Put the following code into that file: <?php namespace Application\\Validator; use Laminas\\Validator\\AbstractValidator; // This validator class is designed for checking a phone number for // conformance to the local or to the international format. class PhoneValidator extends AbstractValidator { // Phone format constants. const PHONE_FORMAT_LOCAL = 'local'; // Local phone format. const PHONE_FORMAT_INTL = 'intl'; // International phone format. // Available validator options. protected $options = [ 'format' => self::PHONE_FORMAT_INTL ]; // Validation failure message IDs. const NOT_SCALAR = 'notScalar'; const INVALID_FORMAT_INTL = 'invalidFormatIntl'; const INVALID_FORMAT_LOCAL = 'invalidFormatLocal'; // Validation failure messages. protected $messageTemplates = [ self::NOT_SCALAR => \"The phone number must be a scalar value\", self::INVALID_FORMAT_INTL => \"The phone number must be in international format\", self::INVALID_FORMAT_LOCAL => \"The phone number must be in local format\", ]; // Constructor. public function __construct($options = null) { // Set filter options (if provided). if(is_array($options)) { if(isset($options['format'])) $this->setFormat($options['format']); } // Call the parent class constructor. parent::__construct($options); } // Sets phone format. public function setFormat($format) { // Check input argument. if($format!=self::PHONE_FORMAT_LOCAL && $format!=self::PHONE_FORMAT_INTL) { throw new \\Exception('Invalid format argument passed.'); } $this->options['format'] = $format; } // Validates a phone number. public function isValid($value) { if(!is_scalar($value)) { $this->error(self::NOT_SCALAR); return false; // Phone number must be a scalar. } // Convert the value to string. $value = (string)$value; $format = $this->options['format']; // Determine the correct length and pattern of the phone number, // depending on the format. if($format == self::PHONE_FORMAT_INTL) { $correctLength = 16; $pattern = '/^\\d \\(\\d{3}\\) \\d{3}-\\d{4}$/'; } else { // self::PHONE_FORMAT_LOCAL $correctLength = 8; $pattern = '/^\\d{3}-\\d{4}$/'; } // First check phone number length $isValid = false; if(strlen($value)==$correctLength) { // Check if the value matches the pattern. if(preg_match($pattern, $value)) $isValid = true; } // If there was an error, set error message. if(!$isValid) { if($format==self::PHONE_FORMAT_INTL) $this->error(self::INVALID_FORMAT_INTL); else $this->error(self::INVALID_FORMAT_LOCAL); } // Return validation result. return $isValid; } } From line 2, you can see that the validator class lives in the Application\\Validator namespace. In line 8, we define the PhoneValidator class. We derive our validator class from the AbstractValidator base class to reuse the functionality it provides. Line 4 contains the short alias for the @ AbstractValidator class. In lines 11-12, for convenience, we define the phone format constants ( PHONE_FORMAT_INTL for international format and PHONE_FORMAT_LOCAL for local format). These are the equivalents of the \"intl\" and \"local\" strings, respectively. In lines 15-17, we define the $options private array variable which is an array having the single key named \"format\". This key will contain the phone format option for our validator. In lines 20-22, we define the error message identifiers. We have three identifiers ( NOT_SCALAR , INVALID_FORMAT_INTL and INVALID_FORMAT_LOCAL ), because our validator may generate three different error messages. These identifiers are intended for distinguishing different error messages by machine, not by human. In lines 25-29, we have the $messageTemplates array variable that contains mapping before error message identifiers and their textual representations. The textual messages are intended for displaying to a human. In lines 32-43, we have the constructor method which takes the single argument $options . When constructing the validator manually, you may omit this parameter. But, when the validator is constructed by the factory class, the factory will pass validation options to validator's constructor through this argument. In lines 46-55, we have the setFormat() method that allow to set the current phone format, respectively. In lines 58-98, we have the isValid() method. This method encapsulates the phone number checking algorithm. It takes the $value parameter, performs the regular expression match, and returns true on success. On failure, the isValid() method it returns the boolean false , and the list of errors can be retrieved by the getMessages() method. Note You might notice that we didn't define the getMessages() method in our PhoneValidator class. This is because we inherited this method from the @ AbstractValidator base class. Inside of our isValid() method, for generating error messages, we also used the error() protected method provided by the base class (lines 61, 91, 93). Note The PhoneValidator is only for demonstration of how to write custom validators in Laminas. Implementing a validator that will work correctly against all possible phone numbers in the world is beyond the scope of this book. If you'd like to use this validator in a real-life app, you will definitely need to improve it. For example, take a look at the libphonenumber PHP library from Google.","title":"Writing Own Validator"},{"location":"validators/#using-the-phonevalidator-class","text":"When the PhoneValidator validator class is ready, you can easily start using it in the feedback form (or in another form) as follows. It is assumed that you call the following code inside of the ContactForm::addInputFilter() method: $inputFilter->add([ 'name' => 'phone', 'required' => true, 'validators' => [ [ [ 'name' => PhoneValidator::class, 'options' => [ 'format' => PhoneValidator::PHONE_FORMAT_INTL ] ], ], // ... ], // ... ]); You can see how the PhoneValidator validator works in the Form Demo sample application bundled with this book. Open the \"http://localhost/contactus\" page in your web browser. If you enter some phone number in an incorrect format, the validator will display an error (see figure 9.3). If you wish, you can use the PhoneValidator outside of forms, as shown in code example below: <?php use Application\\Validator\\PhoneValidator; // Create PhoneValidator validator $validator = new PhoneValidator(); // Configure the validator. $validator->setFormat(PhoneValidator::PHONE_FORMAT_INTL); // Validate a phone number $isValid = $validator->isValid('1 (234) 567-8901'); // Returns true. $isValid2 = $validator->isValid('12345678901'); // Returns false. if(!$isValid2) { // Get validation errors. $errors = $validator->getMessages(); }","title":"Using the PhoneValidator Class"},{"location":"validators/#using-filters-validators-outside-a-form","text":"In this section, we will provide an example of how you can use filters and/or validators in your controller to transform and check the data extracted from GET and/or POST variables. Let's assume we implement a payment gateway system and need to create a web page displaying a payment history for the given credit card on given date. This page can be handled by some paymentHistoryAction() action of a controller class, and the credit card number and date will be extracted from GET variables. For the paymentHistoryAction() method, we need to implement some security checks: we want to ensure that the credit card number looks like a typical credit card number \"4532-7103-4122-1359\" (conforms to ISO/IEC 7812 standard); and that the date is in 'YYYY-MM-DD' format. Below, you can find the code of the action method: <?php namespace Application\\Controller; use Laminas\\Mvc\\Controller\\AbstractActionController; use Laminas\\View\\Model\\ViewModel; use Laminas\\Filter\\StaticFilter; use Laminas\\Validator\\StaticValidator; class IndexController extends AbstractActionController { // An action which shows the history of a credit // card operations on certain date. public function paymentHistoryAction() { // Get parameters from GET. $cardNumber = (string)$this->params()->fromQuery('card', ''); $date = (string)$this->params()->fromQuery('date', date(\"Y-m-d\")); // Validate credit card number. $isCardNumberValid = StaticValidator::execute($cardNumber, 'CreditCard'); if(!$isCardNumberValid) { throw new \\Exception('Not a credit card number.'); } // Convert date to the right format. $date = StaticFilter::execute($date, 'DateTimeFormatter', ['format'=>'Y-m-d']); // The rest of action code goes here... return new ViewModel(); } } Inside the action method, we use the params() controller plugin (lines 16-17) to retrieve two variables from $_GET super-global array: the card variable (credit card number) and the date variable (the date). In line 20, we validate the credit card number with the help of the CreditCard validator. If the card number is not acceptable, we throw an exception indicating an error (line 22). In line 26, we use the DateTimeFormatter filter to convert the date to the right format.","title":"Using Filters &amp; Validators Outside a Form"},{"location":"validators/#summary","text":"Validators are designed to take some input data, check it for correctness, and return a boolean result telling whether the data is correct (and error messages if the data has some errors). In Laminas Framework, there are several groups of standard validators: validators for checking value conformance to certain format; validators for checking a numerical value lies in a given range; validators working as \"proxies\" to other validators. In some cases, a standard validator is not suitable, and you need to apply your own checking algorithm to the input data. In such case, you may use either the @ Callback [Laminas\\Validator\\Callback] validator or write your own custom validator class. Here, we only consider the standard validator classes belonging to the @ Laminas\\Validator namespace. But, actually there are more validators that can be considered as standard. We will cover them in further chapters. \u21a9 An MX record is a type of record used in the Domain Name System (DNS). MX records define one or several mail server addresses assigned to recipient's domain. \u21a9 The ALLOW_ -prefixed constants are provided by the @ Hostname [Laminas\\Validator\\Hostname] validator. \u21a9 An Internet Protocol version 4 (IPv4) address typically consists of four octets of the address expressed separated by periods, like \"192.168.56.101\". \u21a9 An Internet Protocol version 6 (IPv6) address typically consists of eight groups of four hexadecimal digits separated by colons, such as \"2001:0db8:85a3:0000:0000:8a2e:0370:7334\". \u21a9 IPvFuture is loosely defined in the Section 3.2.2 of RFC 3986. \u21a9 A literal IPv6 address is a modification of a usual IPv6 address for using inside of a URL. (The problem with original IPv6 addresses is that the \":\" and \".\" characters are delimiters in URLs.) \u21a9 An internationalized domain name (IDN) is an Internet domain name that contains at least one label that is displayed, in whole or in part, in a language-specific script or alphabet, like Arabic, Chinese or Russian. \u21a9 A Uniform Resource Identifier (URI) is a compact sequence of characters that identifies an abstract or physical resource. An Uniform Resource Locator (URL) is a type of URI. But, that doesn't mean all URIs are URLs. \u21a9 The PhoneValidator class may be considered as a service model, because its goal is to process data, not to store it. By convention, we store custom validators under the Validator directory. \u21a9","title":"Summary"}]}