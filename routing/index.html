<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><link rel="canonical" href="https://modir.github.io/routing/" />
      <link rel="shortcut icon" href="../img/favicon.ico" />
    <title>Routing - Using Laminas Framework</title>
    <link rel="stylesheet" href="../css/theme.css" />
    <link rel="stylesheet" href="../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "Routing";
        var mkdocs_page_input_path = "routing.md";
        var mkdocs_page_url = "/routing/";
      </script>
    
    <!--[if lt IE 9]>
      <script src="../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
      <script>hljs.highlightAll();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href=".." class="icon icon-home"> Using Laminas Framework
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="..">Preface</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../intro/">None</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../acknowledgments/">Acknowledgments</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../intro/">Introduction to Laminas Framework</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../skeleton/">Laminas Skeleton Application</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../operation/">Website Operation</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../mvc/">Model-View-Controller</a>
                </li>
              </ul>
              <ul class="current">
                <li class="toctree-l1 current"><a class="reference internal current" href="./">Routing</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#url-structure">URL Structure</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#route-types">Route Types</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#combining-route-types">Combining Route Types</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#simple-route-stack">Simple Route Stack</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#tree-route-stack">Tree Route Stack</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#routing-configuration">Routing Configuration</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#configuration-for-simple-routes">Configuration for Simple Routes</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#configuration-for-nested-routes">Configuration for Nested Routes</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#default-routing-configuration-in-laminas-skeleton-application">Default Routing Configuration in Laminas Skeleton Application</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#literal-route-type">Literal Route Type</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#segment-route-type">Segment Route Type</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#regex-route-type">Regex Route Type</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#other-route-types">Other Route Types</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#hostname">Hostname</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#scheme">Scheme</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#method">Method</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#extracting-parameters-from-route">Extracting Parameters from Route</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#retrieving-the-routematch-and-the-router-object">Retrieving the RouteMatch and the Router Object</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#generating-urls-from-route">Generating URLs from Route</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#generating-urls-in-view-templates">Generating URLs in View Templates</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#passing-parameters">Passing Parameters</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#generating-absolute-urls">Generating Absolute URLs</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#specifying-query-part">Specifying Query Part</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#generating-urls-in-controllers">Generating URLs in Controllers</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#url-encoding">URL Encoding</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#writing-own-route-type">Writing Own Route Type</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#routeinterface">RouteInterface</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#custom-route-class">Custom Route Class</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#summary">Summary</a>
    </li>
    </ul>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../appearance/">Page Appearance and Layout</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../forms/">Collecting User Input with Forms</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../filters/">Transforming Input Data with Filters</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../validators/">Checking Input Data with Validators</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../uploads/">Uploading Files with Forms</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../forms_advanced/">Advanced Usage of Forms</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../doctrine/">Database Management with Doctrine ORM</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../doctrine_migrations/">Database Migrations</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../modules/">Creating a New Module</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../session/">Working with Sessions</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../users/">User Management, Authentication and Access Filtering</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../roles/">Role-Based Access Control</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../devenv/">Appendix A. Configuring Web Development Environment</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../netbeans/">Appendix B. Introduction to PHP Development in NetBeans IDE</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../bootstrap/">Appendix C. Introduction to Twitter Bootstrap</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../doctrine_intro/">Appendix D. Introduction to Doctrine</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../ec2_tutorial/">Appendix E. Installing a Laminas Web Application to Amazon EC2</a>
                </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="..">Using Laminas Framework</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href=".." class="icon icon-home" aria-label="Docs"></a></li>
      <li class="breadcrumb-item active">Routing</li>
    <li class="wy-breadcrumbs-aside">
          <a href="https://github.com/modir/laminas-book/edit/main/docs/routing.md" class="icon icon-github"> Edit on GitHub</a>
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="routing">Routing</h1>
<p>When a site user enters a URL in a web browser, the HTTP request is finally dispatched to
controller's action in your laminas-based website. In this chapter, we will learn about how laminas-based application maps page URLs to
controllers and their actions. This mapping is accomplished with the help of routing.
Routing is implemented as a part of @<code>Laminas\Router</code> component.</p>
<p>Laminas components covered in this chapter:</p>
<table>
<thead>
<tr>
<th><em>Component</em></th>
<th><em>Description</em></th>
</tr>
</thead>
<tbody>
<tr>
<td>@<code>Laminas\Router</code></td>
<td>Implements support of routing.</td>
</tr>
<tr>
<td>@<code>Laminas\Barcode</code></td>
<td>Auxiliary component implementing barcodes.</td>
</tr>
</tbody>
</table>
<h2 id="url-structure">URL Structure</h2>
<p>To better understand routing, we first need to look at the URL structure.
A typical URL from an HTTP request consists of several parts. There are scheme, host name, path, fragment and query
parts.</p>
<p>For example, let's look at the URL "http://site1.yourserver.com/path/to/page?a=1&amp;b=2#section" (figure 5.1).</p>
<p><img alt="Figure 5.1. Typical URL structure" src="../images/routing/url_segments.png" /></p>
<p>This URL begins with the scheme (the scheme typically looks like <em>http</em> or <em>https</em>).
Then, the host name follows which is the domain name of your web server (like <em>site1.yourserver.com</em>).
Optional path segments (separated by '/' character) follow the host name. So if you have the path part "/path/to/page" then
"path", "to", and "page" would each be a path segment. Next, after the question mark,
the optional query part follows. It consists of one or several "name=value" parameters separated
from each other by an ampersand character ('&amp;'). Finally, after the hash ('#'), we have the fragment name.</p>
<p>Each part in a URL uses special character encoding, which is named the <em>URL encoding</em>.
This encoding ensures that the URL contains only "safe" characters from the ASCII <sup id="fnref:ascii"><a class="footnote-ref" href="#fn:ascii">1</a></sup> table. If a URL contains
unsafe characters, they are replaced with a percentage character ('%') followed by two
hexadecimal digits (for example, the space character will be replaced by '%20').</p>
<h2 id="route-types">Route Types</h2>
<p><em>Routing</em> is a mechanism which allows to map HTTP request to a controller's action.
With routing, Laminas knows which of the controller's action method to execute
as the result of the request. For example, you can map "http://localhost/" URL to <code>IndexController::indexAction()</code> method,
and "http://localhost/about" URL to <code>IndexController::aboutAction()</code> method.</p>
<blockquote>
<p>You define the mapping between URLs and controllers with the help of <em>routes</em>.</p>
</blockquote>
<p>There are several standard route types provided by Laminas Framework (shown in table 5.1).
These route types are implemented as classes living in the @<code>Laminas\Router\Http</code>[Laminas\Router] namespace.</p>
<table>
<thead>
<tr>
<th><em>Route Type</em></th>
<th><em>Description</em></th>
</tr>
</thead>
<tbody>
<tr>
<td><em>Literal</em></td>
<td>Exact matching against the path part of a URL.</td>
</tr>
<tr>
<td><em>Segment</em></td>
<td>Matching against a path segment (or several segments) of a URL.</td>
</tr>
<tr>
<td><em>Regex</em></td>
<td>Matching the path part of a URL against a regular expression template.</td>
</tr>
<tr>
<td><em>Hostname</em></td>
<td>Matching the host name against some criteria.</td>
</tr>
<tr>
<td><em>Scheme</em></td>
<td>Matching URL scheme against some criteria.</td>
</tr>
<tr>
<td><em>Method</em></td>
<td>Matching an HTTP method (e.g. GET, POST, etc.) against some criteria.</td>
</tr>
</tbody>
</table>
<p>Table 5.1. Route Types</p>
<p>Each route type in the table above (except the <em>Method</em> type) may be matched against a specific part
(or several parts) of a URL. The <em>Method</em> route type is matched against the HTTP method (either GET
or POST) retrieved from HTTP request.</p>
<h2 id="combining-route-types">Combining Route Types</h2>
<p>Routes may be combined with the help of "aggregate" route types (shown in table 5.2).
The compound route types allow to define arbitrarily complex URL mapping rules.</p>
<table>
<thead>
<tr>
<th><em>Route Type</em></th>
<th><em>Description</em></th>
</tr>
</thead>
<tbody>
<tr>
<td><em>SimpleRouteStack</em></td>
<td>Aggregates different route types in a list with priorities.</td>
</tr>
<tr>
<td><em>TreeRouteStack</em></td>
<td>Aggregates different route types in a tree-like structure.</td>
</tr>
<tr>
<td><em>Part</em></td>
<td>Aggregates different route types in a subtree.</td>
</tr>
<tr>
<td><em>Chain</em></td>
<td>Aggregates different route types in a chain (degenerated subtree).</td>
</tr>
</tbody>
</table>
<p>Table 5.2. Aggregate Route Types</p>
<p>The @<code>TreeRouteStack</code>[Laminas\Router\Http\TreeRouteStack] and @<code>SimpleRouteStack</code>[Laminas\Router\SimpleRouteStack] are used as the "top-level" route types.
The <em>SimpleRouteStack</em> allows to organize different routes in a priority list.
The <em>TreeRouteStack</em> allows to <em>nest</em> different routes, forming a "tree".</p>
<p>Figure 5.2 shows the route class inheritance diagram.</p>
<p><img alt="Figure 5.2. Route class inheritance diagram" src="../images/routing/route_inheritance.png" /></p>
<p>As you can see from the image, all route classes are inherited from @<code>RouteInterface</code>[Laminas\Router\RouteInterface] interface (we
will learn this interface in details in the <em>Writing Own Route Type</em> section later in this
chapter). The @<code>SimpleRouteStack</code>[Laminas\Router\SimpleRouteStack] is a parent class for @<code>TreeRouteStack</code>[Laminas\Router\Http\TreeRouteStack] class, which
inherits the behavior of the simple route stack (allows to organize routes in priority list) and
extends it (allows to organize routes in subtrees). The @<code>Part</code>[Laminas\Router\Http\Part] and @<code>Chain</code>[Laminas\Router\Http\Chain] classes are
derived from @<code>TreeRouteStack</code>[Laminas\Router\Http\TreeRouteStack] class and are used internally by the @<code>TreeRouteStack</code>[Laminas\Router\Http\TreeRouteStack] for building
subtrees and chains of child routes.</p>
<h3 id="simple-route-stack">Simple Route Stack</h3>
<p>The @<code>SimpleRouteStack</code>[Laminas\Router\SimpleRouteStack] allows to combine different routes in a priority list.
For an example of such a list, look at the route stack in the left part of figure 5.3.
The example list contains several <em>Literal</em> routes and several <em>Segment</em> routes.</p>
<p>When matching against the HTTP request, the @<code>SimpleRouteStack</code>[Laminas\Router\SimpleRouteStack] walks through the list
of routes and tries to match each route in turn. Each route in the list has a priority;
the routes with the higher priority are visited first. The lookup is finished once some route matches
the HTTP request. If none of the routes match, the "not found" error is raised.</p>
<p><img alt="Figure 5.3. An example of Simple Route Stack (left) and Tree Route Stack (right)" src="../images/routing/route_tree.png" /></p>
<h3 id="tree-route-stack">Tree Route Stack</h3>
<p>The @<code>TreeRouteStack</code>[Laminas\Router\Http\TreeRouteStack] class extends the @<code>SimpleRouteStack</code>[Laminas\Router\SimpleRouteStack] class, which means it can
organize routes in a priority list, plus it provides an ability to nest routes in subtrees
and chains. An example tree route stack is presented in the right part of figure 5.3.
The list contains of one @<code>Literal</code>[Laminas\Router\Http\Literal] route, a chain of @<code>Literal</code>[Laminas\Router\Http\Literal] and @<code>Segment</code> routes,
and a subtree consisting of two branches: a branch containing a single @<code>Segment</code> route,
and a branch consisting of @<code>Scheme</code>, @<code>Hostname</code>[Laminas\Router\Http\Hostname] and @<code>Segment</code> routes.</p>
<p>The tree route stack performs request matching in the following way. It walks through
its priority list items (denoted by dashed lines in figure 5.3), starting from high-priority routes. If a certain item is
a @<code>Chain</code>[Laminas\Router\Http\Chain] route or a @<code>Part</code>[Laminas\Router\Http\Part] route, it processes such a nested route from its parent route to children.
If the parent route matches, the children (denoted with solid lines) are analyzed then. The nested route is considered matching
if at least one route matches in each tree (or chain) level.</p>
<p>Each route in a tree (or chain) consumes a part of the URL (figure 5.4). The parent route is matched against the
first part of the URL, its child is matched again
the next part, and so on, until the end of the URL string
is reached.</p>
<p><img alt="Figure 5.4. An example of nested route matching" src="../images/routing/route_matching.png" /></p>
<h2 id="routing-configuration">Routing Configuration</h2>
<p>You typically do not create the route stack (or tree) yourself, instead you provide the
instructions for Laminas on how to do that.</p>
<p>The routing configuration for a module is stored in <em>module.config.php</em> configuration file:</p>
<pre><code class="language-php">&lt;?php
use Laminas\Router\Http\TreeRouteStack;

return [
    //...
    'router' =&gt; [
        'router_class' =&gt; TreeRouteStack::class,
        'routes' =&gt; [
            // Register your routing rules here...
        ],
        'default_params' =&gt; [
            // Specify default parameters here for all routes here ...
        ]
    ],
];
</code></pre>
<p>Above, in line 6 we have the <em>router</em> key, under which there is the <em>routes</em> subkey (line 8),
containing the routing rules.</p>
<p>You can specify which top-level route class to use (either @<code>TreeRouteStack</code>[Laminas\Router\Http\TreeRouteStack] or @<code>SimpleRouteStack</code>[Laminas\Router\SimpleRouteStack])
with the <code>router_class</code> parameter (line 7). If this parameter is not present,
the @<code>TreeRouteStack</code>[Laminas\Router\Http\TreeRouteStack] is used by default.</p>
<p>You can use the optional <code>default_params</code> key (line 11) to define the <em>default values</em> for parameters
for all routes at once. However, you typically do not use this key and define
the defaults on a per-route basis.</p>
<blockquote>
<p>We will show how you extract parameters from route later in this chapter.</p>
</blockquote>
<h3 id="configuration-for-simple-routes">Configuration for Simple Routes</h3>
<p>A typical route has the <em>name</em>, <em>type</em> and <em>options</em>:</p>
<ul>
<li>The <em>name</em> is used to uniquely identify the route.</li>
<li>The <em>type</em> defines the fully qualified name of the route type (PHP class which implements
    the matching algorithm).</li>
<li>The <em>options</em> is an array that includes the <em>route</em>
    string which should be compared against the URL part, and several parameters called the <em>defaults</em>.</li>
</ul>
<p>Configuration for each route under the <code>routes</code> subkey may have the following format:</p>
<pre><code class="language-php">'&lt;route_name&gt;' =&gt; [
    'type' =&gt; '&lt;route_type_class&gt;',
    'priority' =&gt; &lt;priority&gt;,
    'options' =&gt; [
        'route' =&gt; '&lt;route&gt;',
        'defaults' =&gt; [
            //...
        ],
    ],
]
</code></pre>
<p>Above, the <code>&lt;route_name&gt;</code> placeholder should be the name of the route. A route name must be in lower case,
like "home" or "about". The <code>type</code> key specifies the fully qualified route class name.</p>
<p>The optional <code>priority</code> key allows to define the priority (which should be an integer number)
of the route in the priority list (routes with higher priority will be visited first). If you
omit the <code>priority</code> key, the routes will be visited in the LIFO <sup id="fnref:lifo"><a class="footnote-ref" href="#fn:lifo">2</a></sup> order.</p>
<blockquote>
<p>Routes having equal priority will be visited in the LIFO order. Thus, for the best performance, you should
register routes that will match most often in the last turn, and least common routes should be registered first.</p>
</blockquote>
<p>The <code>options</code> key defines the array of route's options. We will discuss the options
in the following sections of this chapter.</p>
<h3 id="configuration-for-nested-routes">Configuration for Nested Routes</h3>
<p>To organize routes in a subtree, you add the <code>child_routes</code> key to the route definition,
and add your child routes under that key, like below:</p>
<pre><code class="language-php">'&lt;route_name&gt;' =&gt; [
    'type' =&gt; '&lt;route_type_class&gt;',
    'priority' =&gt; &lt;priority&gt;,
    'options' =&gt; [
        //...
    ],
    'child_routes' =&gt; [
        // Add child routes here.
        // ...
    ]
],
</code></pre>
<p>If you need to organize the routes in a chain (degenerated subtree), you add the
<code>chain_routes</code> key to your route configuration:</p>
<pre><code class="language-php">'&lt;route_name&gt;' =&gt; [
    'type' =&gt; '&lt;route_type_class&gt;',
    'priority' =&gt; &lt;priority&gt;,
    'options' =&gt; [
        //...
    ],
    'chain_routes' =&gt; [
        // Add chained routes here.
        // ...
    ]
],
</code></pre>
<blockquote>
<p>Looking at the two examples above, you won't see the explicit usage of @<code>Part</code>[Laminas\Router\Http\Part] and
@<code>Chain</code>[Laminas\Router\Http\Chain] route types, because (for your convenience) they are used by the Laminas automatically when
it encounters the <code>child_routes</code> and <code>chain_routes</code> keys in your routing configuration.</p>
</blockquote>
<h3 id="default-routing-configuration-in-laminas-skeleton-application">Default Routing Configuration in Laminas Skeleton Application</h3>
<p>Now that you know how to configure routes and organize them in compound structures,
let's look at the real life example. In a fresh Laminas Skeleton Application, the routing
configuration looks like below:</p>
<pre><code class="language-php">&lt;?php
use Laminas\Router\Http\Literal;
use Laminas\Router\Http\Segment;

return [
    'router' =&gt; [
        'routes' =&gt; [
            'home' =&gt; [
                'type' =&gt; Literal::class,
                'options' =&gt; [
                    'route'    =&gt; '/',
                    'defaults' =&gt; [
                        'controller' =&gt; Controller\IndexController::class,
                        'action'     =&gt; 'index',
                    ],
                ],
            ],
            'application' =&gt; [
                'type'    =&gt; Segment::class,
                'options' =&gt; [
                    'route'    =&gt; '/application[/:action]',
                    'defaults' =&gt; [
                        'controller'    =&gt; Controller\IndexController::class,
                        'action'        =&gt; 'index',
                    ],
                ],
            ],
        ],
    ],

  //...
];
</code></pre>
<p>In the configuration presented above, we have two routing rules listed in turn:
first we have the "home" route (line 8) and then we have the "application" route (line 18).</p>
<p>The "home" route maps the empty URL path to the "index" action of the <code>IndexController</code> controller. For example,
enter "http://localhost/" in your browser to see the Home page of your website. This route
is of type "Literal".</p>
<p>The "application" route (of type "Segment") maps URLs looking like "http://localhost/application",
"http://localhost/application/about", "http://localhost/application/news", etc onto the corresponding
action of the <code>IndexController</code> controller. The actual action name is determined by the "action" parameter.
The default value for this parameter is "index". That means that if you do not specify any action, the request
will be dispatched to "index" action.</p>
<p>This configuration corresponds to the tree route stack shown in figure 5.5:</p>
<p><img alt="Figure 5.5. Default route stack in the Skeleton Application" src="../images/routing/skeleton_route_tree.png" /></p>
<p>In the next sections, we will provide some examples on how to use the route types
in your website.</p>
<h2 id="literal-route-type">Literal Route Type</h2>
<p>With <em>Literal</em> route type, the route match is achieved only when you have the
exact match of the route string against the URL path part. You typically use the <em>Literal</em> type
for URLs which should be short and memorable, like '/about' or '/news'.</p>
<p>Below, the definition of the route named "home" is presented. The "home" route is
usually mapped to the "index" action of the <code>IndexController</code> and points to the <em>Home</em> page of
your site:</p>
<pre><code class="language-php">'home' =&gt; [
    'type' =&gt; Literal::class,
    'options' =&gt; [
        'route'    =&gt; '/',
        'defaults' =&gt; [
            'controller' =&gt; Controller\IndexController::class,
            'action'     =&gt; 'index',
        ],
    ],
],
</code></pre>
<p>Line 2 of this example says that the route's type is <em>Literal</em>. The actual
route matching algorithm is implemented in the @<code>Laminas\Router\Http\Literal</code>
class.</p>
<p>Line 4 defines the route string to match against the URL path (the forward slash '/' means the empty URL part).
Because we have the literal route type, the route match is achieved only when you have the
exact literal path match. For example, if you have the URL "http://localhost/" or "http://localhost",
it will match the '/' route string.</p>
<p>Lines 5-8 define the <code>defaults</code>, which are the parameters returned by the router
if the route matches. The <code>controller</code> and <code>action</code> parameters define the controller
and controller's action method which should be executed. You can also define other
parameters here, if needed.</p>
<p>As another example of the <em>Literal</em> route type, let's add the '/about' route for the <em>About</em> page we've
created earlier in the <em>Views</em> section of the chapter <a href="#mvc">Model-View-Controller</a>. To create the route, add
the following lines right after the "home" route definition inside of your
<em>module.config.php</em> file:</p>
<pre><code class="language-php">'about' =&gt; [
    'type' =&gt; Literal::class,
    'options' =&gt; [
        'route' =&gt; '/about',
        'defaults' =&gt; [
            'controller' =&gt; Controller\IndexController::class,
            'action'     =&gt; 'about',
        ],
    ],
],
</code></pre>
<p>If you now open the "http://localhost/about" URL in your web browser, you should
see the <em>About</em> page.</p>
<h2 id="segment-route-type">Segment Route Type</h2>
<p>The <em>Segment</em> route type allows for matching the route string against one
or several URL path segments.</p>
<blockquote>
<p>If you look at the <em>module.config.php</em> file, you can see the <em>Segment</em> route type is
used inside of the "application" route to make actions of your <code>IndexController</code>
automatically mapped to site URLs. You just add an action method to your <code>IndexController</code> class,
and it becomes available by a URL like "http://localhost/application/&lt;action&gt;".
For example, you can see the <em>About</em> page of your site with the following URL:
"http://localhost/application/about".</p>
</blockquote>
<p>To demonstrate the creation of the <em>Segment</em> route type, let's implement
a controller action which will generate a simple barcode image.
Barcodes are widely used in supermarkets for optically recognizing goods in your
shopping cart. The barcodes may be of different types and have different
labels. We will use the <em>Segment</em> route type to map the action to a URL like
"http://localhost/barcode/&lt;type&gt;/&lt;label&gt;".</p>
<blockquote>
<p>To be able to use barcodes, you need to install the @<code>Laminas\Barcode</code> component with Composer, by
typing the following command:</p>
<p><code>php composer.phar require laminas/laminas-barcode</code></p>
</blockquote>
<p>W&gt; Please note that for barcode images to work, you need to have the GD<sup id="fnref:gd"><a class="footnote-ref" href="#fn:gd">3</a></sup> extension
W&gt; of the PHP engine installed and enabled. In Linux Ubuntu, you can install this extension with the
W&gt; following command:
W&gt;
W&gt; <code>sudo apt-get install php-gd</code>
W&gt;
W&gt; After installing the extension, restart Apache to apply your changes.</p>
<p>First, we define the "barcode" route in the <em>module.config.php</em> file:</p>
<pre><code class="language-php">'barcode' =&gt; [
    'type' =&gt; Segment::class,
    'options' =&gt; [
        'route' =&gt; '/barcode[/:type/:label]',
        'constraints' =&gt; [
            'type' =&gt; '[a-zA-Z][a-zA-Z0-9_-]*',
            'label' =&gt; '[a-zA-Z0-9_-]*'
        ],
        'defaults' =&gt; [
            'controller' =&gt; Controller\IndexController::class,
            'action' =&gt; 'barcode',
        ],
    ],
],
</code></pre>
<p>Segments of the route string (line 4) may be constant or variable. You can define the variable
segments by using "wildcards". We have three segments: <code>barcode</code>, <code>:type</code> and <code>:label</code>.
The <code>barcode</code> segment is constant, while the latter two are wildcards (wildcard's name
should start with a colon).</p>
<p>You specify how a wildcard should look like inside of the <code>constraints</code> subkey (lines 5-8).
We define the regular expression <code>[a-zA-Z][a-zA-Z0-9_-]*</code> which constraints our <code>:type</code>
wildcard to begin with a letter and (optionally) contain several letters, digits,
underscores or minus characters. The constraint for the <code>:label</code> wildcard is almost the same,
but this segment can start with any allowed character (either letter, digit, underscore or minus sign character).</p>
<p>Optional segments can be enclosed in square brackets. In our example, we
have both the <code>:type</code> and <code>:label</code> segments as optional.</p>
<p>In lines 9-12, we define the <code>defaults</code>, the parameters that will be returned by the router.
The <code>controller</code> and <code>action</code> defaults specify which controller and action method to
execute on route match.</p>
<p>Next, we add the <code>barcodeAction()</code> method into the <code>IndexController</code> class:</p>
<pre><code class="language-php">// Add name alias in the beginning of the file
use Laminas\Barcode\Barcode;

// ...

// The &quot;barcode&quot; action
public function barcodeAction()
{
  // Get parameters from route.
    $type = $this-&gt;params()-&gt;fromRoute('type', 'code39');
    $label = $this-&gt;params()-&gt;fromRoute('label', 'HELLO-WORLD');

    // Set barcode options.
    $barcodeOptions = ['text' =&gt; $label];
    $rendererOptions = [];

    // Create barcode object
    $barcode = Barcode::factory($type, 'image',
                 $barcodeOptions, $rendererOptions);

    // The line below will output barcode image to standard
    // output stream.
    $barcode-&gt;render();

    // Return Response object to disable default view rendering.
    return $this-&gt;getResponse();
}
</code></pre>
<p>In lines 10-11 we get the values of the <code>type</code> and <code>label</code> wildcards
from route. We do that with the help of @<code>Params</code> controller plugin's
<code>fromRoute()</code> method. Analogous to <code>fromQuery()</code> method, it takes
two arguments: the variable name and its default value.</p>
<p>For generating the barcode image, we use the @<code>Laminas\Barcode</code> component.
In line 14 we define the label text for the barcode. In lines 18-19 we
create the @<code>Barcode</code>[Laminas\Barcode\Barcode] object with the factory method. Finally, in line 23 we
render the image file by dumping it to PHP output stream.</p>
<blockquote>
<p>@<code>Laminas\Barcode</code> is an auxiliary component used for generation of various
barcode images. For additional information about this component, please
refer to the corresponding section of Laminas Framework reference manual.</p>
</blockquote>
<p>In line 26 we return the @<code>Response</code>[Laminas\Http\PhpEnvironment\Response] object to suppress the default view rendering.</p>
<p>Now, enter the "http://localhost/barcode" URL into your browser to see
the barcode image (shown in figure 5.6):</p>
<p><img alt="Figure 5.6. An example barcode image" src="../images/routing/barcode.png" /></p>
<p>Because we have the wildcards in the route, you can pass the type and label
parameters of the barcode image in the URL. Below, several
URL examples are provided (corresponding barcodes are presented in figure
5.7):</p>
<pre><code>a. http://localhost/barcode/code39/HELLO-WORLD
b. http://localhost/barcode/leitcode/12345
c. http://localhost/barcode/identcode/98765453212
d. http://localhost/barcode/postnet/123456
e. http://localhost/barcode/planet/1234567890123
f. http://localhost/barcode/upca/12345678901
g. http://localhost/barcode/code128/ABCDEF
h. http://localhost/barcode/ean2/12
</code></pre>
<p><img alt="Figure 5.7. Barcode types" src="../images/routing/barcodes.png" /></p>
<h2 id="regex-route-type">Regex Route Type</h2>
<p>The regular expression route type (<em>Regex</em>) is useful if you have URLs which can be
matched against a regular expression.</p>
<p>For example, assume you want to create a simple documentation system for your website.
The documentation would consist of "static" pages mapped to URLs like <em>/doc/&lt;page_name&gt;.html</em>.</p>
<blockquote>
<p>By the term "static page" we refer to a page which mostly contains static HTML code
plus several PHP inline fragments. For such simple pages you do not need to create
separate controller actions. All "static" pages can be served by the single controller action.</p>
</blockquote>
<p>Let's implement the route which will serve the "static" pages of the site. Because "static"
pages are simple, you typically won't need to add per-page action methods
to the controller. All pages will be handled by the single action <code>IndexController::docAction()</code>.</p>
<p>First, we add the <em>Regex</em> route named "doc" to the <em>module.config.php</em> file:</p>
<pre><code class="language-php">'doc' =&gt; [
    'type' =&gt; Regex::class,
    'options' =&gt; [
        'regex'    =&gt; '/doc(?&lt;page&gt;\/[a-zA-Z0-9_\-]+)\.html',
        'defaults' =&gt; [
            'controller' =&gt; Controller\IndexController::class,
            'action'     =&gt; 'doc',
        ],
        'spec'=&gt;'/doc/%page%.html'
    ],
],
</code></pre>
<p>Line 2 defines the <em>Regex</em> type for the route. In line 4, we
have the regular expression <code>/doc(?&lt;page&gt;\/[a-zA-Z0-9_\-]+)\.html</code>.
It will match to URLs like "/doc/contents.html", "/docs/introduction.html" and so on.
The expression contains the named capture <sup id="fnref:capture"><a class="footnote-ref" href="#fn:capture">4</a></sup> "page", which will be returned by
the router on match together with the default parameters.</p>
<p>Line 9 contains <code>spec</code> option, which is used for generating URLs by route (we will discuss generating URLs
by route later in this chapter).</p>
<blockquote>
<p>Do not forget to add the following line to the beginning of <code>module.config.php</code> file:</p>
<p><code>use Laminas\Router\Http\Regex;</code></p>
</blockquote>
<p>Next, add the following action to <code>IndexController</code> class:</p>
<pre><code class="language-php">public function docAction()
{
    $pageTemplate = 'application/index/doc'.
        $this-&gt;params()-&gt;fromRoute('page', 'documentation.phtml');

    $filePath = __DIR__.'/../../view/'.$pageTemplate.'.phtml';
    if(!file_exists($filePath) || !is_readable($filePath)) {
        $this-&gt;getResponse()-&gt;setStatusCode(404);
        return;
    }

    $viewModel = new ViewModel([
            'page'=&gt;$pageTemplate
        ]);
    $viewModel-&gt;setTemplate($pageTemplate);

    return $viewModel;
}
</code></pre>
<p>In lines 3-4 above, we retrieve the <code>page</code> parameter from route (remember the "page"
named capture from our regular expression?) and save it as the
<code>$pageTemplate</code> variable. We will use the <code>$pageTemplate</code> variable for determining the view template name
to pass to the view resolver. Then, in lines 6-10, we check if such a file is present,
and if not, return the 404 "Not Found" status code, which will force Laminas to display
the error page. In line 12, we create the @<code>ViewModel</code>[Laminas\View\Model\ViewModel] variable container, and in line
15 we explicitly set the view template name for rendering.</p>
<p>To see the documentation system in action, create a couple of "static" view template files:
the Table of Contents page (<code>contents.phtml</code>) and the Introduction page (<code>introduction.phtml</code>).
Create the <em>doc</em> subdirectory under the <em>view/application/index</em> directory of the <code>Application</code> module and
put the <em>contents.phtml</em> view template there:</p>
<pre><code class="language-php">&lt;h1&gt;Table of Contents&lt;/h1&gt;

&lt;ul&gt;
    &lt;li&gt;
        &lt;a href=&quot;&lt;?= $this-&gt;url('doc', ['page'=&gt;'introduction']); ?&gt;&quot;&gt;
            Introduction
        &lt;/a&gt;
    &lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<p>In the lines above, we provide the HTML code for the "Table of Contents" page header,
and the list which contains the single item named "Introduction" pointing to the Introduction "static" page.
The link URL is generated with the @<code>Url</code>[Laminas\View\Helper\Url] view helper (for more details on the <code>Url</code>[Laminas\View\Helper\Url] helper, see further sections
in this chapter).</p>
<p>Then add the <em>introduction.phtml</em> page into the same <em>doc</em> directory:</p>
<pre><code class="language-php">&lt;h1&gt;Introduction&lt;/h1&gt;

&lt;p&gt;Some introductory materials.&lt;/p&gt;
</code></pre>
<p>In the lines above, we define the HTML markup for the simple Introduction page.</p>
<p>Now, if you open the "http://localhost/doc/contents.html" URL in your
browser, you should see a nice simple documentation system which you can extend and
use in your site (figure 5.8):</p>
<p><img alt="Figure 5.8. &quot;Static&quot; Page" src="../images/routing/static_page.png" /></p>
<p>Clicking the <em>Introduction</em> link will direct you to the "Introduction" static page.
You can also add other pages to the <em>doc</em> directory to make them automatically
available for site users through our <em>Regex</em> route.</p>
<blockquote>
<p>One disadvantage of such a documentation system is that it does not work well if you place nested
pages in subdirectories under the <em>doc</em> directory. The reason of this limitation lies in the way the
<em>Regex</em> route assembles URLs. You can't generate URLs containing slash characters, as these "unsafe"
characters will be automatically URL-encoded. We will work-around this problem with our custom route
type that we will create at the end of this chapter.</p>
</blockquote>
<h2 id="other-route-types">Other Route Types</h2>
<p>The <em>Hostname</em>, <em>Scheme</em>, and <em>Method</em> route types are used less commonly
compared to the route types mentioned previously.</p>
<h3 id="hostname">Hostname</h3>
<p>The <em>Hostname</em> route type can be used, for example, if you develop a content
management system (CMS) <sup id="fnref:cms"><a class="footnote-ref" href="#fn:cms">5</a></sup> engine, which should serve several websites at once,
each site using a different sub-domain. In that case you will define the <em>Hostname</em>
route as the parent, and nest child routes of other types inside of it:</p>
<pre><code class="language-php">'routename' =&gt; [
    'type' =&gt; Hostname::class,
    'options' =&gt; [
        'route' =&gt; ':subdomain.yourserver.com',
        'constraints' =&gt; [
            'subdomain' =&gt; '[a-zA-Z][a-zA-Z0-9_-]*'
        ],
        'defaults' =&gt; [
        ],
    ],
    'child_routes'=&gt;[
        //...
    ],
],
</code></pre>
<p>In the example above, in line 1 we define the route which
has the <em>Hostname</em> type. The <code>route</code> option (line 4) defines
the domain name to match against. The <code>:subdomain</code> is a wildcard,
which can take different sub-domain values. The <code>constraints</code> key defines the regular expression
this sub-domain parameter must match. The <em>Hostname</em> route will differentiate your
domains, so each site will behave differently, depending on the value of the
<code>subdomain</code> parameter returned:</p>
<pre><code class="language-php">// An example of an action that uses parameters returned by
// Hostname route.
public function someAction()
{
    // Get the 'subdomain' parameter from the route.
    $subdomain = $this-&gt;params()-&gt;fromRoute('subdomain', null);

    // Use different logic based on sub-domain.
    //...

    // Render the view template.
    return new ViewModel();
}
</code></pre>
<h3 id="scheme">Scheme</h3>
<p>The <em>Scheme</em> route type is useful if you need to handle HTTP and HTTPS <sup id="fnref:https"><a class="footnote-ref" href="#fn:https">6</a></sup> protocols
in different ways.</p>
<p>The typical <em>Scheme</em> route configuration is presented below:</p>
<pre><code class="language-php">'routename' =&gt; [
    'type' =&gt; Scheme::class,
    'options' =&gt; [
        'scheme' =&gt; 'https',
        'defaults' =&gt; [
            'https' =&gt; true,
        ],
    ],
    'child_routes'=&gt;[
        //...
    ],
],
</code></pre>
<p>Above, we define the route of type <em>Scheme</em>. It takes the <code>scheme</code> option,
which should be the scheme to match against (like <code>http</code> or <code>https</code>).
If the scheme in HTTP request's URL is exactly the same as the <code>scheme</code> option,
the route is considered matching. You can use the <code>defaults</code> key to return some
parameters on route match. In the example above, the <code>https</code> boolean parameter
will be returned.</p>
<h3 id="method">Method</h3>
<p>The <em>Method</em> route type can be used if you need to direct <em>GET</em> and <em>POST</em> requests
into different controller's actions. Its typical configuration is presented below:</p>
<pre><code class="language-php">'routename' =&gt; [
    'type' =&gt; Method::class,
    'options' =&gt; [
        'verb' =&gt; 'post',
        'defaults' =&gt; [
        ],
    ],
    'child_routes'=&gt;[
        //...
    ],
],
</code></pre>
<p>Above, we define the route which has the <em>Method</em> type. It takes the <code>verb</code> option,
which may be the comma-separated list of acceptable HTTP verbs (like <em>get</em>, <em>post</em>, <em>put</em>, etc.)</p>
<h2 id="extracting-parameters-from-route">Extracting Parameters from Route</h2>
<p>On route match, the router (top-level route class) returns
some parameters: the "defaults" (parameters listed in the <code>defaults</code> section of
routing configuration) plus any wildcard parameters extracted from URL string.</p>
<p>In your controller, you will often need to retrieve these parameters.
We already did this in the examples above. In this section, we will give some summary.</p>
<p>To retrieve a parameter from the route in your controller's action method,
you typically use the @<code>Params</code> controller plugin and its <code>fromRoute()</code> method,
which takes two arguments: the name of the parameter to retrieve and the value to
return if the parameter is not present.</p>
<p>The <code>fromRoute()</code> method can also be used to retrieve all parameters at once as an array.
To do that, call the <code>fromRoute()</code> without arguments, as shown in the example below:</p>
<pre><code class="language-php">// An example action.
public function someAction()
{
    // Get the single 'id' parameter from route.
    $id = $this-&gt;params()-&gt;fromRoute('id', -1);

    // Get all route parameters at once as an array.
    $params = $this-&gt;params()-&gt;fromRoute();

    //...
}
</code></pre>
<h3 id="retrieving-the-routematch-and-the-router-object">Retrieving the RouteMatch and the Router Object</h3>
<p>On route match, the router class internally creates an instance of @<code>Laminas\Router\RouteMatch</code> class,
providing the methods for extracting the matched route name and parameters extracted from route.
The useful methods of the @<code>RouteMatch</code>[Laminas\Router\RouteMatch] class are listed in table 5.3:</p>
<table>
<thead>
<tr>
<th><em>Method Name</em></th>
<th><em>Description</em></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>getMatchedRouteName()</code></td>
<td>Gets the name of matched route.</td>
</tr>
<tr>
<td><code>getParams()</code></td>
<td>Get all parameters.</td>
</tr>
<tr>
<td><code>getParam($name, $default)</code></td>
<td>Get a specific parameter.</td>
</tr>
</tbody>
</table>
<p>Table 5.3. Laminas\Router\RouteMatch class methods</p>
<blockquote>
<p>In most cases, it will be sufficient to use the @<code>Params</code> controller plugin, but alternatively
you can use the @<code>RouteMatch</code>[Laminas\Router\RouteMatch] object for accomplishing the same task.</p>
</blockquote>
<p>To get the @<code>RouteMatch</code>[Laminas\Router\RouteMatch] object from your controller's action method, you can use the following
code:</p>
<pre><code class="language-php">// An example action.
public function someAction()
{
    // Get the RouteMatch object.
    $routeMatch = $this-&gt;getEvent()-&gt;getRouteMatch();

    // Get matched route's name.
    $routeName = $routeMatch-&gt;getMatchedRouteName();

    // Get all route parameters at once as an array.
    $params = $routeMatch-&gt;getParams();

    //...
}
</code></pre>
<p>In line 5 of the code above, we use the <code>getEvent()</code> method of the <code>AbstractActionController</code> base class
to retrieve the @<code>MvcEvent</code> object, which represents the event (in Laminas, the application life cycle consists
of events). We then use the <code>getRouteMatch()</code> method of the @<code>MvcEvent</code> class to retrieve the <code>RouteMatch</code> object.</p>
<p>In line 8, we use the <code>getMatchedRouteName()</code> method to retrieve the name of the route that matched
the HTTP request, and in line 11 we retrieve all the parameters from the route.</p>
<p>The @<code>MvcEvent</code> class can also be used for retrieving the router (the top-level route class). You can
do this with the <code>getRouter()</code> method of the @<code>MvcEvent</code> class, as below:</p>
<pre><code class="language-php">    // Call this inside of your action method
    // to retrieve the RouteStackInterface for the router class.
    $router = $this-&gt;getEvent()-&gt;getRouter();
</code></pre>
<p>In the code above, we use the <code>getRouter()</code> method, which returns the @<code>RouteStackInterface</code> interface.
This interface is the base interface for both @<code>SimpleRouteStack</code>[Laminas\Router\SimpleRouteStack] and @<code>TreeRouteStack</code>[Laminas\Router\Http\TreeRouteStack], and it provides
the methods for working with the routes contained inside the route stack.</p>
<h2 id="generating-urls-from-route">Generating URLs from Route</h2>
<p>The main task of any route class is to determine whether this given route matches the HTTP request, and on match
return the set of parameters by which a controller and action can be determined. An opposite
task a route class allows to generate a URL by parameters. This feature can be used
in your controller action methods for generating URLs, for example, for redirecting a user to another page.
It can also be used inside view templates for generating hyperlinks.</p>
<h3 id="generating-urls-in-view-templates">Generating URLs in View Templates</h3>
<p>Your web pages usually contain hyperlinks to other pages. These links may point either
to a page internal to your site or to a page on another site. A hyperlink is represented by <code>&lt;a&gt;</code> HTML tag
having <code>href</code> attribute specifying the URL of the destination page. Below, an example of a hyperlink
pointing to an external page is presented:</p>
<p><code>&lt;a href="http://example.com/path/to/page"&gt;A link to another site page&lt;/a&gt;</code></p>
<p>When you generate a hyperlink to a resource internal to your site, you typically
use relative URL (without host name):</p>
<p><code>&lt;a href="/path/to/internal/page"&gt;A link to internal page&lt;/a&gt;</code></p>
<p>To generate URLs in your view templates (<em>.phtml</em> files), you can use the @<code>Url</code>[Laminas\View\Helper\Url] view helper class,
which takes the route name as an input argument:</p>
<pre><code class="language-php">&lt;!-- A hyperlink to Home page --&gt;
&lt;a href=&quot;&lt;?= $this-&gt;url('home'); ?&gt;&quot;&gt;Home page&lt;/a&gt;

&lt;!-- A hyperlink to About page --&gt;
&lt;a href=&quot;&lt;?= $this-&gt;url('about'); ?&gt;&quot;&gt;About page&lt;/a&gt;
</code></pre>
<p>In the lines above, we generate two relative URLs. In line 2, we call the @<code>Url</code>[Laminas\View\Helper\Url] view helper
and pass the "home" route name as its parameter. In line 5, we pass the "about" route name as
an argument for the @<code>Url</code>[Laminas\View\Helper\Url] view helper.</p>
<blockquote>
<p>In the example above, the @<code>Url</code>[Laminas\View\Helper\Url] view helper internally uses the @<code>RouteMatch</code>[Laminas\Router\RouteMatch] object and calls
the @<code>Literal</code>[Laminas\Router\Http\Literal] route to assemble the URL string by route name.</p>
</blockquote>
<p>After the @<code>PhpRenderer</code> class executes the view template's
code, the output HTML markup will be the following:</p>
<pre><code class="language-php">&lt;!-- A hyperlink to Home page --&gt;
&lt;a href=&quot;/&quot;&gt;Home page&lt;/a&gt;

&lt;!-- A hyperlink to About page --&gt;
&lt;a href=&quot;/about&quot;&gt;About page&lt;/a&gt;
</code></pre>
<h4 id="passing-parameters">Passing Parameters</h4>
<p>If a route uses some variable parameters, you should pass them to the @<code>Url</code>[Laminas\View\Helper\Url] view helper
as the second argument:</p>
<pre><code class="language-php">&lt;!-- A hyperlink to About page --&gt;
&lt;a href=&quot;&lt;?= $this-&gt;url('application', ['action' =&gt; 'about']); ?&gt;&quot; &gt;
  About page
&lt;/a&gt;

&lt;!-- A hyperlink to Barcode image --&gt;
&lt;a href=&quot;&lt;?= $this-&gt;url('application', ['action' =&gt; 'barcode',
  'type' =&gt; 'code39', 'text' =&gt; 'HELLO-WORLD']); ?&gt;&quot; &gt;
  Barcode image &lt;/a&gt;
</code></pre>
<p>In the example above, we use @<code>Url</code>[Laminas\View\Helper\Url] view helper to generate the two
URLs by route name and parameters. We pass the "application"
route name as the first argument, and an array of parameters
as the second argument.</p>
<p>In line 2, we pass the "action" parameter to tell the
<em>Segment</em> route class that it should substitute the corresponding wildcard
in the route string with the "about" string.</p>
<p>After the @<code>PhpRenderer</code> class executes the view template's
code, the output HTML markup will be the following:</p>
<pre><code class="language-php">&lt;!-- A hyperlink to About page --&gt;
&lt;a href=&quot;/application/about&quot; &gt; About page &lt;/a&gt;

&lt;!-- A hyperlink to Barcode image --&gt;
&lt;a href=&quot;/application/barcode/code39/HELLO-WORLD&quot; &gt; Barcode image &lt;/a&gt;
</code></pre>
<p>As another example, let's try to generate a URL for our <em>Regex</em> route
(the one which serves our "static" pages):</p>
<pre><code class="language-php">&lt;!-- A hyperlink to Introduction page --&gt;
&lt;a href=&quot;&lt;?= $this-&gt;url('doc', ['page'=&gt;'introduction']); ?&gt;&quot;&gt;
 Introduction &lt;/a&gt;
</code></pre>
<p>This will generate the following HTML markup:</p>
<pre><code class="language-php">&lt;!-- A hyperlink to Introduction page --&gt;
&lt;a href=&quot;/doc/introduction.html&quot;&gt; Introduction &lt;/a&gt;
</code></pre>
<h4 id="generating-absolute-urls">Generating Absolute URLs</h4>
<p>If you need to generate an absolute URL (having the scheme and host name),
you can specify the third parameter for the @<code>Url</code>[Laminas\View\Helper\Url] view helper. The third parameter
should be an array containing one or several options. For assembling the absolute
URL, pass the <code>force_canonical</code> option, as in the example below:</p>
<pre><code class="language-php">&lt;!-- A hyperlink to Home page --&gt;
&lt;a href=&quot;&lt;?= $this-&gt;url('home', [], ['force_canonical' =&gt; true]); ?&gt;&quot; &gt;
  Home page &lt;/a&gt;

&lt;!-- A hyperlink to About page --&gt;
&lt;a href=&quot;&lt;?php echo $this-&gt;url('application', ['action' =&gt; 'about'],
  ['force_canonical' =&gt; true]); ?&gt;&quot; &gt; About page &lt;/a&gt;
</code></pre>
<p>In line 2 of the example above, we pass the "home" route name as the first
argument, empty array as the second argument, and an array containing <code>force_canonical</code>
option as the third argument. In lines 6-7, we also pass the <code>force_canonical</code> option
as the third argument for generating the URL of the About page.</p>
<p>The resulting HTML markup of the code above will be as follows:</p>
<pre><code class="language-php">&lt;!-- A hyperlink to Home page --&gt;
&lt;a href=&quot;http://localhost/&quot; &gt; Home page &lt;/a&gt;

&lt;!-- A hyperlink to About page --&gt;
&lt;a href=&quot;http://localhost/application/index/about&quot; &gt; About page &lt;/a&gt;
</code></pre>
<h4 id="specifying-query-part">Specifying Query Part</h4>
<p>If you want your URL to have a query part, you can specify the <code>query</code> option in
the third argument of the <code>Url</code> view helper. For example, assume you have the "search"
action in some controller (and a route mapped to this action), and you want to pass it search query string and count of output results
per page. The URL for this action would be like this: "http://localhost/search?q=topic&amp;count=10".
To generate such a URL, you can use the following code:</p>
<pre><code class="language-php">&lt;a href=&quot;&lt;?= $this-&gt;url('search', [], ['force_canonical' =&gt; true,
         'query'=&gt;['q'=&gt;'topic', 'count'=&gt;10]]); ?&gt;&quot; &gt;
  Search &lt;/a&gt;
</code></pre>
<p>In the code above, we specified the <code>query</code> option, which is the array containing <em>name=&gt;value</em>
pairs of the query parameters.</p>
<h3 id="generating-urls-in-controllers">Generating URLs in Controllers</h3>
<p>You can generate URLs inside your controller's action methods using the <code>Url</code> controller
plugin. To generate a URL, you call the @<code>Url</code>[Laminas\Mvc\Controller\Plugin\Url] controller plugin's <code>fromRoute()</code> method, as in the example
below:</p>
<pre><code class="language-php">// An example action method
public function someAction()
{
    // Generate a URL pointing to the Home page ('/')
    $url1 = $this-&gt;url()-&gt;fromRoute('home');

    // Generate an absolute URL pointing to the About page
    // ('http://localhost/application/about')
    $url2 = $this-&gt;url()-&gt;fromRoute('application',
              ['action'=&gt;'about'], ['force_canonical'=&gt;true]);
}
</code></pre>
<blockquote>
<p>The arguments the <code>Url</code> plugin takes and their meaning are identical to the @<code>Url</code>[Laminas\View\Helper\Url] view helper's
ones. So, you can generate absolute or relative URLs the same way you did in your view templates.</p>
</blockquote>
<h3 id="url-encoding">URL Encoding</h3>
<p>When generating URLs either with the @<code>Url</code>[Laminas\View\Helper\Url] view helper or with the @<code>Url</code>[Laminas\Mvc\Controller\Plugin\Url] controller plugin,
you should remember that URLs may only contain "safe" characters from ASCII character set. Thus,
if you pass the parameter containing unsafe characters, these characters will be replaced with
the sequence of the percentage character and two digits.</p>
<p>For example, let's try to generate a URL for our <em>Regex</em> route and pass it the "page" parameter
with the value "/chapter1/introduction".</p>
<pre><code class="language-php">&lt;!-- A hyperlink to Introduction page --&gt;
&lt;a href=&quot;&lt;?= $this-&gt;url('doc', ['page'=&gt;'chapter1/introduction']); ?&gt;&quot;&gt;
  Introduction &lt;/a&gt;
</code></pre>
<p>We could assume it generates the URL like "/doc/chapter1/introduction.html". But
because the slash ('/') character is unsafe, it will be replaced with the "%2F" characters
for security reasons, and we will have the following HTML code:</p>
<pre><code class="language-text">&lt;!-- A hyperlink to Introduction page --&gt;
&lt;a href=&quot;/doc/chapter1%2Fintroduction.html&quot;&gt; Introduction &lt;/a&gt;
</code></pre>
<p>Unfortunately, this hyperlink is unusable, because it won't match our
<em>Regex</em> route.</p>
<h2 id="writing-own-route-type">Writing Own Route Type</h2>
<p>Although Laminas provides you with many route types, in some situations, you will need
to write your own route type.</p>
<p>One example of the need for such a custom route type is when you have to define the URL mapping rules
dynamically. Usually, you store the routing configuration in module's config file,
but in some CMS systems you will have documents stored in the database. For such a system, you would need to develop a custom route type which
would connect to the database and perform route matching against the data stored in the database.
You cannot store this information in config file, because new documents are created by system
administrators, not programmers.</p>
<h3 id="routeinterface">RouteInterface</h3>
<p>We know that every route class must implement the @<code>Laminas\Router\Http\RouteInterface</code> interface.
The methods of this interface are presented in table 5.4:</p>
<table>
<thead>
<tr>
<th><em>Method Name</em></th>
<th><em>Description</em></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>factory($options)</code></td>
<td>Static method for creation of the route class.</td>
</tr>
<tr>
<td><code>match($request)</code></td>
<td>Method which performs match against the HTTP request data.</td>
</tr>
<tr>
<td><code>assemble($params, $options)</code></td>
<td>Method for generating URL by route parameters.</td>
</tr>
<tr>
<td><code>getAssembledParams()</code></td>
<td>Method for retrieving parameters that were utilized for URL generation.</td>
</tr>
</tbody>
</table>
<p>Table 5.4. RouteInterface methods</p>
<p>The static <code>factory()</code> method is used by the Laminas router (@<code>TreeRouteStack</code>[Laminas\Router\Http\TreeRouteStack] or @<code>SimpleRouteStack</code>[Laminas\Router\SimpleRouteStack])
for instantiating the route class. The router passes the <code>options</code> array an argument for the
<code>factory()</code> method.</p>
<p>The <code>match()</code> method is used to perform the matching of the HTTP request (or, particularly its URL)
against the options data passed to the route class through the <code>factory()</code>. The <code>match()</code> method should
return either an instance of the <code>RouteMatch</code> class on successful match, or <code>null</code> on failure.</p>
<p>The <code>assemble()</code> method is used for generating URL string by
route parameters and options. The <code>getAssembledParams()</code> helper method's purpose is
to return the array of parameters which were used on URL generation.</p>
<h3 id="custom-route-class">Custom Route Class</h3>
<p>To demonstrate the creation of a custom route type, let's improve our previous
approach to building the simple documentation system with <em>Regex</em> route type.
The disadvantage of the <em>Regex</em> route type is that you cannot organize the
static pages in a hierarchy by creating subdirectories under the <em>doc</em> directory
(when generating an URL for such a page, the slash directory separator will be
URL-encoded making the hyperlink unusable). We will create our
custom <code>StaticRoute</code> class that allows to fix this issue.</p>
<p>Moreover, the class we will create is more powerful, because it will
not only recognize URLs starting with "/doc" and ending with ".html". Instead,
it will recognize generic URLs, like "/help" or "/support/chapter1/introduction".</p>
<p>What we want to achieve:</p>
<ul>
<li>
<p>The <code>StaticRoute</code> class should be insertable to the route stack (to <code>SimpleRouteStack</code>
  or to <code>TreeRouteStack</code>) and usable together with other route types.</p>
</li>
<li>
<p>The route class should recognize generic URLs, like "/help" or "/introduction".</p>
</li>
<li>
<p>The route class should match the URL against the directory structure. For example,
  if the URL is "/chapter1/introduction", then the route should check if the corresponding view
  template file <em>&lt;base_dir&gt;/chapter1/introduction.phtml</em> exists and is readable, and if so,
  report match. If the file does not exist (or not readable), return the failure status.</p>
</li>
<li>
<p>The route class should check the URL for acceptable file names using a regular expression.
  For example, the file name "introduction" is acceptable, but the name "*int$roduction" is not.
  If the file name is not acceptable, the failure status should be returned.</p>
</li>
<li>
<p>The route should be able to assemble the URL string by route name and parameters.</p>
</li>
</ul>
<p>To start, create the <em>Route</em> subdirectory under the module's source directory
and put the <em>StaticRoute.php</em> file inside of it (figure 5.9).</p>
<p><img alt="Figure 5.9. StaticRoute.php file" src="../images/routing/static_route_php.png" /></p>
<p>Inside that file, paste the stub code presented below:</p>
<pre><code class="language-php">&lt;?php
namespace Application\Route;

use Traversable;
use \Laminas\Router\Exception;
use \Laminas\Stdlib\ArrayUtils;
use \Laminas\Stdlib\RequestInterface as Request;
use \Laminas\Router\Http\RouteInterface;
use \Laminas\Router\Http\RouteMatch;

// Custom route that serves &quot;static&quot; web pages.
class StaticRoute implements RouteInterface
{
    // Create a new route with given options.
    public static function factory($options = [])
    {
    }

    // Match a given request.
    public function match(Request $request, $pathOffset = null)
    {
    }

    // Assembles a URL by route params.
    public function assemble(array $params = [], array $options = [])
    {
    }

    // Get a list of parameters used while assembling.
    public function getAssembledParams()
    {
    }
}
</code></pre>
<p>From the code above, you can see that we placed the <code>StaticRoute</code> class
inside the <code>Application\Route</code> namespace (line 2).</p>
<p>In lines 4-9, we define some class name aliases for making
the class names shorter.</p>
<p>In lines 12-33, we define the stub for the <code>StaticRoute</code> class. The <code>StaticRoute</code>
class implements the @<code>RouteInterface</code>[Laminas\Router\RouteInterface] interface and defines all the methods specified
by the interface: <code>factory()</code>, <code>match()</code>, <code>assemble()</code> and <code>getAssembledParams()</code>.</p>
<p>Next, let's add several protected properties and the constructor method to the <code>StaticRoute</code>
class, as shown below:</p>
<pre><code class="language-php">&lt;?php
//...

class StaticRoute implements RouteInterface
{
    // Base view directory.
    protected $dirName;

    // Path prefix for the view templates.
    protected $templatePrefix;

    // File name pattern.
    protected $fileNamePattern = '/[a-zA-Z0-9_\-]+/';

    // Defaults.
    protected $defaults;

    // List of assembled parameters.
    protected $assembledParams = [];

    // Constructor.
    public function __construct($dirName, $templatePrefix,
            $fileNamePattern, array $defaults = [])
    {
        $this-&gt;dirName = $dirName;
        $this-&gt;templatePrefix = $templatePrefix;
        $this-&gt;fileNamePattern = $fileNamePattern;
        $this-&gt;defaults = $defaults;
    }

    // ...
}
</code></pre>
<p>Above, in line 7, we define the <code>$dirName</code> property that is intended for storing
the name of the base directory where the "static" view templates will be located.
In line 10, we define the <code>$templatePrefix</code> class variable for storing the prefix
for prepending to all view template names. Line 13 contains the <code>$fileNamePattern</code>
variable that will be used for checking the file name.</p>
<p>In lines 22-29, we define the constructor method that is called on instance
creation for initializing the protected properties.</p>
<p>Next, let's implement the <code>factory()</code> method for our <code>StaticRoute</code> custom route class.
The <code>factory()</code> method will be called by the router for instantiating the route class:</p>
<pre><code class="language-php">&lt;?php
//...

class StaticRoute implements RouteInterface
{
    //...

    // Create a new route with given options.
    public static function factory($options = [])
    {
        if ($options instanceof Traversable) {
            $options = ArrayUtils::iteratorToArray($options);
        } elseif (!is_array($options)) {
            throw new Exception\InvalidArgumentException(__METHOD__ .
                ' expects an array or Traversable set of options');
        }

        if (!isset($options['dir_name'])) {
            throw new Exception\InvalidArgumentException(
                'Missing &quot;dir_name&quot; in options array');
        }

        if (!isset($options['template_prefix'])) {
            throw new Exception\InvalidArgumentException(
                'Missing &quot;template_prefix&quot; in options array');
        }

        if (!isset($options['filename_pattern'])) {
            throw new Exception\InvalidArgumentException(
                'Missing &quot;filename_pattern&quot; in options array');
        }

        if (!isset($options['defaults'])) {
            $options['defaults'] = [];
        }

        return new static(
            $options['dir_name'],
            $options['template_prefix'],
            $options['filename_pattern'],
            $options['defaults']);
    }
}
</code></pre>
<p>In the code above, we see that the <code>factory()</code> method takes the <code>options</code>
array as the argument (line 9). The <code>options</code> array may contain the options
for configuring the route class. The <code>StaticRoute</code> class will accept the following
options:</p>
<ul>
<li><code>dir_name</code> - the base directory where to store all "static" view templates.</li>
<li><code>template_prefix</code> - the prefix to prepend to all template names.</li>
<li><code>filename_pattern</code> - the regular expression for checking the file names.</li>
<li><code>defaults</code> - parameters returned by router by default.</li>
</ul>
<p>Once we parsed the options, in lines 37-41 we call the class' constructor
method to instantiate and return the <code>StaticRoute</code> object.</p>
<p>The next method we add to the <code>StaticRoute</code> route class is the <code>match()</code> method:</p>
<pre><code class="language-php">&lt;?php
//...

class StaticRoute implements RouteInterface
{
    //...

    // Match a given request.
    public function match(Request $request, $pathOffset=null)
    {
        // Ensure this route type is used in an HTTP request
        if (!method_exists($request, 'getUri')) {
            return null;
        }

        // Get the URL and its path part.
        $uri  = $request-&gt;getUri();
        $path = $uri-&gt;getPath();

        if($pathOffset!=null)
            $path = substr($path, $pathOffset);

        // Get the array of path segments.
        $segments = explode('/', $path);

        // Check each segment against allowed file name template.
        foreach ($segments as $segment) {
            if(strlen($segment)==0)
                continue;
            if(!preg_match($this-&gt;fileNamePattern, $segment))
            return null;
        }

        // Check if such a .phtml file exists on disk
        $fileName = $this-&gt;dirName . '/'.
                $this-&gt;templatePrefix.$path.'.phtml';
        if(!is_file($fileName) || !is_readable($fileName)) {
            return null;
        }

        $matchedLength = strlen($path);

        // Prepare the RouteMatch object.
        return new RouteMatch(array_merge(
              $this-&gt;defaults,
              ['page'=&gt;$this-&gt;templatePrefix.$path]
             ),
             $matchedLength);
    }
}
</code></pre>
<p>In the code above, we see that the <code>match()</code> method takes
two arguments: the HTTP request object (an instance of @<code>Laminas\Stdlib\Request</code>
class) and the URL path offset. The request object is used for
accessing the request URL (line 17). The path offset parameter is a non-negative integer,
which points to the portion of the URL the route is matched against (line 21).</p>
<p>In line 24, we extract the segments from URL. Then we check if every segment is
an acceptable file (directory) name (lines 27-32). If the segment is not a valid file name,
we return <code>null</code> as a failure status.</p>
<p>In line 35, we calculate the path to the view template, and in lines 37-39 we check if such
a file really exists and accessible for reading. This way we match the URL against the
directory structure.</p>
<p>In lines 44-48, we prepare and return the @<code>RouteMatch</code>[Laminas\Router\RouteMatch] object with the default
parameters plus the "page" parameter containing the view template name for rendering.</p>
<p>To complete the implementation of our <code>StaticRoute</code> class, we add the <code>assemble()</code> and
<code>getAssembledParams()</code> methods, that will be used for generation of URLs by route parameters.
The code for these methods is presented below:</p>
<pre><code class="language-php">&lt;?php
//...

class StaticRoute implements RouteInterface
{
    //...

    // Assembles a URL by route params
    public function assemble(array $params = [],
                           array $options = [])
    {
        $mergedParams = array_merge($this-&gt;defaults, $params);
        $this-&gt;assembledParams = [];

        if(!isset($params['page'])) {
            throw new Exception\InvalidArgumentException(__METHOD__ .
               ' expects the &quot;page&quot; parameter');
        }

        $segments = explode('/', $params['page']);
        $url = '';
        foreach($segments as $segment) {
            if(strlen($segment)==0)
                continue;
            $url .= '/' . rawurlencode($segment);
        }

        $this-&gt;assembledParams[] = 'page';

        return $url;
    }

    // Get a list of parameters used while assembling.
    public function getAssembledParams()
    {
        return $this-&gt;assembledParams;
    }
}
</code></pre>
<p>In the code above, we define the <code>assemble()</code> method, which takes
the two arguments: the <code>parameters</code> array and the <code>options</code> array (line 9).
The method constructs the URL by encoding the segments with URL encoding
and concatenating them (line 20-26).</p>
<p>The method <code>getAssembledParams()</code> just returns the names of the parameters
we used for URL generation (line 36).</p>
<p>Now we've finished the <code>StaticRoute</code> route class. To use our custom route type,
we add the following configuration to the <em>module.config.php</em> configuration file:</p>
<pre><code class="language-php">'static' =&gt; [
    'type' =&gt; StaticRoute::class,
    'options' =&gt; [
        'dir_name'         =&gt; __DIR__ . '/../view',
        'template_prefix'  =&gt; 'application/index/static',
        'filename_pattern' =&gt; '/[a-z0-9_\-]+/',
        'defaults' =&gt; [
            'controller' =&gt; Controller\IndexController::class,
            'action'     =&gt; 'static',
        ],
    ],
],
</code></pre>
<p>In line 1 of the configuration above, we define the routing rule named "static".
The <code>type</code> parameter defines the fully qualified <code>StaticRoute</code> class name (line 2).
In the <code>options</code> array, we define the base directory where the "static" pages will be
placed (line 4), the template prefix (line 5), the filename pattern (line 6),
and the <code>defaults</code> array, containing the name of the controller and the action that
will serve all the static pages.</p>
<blockquote>
<p>Do not forget to insert the following line to the beginning of the <code>module.config.php</code> class:</p>
<p><code>use Application\Route\StaticRoute;</code></p>
</blockquote>
<p>The final step is creating the action method in the <code>IndexController</code> class:</p>
<pre><code class="language-php">public function staticAction()
{
    // Get path to view template from route params
    $pageTemplate = $this-&gt;params()-&gt;fromRoute('page', null);
    if($pageTemplate==null) {
        $this-&gt;getResponse()-&gt;setStatusCode(404);
        return;
    }

    // Render the page
    $viewModel = new ViewModel([
            'page'=&gt;$pageTemplate
        ]);
    $viewModel-&gt;setTemplate($pageTemplate);
    return $viewModel;
}
</code></pre>
<p>The action above is almost identical to the action we used for the <em>Regex</em> route.
In line 4, we retrieve the <code>page</code> parameter from route and save it as the
<code>$pageTemplate</code> variable. In line 11, we create the <code>ViewModel</code> variable container, and in line
14 we explicitly set the view template name for rendering.</p>
<p>To see the system in action, let's add a couple of "static" view pages:
the Help page (<code>help.phtml</code>) and the introduction page (<code>intro.phtml</code>).
Create the <em>static</em> subdirectory under the <em>view/application/index</em> directory
of the <code>Application</code> module and put the <em>help.phtml</em> view template there:</p>
<pre><code class="language-php">&lt;h1&gt;Help&lt;/h1&gt;

&lt;p&gt;
    See the help &lt;a href=&quot;&lt;?= $this-&gt;url('static',
       ['page'=&gt;'/chapter1/intro']); ?&gt;&quot;&gt;introduction&lt;/a&gt; here.
&lt;/p&gt;
</code></pre>
<p>Then create the <em>chapter1</em> subdirectory in the <em>static</em> directory and
put the following <em>chapter1/intro.phtml</em> file in there:</p>
<pre><code class="language-php">&lt;h1&gt;Introduction&lt;/h1&gt;

&lt;p&gt;
    Write the help introduction here.
&lt;/p&gt;
</code></pre>
<p>Finally, you should receive the following directory structure (see figure 5.10):</p>
<p><img alt="Figure 5.10. Static pages" src="../images/routing/static_page_dir.png" /></p>
<p>Eventually, open the following URL in your browser: <em>http://localhost/help</em>. The
Help page should appear (see figure 5.11 for example). If you type the <em>http://localhost/chapter1/intro</em>
URL in your browser, you should see the Introduction page (figure 5.12).</p>
<p><img alt="Figure 5.11. Help page" src="../images/routing/help_page.png" /></p>
<p><img alt="Figure 5.12. Introduction page" src="../images/routing/chapter1_intro.png" /></p>
<p>You can create static pages just by adding the phtml files under the
<em>static</em> directory, and they will automatically become available to site users.</p>
<blockquote>
<p>If you are stuck, you can find this complete working example inside the <em>Hello World</em>
application.</p>
</blockquote>
<h2 id="summary">Summary</h2>
<p>In this chapter, we've learned about routing. Routing is used for mapping HTTP
request to controller's action method. There are several route types (<em>Literal</em>,
<em>Segment</em>, <em>Regex</em>, <em>Hostname</em>, <em>Scheme</em>, <em>Method</em> etc.).
Each route type uses different URL parts (and, possibly, other data from HTTP request)
to compare the URL with the specified route template. We also learned how to write custom
route class if the capabilities of standard route types are not sufficient.</p>
<p>The main task of a route class is to return a route match containing the set of parameters,
by which a controller and action can be determined. An opposite task a route class allows to
generate a URL by parameters. This feature is widely used in view layer of the application
for generating hyperlinks.</p>
<p>Route types can be combined in a nested tree with the help of <code>TreeRouteStack</code> router,
or organized in a chain with <code>SimpleRouteStack</code> router. These two routers allow to define
arbitrarily complex rules.</p>
<p>Routing configuration is stored in module's configuration file under the <code>router</code> key.
Each module exposes its own routing rules, which are merged with other modules' configuration
upon application start up.</p>
<div class="footnote">
<hr />
<ol>
<li id="fn:ascii">
<p>ASCII (American Standard Code for Information Interchange) is a character set which
      can be used to encode characters from the English alphabet. It encodes 128 characters: digits, letters,
      punctuation marks and several control codes inherited from Teletype machines.&#160;<a class="footnote-backref" href="#fnref:ascii" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
<li id="fn:lifo">
<p>LIFO (stands for Last In, First Out) is used to organize items in a stack, where
     the topmost item, which is added last, is taken out first.&#160;<a class="footnote-backref" href="#fnref:lifo" title="Jump back to footnote 2 in the text">&#8617;</a></p>
</li>
<li id="fn:gd">
<p>PHP GD extension allows to create image files in different formats (like JPEG, PNG, GIF, etc.)&#160;<a class="footnote-backref" href="#fnref:gd" title="Jump back to footnote 3 in the text">&#8617;</a></p>
</li>
<li id="fn:capture">
<p>In PHP PCRE regular expressions, it is possible to name a sub-pattern
        using the syntax <code>(?P&lt;name&gt;pattern)</code>. This sub-pattern will then be indexed
        in the <em>matches</em> array by its name.&#160;<a class="footnote-backref" href="#fnref:capture" title="Jump back to footnote 4 in the text">&#8617;</a></p>
</li>
<li id="fn:cms">
<p>A Content Management System (CMS) is a website allowing for collaborative creating, editing and
    publishing content (blogs, pages, documents, videos etc.) using a centralized web interface.
    CMS systems make it possible for non-programmers to perform the website's daily tasks, like
    content publishing.&#160;<a class="footnote-backref" href="#fnref:cms" title="Jump back to footnote 5 in the text">&#8617;</a></p>
</li>
<li id="fn:https">
<p>The HTTPS protocol is typically used for secure connections, like account page
      or shopping cart page. When you use HTTPS, the request data is tunnelled through Secure Socket Layer (SSL) channel
      and not available to third parties.&#160;<a class="footnote-backref" href="#fnref:https" title="Jump back to footnote 6 in the text">&#8617;</a></p>
</li>
</ol>
</div>
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Footer Navigation">
        <a href="../mvc/" class="btn btn-neutral float-left" title="Model-View-Controller"><span class="icon icon-circle-arrow-left"></span> Previous</a>
        <a href="../appearance/" class="btn btn-neutral float-right" title="Page Appearance and Layout">Next <span class="icon icon-circle-arrow-right"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
        <span>
          <a href="https://github.com/modir/laminas-book" class="fa fa-github" style="color: #fcfcfc"> GitHub</a>
        </span>
    
    
      <span><a href="../mvc/" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
      <span><a href="../appearance/" style="color: #fcfcfc">Next &raquo;</a></span>
    
  </span>
</div>
    <script src="../js/jquery-3.6.0.min.js"></script>
    <script>var base_url = "..";</script>
    <script src="../js/theme_extra.js"></script>
    <script src="../js/theme.js"></script>
      <script src="../search/main.js"></script>
    <script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>

</body>
</html>
